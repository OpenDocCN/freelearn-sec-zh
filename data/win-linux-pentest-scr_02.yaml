- en: '*Chapter 5*: Assessing Network Security'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：评估网络安全'
- en: We’ve had a lot of fun poking around the network in the first few chapters.
    There has been an emphasis on man-in-the-middle attacks, and it’s easy to see
    why – they’re particularly devastating when performed properly. However, your
    focus when educating your clients should be on the fact that these are fairly
    old attacks, and yet, they still often work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们在网络中探索了很多有趣的内容。重点是中间人攻击，原因显而易见 - 当正确执行时，它们特别具有破坏性。然而，当你教育客户时，你的重点应该是这些都是相当古老的攻击，然而它们仍然经常有效。
- en: One reason is that we still rely on very old technology in our networks, and
    man-in-the-middle attacks generally exploit inherent design vulnerabilities at
    the protocol level. Consider the internet protocol suite, underlying the internet
    as we know it today – the original research that ultimately led to TCP/IP dates
    back to the 1960s, with official activation and adoption gaining traction in the
    early 1980s. Old doesn’t necessarily imply insecure, but the issue here is the
    context in which these protocols were designed – there weren’t millions upon millions
    of devices attached to networks of networks, operated by everyone on the street
    from the teenager in his parents’ basement to his grandmother, and they weren’t
    supported by network stacks embedded into devices ranging from physical mechanisms
    in nuclear power plants down to a suburban home’s refrigerator, sending packets
    to alert someone that they’re running low on milk. This kind of adoption and proliferation
    wasn’t a consideration; the reality was that physical access to nodes was tightly
    controlled. This inherent problem hasn’t gone unnoticed—the next version of the
    internet protocol, IPv6, was formally defined in the **Request for Comments**
    (**RFC**) document during the late 1990s (with the most recent RFC being published
    in 2017). We’ll touch on IPv6 in this chapter, but we’ll also demonstrate how
    to practically interface IPv4 with IPv6\. This highlights that adoption has been
    slow and a lot of effort has been placed into making IPv6 work well with IPv4
    environments, ensuring that we’re going to be playing with all the inherent insecurity
    goodies of IPv4 for some time to come.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个原因是我们在网络中仍然依赖非常老旧的技术，而中间人攻击通常利用协议层面的固有设计漏洞。考虑到互联网协议套件，构成了我们今天所知的互联网 - 最初导致
    TCP/IP 的研究可以追溯到 1960 年代，官方的激活和采用在 1980 年代初开始获得关注。老旧并不一定意味着不安全，但问题在于这些协议设计时的背景
    - 那时候并没有数以百万计的设备连接到网络，由从地下室的青少年到奶奶在家中操作，它们也没有被嵌入到从核电站的物理机制到郊区家庭冰箱的各种设备中的网络堆栈支持，发送数据包以提醒某人他们的牛奶即将用完。这种采纳和传播方式并未被考虑；事实上，对节点的物理访问是严格控制的。这种固有问题并未被忽视
    - 下一代互联网协议 IPv6 在 1990 年代末正式定义（最近一篇 RFC 于 2017 年发布）。我们将在本章讨论 IPv6，但也会演示如何将 IPv4
    与 IPv6 实际接口化。这突显了采用速度缓慢以及在使 IPv6 在 IPv4 环境中良好运行方面投入了大量精力，确保我们将继续使用 IPv4 的所有固有不安全功能。
- en: As a pen tester on a job, it’s exciting to watch that shell pop up on your system.
    But when the fun and games are over, you’re left with a mountain of findings that
    will be laid out in a report for your client. Remember that your job is to help
    your client secure their enterprise, and it’s about more than just software flaws.
    Look for opportunities to educate as well as inform.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名工作中的渗透测试员，看到你的系统上弹出 shell 是令人兴奋的。但当游戏结束时，你将面对大量的发现，这些发现将在报告中向客户展示。记住，你的工作是帮助客户保护他们的企业，而不仅仅是软件漏洞。寻找机会来教育和提醒。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Network probing with Nmap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行网络探测
- en: Exploring binary injection with BetterCAP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 BetterCAP 探索二进制注入
- en: Smuggling data – dodging firewalls with HTTPTunnel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据走私 - 使用 HTTPTunnel 规避防火墙
- en: IPv6 addressing, recon, man-in-the-middle, and mapping from IPv4
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6 寻址、侦察、中间人攻击，以及从 IPv4 进行映射
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a laptop running Kali Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一章，你将需要一台运行 Kali Linux 的笔记本电脑。
- en: Network probing with Nmap
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行网络探测
- en: 'Let’s play *Jeopardy*. Here’s the answer – “*This network mapping tool, first
    released 24 years ago, caused a stir when its accurate portrayal in Hollywood
    films prompted organizations such as Scotland Yard to remind the public that its
    use is potentially illegal*.” If you said, “*What is Nmap?*” as the question,
    then you have won this Daily Double. Nmap is the go-to tool for just about anyone
    working on networked computers. Nmap means **network mapper**, and it’s useful
    in a wide variety of disciplines outside of security: network engineering, systems
    administration, and so on. Nmap’s innovation is that it allows the probes that
    you send to be customized to a high degree, allowing for unique responses that
    reveal a great deal of information about the target, and even finding shortcuts
    through a firewall.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来玩一场 *Jeopardy*（危险边缘）。这是答案——“*这款网络映射工具首次发布于 24 年前，当它在好莱坞电影中的精准描绘引起轰动时，苏格兰场等组织提醒公众，它的使用可能是非法的*。”如果你回答“*这是什么
    Nmap?*”作为问题，那么你就赢得了这个每日双倍奖。Nmap 是几乎所有从事网络计算机工作的人必备的工具。Nmap 意味着 **网络映射器**，它在安全领域之外的多种学科中都很有用：网络工程、系统管理等。Nmap
    的创新之处在于，它允许你发送的探针高度自定义，可以产生独特的响应，揭示大量目标信息，甚至能找到穿越防火墙的捷径。
- en: Nmap is the embodiment of the colloquialism *Swiss-army knife*, so let’s break
    down its key purposes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 是俚语“**瑞士军刀**”的化身，接下来我们来解析它的主要用途。
- en: Host discovery
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机发现
- en: Nmap can perform ping and port scans, but this is no ordinary scanner – it allows
    you to send a variety of probes to improve the chances of finding a target. You
    can simply ping targets, or you can send special lightweight probes to certain
    ports. The whole idea is sending something that elicits a response from the target.
    The flexibility here allows Nmap to function as an ideal sidekick for any administrator
    as well as a pen tester.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 可以执行 ping 和端口扫描，但这不是普通的扫描器——它允许你发送多种探针来提高找到目标的机会。你可以简单地 ping 目标，也可以向某些端口发送特定的轻量级探针。整体思路是发送某些内容来激发目标的响应。这里的灵活性使得
    Nmap 成为任何管理员以及渗透测试者的理想伙伴。
- en: List Scan (-sL)
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表扫描（-sL）
- en: This merely lists hosts for scanning, including reverse DNS lookups along the
    way. However, no traffic is sent to the targets. This is useful for validating
    the range of IPs you’re working with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅列出了扫描的主机，包括沿途的反向 DNS 查找。然而，不会向目标发送任何流量。这对于验证你正在使用的 IP 范围非常有用。
- en: Ping Scan (-sn)
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ping 扫描（-sn）
- en: Ping Scan allows you to effectively run a *ping sweep* against the targets –
    that is, there is no port scanning, but unlike the List Scan, we are sending data
    in the form of pings (specifically, an ICMP ECHO request) to the targets. There
    is *some* port activity with the default settings – Nmap will send an SYN to port
    **443**, an ACK to port **80**, and an ICMP timestamp request. This can be combined
    with the discovery probes discussed next, in which case this default behavior
    is skipped.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Ping 扫描允许你有效地对目标进行 *ping 扫描*——也就是说，不进行端口扫描，但与列表扫描不同，我们会向目标发送以 ping 形式的数据（具体来说，是
    ICMP ECHO 请求）。在默认设置下，*会有一些*端口活动——Nmap 会向端口 **443** 发送 SYN 向端口 **80** 发送 ACK 并发送
    ICMP 时间戳请求。这可以与下文讨论的发现探针结合使用，在这种情况下会跳过默认行为。
- en: Skip host discovery (-Pn)
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过主机发现（-Pn）
- en: 'This is a setting for Nmap users who know what they want: it won’t bother determining
    if hosts are up, so it effectively treats *every IP address in the range* as online.
    There may be times when you will want this, such as if you don’t fully trust the
    results of host discovery. Firewalls can be configured to make online hosts silent
    to popular discovery methods. The upside of this setting is that you can be sure
    no host is ignored when the port scan starts. The downside is that the scan will
    take a lot longer, as Nmap will be waiting for responses and timing out for every
    specified port on every specified IP address – this means a whole lot of probing
    computers that aren’t even there.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为那些明确知道自己需要什么的 Nmap 用户设置的：它不会去确定主机是否在线，因此它有效地将 *范围内的每个 IP 地址* 都视为在线。你可能会在某些情况下使用这个选项，比如当你不完全信任主机发现的结果时。防火墙可以被配置为让在线主机对流行的发现方法保持沉默。这个设置的好处是，你可以确保在端口扫描开始时没有主机会被忽略。缺点是扫描将需要更长时间，因为
    Nmap 会等待响应并超时，针对每个指定的端口和每个指定的 IP 地址进行检查——这意味着它会对那些根本不存在的计算机进行大量探测。
- en: Specialized discovery probes (-PS, -PA, -PU, -PY, -PO)
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专用发现探针（-PS，-PA，-PU，-PY，-PO）
- en: 'Somewhere between using the **ping** utility to find hosts and running port
    scans to find services lies Nmap’s host discovery options. SYN Ping (**-PS**),
    for example, sends an empty SYN packet either to a default port of 80 or to one
    you specify. If the host responds, no connection is established, but it tells
    Nmap that the host is there. Very similar to this discovery option is ACK Ping
    (**-PA**), which does the same thing – it sends an empty packet but with the **ACK**
    flag set. This option can help in discovering hosts behind firewalls configured
    to drop SYN requests but aren’t fancy enough to drop an unsolicited ACK. UDP Ping
    is similar and lets you configure specific ports, but it uses UDP instead of TCP.
    Since there is no three-way handshake in UDP, what Nmap is waiting for is an ICMP
    **port unreachable** message, which proves the host is there. The port number
    matters less here; in fact, you’ll want to avoid the common ports. The default
    is **40125** – surely an uncommonly used port number for hosting services. **Stream
    Control Transmission Protocol** (**SCTP**) also has a discovery option along with
    a scanning option: **-PY** sends an SCTP message with an INIT chunk set, waiting
    for either an ABORT or INIT-ACK in response. Another fine-tuned probe that can
    be sent is the IP Protocol Ping (**-PO**), which sends packets with a specific
    protocol defined in the header. For example, suppose you want to try probing for
    hosts with IGMP. You may get an **unreachable** message, or even an IGMP response
    – in either case, the host proved its existence.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**ping**工具查找主机和运行端口扫描查找服务之间，Nmap 的主机发现选项占据了一个位置。例如，SYN Ping（**-PS**）会向默认的
    80 端口或您指定的端口发送一个空的 SYN 数据包。如果主机响应，虽然没有建立连接，但它告诉 Nmap 主机是存在的。与此类似的发现选项是 ACK Ping（**-PA**），其作用相同——发送一个空数据包，但设置了**ACK**标志。这个选项有助于发现那些配置为丢弃
    SYN 请求的防火墙后面的主机，但防火墙可能没有足够“智能”去丢弃未请求的 ACK 数据包。UDP Ping 类似，并允许您配置特定的端口，但它使用 UDP
    而不是 TCP。由于 UDP 没有三次握手，Nmap 等待的是 ICMP **端口不可达**消息，这证明主机是存在的。端口号在这里并不那么重要；事实上，您可能希望避开常见的端口。默认端口是
    **40125**——这肯定是一个不常用的服务托管端口。**流控制传输协议**（**SCTP**）也有一个发现选项和扫描选项：**-PY** 发送带有 INIT
    数据块的 SCTP 消息，等待响应 ABORT 或 INIT-ACK。另一个精细调整的探测方式是 IP 协议 Ping（**-PO**），它发送带有特定协议的包头。例如，假设您想通过
    IGMP 探测主机。您可能会收到一个 **不可达** 消息，或者甚至得到一个 IGMP 响应——无论哪种情况，主机都证明了其存在。
- en: Ping on steroids (-PE, -PP, -PM)
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强化版 Ping（-PE, -PP, -PM）
- en: You’re probably already aware that often, a host won’t reply to a basic ping
    – administrators often configure hosts and firewalls to drop these ubiquitous
    ECHO requests, especially from untrusted networks. It’s not uncommon for the *other*
    message types in ICMP to be overlooked. This is where the different ping options
    come into play. You can use **–PE** for that classic ping taste, but **–PP** and
    **–PM** allow you to send timestamp queries and address mask queries over ICMP,
    respectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道，通常情况下，主机不会响应基本的 ping 请求——管理员通常会配置主机和防火墙来丢弃这些普遍的 ECHO 请求，尤其是来自不受信任网络的请求。ICMP
    中的*其他*消息类型往往被忽视。这就是不同 ping 选项发挥作用的地方。您可以使用 **–PE** 来执行经典的 ping 请求，但 **–PP** 和
    **–PM** 分别允许您通过 ICMP 发送时间戳查询和地址掩码查询。
- en: Port scanning – scan types
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口扫描 – 扫描类型
- en: Nmap has come a long way from its debut as a user-friendly and fast port scanner.
    It allows for fine-tuning to hone in on the actual condition of your target with
    incredible reliability. However, any tool can be quickly whipped together and
    trusted to try connecting to ports – where Nmap earns its stripes is in its ability
    to send carefully crafted unexpected messages and analyze the response. Let’s
    take a look at the different techniques.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 从最初作为一个用户友好且快速的端口扫描器起步，已经走了很长一段路。它允许精细调节，以令人难以置信的可靠性深入了解目标的实际状态。然而，任何工具都可以快速组装并信任去尝试连接端口——而
    Nmap 之所以脱颖而出，是因为它能够发送精心构造的意外消息并分析响应。让我们来看看不同的技术。
- en: TCP SYN scan (-sS)
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP SYN 扫描（-sS）
- en: This scan sends the initial synchronize (SYN) request of a TCP three-way handshake
    but with no intention of completing the transaction. The goal here is to listen
    for the expected SYN-ACK of a service ready for communication, and if received,
    mark the port as open. This technique is sometimes called **stealth scanning**,
    but I would regard it as a bit of a misnomer – any intrusion detection system
    will know a port scan when it sees one. It’s stealthy in the sense that the transaction
    is never completed, meaning there’s no connection to pass up the remaining OSI
    layers. Therefore, the application never gets a connection and won’t log one.
    Don’t be discouraged from using it – it’s better to be a network nuisance alone
    than a network nuisance *and* an application log nuisance. It also has the potential
    for speed, as we aren’t waiting for established connections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种扫描发送 TCP 三次握手的初始同步（SYN）请求，但并不打算完成该事务。这里的目的是监听服务是否准备好通信的 SYN-ACK 响应，如果收到，则标记端口为开放。这个技巧有时被称为
    **隐身扫描**，但我认为它是一个误称——任何入侵检测系统都会知道端口扫描的存在。它之所以“隐身”，是因为事务从未完成，这意味着没有连接能够通过剩余的 OSI
    层。因此，应用程序从未收到连接，也不会记录下来。不要因为这个就气馁——做一个网络上的烦人角色总比既是网络烦人角色又是应用日志烦人角色要好。而且它有潜力更快，因为我们不需要等待已建立的连接。
- en: TCP Connect() scan (-sT)
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP Connect() 扫描 (-sT)
- en: If you ask someone the difference between SYN scans and the Connect() scan,
    a common answer is *reliability*. SYN scans, being half-opened, may give unexpected
    results; but what about a completed three-way handshake? That’s a demonstrated
    open port that’s ready for communication. The reality is that SYN scans are plenty
    reliable against any proper and compliant TCP stack – there isn’t a lot of room
    for interpretation when you get an SYN-ACK response from an SYN. The practical
    difference between the two options is your local privileges. This won’t mean much
    to all of you Kali hackers – you’re already running as root. But perhaps you have
    lowly user privileges – the fancier SYN scan isn’t an option since it is a customized
    packet and thus requires raw socket privileges. The Connect() scan makes use of
    the **connect()** system call, just as any ordinary program that needs to establish
    a connection would. It’s reliable, but it’s slower, and the target application
    will notice it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问某人 SYN 扫描和 Connect() 扫描的区别，常见的回答是 *可靠性*。SYN 扫描由于是半开连接，可能会给出意外的结果；但是，已完成的三次握手又如何呢？那是一个已开放的端口，准备好进行通信。实际上，SYN
    扫描在任何合规的 TCP 协议栈上都是非常可靠的——当你从 SYN 收到 SYN-ACK 响应时，几乎不需要解释什么。两者之间的实际区别在于你的本地权限。这对所有的
    Kali 黑客来说可能没有太大意义——你们已经是 root 用户了。但如果你只有较低的用户权限呢？那么花哨的 SYN 扫描就不是一个选项，因为它是一个自定义的数据包，因此需要原始套接字权限。Connect()
    扫描利用了 **connect()** 系统调用，就像任何需要建立连接的普通程序一样。它很可靠，但速度较慢，目标应用程序会注意到它。
- en: UDP scan (-sU)
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDP 扫描 (-sU)
- en: I could tell you a joke about UDP, but you may not get it. Get it? The good
    ol’ fire-and-forget **User Datagram Protocol** is often ignored by pen testers,
    but the potential for attack vectors is the same as with the more obvious TCP.
    What’s counterintuitive about UDP scanning is speed – though UDP is associated
    with the blistering fast streaming services of today, thanks to the eliminated
    need to wait for confirmation on every packet, an open UDP port may not even send
    a response to Nmap’s probe. There’s no need for a handshake, after all. Knowing
    the difference between a lost datagram and one that was received but unanswered
    means Nmap has to retry and wait to decide. This is less of an issue with the
    well-known protocols such as SNMP, where Nmap knows to send data specific to that
    protocol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给你讲一个关于 UDP 的笑话，但你可能听不懂。懂了吗？那种经典的“发射后忘记”的 **用户数据报协议** (UDP) 常常被渗透测试员忽视，但其攻击向量的潜力与更显眼的
    TCP 是一样的。关于 UDP 扫描，反直觉的是它的速度——尽管 UDP 与如今那些快速的流媒体服务相关联，但由于每个数据包不需要等待确认，打开的 UDP
    端口甚至可能不会回应 Nmap 的探测。毕竟，不需要握手。知道丢失的数据报和已接收但没有回应的数据报之间的区别意味着 Nmap 需要重试并等待判断。这在一些常见协议（如
    SNMP）中问题较小，因为 Nmap 知道该发送该协议特定的数据。
- en: SCTP INIT and COOKIE ECHO scans (-sY / -sZ)
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SCTP INIT 和 COOKIE ECHO 扫描 (-sY / -sZ)
- en: 'These scans make use of SCTP, which is a blend of TCP reliability and UDP speed.
    You may not encounter a need for it, but Nmap is ready for it just in case. INIT
    is the SCTP equivalent of an SYN request, and INIT-ACK is the expected response
    when the port is open. COOKIE ECHO is a special response; as designed, the remote
    system sends a **cookie** as part of its INIT-ACK, and the initiator responds
    with COOKIE ECHO. However, an unsolicited COOKIE ECHO will just be dropped by
    an open port, allowing Nmap to differentiate between open and closed ports. Like
    the TCP NULL/FIN/Xmas scans discussed next, this is an example of Nmap’s genius
    in exploiting an RFC technicality: things are *supposed* to go a certain way,
    and the RFCs prescribe what to do when they don’t. Nmap exploits this.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扫描利用了SCTP，这是一种结合了TCP可靠性和UDP速度的协议。你可能不会遇到这种需求，但Nmap为此做了准备。INIT是SCTP中与SYN请求等效的部分，而INIT-ACK是在端口打开时的预期响应。COOKIE
    ECHO是一种特殊的响应；按照设计，远程系统在其INIT-ACK中发送一个**cookie**，发起方则响应COOKIE ECHO。然而，未请求的COOKIE
    ECHO会被开放端口丢弃，从而使Nmap能够区分开放端口和关闭端口。就像接下来讨论的TCP NULL/FIN/Xmas扫描一样，这是Nmap在利用RFC技术细节方面的一个例子：事情*应该*按照某种方式进行，RFC规范规定了当它们没有按照预期进行时该如何处理。Nmap正是利用了这一点。
- en: TCP NULL/FIN/Xmas/Maimon scans (-sN / -sF / -sX / -sM)
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP NULL/FIN/Xmas/Maimon扫描（-sN / -sF / -sX / -sM）
- en: To understand these scans, let’s dive into some theories for a bit. Deep in
    the RFC for **Transmission Control Protocol** (**TCP**), in the *Event Processing*
    section of the functional specification, there are some key prescriptions for
    handling weird events. Every TCP segment has a header containing information about
    the role that particular chunk of the payload plays in a connection. It’s a fixed
    length and contains information such as the source port and destination port.
    There is a section of **reserved bits** that are used for setting **flags**. This
    is where a packet is defined as a, say, SYN request. If these flags are set strangely,
    the design specification dictates what to do about it. Here’s an example from
    the RFC regarding closed ports – “*If the state is CLOSED, then all the data in
    the incoming segment is discarded. An incoming segment containing an RST is discarded.
    An incoming segment not containing an RST causes an RST to be sent in response*.”
    Another key point is on the next page, which discusses open ports – “*An incoming
    RST segment could not be valid, since it could not have been sent in response
    to anything sent by this incarnation of the connection. So, you are unlikely to
    get here, but if you do, drop the segment, and return*.” Even though this specific
    event is called out as being invalid, the specification still describes how to
    handle it. Thus, Nmap can infer the state of the port.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些扫描，我们先深入探讨一些理论。在**传输控制协议**（**TCP**）的RFC中，功能规范的*事件处理*部分列出了一些处理异常事件的关键规定。每个TCP段都有一个头部，其中包含关于该数据块在连接中所扮演角色的信息。这个头部的长度是固定的，包含了诸如源端口和目标端口等信息。还有一部分是**保留位**，用于设置**标志**。在这里，数据包被定义为，例如，SYN请求。如果这些标志设置异常，设计规范就会规定如何处理这种情况。以下是RFC中关于关闭端口的一个示例——“*如果状态为CLOSED，则丢弃所有传入段中的数据。包含RST的传入段将被丢弃。未包含RST的传入段将发送RST作为响应*。”另一个关键点出现在下一页，讨论了打开端口——“*传入的RST段可能无效，因为它不可能是对本连接实例发送的任何内容的响应。因此，你不太可能到达这里，但如果发生了，丢弃该段并返回*。”即使这个特定事件被指出是无效的，规范仍然描述了如何处理它。因此，Nmap可以推断端口的状态。
- en: The NULL scan (**-sN**) doesn’t set any flags; that is, the reserved bits are
    all zero. The FIN scan (**-sF**) only sets the FIN bit. The Xmas scan (**-sX**)
    sets FIN (gracefully close the connection), PSH (push the data to the application
    immediately), and URG (some or all of the payload should be prioritized) bits
    all at once – a situation that wouldn’t happen in a legitimate context. This causes
    the packet to be *lit up* like a Christmas tree. The Maimon scan (**-sM**) is
    similar to the Xmas scan, except it sets FIN/ACK.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: NULL扫描（**-sN**）不会设置任何标志；也就是说，保留位全部为零。FIN扫描（**-sF**）只设置FIN位。Xmas扫描（**-sX**）一次性设置FIN（优雅地关闭连接）、PSH（立即将数据推送到应用程序）和URG（某些或所有有效负载应优先处理）位——这种情况在合法上下文中是不可能发生的。这使得数据包像圣诞树一样*亮起*。Maimon扫描（**-sM**）类似于Xmas扫描，只是它设置了FIN/ACK。
- en: 'Now, let’s pull ourselves out of the theory and jump back into the practical
    – are these scans useful? To answer this, keep the main implication of this technique
    in mind: it’s only meaningful against TCP stacks that have faithfully executed
    the RFC’s specification. There are no RFC cops who come knocking on your door
    if your software fails to silently drop a weird packet. A notable example is the
    Windows **operating system** (**OS**), which will send an RST (a forceful way
    of shutting down a connection) in response to these silly packets, regardless
    of port state. Some BSD-based systems will drop a Maimon packet instead of an
    RST when the port is open, creating a rare scenario where that scan type is meaningful.
    Speaking for myself, I have very rarely used these scans.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从理论中跳出来，回到实际操作——这些扫描有用吗？为了回答这个问题，请记住这种技术的主要含义：它仅对那些严格执行RFC规范的TCP堆栈有意义。如果你的软件没有默默地丢弃这些奇怪的包，没人会作为RFC警察敲你家门。一个显著的例子是Windows
    **操作系统**（**OS**），它会在收到这些无聊的包时，不管端口状态如何，发送一个RST（强制断开连接）。一些基于BSD的系统在端口开放时，会丢弃Maimon包而不是RST，这就造成了一个少见的场景，在这种场景下该扫描类型是有意义的。就我个人而言，我很少使用这些扫描。
- en: TCP ACK scan (-sA)
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP ACK扫描 (-sA)
- en: 'Similarly, the ACK scan exploits a nuance in how stacks reply to strangeness:
    only the ACK flag is set. A port that receives such a packet will send back an
    RST, regardless of its state – so, this isn’t for determining state. If we get
    an RST back, we’ll know that the message got to our target. Thus, it’s a relatively
    stealthy way to map out firewall holes.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，ACK扫描利用了堆栈如何应对异常的细微差别：只有ACK标志被设置。接收到此类包的端口将返回一个RST，无论其状态如何——因此，这种方法不能用来判断端口状态。如果我们收到RST，我们就知道消息已经到达目标。这样，它就成为一种相对隐蔽的方式来绘制防火墙的漏洞。
- en: Zombie scan (-sI)
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 僵尸扫描 (-sI)
- en: 'Now, we’re getting to my favorite scan type: the idle zombie scan. It is *actually*
    stealthy – you don’t send any data whatsoever to your target. The only caveat
    is similar to the previous discussion about how different systems are designed
    – the idle zombie scan requires a host that will *play by the rules* of IP packet
    incrementation. Let’s dive a little deeper into the theory. So, suppose I send
    an SYN packet to a host on an open port. That host will reply with an SYN-ACK
    and wait for our final ACK. Now, suppose I send an SYN packet to a closed port
    on that host. It’ll angrily fire back an RST and I’ll know the port isn’t open
    for a chat. Let’s go through this again, but this time, I will *forge* the return
    address – the address of the zombie – on my SYN request. That open port will reply
    SYN-ACK and send it to the *forged* address, not mine. Let’s do this with the
    closed port, too: our target fires back an RST but again, it’s addressed to the
    forged address. We never get a reply.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要讨论我最喜欢的扫描类型：闲置僵尸扫描。它*实际上*是隐蔽的——你完全不需要向目标发送任何数据。唯一的限制类似于之前讨论的关于不同系统设计的问题——闲置僵尸扫描需要一个符合IP包递增规则的主机。让我们更深入地探讨一下这个理论。假设我向一个开放端口的主机发送一个SYN包。该主机会回复一个SYN-ACK，并等待我们发送最终的ACK。现在，假设我向该主机的一个关闭端口发送SYN包。它会愤怒地回送一个RST，我就知道该端口无法进行连接。我们再回顾一遍，但这次，我将在SYN请求中*伪造*返回地址——即僵尸主机的地址。那个开放端口会回复SYN-ACK并将其发送到*伪造*的地址，而不是我的地址。我们也可以对关闭端口进行相同的操作：我们的目标会回送一个RST，但同样，这个RST是发送到伪造的地址。我们永远也不会收到回复。
- en: 'The genius of the idle zombie scan is that it leverages both the nature of
    how TCP handles weirdness per the RFC, as discussed previously, and the fact that
    every single packet on any network has a fragment identification number. Let’s
    consider a few conditions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 闲置僵尸扫描的妙处在于它同时利用了TCP如何根据RFC处理异常的特性（如前所述），以及网络上每个包都有一个碎片ID号这一事实。我们考虑以下几种情况：
- en: The zombie is running an OS that merely *increments* the fragment ID number
    for each one it sends.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 僵尸主机运行的操作系统仅仅*递增*它发送的每个碎片ID号。
- en: The zombie is truly *idle*.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 僵尸主机确实是*闲置*的。
- en: 'The zombie’s TCP stack behaves as expected when it receives an unsolicited
    SYN/ACK: it responds with an RST, whereas the unsolicited RST is *ignored*.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当僵尸主机接收到未经请求的SYN/ACK时，它的TCP堆栈会按预期行为作出反应：发送一个RST响应，而未经请求的RST则被*忽略*。
- en: The zombie scan monitors the zombie with pings and carefully tracks the incrementation
    while sending carefully timed forged SYN packets to the target. It’s truly a beautiful
    thing to behold.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸扫描通过ping监控僵尸主机，并精确跟踪递增的情况，同时向目标发送精确时机的伪造SYN包。这个过程真是美不胜收。
- en: All of that being said, how practical is this attack? The challenge today is
    finding zombies that are truly idle. This kind of analysis requires high confidence
    that any packets sent by the zombie during the scan are related to our scan –
    it’s hard to have this sort of confidence. The other concern has to do with how
    faithful the zombie’s stack is to the RST; if it’s going to fire RSTs back to
    our target with every unsolicited message that’s received, we can’t infer anything.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这些，这种攻击有多实际呢？今天的挑战是找到真正空闲的僵尸。这样的分析需要对僵尸在扫描期间发送的任何数据包与我们的扫描相关有足够的信心——很难拥有这种信心。另一个问题是，僵尸栈对
    RST 的响应有多忠实；如果它会对每个接收到的无请求消息发送 RST 返回到我们的目标，我们就无法推断出任何信息。
- en: Port scanning – port states
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口扫描 – 端口状态
- en: 'In [*Chapter 9*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165), *PowerShell
    Fundamentals*, we’ll build a basic port scanner with PowerShell. While handy,
    you’ll notice that it doesn’t discriminate the results beyond an open or closed
    port. Nmap reports the port status as one of six states. The first three are the
    most commonly encountered for most enumeration exercises, while the last three
    are special responses based on the different scan techniques:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165)《PowerShell基础》中，我们将用
    PowerShell 构建一个基本的端口扫描器。尽管它非常实用，但你会注意到它只能判断端口是开放还是关闭，而不能进一步区分结果。Nmap 会将端口状态报告为六种状态之一。前三种是大多数枚举操作中最常见的状态，而后面三种则是根据不同扫描技术的特殊响应：
- en: '**open**: As its name suggests, the reported port is actively accepting connection
    requests; that is, a service on the target is up and available to serve clients.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放**：顾名思义，报告的端口正在积极接收连接请求；也就是说，目标上的某个服务正在运行并且可供客户端使用。'
- en: '**Closed**: This is where the granularity of Nmap’s report starts to show.
    Suppose that on one target, a port isn’t being blocked by any kind of packet filtering
    mechanism, but there’s simply no service running there. Now, suppose that, on
    a different target, we can’t tell if there’s a service or not because there’s
    an active filtering mechanism in play. Your *run-of-the-mill* port scan will not
    distinguish those conditions – Nmap will. Closed is the former scenario – the
    port is reachable and can respond to the probes, but there’s no service present.
    The next state is where filtering comes into play.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：这是 Nmap 报告的粒度开始显现的地方。假设在一个目标上，某个端口没有被任何包过滤机制阻塞，但该端口上没有任何服务在运行。现在，假设在另一个目标上，我们无法判断是否有服务，因为有一个活跃的过滤机制在起作用。你常见的端口扫描无法区分这些情况——Nmap
    可以。关闭就是前者的情况——端口是可访问的并且可以响应探针，但没有服务存在。下一个状态是过滤机制开始发挥作用的地方。'
- en: '**Filtered**: Now, Nmap has established that something is preventing our probes
    from getting to this port, whether it’s a network-based firewall, host-based firewall,
    or even some kind of routing rule.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已过滤**：现在，Nmap 已经确定有某种机制阻止了我们的探针到达此端口，无论是基于网络的防火墙、主机防火墙，还是某种路由规则。'
- en: '**Unfiltered**: This is a special result from ACK scans that shows that the
    port is accessible, but Nmap couldn’t establish its state. The other scan types
    can resolve this ambiguity. Narrowing down the ports where you may need to resort
    to an SYN scan can help with stealth.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未过滤**：这是来自 ACK 扫描的一种特殊结果，表明端口是可访问的，但 Nmap 无法确定其状态。其他扫描类型可以解决这种模糊性。缩小可能需要
    resort 到 SYN 扫描的端口，有助于提高隐蔽性。'
- en: '**Open|Filtered**: This is to be read, in plain English, as “open or filtered.”
    It’s one of the special results for certain scan types and it means Nmap can’t
    be sure if the port is open or filtered when running a scan type where open ports
    are expected to give no response. For example, consider the UDP scan that we discussed
    previously. UDP is connectionless, so an open UDP port may not respond to our
    probes. Another example is the NULL or Xmas scans, which rely on the RFC’s prescription
    of merely dropping weird packets received at open ports – Nmap is expecting that
    there will be no response. Naturally, this leaves us asking, “*How do we know
    that there isn’t a firewall that silently dropped our packet, and it never even
    made it to the port?*” This is why Nmap is telling you “open or filtered.”'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放|过滤**：这应以简单明了的英文理解为“open or filtered”。这是某些扫描类型的特殊结果，表示Nmap无法确定端口是开放的还是被过滤的，尤其在执行预期没有响应的开放端口扫描时。例如，考虑我们之前讨论的UDP扫描。UDP是无连接的，因此一个开放的UDP端口可能不会对我们的探测作出响应。另一个例子是NULL扫描或圣诞扫描，它们依赖于RFC规定的只丢弃接收到的异常数据包的行为——Nmap预期这些开放端口不会有响应。自然而然地，这就让我们产生了疑问，"*我们怎么知道是不是有防火墙悄悄丢弃了我们的数据包，而且根本没有到达端口？*"
    这就是Nmap告诉你“open or filtered”的原因。'
- en: '**Closed|Filtered**: Just like the previous one, but “*closed*” instead of
    “*open*” – Nmap can’t tell if the targeted port is actually closed or if it’s
    just being filtered. The special situation here is the idle zombie scan. Recall
    that if our probe hits an open port on the target, the target will reply SYN/ACK
    and send it to the zombie. The zombie, not expecting any SYN/ACK from our target,
    responds with an RST packet – thus, this packet increments the fragment ID counter
    and Nmap will consider the port open. But what if our probe hits a closed port
    on the target? Then the target sends an RST to the zombie – and if the zombie
    is following the functional specification, it will *ignore* our target’s RST packet.
    Thus, there is no response and no fragment ID is incremented. Now, suppose the
    port can’t be reached because of a firewall – then nothing ever reaches the target,
    which means it has no reason to send anything to the zombie, which accordingly
    sends no packets to increment the fragment ID. From the perspective of the Nmap
    scanner that is monitoring the zombie, there’s no way to know the difference between
    closed and filtered.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭|过滤**：就像之前的情况一样，不过是“*closed*”而不是“*open*”——Nmap无法判断目标端口是否真正关闭，还是只是被过滤了。这里的特殊情况是空闲僵尸扫描。回想一下，如果我们的探测命中目标的开放端口，目标会回应SYN/ACK并将其发送到僵尸。僵尸并不期望从目标收到SYN/ACK，因此会回应一个RST数据包——这样，这个数据包就会增加分段ID计数器，Nmap就会认为端口是开放的。但如果我们的探测命中目标的关闭端口呢？那目标就会发送一个RST到僵尸——如果僵尸遵循功能规范，它会*忽略*目标的RST数据包。因此，没有响应，也没有分段ID增加。现在，假设由于防火墙的存在，端口无法到达——那么就没有任何数据包能够到达目标，这意味着目标没有理由向僵尸发送任何数据包，从而僵尸也不会发送任何数据包来增加分段ID。从Nmap扫描器监视僵尸的角度来看，无法分辨端口是关闭的还是被过滤的。'
- en: Now that we have a nice foundation for Nmap discovery, probing, and the responses
    from these probes, it’s time to dive into Nmap’s ability to evade detection.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为Nmap发现、探测以及这些探测的响应打下了坚实的基础，是时候深入探讨Nmap的规避检测能力了。
- en: Firewall/IDS evasion, spoofing, and performance
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防火墙/IDS规避、欺骗和性能
- en: “Oh, the Noise! Noise! Noise! Noise! That’s one thing he hated!”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，噪音！噪音！噪音！噪音！这是他最讨厌的事！”
- en: –Dr. Seuss
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: –苏斯博士
- en: 'We have already covered some scanning techniques that can serve as firewall
    or IDS evasion: the NULL, FIN, Xmas, and Maimon scans. However, keep in mind that
    this tool is fairly old and has been in active development for several years.
    The clever tricks that Nmap can cook up have been known for a long time, so any
    IDS will know something is up. The story isn’t over, though: advancements in technology
    have been accompanied by an increase in network chatter. Just loading a simple
    website takes a lot more data than it used to, and there are many legitimate reasons
    why a host may be querying others in a way that’s exciting for hackers. This all
    adds up to *noise*. Add into this equation the business component: your clients
    are businesses first and foremost. This is the entire reason your role even exists,
    so respect it! Business needs will always clash with security needs, and the ideal
    solution is going to be a delicate balance between the two. What this means for
    us during our Nmap analysis is simple – attempting to research every single potentially
    suspicious activity is simply unfeasible. Thus, the defense tends to work with
    *thresholds*. There are two main perspectives here: you can confuse the defender,
    or you can fly under the radar.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了一些可以用于防火墙或入侵检测系统（IDS）规避的扫描技术：NULL、FIN、Xmas 和 Maimon 扫描。然而，请记住，这个工具相对较老，已经在积极开发多年。Nmap
    能够使用的巧妙技巧早已为人所知，因此任何 IDS 都能察觉到有问题。不过，故事并未结束：技术的进步伴随着网络流量的增加。仅仅加载一个简单的网站所需的数据量比以前要大得多，而且有许多正当理由说明某个主机可能会以对黑客来说充满吸引力的方式查询其他主机。这一切最终加起来就是*噪音*。再加上商业因素：你的客户首先是企业。这也是你存在的全部原因，所以要尊重这一点！商业需求总是与安全需求发生冲突，理想的解决方案是这两者之间的微妙平衡。这对我们在进行
    Nmap 分析时意味着什么呢——尝试研究每一项可能的可疑活动根本不可行。因此，防御通常会采用*阈值*的方法。这里有两个主要视角：你可以迷惑防御者，或者你可以保持低调。
- en: First, let’s look at confusing the defender. Nmap lets you fragment its packets
    (**-f**), and you can precisely define how fragmented things will get. The idea
    here is that there are just so many packets for any given task that it makes it
    harder for the defenders to screen them. Keep in mind that firewalls and hosts
    can choose to queue up all the fragments – however, this might be impractical
    for large networks. One of my favorite ways of creating confusion is the decoy
    option (**-D**), which performs your scanning activities normally but also generates
    packets with spoofed return addresses. Unlike the idle zombie scan, we get our
    probes back here; however, the defender will see any number of *other* hosts scanning
    them, too! The best way for this to work is by using hosts that are up, so use
    IP addresses from your host discovery phase. You can also just do a good old-fashioned
    source address spoof (**–S**), but as you may imagine, you won’t get the responses
    back. There might be situations in which this source address spoof is useful,
    though. For example, perhaps you’re able to intercept all the traffic so that
    you can see the response anyway. The other kind of source spoof that is useful
    is spoofing the port number (**-g**). Due to oversight or otherwise, many firewalls
    don’t restrict source ports. An additional step you can take when creating confusion
    is appending custom data to the packets (**--data** for hex and **--data-string**
    for strings). This is very much dependent on the situation, but you can imagine
    the amount of power Nmap gives you over your probes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看如何迷惑防御者。Nmap 允许你将数据包进行分片（**-f**），并且你可以精确地定义数据包分片的程度。这里的思路是，对于任何给定的任务，数据包数量如此之多，以至于使得防御者更难筛选它们。请记住，防火墙和主机可以选择将所有分片排队处理——然而，对于大型网络来说，这可能不太实际。我最喜欢制造混乱的方式之一是诱饵选项（**-D**），它会正常执行扫描活动，但同时生成带有伪造返回地址的数据包。与闲置僵尸扫描不同，我们在这里会收到回传探测数据；然而，防御者也会看到有任何数量的*其他*主机在扫描它们！为了使这种方法发挥作用，最好的方式是使用处于活动状态的主机，因此请使用你在主机发现阶段获得的
    IP 地址。你也可以直接进行传统的源地址欺骗（**–S**），但正如你可能想象的那样，你是无法获得响应的。然而，这种源地址欺骗在某些情况下可能会有用。例如，假设你能够截获所有流量，这样你依然可以看到响应。另一种有用的源欺骗方法是伪造端口号（**-g**）。由于疏忽或其他原因，许多防火墙并未限制源端口。你在制造混乱时还可以采取的额外步骤是将自定义数据附加到数据包中（**--data**
    用于十六进制数据，**--data-string** 用于字符串）。这非常依赖于具体情况，但你可以想象 Nmap 在探测过程中给你带来的强大控制力。
- en: The other perspective is flying under the radar. Any intrusion detection system
    has some means of logging something that triggered a rule, and it’s surprising
    how often we can go unnoticed simply by being slow. Though Nmap is well-known
    for its speed, sometimes, that’s the opposite of what you need – and not just
    for dodging defenses, either. You may be stuck with rate limiting or a bad connection.
    Nmap gives you some timing control by offering both timing templates (**-T**)
    and the ability to define the time between probes and parallelization. Let’s take
    a look at the templates, which have predefined values for the time between probes
    and how parallelization works. First, you have **paranoid** (**-T0**). As its
    name suggests, it is extremely slow – 5 minutes between probes and no parallelization.
    The next level up is **sneaky** (**-T1**), which is more reasonable while still
    being evasive. The delay between probes reaches 15 seconds, but packets are still
    sent one at a time. Next is **polite** (**-T2**), which increases the speed to
    0.4 seconds between probes. This sounds decently fast but it is still well below
    Nmap’s ability – it is “*polite*” because it’s not trying to be evasive; it’s
    just being nice to resources. The default setting of Nmap is called **normal**
    (**-T3**, though you’d merely omit this flag for the same settings), where we
    start parallelizing our probes. The **aggressive** (**-T4**) and **insane** (**-T5**)
    modes are useful when speed is a paramount concern and you have a very fast network.
    **aggressive** mode is fine for assessing large organizations with zippy resources,
    but **insane** mode is probably better for testing or demonstration purposes,
    or on very fast networks. After all, the author of the tool *did* warn us when
    he called it insane.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是低调行事。任何入侵检测系统都有某种方式来记录触发规则的事件，令人惊讶的是，我们常常能仅凭慢速操作而不被注意到。虽然 Nmap 因其速度而闻名，但有时这恰恰不是你所需要的——不仅仅是为了躲避防御系统。你可能会因为速率限制或网络连接不好而被卡住。Nmap
    提供了一些时间控制的选项，提供了定时模板（**-T**）和定义探测之间时间以及并行化的能力。让我们来看看这些模板，它们为探测之间的时间和并行化的工作方式提供了预定义的值。首先是
    **paranoid**（**-T0**）。顾名思义，它非常慢——每次探测之间需要 5 分钟，并且没有并行化。下一个级别是 **sneaky**（**-T1**），它在保持隐蔽性的同时更加合理。探测之间的延迟达到
    15 秒，但数据包仍然是一个一个地发送。接下来是 **polite**（**-T2**），它将探测之间的时间增加到 0.4 秒。听起来相当快，但仍然远低于
    Nmap 的能力——它之所以叫做“*polite*”，是因为它不是为了规避检测；它只是对资源比较友好。Nmap 的默认设置叫做 **normal**（**-T3**，不过你可以省略这个标志来使用相同的设置），此时我们开始并行化探测。**aggressive**（**-T4**）和
    **insane**（**-T5**）模式在速度至关重要并且你有非常快的网络时非常有用。**aggressive** 模式适用于评估拥有高速资源的大型组织，但
    **insane** 模式可能更适合测试或演示目的，或者在非常快速的网络上使用。毕竟，工具的作者在称它为“insane”时*确实*提醒过我们。
- en: Service and OS detection
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务和操作系统检测
- en: There’s blindly knocking on a door, and then there’s reading all the signage
    out front. Nmap can go well beyond merely establishing the presence of a service
    – it will have a nice chat with it and gather information about the service. While
    it runs, Nmap references a database to parse the information and return version
    information. You can tweak the *intensity* of the version analysis (**--version-intensity**)
    to a level between 0 and 9\. The default is already 7, so you won’t need 8 or
    9 until you suspect something esoteric.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有盲目敲门的做法，也有在门前阅读所有标识的做法。Nmap 不仅仅是确认服务是否存在，它会与服务进行良好的对话，并收集关于服务的信息。在运行过程中，Nmap
    会引用一个数据库来解析信息并返回版本信息。你可以调整版本分析的*强度*（**--version-intensity**），其值范围在 0 到 9 之间。默认值是
    7，除非你怀疑有一些晦涩的内容，否则你不需要使用 8 或 9。
- en: Similar to a database that helps Nmap parse version information out of conversations
    with services, Nmap also has a database that contains more than 2,600 OS *fingerprints*
    that allow it to determine the host OS based on how the TCP/IP stack behaves.
    We explored this concept in [*Chapter 2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)*,
    Bypassing Network Access Control*, when we used **p0f** to fingerprint OS fingerprints.
    It considers things such as Time To Live, Maximum Segment Size, and more to guess
    the OS that sent those packets. Keep in mind that it is a guess, so its reliability
    can vary. Also, keep in mind that, as we have learned, you can use the database
    to build custom packets (for example, with Scapy) that Nmap will say came from
    any OS you please. Maybe it’s a Windows XP box, maybe it’s a Linux box that wants
    to look like XP.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于帮助 Nmap 解析与服务对话中的版本信息的数据库，Nmap 还拥有一个包含超过 2600 个操作系统*指纹*的数据库，允许它根据 TCP/IP
    堆栈的行为来确定主机操作系统。我们在[*第 2 章*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)*，绕过网络访问控制*中探讨了这个概念，当时我们使用
    **p0f** 来指纹识别操作系统。它考虑了诸如生存时间、最大报文段大小等因素，以猜测发送这些数据包的操作系统。请记住，这只是一个猜测，因此它的可靠性可能会有所不同。此外，记住，正如我们所学，你可以使用数据库来构建自定义数据包（例如使用
    Scapy），Nmap 会说这些数据包来自任何你想要的操作系统。也许它是一个 Windows XP 机器，也许它是一个想要伪装成 XP 的 Linux 机器。
- en: The Nmap Scripting Engine (NSE)
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Nmap 脚本引擎（NSE）
- en: If I had to reduce Nmap to just two core features, I’d call it a port scanner
    and a networking scripting engine. This is where Nmap is blurring the lines between
    a simple network testing utility up to a vulnerability scanner and a pen testing
    sidekick. Using the Lua programming language, anyone can create scripts to automate
    Nmap to not just conduct all of the recon discussed previously, but even probe
    for and (safely) exploit vulnerabilities. In Kali, head on over to **/usr/share/nmap/scripts**
    and punch in **ls | grep "http"** to see what’s available for just that protocol
    alone.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我必须将 Nmap 简化为仅有的两个核心功能，我会称它为端口扫描器和网络脚本引擎。Nmap 就是在模糊简单的网络测试工具与漏洞扫描器以及渗透测试助手之间的界限。使用
    Lua 编程语言，任何人都可以创建脚本，自动化 Nmap，不仅可以执行之前讨论的所有侦查任务，甚至还可以探测和（安全地）利用漏洞。在 Kali 中，前往 **/usr/share/nmap/scripts**，输入
    **ls | grep "http"** 查看仅针对该协议的可用脚本。
- en: 'By way of example, let’s use Nmap to look for VNC connections that don’t require
    authentication. We will invoke the script in question with **–-script <name>**,
    which you can copy right out of the **scripts** folder (leave out the **.nse**
    extension). Then, running as root, we will execute **nmap -–script vnc-brute –p
    5900 -–open 192.168.108.0/24** and wait for the scan to complete:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以示例的方式，让我们使用 Nmap 查找不需要身份验证的 VNC 连接。我们将使用 **–-script <name>** 来调用相关脚本，脚本可以直接从
    **scripts** 文件夹中复制（去掉 **.nse** 后缀）。然后，以 root 用户身份运行 **nmap -–script vnc-brute
    –p 5900 -–open 192.168.108.0/24** 并等待扫描完成：
- en: '![Figure 5.1 – Running Nmap with an NSE script enabled ](image/Figure_5.01_B17616.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 启用 NSE 脚本运行 Nmap](image/Figure_5.01_B17616.jpg)'
- en: Figure 5.1 – Running Nmap with an NSE script enabled
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 启用 NSE 脚本运行 Nmap
- en: As you can see, Nmap is doing its job – and for each host, the script steps
    in and does its job.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Nmap 正在完成它的工作——对于每个主机，脚本都会介入并执行它的工作。
- en: Hands-on with Nmap
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Nmap 动手实践
- en: 'Okay, that’s a lot of theory – now, let’s sit down with Nmap. I think your
    first step should always be to run Nmap with no arguments, causing the help screen
    to appear:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这么多理论——现在，让我们坐下来使用 Nmap。我认为你第一步应该总是运行没有任何参数的 Nmap，这样就会出现帮助屏幕：
- en: '![Figure 5.2 – Running Nmap with no arguments ](image/Figure_5.02_B17616.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 无参数运行 Nmap](image/Figure_5.02_B17616.jpg)'
- en: Figure 5.2 – Running Nmap with no arguments
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 无参数运行 Nmap
- en: I’ve done this so that we can step through building our command. This help screen
    is fantastic, allowing us to use a command-line tool while offering the experience
    of ordering a three-course meal. **Host Discovery** is the crab cake appetizer,
    **Scan Techniques** is the steak, **Service Detection** is the side of potatoes
    (or vegetables if you’re watching your carbs), and so on. Let’s build our scenario
    first.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是为了帮助我们逐步构建我们的命令。这个帮助屏幕非常棒，它允许我们使用命令行工具，同时提供点餐三道菜的体验。**主机发现**是蟹饼开胃菜，**扫描技术**是牛排，**服务检测**是土豆配菜（或者如果你在控制碳水化合物，可以选择蔬菜），依此类推。让我们先构建我们的场景。
- en: 'Let’s suppose I want to simply look for web servers on either port 80 or 443\.
    I don’t want to discover which ones are up first; I want to check every single
    IP in the range, just so I know I’m not missing anything. The web servers are
    always found in the 10-20 section of several slash-24 subnets; that is, of the
    256 possible IPs ranging from 0 to 255, our targets will end in a number between
    10 and 20\. The range starts at **10.10.105.0** and ends at **10.10.115.255**.
    I want to use half-open scanning so that the application doesn’t log a connection.
    If servers are discovered, I want to grab version information. I want this to
    be reasonably fast, but I’ve been asked by my client’s networking administrator
    to be friendly with the probes. Finally, I want the results to only include hosts
    where these ports have been established as open or possibly open. Okay, let’s
    look at our menu, saving the target specification for last:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想简单地寻找端口80或443上的Web服务器。我不想先检测哪些服务器在线；我希望扫描整个范围的每个IP，只是为了确保没有遗漏任何服务器。Web服务器通常位于几个/24子网的10-20部分；也就是说，在256个可能的IP地址（从0到255）中，我们的目标IP会以10到20之间的数字结尾。范围从**10.10.105.0**开始，到**10.10.115.255**结束。我希望使用半开放扫描，以便应用程序不会记录连接。如果发现服务器，我希望获取版本信息。我希望扫描速度合理，但客户的网络管理员要求我在探测时要“友好”。最后，我希望结果只包括那些已确认开放或可能开放的端口的主机。好了，让我们看看菜单，将目标指定留到最后：
- en: '![Figure 5.3 – Identifying our desired host discovery option ](image/Figure_5.03_B17616.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 确定我们期望的主机发现选项](image/Figure_5.03_B17616.jpg)'
- en: Figure 5.3 – Identifying our desired host discovery option
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 确定我们期望的主机发现选项
- en: 'I don’t want to establish if a host is online – I just want to get to port
    scanning. So, my first argument is **–Pn**. Now, let’s look at the scan techniques:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想确定主机是否在线——我只想进行端口扫描。因此，我的第一个参数是**–Pn**。现在，我们来看一下扫描技术：
- en: '![Figure 5.4 – Identifying our desired scan technique ](image/Figure_5.04_B17616.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 确定我们期望的扫描技术](image/Figure_5.04_B17616.jpg)'
- en: Figure 5.4 – Identifying our desired scan technique
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 确定我们期望的扫描技术
- en: 'I want a half-open scan, so I have picked **–sS**. Now, let’s look at the port
    specification and service detection setting:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要一个半开放扫描，因此选择了**–sS**。现在，我们来看一下端口指定和服务探测设置：
- en: '![Figure 5.5 – Identifying our desired port range and service detection setting
    ](image/Figure_5.05_B17616.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 确定我们期望的端口范围和服务探测设置](image/Figure_5.05_B17616.jpg)'
- en: Figure 5.5 – Identifying our desired port range and service detection setting
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 确定我们期望的端口范围和服务探测设置
- en: I know my ports are 80 and 443, and I only want to see confirmed open ports,
    so the next command is **–p 80,443 --open**. I want version information from the
    servers I find, so I have added **–sV**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我的端口是80和443，并且只希望看到已确认开放的端口，因此接下来的命令是**–p 80,443 --open**。我希望从找到的服务器中获取版本信息，因此添加了**–sV**。
- en: 'Now, the last step before we specify our targets is to configure timing. The
    keyword was “friendly” when the network admin asked us to tone it down, so let’s
    go with the polite template by adding **–T2**:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们指定目标之前的最后一步是配置时间设置。网络管理员要求我们降低探测强度时，使用的关键词是“友好”，所以我们通过添加**–T2**来选择礼貌的模板：
- en: '![Figure 5.6 – Identifying our desired timing template ](image/Figure_5.06_B17616.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 确定我们期望的时间模板](image/Figure_5.06_B17616.jpg)'
- en: Figure 5.6 – Identifying our desired timing template
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 确定我们期望的时间模板
- en: Now, we must define the target IP addresses. Thankfully, Nmap gives us the freedom
    to use more human-friendly methods of defining ranges; a dash between two numbers
    makes that a range, and you can do it within the octets. So, we know our range
    starts at **10.10.105.0** and ends at **10.10.115.255**. Thus, this makes the
    specification **10.10.105-115.255**. Ah, but wait – we only want the 10 addresses
    from 10 to 20\. Therefore, the specification is **10.10.105-115.10-20**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义目标IP地址。幸运的是，Nmap允许我们使用更为人性化的方式来定义范围；两个数字之间加一个短横线就能表示一个范围，甚至可以在八位字节内进行定义。所以，我们知道范围从**10.10.105.0**开始，到**10.10.115.255**结束。因此，定义为**10.10.105-115.255**。哦，等等——我们只需要10到20之间的10个地址。所以，定义为**10.10.105-115.10-20**。
- en: 'Put it all together to see your command on the screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容汇总，查看屏幕上的命令：
- en: '![Figure 5.7 – The full command, ready for execution ](image/Figure_5.07_B17616.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 完整命令，准备执行](image/Figure_5.07_B17616.jpg)'
- en: Figure 5.7 – The full command, ready for execution
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 完整命令，准备执行
- en: Where you will really enjoy Nmap’s power is in Metasploit Console. Let’s take
    a look.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你将真正享受到Nmap强大功能的地方是在Metasploit控制台。我们来看看。
- en: Integrating Nmap with Metasploit Console
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Nmap 与 Metasploit 控制台集成
- en: Suppose you want to run some auxiliary modules in Metasploit and you want to
    do some host discovery first. Here’s the catch, though – you want the discovered
    hosts that meet your criteria to be in Metasploit’s PostgreSQL database. Look
    no further than **db_nmap**, the incarnation of Nmap that works directly with
    your database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在 Metasploit 中运行一些辅助模块，并且你想先进行一些主机发现。但这里有个问题 – 你希望符合你条件的已发现主机存在于 Metasploit
    的 PostgreSQL 数据库中。别无他法，只需使用 **db_nmap**，这是与你的数据库直接工作的 Nmap 的具象化版本。
- en: 'First, we need to make sure the database is up and initiated. If you haven’t
    done that already, go ahead and run **msfdb init**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保数据库已启动和初始化。如果你还没有这样做，请运行 **msfdb init**：
- en: '![Figure 5.8 – Configuring Metasploit’s database for the first time ](image/Figure_5.08_B17616.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 首次配置 Metasploit 的数据库](image/Figure_5.08_B17616.jpg)'
- en: Figure 5.8 – Configuring Metasploit’s database for the first time
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 首次配置 Metasploit 的数据库
- en: 'Now that we’re up and running, load up Metasploit with the **msfconsole** command.
    When the **msf6** prompt appears, check the database’s status with **db_status**.
    Assuming we’re ready to go, I can just fire off **db_nmap** right here at the
    **msf6** prompt. I only want Nmap to spit out hosts where the port is confirmed
    open, so I am using the **–-open** flag here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动，使用 **msfconsole** 命令加载 Metasploit。当 **msf6** 提示出现时，使用 **db_status**
    检查数据库的状态。假设我们准备好了，我可以在 **msf6** 提示符下直接运行 **db_nmap**。我只希望 Nmap 输出端口确认打开的主机，因此在这里使用
    **–-open** 标志：
- en: '![Figure 5.9 – Running db_nmap within our Metasploit Console session ](image/Figure_5.09_B17616.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 在我们的 Metasploit 控制台会话中运行 db_nmap](image/Figure_5.09_B17616.jpg)'
- en: Figure 5.9 – Running db_nmap within our Metasploit Console session
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 在我们的 Metasploit 控制台会话中运行 db_nmap
- en: 'Once our scan is complete, a simple **hosts** command will query the database
    for the hosts we’ve captured. As you can see, there were three hosts running VNC
    on port **5900**:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的扫描完成，一个简单的 **hosts** 命令将查询数据库中我们捕获的主机。正如你所看到的，有三台主机在端口 **5900** 上运行 VNC：
- en: '![Figure 5.10 – db_nmap output entered into the database ](image/Figure_5.10_B17616.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 将 db_nmap 输出输入到数据库中](image/Figure_5.10_B17616.jpg)'
- en: Figure 5.10 – db_nmap output entered into the database
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 将 db_nmap 输出输入到数据库中
- en: Now, I will switch over to the auxiliary scanner with the **use scanner/vnc/vnc_login**
    command. I’ll run the **hosts** command again, but this time, I’ll pass **–R**
    to auto-populate the **RHOSTS** property of the module!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将使用 **use scanner/vnc/vnc_login** 命令切换到辅助扫描程序。我将再次运行 **hosts** 命令，但这次我会传递
    **–R** 来自动填充模块的 **RHOSTS** 属性！
- en: 'Finally, I can use **run** or **exploit** to run this module:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以使用 **run** 或 **exploit** 运行这个模块：
- en: '![Figure 5.11 – Setting RHOSTS with the database entries and running the module
    ](image/Figure_5.11_B17616.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 使用数据库条目设置 RHOSTS 并运行模块](image/Figure_5.11_B17616.jpg)'
- en: Figure 5.11 – Setting RHOSTS with the database entries and running the module
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 使用数据库条目设置 RHOSTS 并运行模块
- en: As you can imagine, being able to let Nmap work directly with Metasploit’s database
    makes our lives a whole lot easier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，让 Nmap 直接与 Metasploit 的数据库配合工作能极大地简化我们的生活。
- en: Let’s take a break from Nmap and Metasploit and get into something truly invasive
    – intercepting binaries and injecting our own.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时把注意力从 Nmap 和 Metasploit 转移到一些真正具有侵入性的事情上 – 拦截二进制文件并注入我们自己的内容。
- en: Exploring binary injection with BetterCAP
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BetterCAP 探索二进制注入
- en: 'In [*Chapter 3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050), *Sniffing
    and Spoofing*, we explored custom filters with Ettercap to manipulate traffic
    on the fly. When we can serve as the go-between, the possibilities are exciting:
    we can manipulate messages between the server and user, even to the extent of
    delivering an executable masquerading as their requested file. BetterCAP continues
    to make things better (and easier) by allowing for slick automation of this process.
    In this exercise, we’re going to prepare a malicious executable for a Windows
    target and call it **setup.exe**. Then, we’ll set up a man-in-the-middle proxy
    attack that will intercept an HTTP request for an installer and invisibly replace
    the downloaded binary with ours. We’ll be covering these concepts and tools in
    more detail later in this book, so consider this an introduction to the power
    of custom modules in advanced man-in-the-middle attacks.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050)，*嗅探和欺骗*，我们使用Ettercap探索定制过滤器，以即时操纵流量。当我们充当中间人时，可能性令人兴奋：我们可以操纵服务器和用户之间的消息，甚至可以交付伪装为其请求文件的可执行文件。BetterCAP通过允许对此过程进行流畅自动化，使事情变得更好（和更容易）。在这个练习中，我们将为Windows目标准备一个恶意可执行文件并称之为**setup.exe**。然后，我们将设置一个中间人代理攻击，拦截一个安装程序的HTTP请求，并将下载的二进制文件无形地替换为我们自己的。稍后在本书中我们将更详细地涵盖这些概念和工具，因此请将其视为高级中间人攻击自定义模块强大功能的介绍。
- en: The magic of download hijacking
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载劫持的魔力
- en: Now, curl up with a cup of hot cocoa while Grandpa Phil rocks in his chair and
    regales you with tales from the distant past (2018, when the first edition was
    published). Back then, BetterCAP was a CLI tool and we could tweak the underlying
    functionality after brushing up on our Ruby. These days, as we saw in [*Chapter
    3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050), *Sniffing and Spoofing*,
    BetterCAP is a slick and powerful point-and-click environment sporting an HTTP
    UI and even an API. (If you’re a scripter and you understand how to work with
    APIs, you’ll drool at the opportunity inherent to BetterCAP.) The environment
    allows you to manage **caplets**, the new word for modules. For our binary injection
    exercise, we’ll be working with the **download-autopwn** caplet. The principle
    is straightforward – wait for an executable to be requested, then drop our executable
    in its place. The process is seamless – our payload is delivered by the same mechanism
    that was queried, so we don’t have to masquerade the interface or messages. BetterCAP
    will even do us the favor of stuffing the executable with fluff to meet the file
    size, which is especially useful when our payload is a lightweight connect-back
    Trojan.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拿起一杯热可可，享受一下，而Phil爷爷在摇椅上摇摇晃晃，并讲述来自遥远过去（2018年，第一版出版时）的故事。那时，BetterCAP是一个CLI工具，我们可以在熟悉Ruby后调整其基础功能。如今，正如我们在[*第3章*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050)
    *嗅探和欺骗*中看到的那样，BetterCAP是一个流畅而强大的点-and-click环境，配备了HTTP UI甚至API。（如果您是脚本编写者并且懂得如何使用API，您将对BetterCAP提供的机会感到兴奋。）该环境允许您管理**caplets**，这是模块的新名称。在我们的二进制注入练习中，我们将使用**download-autopwn**
    caplet。其原理很简单 - 等待请求可执行文件，然后将我们的可执行文件放在其位置。该过程是无缝的 - 我们的载荷通过查询时相同的机制传送，因此我们无需伪装界面或消息。BetterCAP甚至会帮助我们将可执行文件填充到文件大小以符合要求，特别是当我们的载荷是轻量级连接回归特洛伊木马时，这一点尤为有用。
- en: Getting Your Environment Ready
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 准备您的环境
- en: If you aren’t joining us from [*Chapter 3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050),
    *Sniffing and Spoofing*, you’ll need to get BetterCAP installed and running on
    Kali. First, run **apt-get update && apt-get install bettercap** to get it installed.
    Then, run the **bettercap –caplet http-ui** command. Don’t forget that the default
    credentials are **user:pass**. Open a new shell window as root for the other activities
    here; BetterCAP will run in the background and wait for your HTTP session.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是从[*第3章*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050) *嗅探和欺骗*一起加入我们，您需要在Kali上安装和运行BetterCAP。首先，运行**apt-get
    update && apt-get install bettercap**进行安装。然后，运行**bettercap –caplet http-ui**命令。不要忘记默认凭据是**user:pass**。为其他活动在root下打开一个新的shell窗口；BetterCAP将在后台运行并等待您的HTTP会话。
- en: Creating the payload and connect-back listener with Metasploit
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Metasploit创建载荷和连接回来的监听器
- en: Of course, you can replace a target file with anything you want. For our demonstration,
    we’ll create a payload designed to connect back to our Kali box where a listener
    is ready. Setting it up will give us a little more hands-on experience with the
    mighty Metasploit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以用任何您想要的目标文件替换目标文件。对于我们的演示，我们将创建一个负载，旨在连接到我们的 Kali 盒子，那里已经准备好了一个监听器。设置它将使我们对强大的
    Metasploit 有更多实际操作的经验。
- en: 'Let’s create our payload with **msfvenom**, a standalone payload generator.
    We’ll be having more fun with **msfvenom** later in this book. I will only run
    the command after I’m established on the network where I want to receive my connect-back
    from the target, so I will start with an **ifconfig** command to grep the connect-back
    IP address that needs to be coded into the payload. In this case, it’s **192.168.249.136**,
    so I will run the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 **msfvenom** 创建我们的负载，这是一个独立的负载生成器。稍后我们将在本书的后面更多地使用 **msfvenom**。我只会在我已经建立好了想要从目标接收回连的网络上运行命令，所以我将从
    **ifconfig** 命令开始，用来提取需要编码到负载中的回连 IP 地址。在这种情况下，它是 **192.168.249.136**，所以我将运行以下命令：
- en: '![Figure 5.12 – Generating a payload with msfvenom ](image/Figure_5.12_B17616.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 使用 msfvenom 生成负载 ](image/Figure_5.12_B17616.jpg)'
- en: Figure 5.12 – Generating a payload with msfvenom
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 使用 msfvenom 生成负载
- en: The options are straightforward: **-p** defines our payload, which in this case
    is the connect-back **meterpreter** session, **-f** is the file type, and **lhost**
    is the IP address that the target will contact (that’s us) on **lport** (**1066**
    because of the Battle of Hastings – just a little trivia to keep things interesting).
    Finally, the **-o** flag allows us to specify where the output will go. In our
    situation, BetterCAP will expect the payload to be called **payload.exe**, so
    I’m setting that here to save me a step later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 选项很简单：**-p** 定义我们的负载，这种情况下是回连的 **meterpreter** 会话，**-f** 是文件类型，**lhost** 是目标将联系的
    IP 地址（也就是我们），**lport** 是端口号（**1066** 是因为哈斯丁斯战役 – 只是一点小知识）。最后，**-o** 标志允许我们指定输出的位置。在我们的情况下，BetterCAP
    将期望负载被称为 **payload.exe**，所以我在这里设置了以节省后续步骤。
- en: 'Before we send our naughty program somewhere, we need a listener standing by.
    Here, we must fire up msfconsole, enter **use exploit/multi/handler**, and set
    our options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们把不良程序发送到某处之前，我们需要一个等待的监听器。在这里，我们必须启动 msfconsole，输入 **use exploit/multi/handler**，并设置我们的选项：
- en: '![Figure 5.13 – Configuring our handler for the inbound connection ](image/Figure_5.13_B17616.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 配置我们的处理程序用于入站连接 ](image/Figure_5.13_B17616.jpg)'
- en: Figure 5.13 – Configuring our handler for the inbound connection
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 配置我们的处理程序用于入站连接
- en: '**LHOST** can be the IP that’s been assigned to our interface or just the zero
    address. Make sure **LPORT** matches what you configured in your payload executable.
    Execute **exploit** and wait for our **meterpreter** session to phone home. Now,
    we can configure and launch BetterCAP. Meanwhile, our target, **192.168.249.139**,
    was engaged in some water cooler chat about a tool called **PdaNet**. He’s planning
    on downloading the installer, **PdaNetA5232b.exe**. Our listener is ready, so
    now, we can jump back to BetterCAP to configure the **download-autopwn** caplet
    and get a better understanding of what it’s going to do.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**LHOST** 可以是分配给我们接口的 IP 地址或者零地址。确保 **LPORT** 与您在负载可执行文件中配置的一致。执行 **exploit**
    并等待我们的 **meterpreter** 会话回家。现在，我们可以配置和启动 BetterCAP。与此同时，我们的目标 **192.168.249.139**
    正在讨论一个名为 **PdaNet** 的工具。他计划下载安装程序 **PdaNetA5232b.exe**。我们的监听器已经准备就绪，所以现在我们可以跳回
    BetterCAP 来配置 **download-autopwn** caplet 并更好地理解它将要做的事情。'
- en: Getting cozy with caplets
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 和 caplets 亲密接触
- en: 'Once you’re logged in to the BetterCAP console, click on the **Caplets** icon
    at the top and browse the list along the left. One glance and you will know this
    tool is *fun*. For now, click on **download-autopwn**. On the right-hand side,
    you’ll see the contents of two files: **download-autopwn.cap** and **download-autopwn.js**.
    The parameters for your attack can be edited in the CAP file; the JavaScript code
    is the actual muscle behind the operation. I don’t find the interface user-friendly
    in this instance, so I’m going to check out the CAP file with nano in a separate
    terminal window:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到 BetterCAP 控制台，点击顶部的 **Caplets** 图标，并浏览左侧的列表。一眼看过去，您就会知道这个工具很有*趣味性*。暂时，点击
    **download-autopwn**。在右侧，您将看到两个文件的内容：**download-autopwn.cap** 和 **download-autopwn.js**。您可以在
    CAP 文件中编辑您攻击的参数；JavaScript 代码是操作的实际核心。在这种情况下，我觉得界面不够用户友好，所以我打算在另一个终端窗口用 nano 检查
    CAP 文件：
- en: '![Figure 5.14 – Reviewing a caplet ](image/Figure_5.14_B17616.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 审查一个 caplet](image/Figure_5.14_B17616.jpg)'
- en: Figure 5.14 – Reviewing a caplet
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 审查一个 caplet
- en: 'Before we make any changes, we need to understand how this works. Once the
    proxy is up, the underlying machinery is going to conduct this attack in the following
    phases:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何更改之前，需要了解这个过程是如何工作的。一旦代理启动，底层机制将按以下阶段进行攻击：
- en: Examine the requested path to find any file extension.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查请求的路径以查找任何文件扩展名。
- en: If the requested path contains an extension, check the user agent data for the
    target OS(s).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求的路径包含扩展名，请检查目标操作系统的用户代理数据。
- en: If the request comes from a target, check the list of target file extensions
    for that system.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求来自目标，请检查该系统的目标文件扩展名列表。
- en: If we have configured padding, BetterCAP examines the size of our payload and
    adds any needed null bytes to fill the file to the brim.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们已配置填充，BetterCAP 会检查我们的负载大小并添加所需的空字节以填满文件。
- en: 'Now, BetterCAP prepares the response message in three steps:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，BetterCAP 分三步准备响应消息：
- en: The Content-Disposition response header is set to **attachment**. This ensures
    that the browser won’t try to display a response page but instead push the download
    right to the browser.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Content-Disposition 响应头被设置为**附件**。这确保了浏览器不会尝试显示响应页面，而是直接将下载推送到浏览器。
- en: The Content-Length header gets stripped.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Content-Length 头被去除。
- en: The payload bytes become the body of the response message.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负载字节将成为响应消息的主体。
- en: 'Fun, right? It’s a big step up from the BetterCAP download intercept of ages
    past. The biggest change is the ability to target machines with their user agent
    data and regex matching. Don’t worry about this fine-tuning now, though – out
    of the box, it’s designed to intercept everything it can see. (Note that our Windows
    target is already defined.) So, tuning our intercept for this session is as easy
    as commenting out the appropriate line. I’m going to comment out everything except
    Windows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣吧？这比过去的 BetterCAP 下载拦截有了很大的提升。最大的变化是能够通过用户代理数据和正则匹配来定位目标机器。不过，暂时不必担心这些精细调整——默认情况下，它设计为拦截它能看到的所有内容。（注意，我们的
    Windows 目标已经定义好了。）因此，调整我们的拦截器就像注释掉适当的行一样简单。我将注释掉除了 Windows 之外的所有内容：
- en: '![Figure 5.15 – Configuring the target system in the download-autopwn caplet
    ](image/Figure_5.15_B17616.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 在 download-autopwn caplet 中配置目标系统](image/Figure_5.15_B17616.jpg)'
- en: Figure 5.15 – Configuring the target system in the download-autopwn caplet
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 在 download-autopwn caplet 中配置目标系统
- en: 'Now, we can scroll down to file extensions. It’s a gold mine, and I encourage
    you to brainstorm some possibilities (malicious APK for Android, anyone?), but
    for now, we’ll comment out the unneeded lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向下滚动到文件扩展名部分。这是一个宝藏，我鼓励你进行一些头脑风暴（比如为 Android 准备的恶意 APK？），但目前我们先注释掉不需要的行：
- en: '![Figure 5.16 – Setting the target file extension in the download-autopwn caplet
    ](image/Figure_5.16_B17616.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 在 download-autopwn caplet 中设置目标文件扩展名](image/Figure_5.16_B17616.jpg)'
- en: Figure 5.16 – Setting the target file extension in the download-autopwn caplet
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 在 download-autopwn caplet 中设置目标文件扩展名
- en: I’m in a lab environment, so I’m not worried about the other file types for
    now, but just be aware that you will want to remove (or add) whatever you need
    for your situation. Finally, the finishing touch is to enable ARP spoofing; this
    friendly caplet can take care of that for us. We’re going to configure our spoofer
    with results from a network probe, so I’ll leave this line commented out.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我在实验室环境中，所以现在不担心其他文件类型，但请注意，你需要根据实际情况移除（或添加）你需要的内容。最后的关键步骤是启用 ARP 欺骗；这个友好的 caplet
    可以为我们处理这个。我们将使用网络探测的结果来配置我们的欺骗工具，因此我将注释掉这一行。
- en: 'Now, we’re all set! Let’s save that modified buffer and take a quick look at
    BetterCAP’s folder layout. Instead of prompting you during the attack, BetterCAP
    will assume you’ve prepped the payload accordingly – that is, you’ve named it
    **payload** and placed it in the appropriate target folder. Let’s run **ls** against
    the **download-autopwn** folder:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪！让我们保存修改后的缓冲区，并快速查看 BetterCAP 的文件夹布局。BetterCAP 在攻击过程中不会提示你，而是默认你已经相应地准备好了负载——也就是说，你已经将其命名为**payload**并将其放置在适当的目标文件夹中。让我们运行**ls**命令查看**download-autopwn**文件夹：
- en: '![Figure 5.17 – File listing in the Windows payloads subfolder ](image/Figure_5.17_B17616.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – Windows 负载子文件夹中的文件列表](image/Figure_5.17_B17616.jpg)'
- en: Figure 5.17 – File listing in the Windows payloads subfolder
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – Windows 负载子文件夹中的文件列表
- en: 'It’s all coming together now, right? Note that by looking at the file sizes,
    these aren’t real payloads. Think of this as a template. So, at this point, we
    go back to our home directory (or wherever you spat out **payload.exe** from **msfvenom**)
    and move it back to the Windows payloads subfolder:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都开始有了进展，对吧？注意，通过查看文件大小，可以看出这些并不是真正的payload。可以把它当作一个模板。所以，在这一点上，我们回到我们的主目录（或者你从**msfvenom**生成**payload.exe**的任何地方），并将其移回Windows
    payloads子文件夹：
- en: '![Figure 5.18 – File listing to confirm the size of payload.exe ](image/Figure_5.18_B17616.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 文件列表，确认payload.exe的大小](image/Figure_5.18_B17616.jpg)'
- en: Figure 5.18 – File listing to confirm the size of payload.exe
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 文件列表，确认payload.exe的大小
- en: 'Checking the sizes one more time, we can see that our 76K file made it over.
    We’re ready to rock and roll, and just in time: **192.168.249.139** is getting
    back to his desk to download that nifty tool. We’ve been sitting at our workstation
    running a probe of our surroundings. Find the target’s IP address, click the dropdown,
    and select **Add to arp.spoof.targets**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查文件大小，我们可以看到我们的76K文件已经成功传输了。我们准备开始了，而且正好赶上：**192.168.249.139**正在回到办公桌上，准备下载这个方便的工具。我们一直坐在工作站上，运行环境探测。找到目标的IP地址，点击下拉菜单，选择**Add
    to arp.spoof.targets**：
- en: '![Figure 5.19 – Configuring the ARP spoof ](image/Figure_5.19_B17616.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 配置ARP欺骗](image/Figure_5.19_B17616.jpg)'
- en: Figure 5.19 – Configuring the ARP spoof
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 配置ARP欺骗
- en: 'Once you add the target, BetterCAP will take you to the configuration for arp.spoof
    and import the probed hosts. This is where you can add other hosts (such as the
    gateway!) and enable things such as full-duplex spoofing. We want to intercept
    a request out to the internet, so we need these options:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加目标，BetterCAP会带你进入arp.spoof的配置界面并导入探测到的主机。在这里，你可以添加其他主机（比如网关！）并启用全双工欺骗等功能。我们希望拦截一条向互联网发出的请求，所以我们需要这些选项：
- en: '![Figure 5.20 – Configuring full-duplex ARP spoofing with the gateway ](image/Figure_5.20_B17616.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – 配置与网关的全双工ARP欺骗](image/Figure_5.20_B17616.jpg)'
- en: Figure 5.20 – Configuring full-duplex ARP spoofing with the gateway
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 配置与网关的全双工ARP欺骗
- en: Now, we can click **Start arp.spoof** and let BetterCAP do its thing. You’ll
    see feedback in the form of pretty popups in the browser, but you’ll see these
    updates in the terminal, too.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以点击**Start arp.spoof**，让BetterCAP执行任务。你会看到浏览器中弹出漂亮的反馈窗口，同时你也可以在终端看到这些更新。
- en: 'That’s all – we’re ready to begin. Head back to the **Caplets** tab, select
    **download-autopwn**, and then click the play button:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些——我们准备开始了。返回到**Caplets**标签页，选择**download-autopwn**，然后点击播放按钮：
- en: '![Figure 5.21 – Firing off the caplet ](image/Figure_5.21_B17616.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – 启动caplet](image/Figure_5.21_B17616.jpg)'
- en: Figure 5.21 – Firing off the caplet
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 启动caplet
- en: 'At this point, we’ll want to watch the progress in the terminal window. The
    log tells us that **download-autopwn** has been enabled and reminds us of our
    parameters. If we get a bite on our fishing line, this is where we’ll see it happen.
    Meanwhile, our target is browsing the home page for the download and spots the
    Windows client:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们需要在终端窗口中观察进度。日志告诉我们**download-autopwn**已经启用，并提醒我们当前的参数。如果我们在钓鱼线上有了反应，我们就能在这里看到。与此同时，我们的目标正在浏览下载的主页，并注意到了Windows客户端：
- en: '![Figure 5.22 – Browsing for files to download on the victim’s browser ](image/Figure_5.22_B17616.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22 – 在受害者浏览器上浏览文件下载](image/Figure_5.22_B17616.jpg)'
- en: Figure 5.22 – Browsing for files to download on the victim’s browser
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 在受害者浏览器上浏览文件下载
- en: 'Meanwhile, on our end, we get the report: the target extension was seen, the
    raw size of our payload is smaller than the requested file, so it gets fluffed
    up, and the spoofed response is served:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们这边收到报告：目标扩展名已被识别，我们的payload的原始大小小于请求的文件，因此它被填充起来，伪造的响应已被提供：
- en: '![Figure 5.23 – The bait and switch is complete ](image/Figure_5.23_B17616.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23 – 诱饵和交换已经完成](image/Figure_5.23_B17616.jpg)'
- en: Figure 5.23 – The bait and switch is complete
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 诱饵和交换已经完成
- en: 'At long last, we can go back to our Metasploit session to wait (and hope) for
    our Meterpreter session to begin:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，我们可以回到我们的Metasploit会话，等待（并希望）我们的Meterpreter会话开始：
- en: '![Figure 5.24 – New Meterpreter session from the target ](image/Figure_5.24_B17616.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24 – 来自目标的新Meterpreter会话](image/Figure_5.24_B17616.jpg)'
- en: Figure 5.24 – New Meterpreter session from the target
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 来自目标的新Meterpreter会话
- en: 'I know what you’re thinking – “*Phil, I just did all these steps with this
    Windows 10 VM I set up, and Defender deleted the payload immediately.*” Indeed;
    for the sake of demonstration, we spat out a plain Meterpreter payload with msfvenom,
    an output that will certainly be flagged by antivirus. This is where the art of
    **antivirus evasion** comes into play, which we’ll look at in [*Chapter 12*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224),
    *Shellcoding – Evading Antivirus*. It’s also worth noting a social engineering
    component: surely, the victim will wonder why apparently nothing happened when
    he executed the installer. We’ll also look at dynamic injection with Shellter
    in [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124), *Advanced Exploitation
    with Metasploit*, as well as how to create message box payloads. Imagine if it
    said something like, **Error detected – please download again**. It’s surprising
    how effective that would be against a lot of people.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么 – “*Phil，我刚刚在这个我设置的 Windows 10 虚拟机上做了所有这些步骤，结果 Defender 立刻删除了有效载荷。*”
    说得对；为了演示，我们使用 msfvenom 输出了一个普通的 Meterpreter 有效载荷，这种输出肯定会被杀毒软件拦截。这就是**杀毒软件规避**技巧的作用，我们将在[*第
    12 章*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224)，*Shellcoding – 规避杀毒软件*中进行详细讨论。值得注意的是，还涉及到社会工程学的成分：受害者肯定会想，为什么在执行安装程序时，看似什么都没有发生。我们还将在[*第
    7 章*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124)，*使用 Metasploit 进行高级利用*中探讨如何使用
    Shellter 进行动态注入，并研究如何创建消息框有效载荷。想象一下，如果显示的是**检测到错误 – 请重新下载**。令人惊讶的是，这对很多人来说非常有效。
- en: In the meantime, we’re going to look at another evasive technique for getting
    our packets around a filtered network.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们将探讨一种规避技术，旨在绕过过滤的网络传输数据包。
- en: Smuggling data – dodging firewalls with HTTPTunnel
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据走私 – 通过 HTTPTunnel 躲避防火墙
- en: 'Now, curl up with another cup of hot cocoa as Grandpa Phil tells you an RDP
    fairytale. We’re going to build a hypothetical situation in which we are lucky
    enough to have a foothold on a Linux server that’s behind a firewall. The firewall
    allows HTTP ports **80**, **443**, and **1433**. You communicated with the server
    over its web service and discovered it is running a vulnerable Apache server.
    We compromised it with a PHP payload and got a shell through the firewall. Here’s
    your extra credit assignment – look at the following screenshot of the payload
    being delivered and figure out the nature of the vulnerability:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拿起另一杯热可可，随着爷爷 Phil 给你讲一个 RDP 的童话故事。我们将构建一个假设场景，假设我们幸运地在一个位于防火墙后面的 Linux 服务器上拥有一个入口。该防火墙允许
    HTTP 端口 **80**、**443** 和 **1433** 的访问。你通过其 Web 服务与服务器进行了通信，并发现它正在运行一个存在漏洞的 Apache
    服务器。我们通过 PHP 有效载荷攻陷了该服务器，并通过防火墙获得了 Shell。以下是你的额外任务 – 查看下面的有效载荷传送截图，弄清楚漏洞的性质：
- en: '![Figure 5.25 – Exploit extra credit – how we compromised our target ](image/Figure_5.25_B17616.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25 – 利用额外积分 – 我们是如何攻陷目标的](image/Figure_5.25_B17616.jpg)'
- en: Figure 5.25 – Exploit extra credit – how we compromised our target
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – 利用额外积分 – 我们是如何攻陷目标的
- en: It’s an oldie but a goldie vulnerability. Despite its age, it’s not unusual
    to see it on internal networks in large organizations. But I digress – back to
    our compromised Linux box.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典漏洞，尽管它已有些年头，但在大型组织的内部网络中仍然很常见。话题有点跑题了 – 让我们回到我们攻陷的 Linux 机器。
- en: What we’ve found is that our compromised Linux server can see a Windows 10 box
    that we want to access with Remote Desktop. We’ve also found that port **1433**
    isn’t hosting a service on the Linux box – presumably, it’s an artifact from an
    older configuration. This is useful but we’re also restricted by deep packet inspection
    – the firewall only permits HTTP traffic. Take a look at the following diagram.
    What’s a hacker to do?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现我们的 Linux 服务器能够看到一台我们希望通过远程桌面访问的 Windows 10 机器。我们还发现，端口 **1433** 并没有在 Linux
    机器上提供服务 – 很可能是旧配置遗留下来的痕迹。这很有用，但我们也受到了深度包检查的限制 – 防火墙仅允许 HTTP 流量。看看以下的示意图。黑客该怎么办呢？
- en: '![Figure 5.26 – HTTP-only firewalling  ](image/Figure_5.26_B17616.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.26 – 仅限 HTTP 的防火墙](image/Figure_5.26_B17616.jpg)'
- en: Figure 5.26 – HTTP-only firewalling
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 仅限 HTTP 的防火墙
- en: 'We already have a root shell on the Linux server, so we could build an HTTP-encapsulated
    tunnel that links our two boxes, and then use the Linux server to contact the
    Windows target on RDP port **3389**. Thankfully, the perfect tool exists for this
    job – HTTPTunnel. In our example, the target server is running Ubuntu and HTTPTunnel
    happens to exist in the repository, so we can drop into the popped shell and pass
    the **apt-get install httptunnel** command on *both* ends – on our Kali attacking
    box and the Ubuntu compromised server. This will install two components: the HTTPTunnel
    *client*, **htc**, and the HTTPTunnel *server*, **hts**. Both ends work via port
    forwarding – **htc** will open a listening port and pass the received data to
    **hts** on the other end of the tunnel; then, **hts** will forward it to a port
    of our choosing. Thus, we’ll need something listening on the **hts** side of the
    tunnel to receive this data. In our example, we’ll use SSH as it’s already on
    the Ubuntu server. Confused yet? Let’s take a better look at this flow before
    continuing:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Linux服务器上获得了root权限，因此可以建立一个HTTP封装隧道，将我们的两台主机连接起来，然后使用Linux服务器联系Windows目标的RDP端口**3389**。幸运的是，有一个完美的工具来完成这项工作——HTTPTunnel。在我们的示例中，目标服务器运行的是Ubuntu，并且HTTPTunnel恰好存在于仓库中，因此我们可以进入已攻陷的Shell，并在*两端*（我们的Kali攻击主机和Ubuntu被攻陷的服务器）运行**apt-get
    install httptunnel**命令。这将安装两个组件：HTTPTunnel *客户端**（**htc**）和HTTPTunnel *服务器**（**hts**）。两端通过端口转发工作——**htc**将打开一个监听端口并将接收到的数据传递给隧道另一端的**hts**；然后，**hts**会将数据转发到我们选择的端口。因此，我们需要在隧道的**hts**端有一个监听器来接收这些数据。在我们的示例中，我们将使用SSH，因为它已经在Ubuntu服务器上运行。还困惑吗？让我们在继续之前更仔细地看看这个数据流：
- en: '![Figure 5.27 – Simplified data flow between the three points in play ](image/Figure_5.27_B17616.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27 – 简化的三点数据流动图](image/Figure_5.27_B17616.jpg)'
- en: Figure 5.27 – Simplified data flow between the three points in play
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 简化的三点数据流动图
- en: We’ll hand off our RDP data to HTTPTunnel on local port **8000** to the server
    running on remote port **1433**; then, this data will be handed off to the SSH
    listener on local port **3535** before getting spat out on remote port **3389**
    on the Windows box. Note that the only arbitrary port numbers here are for the
    local listeners; **1433** is necessary because it’s what the firewall permits,
    and **3389** is the Remote Desktop port.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把RDP数据通过本地端口**8000**交给HTTPTunnel，传递给运行在远程端口**1433**的服务器；然后，这些数据会交给本地端口**3535**上的SSH监听器，再通过远程端口**3389**输出到Windows主机上。请注意，唯一的任意端口号是用于本地监听器的；**1433**是必要的，因为防火墙允许它，**3389**是远程桌面端口。
- en: 'Once we have HTTPTunnel installed, we need to set up our listeners on the compromised
    Ubuntu server. First, let’s set up SSH:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了HTTPTunnel，我们需要在被攻陷的Ubuntu服务器上设置监听器。首先，让我们设置SSH：
- en: '[PRE0]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order, the preceding command sets up a listener on port **3535**, which
    will be forwarded to port **3389** on the host **192.168.108.173** (our Windows
    10 target), and we’re authenticating it with a local user (this could have been
    compromised or you simply created one when you first took control). Next, let’s
    look at the server side of our HTTP tunnel:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，前面的命令在端口**3535**上设置一个监听器，该端口将被转发到主机**192.168.108.173**（我们的Windows 10目标）的端口**3389**，并且我们使用本地用户进行身份验证（这可能已经被攻陷，或者你在首次控制时创建了一个）。接下来，让我们看看我们HTTP隧道的服务器端：
- en: '[PRE1]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order, this command tells **hts** where to send the data that’s coming out
    of our tunnel (to local port **3535**, where SSH is ready) and which port to open
    (**1433**) for an incoming connection from **htc**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，这个命令告诉**hts**将数据发送到隧道中出来的地方（本地端口**3535**，SSH已准备好）以及打开哪个端口（**1433**）来接收来自**htc**的传入连接。
- en: 'We can check the status of our listeners with tools such as **netstat** or
    **ss** and **grep**:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**netstat**或**ss**以及**grep**等工具检查监听器的状态：
- en: '![Figure 5.28 – Configuring and validating our tunnel in a reverse shell session  ](image/Figure_5.28_B17616.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.28 – 在反向Shell会话中配置和验证我们的隧道](image/Figure_5.28_B17616.jpg)'
- en: Figure 5.28 – Configuring and validating our tunnel in a reverse shell session
    with the compromised server
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 在被攻陷的服务器上使用反向Shell会话配置和验证我们的隧道
- en: 'So far, so good. The mechanism that will take the data leaving our HTTP tunnel
    and pass it along to our target’s RDP port is up and running. Now, we need to
    get the client side going. Back in our Kali box, we must pass the **htc –-forward-port
    8000 192.168.108.116:1433** command. In order, this tells **htc** to open local
    port **8000** and send it to the **hts** listener on port **1433** at **192.168.108.116**
    (our compromised Ubuntu server). Again, we must verify that the port is indeed
    up and listening:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。将数据从我们 HTTP 隧道传递到目标的 RDP 端口的机制已经启动并运行。现在，我们需要启动客户端。回到我们的 Kali 主机，我们必须输入
    **htc –-forward-port 8000 192.168.108.116:1433** 命令。按顺序，这条命令告诉 **htc** 打开本地端口
    **8000** 并将其发送到 **192.168.108.116**（我们的被攻陷的 Ubuntu 服务器）上的 **1433** 端口的 **hts**
    监听器。再次，我们必须验证该端口确实已启动并在监听：
- en: '![Figure 5.29 – Configuring and validating the client side of our tunnel on
    the attacking Kali box ](image/Figure_5.29_B17616.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.29 – 在攻击 Kali 主机上配置并验证隧道的客户端](image/Figure_5.29_B17616.jpg)'
- en: Figure 5.29 – Configuring and validating the client side of our tunnel on the
    attacking Kali box
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – 在攻击 Kali 主机上配置并验证隧道的客户端
- en: 'That’s it. It may seem precarious, but we can now connect to the RDP server
    behind the HTTP-only firewall by just pointing our tools at local port **8000**:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。看起来可能有些不稳定，但现在我们只需将工具指向本地端口 **8000**，就能连接到 HTTP 仅限访问的防火墙后面的 RDP 服务器：
- en: '![Figure 5.30 – An RDP session through the HTTP tunnel ](image/Figure_5.30_B17616.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.30 – 通过 HTTP 隧道进行的 RDP 会话](image/Figure_5.30_B17616.jpg)'
- en: Figure 5.30 – An RDP session through the HTTP tunnel
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 通过 HTTP 隧道进行的 RDP 会话
- en: 'If you’re trying this out in your own lab, I recommend firing up Wireshark
    to see the behind-the-scenes action. Note the plain TCP designation; our RDP channel
    is TLS-encrypted, showing that the encrypted data is indeed encapsulated in HTTP.
    Also, note that the network shows us just having a friendly chat with **192.168.108.116**
    on port **1433**, while we’re actually having a desktop session with **192.168.108.173**
    on port **3389**:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的实验室里尝试这个，我建议启动 Wireshark 来查看幕后操作。注意到普通的 TCP 标记；我们的 RDP 通道是经过 TLS 加密的，显示加密数据确实被封装在
    HTTP 中。此外，注意网络上显示我们仅仅是在与 **192.168.108.116** 的 **1433** 端口进行友好对话，而实际上我们是在与 **192.168.108.173**
    的 **3389** 端口进行桌面会话：
- en: '![Figure 5.31 – The network perspective of our encapsulated RDP session ](image/Figure_5.31_B17616.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.31 – 我们封装的 RDP 会话的网络视角](image/Figure_5.31_B17616.jpg)'
- en: Figure 5.31 – The network perspective of our encapsulated RDP session
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 我们封装的 RDP 会话的网络视角
- en: There are a tremendous number of opportunities with this kind of redirection.
    Later in this chapter, we’ll even cover sending our local IPv4 traffic to a remote
    IPv6 host. But first, let’s get familiar with the basics.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重定向方式提供了极大的机会。稍后在本章中，我们还会讨论将本地的 IPv4 流量发送到远程 IPv6 主机。但首先，让我们先了解基础知识。
- en: IPv6 for hackers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑客与 IPv6
- en: I know I say this a lot about certain topics, but a deep dive into the particulars
    of IPv6 could fill its own book, so I have to pick and choose for the discussion
    here. That said, I will cover some introductory knowledge that will be useful
    for further research. As always, my advice for IPv6 is to read the authoritative
    RFCs. RFC 2460 was the original detailed definition and description of the new
    version, but it was a *Draft Standard* for all those years. The levels of *Standard* refer
    to the maturity of the technology being defined, with the *Proposed Standard*
    being the least mature, and the *Internet Standard* being the gold, well, standard.
    IPv6, after those long years, has become an Internet Standard with RFC 8200 (STD
    86) as of July 2017\. Though I certainly encourage reading RFC 2460, it is now
    officially obsolete.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我经常在某些话题上这样说，但深入探讨 IPv6 的细节足以写一本书，所以我必须在这里挑选重点进行讨论。话虽如此，我会介绍一些对进一步研究有用的入门知识。像往常一样，我对
    IPv6 的建议是阅读权威的 RFC 文档。RFC 2460 是新版本的最初详细定义和描述，但它多年来一直是一个 *草案标准*。标准的级别表示所定义技术的成熟度，*提议标准*
    是最不成熟的，*互联网标准* 则是黄金标准。经过多年的发展，IPv6 已经成为了互联网标准，并且自 2017 年 7 月起通过 RFC 8200（STD 86）正式成为标准。尽管我确实鼓励阅读
    RFC 2460，但它现在已经正式废弃。
- en: IPv6 is important to pen testers for two big reasons – one (and hopefully most
    obviously), it’s the newest version of the internet, so you’re only going to see
    more of it; and two, as with many newer things that haven’t quite replaced the
    predecessor yet, it’s not given the same level of security scrutiny in most environments.
    Many administrators aren’t even aware that it’s enabled. You may get some useful
    findings with just basic poking around, and regardless, you’ll help raise awareness
    of this new protocol.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 对渗透测试人员来说有两个重要原因 —— 一是（希望最明显的），它是互联网的最新版本，所以你将会看到更多它的应用；二是，像许多新兴的技术一样，IPv6
    尚未完全取代其前身，在许多环境中并没有受到相同级别的安全审查。许多管理员甚至没有意识到它已经启用。你只需简单地进行一些探索，就可能获得一些有用的发现，而且不管怎样，你都会提高对这一新协议的认识。
- en: IPv6 addressing basics
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 地址基本知识
- en: There are quite a few differences between IPv4 and IPv6; I recommend researching
    those differences by studying the structure of an IPv6 packet. Probably the most
    obvious difference is the address. At first glance, IPv6 addresses are bewildering
    to look at. Aside from being longer than IPv4 addresses, they’re represented (in
    text form) with hexadecimal characters instead of decimal. These scary-looking
    addresses are part of one of the improvements over IPv4 – the address space. An
    IPv4 address is four groups of 8 bits each (an octet), for a total of 32 bits.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 和 IPv6 之间有很多差异；我建议通过研究 IPv6 数据包的结构来了解这些差异。最明显的差异可能就是地址。乍一看，IPv6 地址看起来令人困惑。除了比
    IPv4 地址长之外，它们还以十六进制字符表示（文本形式），而不是十进制。这些看起来吓人的地址是对 IPv4 的一个改进 —— 地址空间。IPv4 地址由四组
    8 位组成（一个八位字节），总共 32 位。
- en: Therefore, the total number of available IPv4 addresses is *2*32 = *4.294967296*
    billion, to be exact. Back in the 1970s, this big-sounding number seemed like
    plenty, but IPv4 address exhaustion soon became a legitimate threat and then,
    starting in the past decade, a reality. Consider, on the other hand, the IPv6
    address: eight groups of four hexadecimal characters each (a single hex character
    takes up 4 bits); therefore, eight groups of 16 bits each (a hextet) for a total
    of 128 bits. Therefore, the total address space is *2*128 = *340,282* decillion addresses.
    That’s enough for every grain of sand on Earth to have 45,000 quadrillion IP addresses
    each. In informal language, this is *quite the handful*. When working with IPv6
    addresses, you may see something as long as **2052:dfb8:85a3:7291:8c5e:0370:aa34:3920**,
    down through something such as **2001:db8:85ad::2:3**, and even down to the IPv6
    zero address (unspecified address), which is just two colons – **::**. So, the
    easiest way to understand them is to start with the core, uncompressed address,
    and then check out the IETF convention for simplifying them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，IPv4 地址的总数是 *2*32 = *4.294967296* 十亿，准确地说。回到 1970 年代，这个听起来很大的数字当时似乎绰绰有余，但
    IPv4 地址耗尽很快就成了一个现实威胁，并且在过去的十年里，成为了一个真正的挑战。另一方面，考虑 IPv6 地址：由八组每组四个十六进制字符组成（每个十六进制字符占用
    4 位）；因此，八组每组 16 位（一个十六进制组）总共 128 位。因此，总的地址空间是 *2*128 = *340,282* 十六万亿个地址。足够让地球上的每一颗沙粒拥有
    45,000 万万亿个 IP 地址。在非正式语言中，这简直是 *相当庞大*。在使用 IPv6 地址时，你可能会看到像 **2052:dfb8:85a3:7291:8c5e:0370:aa34:3920**
    这样的长地址，也可能看到像 **2001:db8:85ad::2:3** 这样的简短地址，甚至是 IPv6 零地址（未指定地址），它就是两个冒号 —— **::**。所以，理解这些地址的最简单方法是从核心的、未经压缩的地址开始，然后查看
    IETF 简化地址的规范。
- en: 'As we’ve just learned, the raw IPv6 address is eight groups of four (lowercase)
    hexadecimal characters, and the groups are separated by colons. Here’s an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚了解到的，原始的 IPv6 地址是由八组四个（小写）十六进制字符组成，并且各组之间用冒号分隔。以下是一个例子：
- en: '[PRE2]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two main compression rules. The first is the omission of initial zeros
    (not entire groups of zero; that’s next) within a hextet. **00aa** becomes **aa**, **05f4**
    becomes **5f4**, and **000e** becomes **e**. In our example, there are three groups
    with initial zeros, so our address becomes the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的压缩规则。第一个规则是省略十六进制组中的前导零（而不是整个零组；那个是接下来的规则）。**00aa** 变成 **aa**，**05f4**
    变成 **5f4**，**000e** 变成 **e**。在我们的例子中，有三个组包含前导零，因此我们的地址变成了如下：
- en: '[PRE3]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second rule involves conversing all-zero groups into double colons (**::**).
    This rule applies to adjacent groups of all zeros; if there are two or more adjacent
    groups of all zeros, they are all replaced with a single double colon. Single groups
    of all zeros are not suppressed and instead are represented with a single **0**.
    If there happens to be more than one multiple group run of zeros, then the leftmost
    run of zeros is suppressed and the others are turned into single-zero groups.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则涉及将所有零的组转换为双冒号（**::**）。此规则适用于相邻的全零组；如果有两个或更多相邻的全零组，它们将全部替换为一个双冒号。单个全零组不会被压缩，而是用一个**0**表示。如果有多个连续的零组，最左侧的零组将被压缩，其余的会变成单个零组。
- en: By only compressing adjacent groups of zero, and by only doing this compression
    once per address, we prevent any ambiguity. If you’re wondering how many uncompressed
    groups of zero are represented by a double colon, just remember that the full
    IPv6 address is eight groups long – so you’ll convert it into however many groups
    it takes to make an even eight.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅压缩相邻的零组，并且每个地址只进行一次这种压缩，我们可以避免任何歧义。如果你想知道双冒号表示多少个未压缩的零组，只需记住完整的 IPv6 地址由八个组组成——所以你将根据需要将其转换成使其总共有八个组的形式。
- en: 'In our example, there is a single multiple-group run of zero (two groups),
    so those eight adjacent zeros become a double colon:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，存在一个连续的零组（两个组），因此这八个相邻的零被压缩成了双冒号：
- en: '[PRE4]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This looks quite a bit more manageable than the uncompressed address, right?
    By following those compression rules, the result is the same address as the first.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来比未压缩的地址更易于管理，对吧？通过遵循这些压缩规则，结果与第一个地址相同。
- en: 'Before we move on, let’s take a look at a few more examples:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们再看几个例子：
- en: '![Table 5.1](image/Table_5.01_B17616.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![表 5.1](image/Table_5.01_B17616.jpg)'
- en: Okay, you have IPv6 address compression fundamentals in your pocket. Let’s take
    a look at some practical discovery tools for IPv6 environments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经掌握了 IPv6 地址压缩的基本知识。现在让我们来看一些适用于 IPv6 环境的实际发现工具。
- en: Watch me neigh neigh – local IPv6 recon and the Neighbor Discovery Protocol
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 看我叫，叫——本地 IPv6 侦查与邻居发现协议
- en: So, you’re on the network and you need to do some recon to find out what’s out
    there in IPv6 land. I know what the hacker in you is thinking at this point –
    “*well, it was feasible to scan even large swaths of the IPv4 address space, but
    a 2128 address space? That’s just a waste of time at best*.” Right you are! Trying
    to combine the **-6** flag in Nmap with a range of addresses will give you an
    error. So, we have to think a little differently about host discovery.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在在网络上，需要进行一些侦查，了解 IPv6 网络上有什么。此时我知道你内心的黑客在想什么——“*好吧，扫描 IPv4 地址空间的大面积范围是可行的，但
    2128 地址空间呢？那充其量是浪费时间*。”你说得对！尝试将 Nmap 中的 **-6** 标志与一系列地址组合使用时会出错。所以，我们必须从不同的角度考虑主机发现。
- en: Before we pull out the offensive toolkit, let’s go back to basics with **ping**.
    If you review the man page for **ping**, you’ll find IPv6 support; but, we can’t
    do a ping sweep like in the good old days. Not a problem – we’ll just ping the
    link-local multicast address. By definition, this will prompt a reply from our
    friendly neighbors and we’ll have some targets. There’s a nice chunk of multicast
    addresses defined for IPv6 for different purposes (for example, all routers on
    the local segment, RIP routers, EIGRP routers, and so on), but the one to memorize
    for now is **ff02::1**. We’ll be effectively mimicking the Neighbor Discovery
    Protocol’s solicitation/advertisement process.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拿出攻击工具包之前，让我们先回归基础，使用**ping**。如果你查看**ping**的手册页面，你会发现支持 IPv6；但是，我们不能像过去那样进行大规模的
    ping 扫描。没问题——我们可以 ping 本地链路组播地址。根据定义，这将促使我们的友好邻居做出响应，从而提供一些目标。目前，IPv6 定义了许多组播地址，用于不同的目的（例如，本地段上的所有路由器、RIP
    路由器、EIGRP 路由器等），但现在要记住的是 **ff02::1**。我们将有效地模拟邻居发现协议的请求/广告过程。
- en: 'We’re going to fire off an IPv6 **ping** command pointing at link-local multicast
    address **ff02::1** to trigger responses from hosts on our segment, which will
    populate the neighbor table; then, we’ll ask **ip** to show us those discovered
    neighbors:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发送一个指向本地链路组播地址 **ff02::1** 的 IPv6 **ping** 命令，以触发来自我们段上主机的响应，从而填充邻居表；然后，我们将让
    **ip** 命令显示这些发现的邻居：
- en: '[PRE5]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s see what this looks like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它长什么样：
- en: '![Figure 5.32 – IPv6 neighbors ](image/Figure_5.32_B17616.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.32 – IPv6 邻居](image/Figure_5.32_B17616.jpg)'
- en: Figure 5.32 – IPv6 neighbors
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – IPv6 邻居
- en: Notice a pattern with the responses? All of the addresses belong to **fe80::/10**.
    The hosts responded with a link-local address, which it will have in addition
    to any globally unique address. We gathered this by pinging the link-local multicast
    address, after all. Pinging is an active task; by conducting some passive listening,
    we may hear devices confirming via the ICMP6 neighbor solicitation and **Duplicate
    Address Discovery** (**DAD**) process that their assigned address is unique. Now,
    we can open up our offensive toolkit.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到响应中的模式了吗？所有地址都属于**fe80::/10**。主机们回应了一个链路本地地址，除了任何全球唯一地址之外，它还会有这个链路本地地址。毕竟，我们是通过对链路本地多播地址进行ping操作来收集这些信息的。ping是一个主动任务；通过进行一些被动监听，我们可能会听到设备通过ICMP6邻居请求和**重复地址检测**（**DAD**）过程确认它们的分配地址是唯一的。现在，我们可以打开我们的攻击工具包了。
- en: 'The standard Swiss-army knife of IPv6 poking and prodding is THC-IPV6, which
    is included with Kali Linux. We command the **detect-new-ip6** tool to listen
    on our interface for any ICMP6 DAD messages:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6探测和攻击的标准瑞士军刀是THC-IPV6，它包含在Kali Linux中。我们指令**detect-new-ip6**工具监听我们的接口，监控任何ICMP6
    DAD消息：
- en: '[PRE7]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see data being returned as new addresses are seen:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到随着新地址的出现，数据被返回：
- en: '![Figure 5.33 – Detecting new addresses with DAD detection ](image/Figure_5.33_B17616.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图5.33 – 使用DAD检测新地址](image/Figure_5.33_B17616.jpg)'
- en: Figure 5.33 – Detecting new addresses with DAD detection
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.33 – 使用DAD检测新地址
- en: With that, we’ve gathered some targets to start scanning for services with the
    **-6** flag in Nmap. Thanks, DAD!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就收集了一些目标，可以开始使用Nmap的**-6**标志扫描服务了。谢谢你，DAD！
- en: IPv6 man-in-the-middle – attacking your neighbors
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6中间人攻击 – 攻击你的邻居
- en: By now, you’ve probably had enough ARP to give you a headache. Don’t worry –
    IPv6 has a different process for resolving link-layer addresses to IPv6 addresses.
    However, it seems the designers didn’t want us to be bored – we can still spoof
    and manipulate the procedure, just as in IPv4 and ARP, thus establishing a man-in-the-middle
    condition. Let’s take a look at how the **Neighbor Discovery Protocol** (**NDP**)
    resolution works in IPv6, and then we’ll attack it with THC-IPV6’s **parasite6**.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经被ARP弄得头疼了。别担心——IPv6有一个不同的过程来将链路层地址解析为IPv6地址。不过，设计者似乎不想让我们感到无聊——我们仍然可以像在IPv4和ARP中那样伪造和操控这个过程，从而建立中间人攻击。让我们来看看**邻居发现协议**（**NDP**）在IPv6中的解析是如何工作的，然后我们将使用THC-IPV6的**parasite6**来攻击它。
- en: 'You’ll recall from sniffing ARP traffic that there are two parts:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得在嗅探ARP流量时，存在两个部分：
- en: Who has **<IP address>**? Tell **<host>**.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁拥有**<IP 地址>**？告知**<主机>**。
- en: '**<IP address>** is at **<MAC address>**.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<IP 地址>** 位于 **<MAC 地址>**。'
- en: In IPv6, these two parts are called **neighbor solicitation** (**NS**) and **neighbor
    advertisement** (**NA**), respectively. First, the node with the query sends an
    NS message to the **ff02::1** multicast address. This is received by all the nodes
    on the segment, including the subject of the NS query. The subject node then replies
    to the requestor with an NA message. All of these messages are carried over ICMPv6.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，这两个部分分别被称为**邻居请求**（**NS**）和**邻居响应**（**NA**）。首先，带有查询的节点向**ff02::1**多播地址发送NS消息。这些消息会被段上的所有节点接收，包括NS查询的目标节点。目标节点随后会以NA消息回复请求者。所有这些消息都是通过ICMPv6传输的。
- en: 'It’s that straightforward. The method is a little different in how replies
    are processed, however. In IPv4 ARP, replies that map a link-layer address to
    an IP address can be broadcast without solicitation, and nodes on the segment
    will update their tables accordingly. In other words, the attacker can preempt
    any resolution request, so the target never identifies itself as the correct address.
    In IPv6 ND, the target system will reply to the NS with an NA directed at the
    requestor; in short, the requestor ends up receiving two NA messages for the same
    query, but they will be pointing to two different link-layer addresses, one of
    which is the attacker. Fun, right? Here’s where you’ll chuckle: by setting the
    ICMPv6 override flag, we tell the recipient to – you guessed it – override any
    previous messages. The requestor will get two answers: “*Hi, I’m the device you’re
    looking for*,” followed immediately by, “*Don’t listen to that guy, it’s actually
    me*.”'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。不过，方法在处理回复时稍有不同。在IPv4 ARP中，将链路层地址映射到IP地址的回复可以在没有请求的情况下广播，网络段上的节点将相应地更新它们的表。换句话说，攻击者可以抢先发起任何解析请求，因此目标永远不会识别自己为正确的地址。在IPv6
    ND中，目标系统将回应NS请求，并向请求者发送NA；简而言之，请求者最终会收到两个NA消息用于相同的查询，但它们指向两个不同的链路层地址，其中一个是攻击者的地址。好玩吧？接下来你会笑出声：通过设置ICMPv6覆盖标志，我们告诉接收者——你猜对了——覆盖任何之前的消息。请求者将收到两个答案：“*嗨，我就是你要找的设备*，”紧接着是，“*别听那家伙的，那实际上是我*。”
- en: 'Our handy NDP spoofer is called **parasite6**. Yes, we need to set up packet
    forwarding so that traffic gets through our interface once the spoofing begins,
    but there’s another setup step required: suppression of ICMPv6 redirects. There
    are certain scenarios in which a device that’s forwarding IPv6 traffic (that would
    be you, the attacker) has to send back a redirect to the source, effectively telling
    the source to send traffic somewhere else.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方便的NDP伪造工具叫做**parasite6**。是的，我们需要设置数据包转发，以便在伪造开始后流量能够通过我们的接口，但还有另一个配置步骤：抑制ICMPv6重定向。在某些情况下，一个转发IPv6流量的设备（也就是你，攻击者）必须发送重定向回源，从而有效地告诉源设备将流量发送到其他地方。
- en: Certain conditions will trigger this, including forwarding traffic out the same
    interface through which it was received – oops. So, we’ll set up an **ip6tables**
    rule as well. Our friendly **parasite6** tool is nice enough to remind us at launch,
    just in case we forgot.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 某些条件会触发这个过程，包括通过接收流量的相同接口转发流量——哎呀。所以，我们还需要设置一个**ip6tables**规则。我们的朋友**parasite6**工具非常贴心，启动时会提醒我们，以防我们忘记。
- en: 'Keep an eye out for that pesky number **6** when working with these protocols: **ping
    -6**, **nmap -6**, and **ip6tables** instead of **iptables**, and so on. There
    is a lot of conceptual and functional overlap, so be careful:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些协议时，要特别留意那个烦人的数字**6**：**ping -6**，**nmap -6**，以及**ip6tables**而不是**iptables**，等等。它们在概念和功能上有很多重叠，所以要小心：
- en: '[PRE8]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot illustrates the output of the preceding commands:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面命令的输出。
- en: '![Figure 5.34 – Configuring IPv6 forwarding and filtering with ip6tables before
    launching the parasite6 attack ](image/Figure_5.34_B17616.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图5.34——在启动parasite6攻击之前，使用ip6tables配置IPv6转发和过滤](image/Figure_5.34_B17616.jpg)'
- en: Figure 5.34 – Configuring IPv6 forwarding and filtering with ip6tables before
    launching the parasite6 attack
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.34——在启动parasite6攻击之前，使用ip6tables配置IPv6转发和过滤
- en: Now, the attack is active and you can progress to the next stage of intercept
    and manipulation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，攻击已经激活，你可以进入拦截和操作的下一阶段。
- en: Living in an IPv4 world – creating a local 4-to-6 proxy for your tools
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生活在IPv4世界中——为你的工具创建本地的4到6代理
- en: 'There’s a tool included with Kali that can be thought of as **netcat** on steroids:
    **socat**. This tool can do many things and we just don’t have enough room to
    go over it all here, but its ability to relay from IPv4 to IPv6 environments is
    especially useful. We’ve seen tools designed for IPv6, but we will occasionally
    find ourselves stuck needing a particular IPv4 tool’s functionality to talk to
    IPv6 hosts. Enter the **socat** proxy.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Kali中有一个工具，可以被看作是增强版的**netcat**：**socat**。这个工具可以做很多事情，我们这里没有足够的空间详细介绍，但它在IPv4和IPv6环境之间进行转发的能力特别有用。我们已经看到了一些为IPv6设计的工具，但我们偶尔会遇到需要某个特定IPv4工具功能来与IPv6主机通信的情况。这时就可以使用**socat**代理。
- en: 'The concept and setup are simple – we create an IPv4 listener that then forwards
    packets over IPv6 to a host where we have a potentially vulnerable web server
    that we want to scan with Nikto:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 概念和设置很简单——我们创建一个 IPv4 监听器，然后通过 IPv6 将数据包转发到我们可能有脆弱 web 服务器的主机上，接着我们用 Nikto 扫描它：
- en: '[PRE11]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Everything happens in the background at this point, so you won’t see anything
    in the terminal. No news is good news with a **socat** proxy; if there’s a problem,
    it’ll let you know. Let’s take a look at these options:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所有操作都在后台进行，因此你在终端中不会看到任何输出。对于 **socat** 代理来说，没有消息就是好消息；如果出现问题，它会提醒你。我们来看看这些选项：
- en: '**TCP-LISTEN:8080** tells **socat** to listen for TCP connections and defines
    the local listening port – in this case, **8080**.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP-LISTEN:8080** 告诉 **socat** 监听 TCP 连接并定义本地监听端口——在此例中，端口为 **8080**。'
- en: '**reuseaddr** is needed for heavy-duty testing by allowing more than one concurrent
    connection.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reuseaddr** 在进行高强度测试时是必要的，它允许多个并发连接。'
- en: '**fork** refers to forking a child process each time a new connection comes
    through the pipe, used in tandem with **reuseaddr**.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fork** 是指每当有新连接通过管道时，都会分叉一个子进程，这与 **reuseaddr** 一起使用。'
- en: '**TCP6** comes after the space that tells **socat** what we’re going to do
    with the traffic that’s received on the listener side of the command; it says
    to send the traffic over to port **80** of a TCP target over IPv6\. Note that
    we need brackets here as the colon is used in both command syntax and IPv6 addresses,
    so this prevents confusion.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP6** 紧跟在空格后面，告诉 **socat** 我们要如何处理在命令监听端接收到的流量；它表示将流量通过 IPv6 转发到 TCP 目标的端口
    **80**。注意，由于冒号在命令语法和 IPv6 地址中都使用，因此这里需要使用括号，以避免混淆。'
- en: 'Now, I can just point my toolset at my local port **8080**, and everything
    will be received by the target over IPv6 at port **80**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只需将我的工具集指向本地端口 **8080**，所有流量将通过 IPv6 在端口 **80** 被目标接收：
- en: '![Figure 5.35 – Running Nikto against a web server at an IPv6 address via a
    socat proxy ](image/Figure_5.35_B17616.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.35 – 通过 socat 代理在 IPv6 地址上运行 Nikto 扫描 web 服务器](image/Figure_5.35_B17616.jpg)'
- en: Figure 5.35 – Running Nikto against a web server at an IPv6 address via a socat
    proxy
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35 – 通过 socat 代理在 IPv6 地址上运行 Nikto 扫描 web 服务器
- en: As you can see, the target and port have to be defined for **socat**. Do you
    know what would be really useful? A Python script that prompts for a host and
    port number and configures **socat** automatically. That’s something to consider
    for later.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，必须为 **socat** 定义目标和端口。你知道什么会非常有用吗？一个 Python 脚本，它可以提示输入主机和端口号，并自动配置 **socat**。这是可以考虑的一个后续事项。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went on a journey through the network of our client in terms
    of discovery and vulnerability analysis. We explored the power of Nmap in today’s
    day and age and demonstrated that it’s still the go-to for network mapping. We
    explored the underlying mechanisms of the different scan types and learned how
    to have Nmap interact directly with Metasploit for ease of targeting. Then, we
    learned how BetterCAP can compromise data streams in real time by swapping out
    a download with a malicious binary and got comfortable with the updated user interface.
    After playing with BetterCAP, we learned how we can encapsulate an arbitrary protocol
    inside an HTTP tunnel to bypass filters. We wrapped up this chapter with a review
    of IPv6 and some basic tooling with IPv6, including how to get by with IPv4 tools
    in an IPv6 environment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过对客户网络的发现和漏洞分析展开了探索。我们探讨了 Nmap 在当今时代的强大功能，并展示了它仍然是网络映射的首选工具。我们研究了不同扫描类型的底层机制，并学会了如何让
    Nmap 与 Metasploit 直接交互，以便更容易定位目标。接着，我们学习了如何通过替换下载内容为恶意二进制文件，利用 BetterCAP 实时破坏数据流，并熟悉了更新后的用户界面。在玩转
    BetterCAP 后，我们学习了如何将任意协议封装在 HTTP 隧道中，以绕过过滤器。最后，我们通过回顾 IPv6 以及一些基础的 IPv6 工具，了解了如何在
    IPv6 环境中使用 IPv4 工具。
- en: In the next chapter, things are going to get goofy-exciting as we jump into
    some cryptography concepts and some lesser-known attacks that still manage to
    get overlooked in many environments. We’re going to not only play with these attacks,
    but we’ll also discuss the underlying mechanisms that make them tick.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将进入一些密码学概念和一些较少为人知的攻击，这些攻击在许多环境中仍然常常被忽视。我们不仅会研究这些攻击，还将讨论使其发生的底层机制。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，测试你对本章内容的掌握：
- en: '**-T1** ensures the fastest scan possible with Nmap. (True | False)'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**-T1** 确保 Nmap 执行最快的扫描。 (正确 | 错误)'
- en: How is the Maimon scan similar to the Xmas scan?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maimon 扫描与 Xmas 扫描有何相似之处？
- en: BetterCAP’s **download-autopwn** can match the payload size with the size of
    the requested file. (True | False)
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BetterCAP 的 **download-autopwn** 可以将有效负载大小与请求文件的大小匹配。（对 | 错）
- en: What two components are necessary to build an HTTP tunnel between two hosts?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建两个主机之间的 HTTP 隧道需要哪些两个组件？
- en: The IPv6 counterpart to IPv4’s ARP is called __________.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPv6 对应于 IPv4 的 ARP 称为 __________。
- en: Provide the uncompressed representation of the link-local multicast address
    **ff02::1**.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供链接本地组播地址 **ff02::1** 的未压缩表示。
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解本章中涉及的主题，请参考以下资源：
- en: 'RFC 8200 ([https://tools.ietf.org/html/rfc8200](https://tools.ietf.org/html/rfc8200)):
    The IPv6 standard, current as of 2017'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 8200 ([https://tools.ietf.org/html/rfc8200](https://tools.ietf.org/html/rfc8200))：IPv6
    标准，2017 年当前版本
- en: 'RFC 2460 ([https://tools.ietf.org/html/rfc2460](https://tools.ietf.org/html/rfc2460)):
    The IPv6 standard, obsolete'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2460 ([https://tools.ietf.org/html/rfc2460](https://tools.ietf.org/html/rfc2460))：IPv6
    标准，已过时
- en: 'RFC 5952 ([https://tools.ietf.org/html/rfc5952](https://tools.ietf.org/html/rfc5952)):
    Rules for IPv6 address representation'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 5952 ([https://tools.ietf.org/html/rfc5952](https://tools.ietf.org/html/rfc5952))：IPv6
    地址表示规则
