- en: Now for Something Completely Different
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在，呈现一些完全不同的内容
- en: This book presents Python as a necessary tool to optimize digital forensic analysis—written
    from an examiner's perspective. In the first two chapters, we introduce the basics
    of Python in preparation for the remainder of this book, where we will develop
    scripts to accomplish forensic tasks. While focused on the use of the language
    as a tool, we will also explore the advantages of Python and how they allow many
    individuals in the field to create solutions for complex forensic challenges.
    Like Monty Python, Python's namesake, the next 12 chapters aim to present *something
    completely different*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将Python作为优化数字取证分析的必要工具——从检查员的角度出发进行编写。在前两章中，我们将介绍Python的基础知识，为本书其余部分做准备，在后续章节中，我们将开发脚本以完成取证任务。虽然重点是将该语言作为工具使用，但我们也会探讨Python的优势，以及它如何帮助许多领域的从业者为复杂的取证挑战创建解决方案。就像Python的名字来源于Monty
    Python一样，接下来的12章旨在呈现*一些完全不同*的内容。
- en: In this fast-paced field, a scripting language provides flexible problem solving
    in an automated fashion, allowing the examiner additional time to investigate
    other artifacts that, due to time constraints, may not have been analyzed as thoroughly
    otherwise. Admittedly, Python may not always be the right tool to complete the
    task at hand, but it is an invaluable tool to add to anyone's DFIR arsenal. Should
    you undertake the task of mastering Python, it will more than pay off the time
    investment as you will increase your analysis capabilities many fold and greatly
    diversify your skill set. This chapter outlines the basics of Python, from `Hello
    World` to core scripting concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个快速发展的领域中，脚本语言以自动化的方式提供灵活的问题解决方案，使检查员能够有更多的时间去调查其他由于时间限制可能未能彻底分析的证据。诚然，Python可能并不总是完成任务的最佳工具，但它是任何人的DFIR工具库中不可或缺的工具。如果你决定掌握Python，它将大大回报你投入的时间，因为你将显著提高分析能力，并大大拓展你的技能。
    本章概述了Python的基础知识，从`Hello World`到核心脚本概念。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to Python and healthy development practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python介绍及健康的开发实践
- en: Basic programming concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本编程概念
- en: Manipulating and storing objects in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中操作和存储对象
- en: Creating simple conditionals, loops, and functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的条件判断、循环和函数
- en: When to use Python
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Python
- en: Python is a powerful forensic tool. However, before deciding to develop a script,
    it is important to consider the type of analysis that's required and the project
    timeline. In the examples that follow, we will outline situations where Python
    is invaluable and, conversely, when it is not worth the development effort. Though
    rapid development makes it easy to deploy a solution in a tough situation, Python
    is not always the best tool to implement. If a tool exists that performs the task
    at hand, and is available, it may be the more appropriate method for analysis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一个强大的取证工具。然而，在决定开发脚本之前，重要的是要考虑所需的分析类型和项目的时间表。在接下来的例子中，我们将概述Python在某些情况下如何是不可或缺的工具，反之，在其他情况下它的开发工作可能并不值得。尽管快速开发使得在复杂情况下轻松部署解决方案，Python并不总是实现任务的最佳工具。如果现有工具已经能够完成任务，并且可以使用，那么它可能是更合适的分析方法。
- en: 'Python is a preferred programming language for forensics due to its ease of
    use, library support, detailed documentation, and interoperability among operating
    systems. There are two main types of programming languages: those that are interpreted
    and those that are compiled. Compiling code allows the programming language to
    be converted into machine language. This lower-level language is more efficient
    for the computer to interpret. Interpreted languages are not as fast as compiled
    languages at runtime, but do not require compilation, which can take some time.
    Because Python is an interpreted language, we can make modifications to our code
    and immediately run and view the results. With a compiled language, we would have
    to wait for our code to re-compile before viewing the effect of our modifications.
    For this reason, Python may not run as quickly as a compiled language, but allows
    for rapid prototyping.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python是取证工作中常用的编程语言，因其易用性、库支持、详细文档以及跨操作系统的互操作性。编程语言主要有两种类型：解释型语言和编译型语言。编译代码可以将编程语言转换为机器语言，这种低级语言计算机更容易解释。解释型语言在运行时的速度不如编译型语言，但不需要编译，这样可以节省一些时间。由于Python是解释型语言，我们可以修改代码并立即运行查看结果。而对于编译型语言，我们必须等待代码重新编译后才能看到修改效果。因此，虽然Python的运行速度可能不如编译型语言，但它支持快速原型开发。
- en: An incident response case presents an excellent example of when to use Python
    in a real-life setting. For example, let's consider that a client calls, panicked,
    reporting a data breach and is unsure of how many files were exfiltrated over
    the past 24 hours from their file server. Once on site, you are instructed to
    perform the fastest count of files accessed in the past 24 hours as this count,
    and the list of compromised files, will determine the course of action.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事件响应案例是一个极好的示例，展示了在实际环境中何时使用Python。例如，假设客户打来电话，慌张地报告数据泄露，并且不确定过去24小时内有多少文件从他们的文件服务器中被外泄。到达现场后，你被指示执行最快的文件访问次数统计，因为这个统计数字和泄露文件的列表将决定下一步的行动。
- en: 'Python fits this bill quite nicely here. Armed with just a laptop, you can
    open a text editor and begin writing a solution. Python can be built and designed
    without the need for a fancy editor or toolset. The build process of your script
    may look like this, with each step building upon the previous one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python在这种情况下非常合适。只需要一台笔记本电脑，你就可以打开文本编辑器并开始编写解决方案。Python可以在没有复杂编辑器或工具集的情况下进行构建和设计。你脚本的构建过程可能是这样的，每一步都建立在前一步的基础上：
- en: Make the script read a single file's last accessed timestamp
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让脚本读取单个文件的最后访问时间戳
- en: Write a loop that steps through directories and subdirectories
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个循环，逐步遍历目录和子目录
- en: Test each file to see if that timestamp is from the past 24 hours
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试每个文件，看看该时间戳是否来自过去24小时
- en: If it has been accessed within 24 hours, then create a list of affected files
    to display file paths and access times
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件在过去24小时内被访问过，则创建一个受影响文件的列表，显示文件路径和访问时间
- en: The process here would result in a script that recurses over the entire server
    and output files found with a last accessed time in the past 24 hours for manual
    review. This script will likely be approximately 20 lines of code and have required
    10 minutes, or less, for an intermediate scripter to develop and validate—it is
    apparent this would be more efficient than manually reviewing timestamps on the
    filesystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的过程将生成一个脚本，该脚本会遍历整个服务器，并输出在过去24小时内最后一次访问时间的文件，以供人工审核。这个脚本可能只有大约20行代码，并且一个中级脚本员大约需要10分钟或更少的时间来开发和验证——显然，这比手动检查文件系统中的时间戳更高效。
- en: Before deploying any developed code, it is imperative that you validate its
    capability first. As Python is not a compiled language, we can easily run the
    script after adding new lines of code to ensure we haven't broken anything. This
    approach is known as **test-then-code**, a method commonly used in script development.
    Any software, regardless of who wrote it, should be scrutinized and evaluated
    to ensure accuracy and precision. Validation ensures that the code is operating
    properly, and although more time-consuming, provides reliable results that are
    capable of withstanding the courtroom, an important aspect in forensics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署任何已开发的代码之前，必须首先验证其能力。由于 Python 不是编译型语言，我们可以在添加新代码行后轻松运行脚本，以确保没有破坏任何功能。这种方法被称为**先测试后编码**，是脚本开发中常用的方式。任何软件，不管是谁编写的，都应当经过仔细审查和评估，以确保准确性和精确性。验证确保代码正常运行，虽然这需要更多的时间，但它提供了可靠的结果，能够经得起法庭的考验，这是法医领域中的一个重要方面。
- en: A situation where Python may not be the best tool is for general case analysis.
    If you are handed a hard drive and asked to find evidence without additional insight,
    then a pre-existing tool will be the better solution. Python is invaluable for
    targeted solutions, such as analyzing a given file type and creating a metadata
    report. Developing a custom all-in-one solution for a given filesystem requires
    too much time to create when other tools, both paid and free, exist that support
    such generic analysis.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般案例分析中，Python 可能不是最佳工具。如果你拿到一个硬盘并被要求在没有额外线索的情况下寻找证据，那么使用已有的工具会是更好的解决方案。Python
    在针对性解决方案中非常有价值，比如分析特定类型的文件并生成元数据报告。为某一文件系统开发一个定制的全能解决方案所需的时间太长，尤其是考虑到市面上已有的支持这种通用分析的工具，不论是付费还是免费。
- en: Python is useful in pre-processing automation. If you find yourself repeating
    the same tasks for each piece of evidence, it may be worthwhile to develop a system
    that automates those steps. A great example of suites that perform such analysis
    is ManTech's analysis and triage system (mantaray: [http://github.com/mantarayforensics](http://github.com/mantarayforensics)),
    which leverages a series of tools to create general reports that can speed up
    analysis when there is no scope of what data may exist.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在预处理自动化中非常有用。如果你发现自己在处理每一份证据时都在重复相同的任务，那么开发一个自动化这些步骤的系统可能是值得的。一个很好的例子是
    ManTech 的分析与分类系统（mantaray：[http://github.com/mantarayforensics](http://github.com/mantarayforensics)），它利用一系列工具生成通用报告，在数据范围不明确的情况下加快分析速度。
- en: When considering whether to commit resources to develop Python scripts, either
    on the fly or for larger projects, it is important to consider what solutions
    already exist, the time available to create a solution, and the time saved through
    automation. Despite best intentions, the development of solutions can go on for
    much longer than initially conceived without a strong design plan.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑是否投入资源开发 Python 脚本时，无论是临时开发还是针对较大项目开发，都应考虑已经存在的解决方案、可用的开发时间以及通过自动化节省的时间。尽管有着最佳的意图，解决方案的开发可能会比最初设想的时间要长得多，尤其是当没有一个强有力的设计计划时。
- en: Development life cycle
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发生命周期
- en: 'The development cycle involves at least five steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开发周期至少包括五个步骤：
- en: Identify
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别
- en: Plan
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划
- en: Program
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程
- en: Validate
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Bugs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'The first step is self-explanatory; before you develop, you must identify the
    problem that needs to be solved. Planning is perhaps the most crucial step in
    the development cycle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是不言自明的：在开发之前，你必须识别出需要解决的问题。规划可能是开发周期中最关键的一步：
- en: '![](img/289dd91f-6deb-4ef5-bb00-85fa1c63de51.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/289dd91f-6deb-4ef5-bb00-85fa1c63de51.png)'
- en: 'Good planning will help later by decreasing the amount of code required and
    the number of bugs. Planning becomes even more vital during the learning process.
    A forensic programmer must begin to answer the following questions: how will data
    be ingested, what Python data types are most appropriate, are third-party libraries
    necessary, and how will the results be displayed to the examiner? In the beginning,
    just as if we were writing a term paper, it is a good idea to write, or draw,
    an outline of your program. As you become more proficient in Python, planning
    will become second nature, but initially, it is recommended to create an outline
    or write pseudocode.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的规划将有助于减少所需的代码量和 bug 数量，从而在后期节省时间。规划在学习过程中变得尤为重要。一个取证程序员必须开始回答以下问题：数据将如何被接收，哪些
    Python 数据类型最为合适，是否需要第三方库，结果将如何呈现给检查员？刚开始时，就像写学期论文一样，最好先写一个大纲，或者画出程序的框架。随着 Python
    熟练度的提高，规划将变成第二天性，但在最初阶段，建议先创建一个大纲或编写伪代码。
- en: 'Pseudocode is an informal way of writing code before filling in the details
    with actual code. Pseudocode can represent the bare bones of the program, such
    as defining pertinent variables and functions while describing how they will all
    fit together within the script''s framework. Pseudocode for a function might look
    like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码是一种在填充实际代码之前编写代码的非正式方式。伪代码可以表示程序的框架，如定义相关的变量和函数，并描述它们如何在脚本框架中组合在一起。一个函数的伪代码可能是这样的：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After identifying and planning, the next three steps make up the largest part
    of the development cycle. Once your program has been sufficiently planned, it
    is time to start writing code! Once the code is written, break in your new program
    with as much test data as possible. Especially in forensics, it is critical to
    thoroughly test your code instead of relying on the results of one example. Without
    comprehensive debugging, the code can crash when it encounters something unexpected,
    or, even worse, it could provide the examiner with false information and lead
    them down the wrong path. After the code has been tested, it is time to release
    it and prepare for bug reports. We are not talking about insects here! Despite
    a programmer's best efforts, there will always be bugs in the code. Bugs have
    a nasty way of multiplying even as you squash one, perpetually causing the programming
    cycle to begin repeatedly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定和规划之后，接下来的三个步骤构成了开发周期的最大部分。一旦程序的规划充分完成，就可以开始编写代码了！编写代码后，用尽可能多的测试数据来测试你的新程序。尤其在取证领域，彻底测试代码至关重要，而不是仅仅依赖一个例子的结果。如果没有全面的调试，代码在遇到意外情况时可能会崩溃，或者更糟糕的是，它可能会给检查员提供错误的信息，导致他们走错方向。代码测试完成后，就可以发布，并准备接受错误报告了。我们这里说的可不是昆虫！尽管程序员尽了最大努力，代码中总是会存在
    bug。即便你修复了一个 bug，它们也有一种令人讨厌的方式会不断繁殖，导致编程周期不断地重复开始。
- en: Getting started
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Before we get started, it is necessary that you install Python on your machine.
    It is important to understand that, at the time of writing this book, there are
    two supported versions of Python: Python 2 and 3\. We will use both Python 2 and
    3 to develop our solutions. Historically, many of the useful third-party forensic
    libraries were developed for Python 2\. At this point, most libraries are compatible
    with Python 3, which has superior Unicode handling, a major headache in Python
    2, among a number of other improvements. All of the code in this book has been
    tested with the latest appropriate versions of Python 2 (v. 2.7.15) or 3 (v. 3.7.1).
    In some cases, our code is compatible with both Python 2 and 3, or only works
    with one of the two. Each chapter will describe what version of Python is required
    to run the code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要在机器上安装 Python。需要明白的是，在编写本书时，Python 有两个支持的版本：Python 2 和 3。我们将同时使用
    Python 2 和 3 来开发我们的解决方案。从历史上看，许多有用的第三方取证库都是为 Python 2 开发的。目前，大部分库都与 Python 3 兼容，而
    Python 3 提供了更强大的 Unicode 处理能力，解决了 Python 2 中的一大难题，还做了许多其他改进。本书中的所有代码都已经在最新的 Python
    2（v. 2.7.15）或 3（v. 3.7.1）版本中进行过测试。在某些情况下，我们的代码兼容 Python 2 和 3，或者只兼容其中一个版本。每一章将会描述运行代码所需的
    Python 版本。
- en: Additionally, we recommend using an **integrated development environment**,
    or **IDE**, such as JetBrain's PyCharm. An IDE will highlight errors and offer
    suggestions that help streamline the development process and promote best practices
    when writing code. In the case that the installation of an IDE is not available,
    a simple text editor will work. We recommend an application such as Notepad++,
    Sublime Text, or Visual Studio Code. For those who are command line orientated,
    an editor such as vim or nano will work as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们建议使用**集成开发环境**，简称**IDE**，例如JetBrain的PyCharm。IDE能够高亮显示错误并提供建议，帮助简化开发过程并促进编码时的最佳实践。如果无法安装IDE，简单的文本编辑器也能使用。我们推荐像Notepad++、Sublime
    Text或Visual Studio Code这样的应用程序。对于喜欢命令行的用户，像vim或nano这样的编辑器也能使用。
- en: With Python installed, let's open the interactive prompt by typing `python`
    into your Command Prompt or Terminal. We will begin by introducing some built-in
    functions for use in troubleshooting. The first line of defense when confused
    by any object or function discussed in this book, or found in the wild, is the
    `type()`, `dir()`, and `help()` built-in functions. We realize we have not yet
    introduced common data types and so the following code might appear confusing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Python后，让我们通过在命令提示符或终端中输入`python`来打开交互式提示符。我们将从介绍一些内置函数开始，以便用于故障排除。遇到本书中讨论的任何对象或函数，或在实际应用中遇到的函数时，第一步就是使用`type()`、`dir()`和`help()`这些内置函数。我们意识到我们尚未介绍常见的数据类型，因此以下代码可能看起来有些困惑。
- en: However, that is exactly the point of this exercise. During development, you
    will encounter data types you are unfamiliar with or be unsure what methods exist
    to interact with the object. These three functions help solve those issues. We
    will introduce the fundamental data types later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这正是本练习的重点。在开发过程中，你会遇到一些你不熟悉的数据类型，或者不确定如何与对象交互。这三个函数有助于解决这些问题。我们将在本章后面介绍基本数据类型。
- en: The `type()` function, when supplied with an object, will return its `__name__`
    attribute, providing type identifying information about the object. The `dir()`
    function, when supplied with a string representing the name of an object, will
    return its attributes, showing the available options of the functions and parameters
    belonging to the object. The `help()` function can be used to display the specifics
    of these methods through its **docstrings**. Docstrings are nothing more than
    descriptions of a function that detail the inputs, outputs, and how to use the
    function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`type()`函数在传入一个对象时，会返回其`__name__`属性，提供关于对象的类型识别信息。`dir()`函数在传入表示对象名称的字符串时，会返回其属性，显示该对象所属函数和参数的可用选项。`help()`函数可以通过其**文档字符串**展示这些方法的具体信息。文档字符串其实就是对一个函数的描述，详细说明了函数的输入、输出以及如何使用该函数。'
- en: Let's look at the `str`, or string, object as an example of these three functions.
    In the following example, passing a series of characters surrounded by single
    quotes to the `type()` function results in a type of `str`, or string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`str`，即字符串对象，作为这三个函数的示例。在以下示例中，将一系列由单引号括起来的字符传递给`type()`函数，返回的类型是`str`，即字符串。
- en: When we show examples where our typed input follows the `>>>` symbol, this indicates
    that you should type these statements in the Python interactive prompt. The Python
    interactive prompt can be accessed by typing `python` in the Command Prompt.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示示例时，如果输入的内容紧跟在`>>>`符号之后，这表示你应在Python交互式提示符中输入这些语句。你可以通过在命令提示符中输入`python`来访问Python交互式提示符。
- en: These basic functions behave similarly in both Python 2 and 3\. Unless otherwise
    stated, these function calls and their output are executed with Python 3.7.1\.
    Please note, however, that the purposes of these built-in functions largely remain
    the same and have similar outputs between Python versions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本函数在Python 2和3中的表现相似。除非另有说明，以下函数调用及其输出都是在Python 3.7.1环境下执行的。然而请注意，这些内置函数的用途在不同的Python版本中大体相同，输出也非常类似。
- en: 'Here is an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we pass in an object to the `dir()` function, such as `str`, we can see its
    methods and attributes. Let's say that we want to know what one of these functions,
    `title()`, does. We can use the `help()` function specifying the object and its
    function as the input.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个对象传递给`dir()`函数，例如`str`，我们可以看到它的方法和属性。假设我们想知道其中一个函数，`title()`，是做什么的。我们可以使用`help()`函数，指定对象和其函数作为输入。
- en: 'The output of the function tells us no input is required, the output is a string
    object, and that the function capitalized the first character of every word. Let''s
    use the `title` method on the `what am I?` string:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的输出告诉我们不需要输入，输出是一个字符串对象，并且该函数将每个单词的第一个字符大写。让我们在`what am I?`字符串上使用`title`方法：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, type `number = 5`. Now we have created a variable, called `number`, that
    has the numerical value of `5`. Using `type()` on that object indicates that `5`
    is an `int`, or integer. Going through the same procedure as before, we can see
    a series of available attributes and functions for the integer object. With the
    `help()` function, we can check what the `__add__()` function does for our `number`
    object. From the following output, we can see that this function is equivalent
    to using the `+` symbol on two values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入`number = 5`。现在我们创建了一个名为`number`的变量，它的数值是`5`。使用`type()`函数查看该对象时，显示它是一个`int`（整数）。按照之前的步骤，我们可以看到整数对象的可用属性和函数。通过`help()`函数，我们可以查看`__add__()`函数在我们的`number`对象上执行了什么操作。从以下输出中，我们可以看到，这个函数等同于在两个值之间使用`+`符号：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s compare the difference between the `__add__()` function and the `+`
    symbol to verify our assumption. Using both methods to add `3` to our `number`
    object results in a returned value of `8`, as expected. Unfortunately, we''ve
    also broken a best practice rule illustrating this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较`__add__()`函数和`+`符号之间的区别，以验证我们的假设。使用这两种方法将`3`加到`number`对象上时，返回的值是`8`，如预期那样。不幸的是，我们在演示这个例子时也违反了最佳实践规则：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how some methods, such as `__add__()`, have double leading and trailing
    underscores. These are referred to as magic methods, and are methods the Python
    interpreter calls and should not be called by the programmer. These magic methods
    are instead called indirectly by the user. For example, the integer `__add__()`
    magic method is called when using the `+` symbol between two numbers. Following
    the previous example, you should never run `number.__add__(3)` instead of `number
    + 3`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意一些方法，例如`__add__()`，前后都有双下划线。这些被称为魔术方法，是Python解释器调用的方法，不应由程序员直接调用。这些魔术方法是通过用户间接调用的。例如，当在两个数字之间使用`+`符号时，整数的`__add__()`魔术方法会被调用。遵循前面的例子，你永远不应该运行`number.__add__(3)`来代替`number
    + 3`。
- en: This rule is broken in a few cases, which we will cover throughout this book,
    though unless the documentation recommends using a magic method, it is best to
    avoid them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则在一些情况下被打破，我们将在本书中讲解这些情况，不过除非文档推荐使用魔术方法，否则最好避免使用它们。
- en: Python, like any other programming language, has a specific syntax. Compared
    to other common programming languages, Python is rather English-like and can be
    read fairly easily in scripts. This feature has attracted many, including the
    forensics community, to use this language. Even though Python's language is easy
    to read, it is not to be underestimated as it is powerful and supports common
    programming paradigms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python和其他编程语言一样，有特定的语法。与其他常见的编程语言相比，Python更像英语，可以在脚本中相对轻松地阅读。这一特点吸引了许多人，包括法医学社区，使用这种语言。尽管Python的语言易于阅读，但它不容小觑，因为它功能强大并支持常见的编程范式。
- en: 'Most programmers start with a simple `Hello World` script, a test that proves
    they are able to execute code and print the famous message into the console window.
    With Python, the code to print this statement is a single line, as seen here,
    written on the first line of a file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员从一个简单的`Hello World`脚本开始，这是一个测试，证明他们能够执行代码并将著名的消息打印到控制台窗口。在Python中，打印这个语句的代码是一行，如下所示，写在文件的第一行：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note that when discussing the code in a script, as opposed to code in
    the interactive prompt, line numbers, starting at 001, are shown for reference
    purposes only. Please do not include these line numbers in your script. The code
    for this script and all scripts can be downloaded at [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当讨论脚本中的代码时，与交互式提示符中的代码不同，行号（从001开始）仅用于参考。请不要在您的脚本中包含这些行号。此脚本及所有脚本的代码可以在[https://packtpub.com/books/content/support](https://packtpub.com/books/content/support)下载。
- en: 'Save this line of code in a file called `hello.py`. To run this script, we
    call Python and the name of the script. If you are using Python 3, the message
    `Hello World!` should be displayed in your Terminal:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一行代码保存在名为`hello.py`的文件中。要运行此脚本，我们调用Python和脚本的名称。如果你使用的是Python 3，`Hello World!`消息应该会显示在你的终端中：
- en: '![](img/383f350b-0090-40e5-88f1-cdc79124cb68.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/383f350b-0090-40e5-88f1-cdc79124cb68.png)'
- en: Let's discuss why this simple script will not execute successfully in some versions
    of Python 2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下为什么这个简单的脚本在某些版本的 Python 2 中无法成功执行。
- en: The omnipresent print() function
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无处不在的 `print()` 函数
- en: Printing in Python is a very common technique as it allows the developer to
    display text to the console as the script executes. While there are many differences
    between Python 2 and 3, the way printing is called is the most obvious change,
    and is the reason why our previous example primarily only works with Python 3
    as it is currently written. With Python 3, `print` became a function rather than
    a statement, as was the case with older versions of Python 2\. Let's revisit our
    previous script and see a slight difference.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中打印是一项非常常见的技术，因为它允许开发者在脚本执行时将文本显示到控制台。虽然 Python 2 和 3 之间有许多差异，但打印调用方式是最明显的变化，也是我们之前的示例仅能在
    Python 3 中运行的原因。到了 Python 3，`print` 变成了一个函数，而不再是像旧版 Python 2 那样的语句。让我们回顾一下之前的脚本，看看有何微小差异。
- en: 'Note the following for Python 3:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Python 3 中的以下内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the following for Python 2:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Python 2 中的以下内容：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference is seemingly minor. In Python 2, where `print` is a statement,
    you do not need to wrap what is being printed in parentheses. It would be disingenuous
    to say the difference is just semantics; however, for now just understand that `print`
    is written in two different ways, depending on the version of Python being used.
    The ramifications of this minor change mean that legacy Python 2 scripts that
    use `print` as a statement cannot be executed by Python 3.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 差异看起来微不足道。在 Python 2 中，`print` 是一个语句，你不需要将要打印的内容括在圆括号中。说这种差异只是语义上的问题并不公平；然而，目前只需理解，`print`
    根据所使用的 Python 版本写法不同。这种微小变化的后果是，使用 `print` 作为语句的旧版 Python 2 脚本无法被 Python 3 执行。
- en: Where possible, our scripts will be written to be compatible with both versions
    of Python. This goal, while seemingly impossible due to the difference in `print`,
    can be accomplished by importing a special Python library, called `__future__`,
    and changing the `print` statement to a function. To do this, we need to import
    the `print` function from the `__future__` library and then write all `print`
    commands as `function`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们的脚本将兼容 Python 2 和 3 两个版本。虽然由于 `print` 的差异，看似不可能实现这一目标，但可以通过导入一个名为
    `__future__` 的特殊 Python 库并将 `print` 语句更改为函数来实现。为此，我们需要从 `__future__` 库中导入 `print`
    函数，然后将所有 `print` 命令写为 `function`。
- en: 'The following script executes in both Python 2 and 3:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本在 Python 2 和 3 中都能执行：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/514ef83c-f121-4986-8c6f-afe695d17374.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/514ef83c-f121-4986-8c6f-afe695d17374.png)'
- en: In the previous screenshot, you can see the result of this script in Python
    2.7.15 and Python 3.7.1.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个截图中，您可以看到在 Python 2.7.15 和 Python 3.7.1 中执行此脚本的结果。
- en: Standard data types
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准数据类型
- en: 'With our first script complete, it is time to understand the basic data types
    of Python. These data types are similar to those found in other programming languages,
    but are invoked with a simple syntax, which is described in the following table
    and sections. For a full list of standard data types available in Python, visit
    the official documentation at [https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一个脚本后，是时候理解 Python 的基本数据类型了。这些数据类型与其他编程语言中的类型类似，但通过简单的语法进行调用，详细描述见下表和相关章节。有关
    Python 中可用的所有标准数据类型的完整列表，请访问官方文档：[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)：
- en: '| **Data Type** | **Description** | **Example** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **描述** | **示例** |'
- en: '| `Str` | String | `str()`, `"Hello"`, `''Hello''` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Str` | 字符串 | `str()`, `"Hello"`, `''Hello''` |'
- en: '| `Unicode` | Unicode characters | `unicode()`, `u''hello''`, `"world".encode(''utf-8'')`
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `Unicode` | Unicode 字符 | `unicode()`, `u''hello''`, `"world".encode(''utf-8'')`
    |'
- en: '| `Int` | Integer | `int()`, `1`, `55` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | 整数 | `int()`, `1`, `55` |'
- en: '| `Float` | Decimal precision integers | `float()`, `1.0`, `.032` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | 小数精度整数 | `float()`, `1.0`, `.032` |'
- en: '| `Bool` | Boolean values | `bool()`, `True`, `False` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | 布尔值 | `bool()`, `True`, `False` |'
- en: '| `List` | List of elements | `list()`, `[3, ''asd'', True, 3]` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `List` | 元素的列表 | `list()`, `[3, ''asd'', True, 3]` |'
- en: '| `Dictionary` | Set of key:value pairs used to structure data | `dict()`,
    `{''element'': ''Mn'', ''Atomic Number'': 25, ''Atomic Mass'': 54.938}` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Dictionary` | 键值对集合，用于结构化数据 | `dict()`, `{''element'': ''Mn'', ''Atomic
    Number'': 25, ''Atomic Mass'': 54.938}` |'
- en: '| `Set` | List of unique elements | `set()`, `[3, 4, ''hello'']` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `Set` | 唯一元素的集合 | `set()`, `[3, 4, ''hello'']` |'
- en: '| `Tuple` | Organized list of elements | `tuple()`, `(2, ''Hello World!'',
    55.6, [''element1''])` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `元组` | 有序元素列表 | `tuple()`, `(2, ''Hello World!'', 55.6, [''element1''])`
    |'
- en: '| `File` | A file object | `open(''write_output.txt'', ''w'')` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `文件` | 一个文件对象 | `open(''write_output.txt'', ''w'')` |'
- en: We are about to dive into the usage of data types in Python, and recommend that
    you repeat this section as needed to help with comprehension. While reading through
    how data types are handled is important, please be at a computer where you can
    run Python when you work through it the first few times. We invite you to explore
    the data type further in your interpreter and test them to see what they are capable
    of.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将深入了解 Python 中数据类型的使用，建议你根据需要反复阅读这一部分以帮助理解。虽然阅读数据类型如何处理很重要，但请确保在你第一次操作时使用可以运行
    Python 的计算机。我们鼓励你在解释器中进一步探索数据类型并进行测试，看看它们能做些什么。
- en: You will find that most of our scripts can be accomplished using only the standard
    data types Python offers. Before we take a look at one of the most common data
    types, strings, we will introduce comments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，我们的大多数脚本都可以仅使用 Python 提供的标准数据类型来完成。在我们查看其中一种最常见的数据类型——字符串之前，我们将介绍注释。
- en: 'Something that is always said, and can never be said enough, is to comment
    your code. In Python, comments are formed by any line beginning with the pound,
    or more recently known as the hashtag, `#` symbol. When Python encounters this
    symbol, it skips the remainder of the line and proceeds to the next line. For
    comments that span multiple lines, we can use three single or double quotes to
    mark the beginning and end of the comments rather than using a single pound symbol
    for every line. What follows are examples of types of comments in a file called
    `comments.py`. When running this script, we should only see `10` printed to the
    console as all comments are ignored:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有人说，而且永远说不够的一点是：注释你的代码。在 Python 中，注释是由任何以井号（也就是现在称为“话题标签”）`#`符号开头的行形成的。当 Python
    遇到这个符号时，它会跳过该行的其余部分，继续到下一行。对于跨多行的注释，我们可以使用三个单引号或双引号来标记注释的开始和结束，而不是为每一行都使用单个井号符号。以下是名为
    `comments.py` 文件中不同类型注释的示例。运行此脚本时，我们只会看到 `10` 打印到控制台，因为所有的注释都被忽略了：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/11aa2e04-ae60-46ee-9779-591806708404.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11aa2e04-ae60-46ee-9779-591806708404.png)'
- en: When this code is executed, we only see the preceding at the console.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，我们只会看到前面的输出在控制台上显示。
- en: Strings and Unicode
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串与 Unicode
- en: Strings are a data type that contain any character, including alphanumeric characters,
    symbols, Unicode, and other codecs. With the vast amount of information that can
    be stored as a string, it is no surprise they are one of the most common data
    types. Examples of areas where strings are found include reading arguments at
    the command line, user input, data from files, and outputting data. To begin,
    let us look at how we can define a string in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种包含任何字符的数据类型，包括字母数字字符、符号、Unicode 和其他编码。由于字符串可以存储大量信息，毫不奇怪它们是最常见的数据类型之一。字符串出现的常见场景包括命令行读取参数、用户输入、文件中的数据以及输出数据。首先，让我们来看一下如何在
    Python 中定义一个字符串。
- en: 'There are three ways to create a string: with single quotes, double quotes,
    or with the built-in `str()` constructor method. Note that there is no difference
    between single- and double-quoted strings. Having multiple ways to create a string
    is advantageous, as it allows us to differentiate between intentional quotes within
    a string. For example, in the `''I hate when people use "air-quotes"!''` string,
    we use the single quotes to demarcate the beginning and end of the main string.
    The double quotes inside the string will not cause any issues with the Python
    interpreter. Let''s verify with the `type()` function that both single and double
    quotes create the same type of object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字符串有三种方式：使用单引号、双引号或内建的 `str()` 构造方法。请注意，单引号和双引号的字符串没有区别。能够通过多种方式创建字符串是有优势的，因为它允许我们在字符串中区分有意使用的引号。例如，在
    `'I hate when people use "air-quotes"!'` 字符串中，我们使用单引号来标记主字符串的开始和结束，字符串中的双引号不会导致
    Python 解释器出现问题。让我们通过 `type()` 函数来验证，单引号和双引号创建的是相同类型的对象：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we saw with comments, a block string can be defined by three single or double
    quotes to create multi-line strings. The only difference is whether we do something
    with the block-quoted value or not:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在注释中所看到的，可以通过三个单引号或双引号来定义块字符串，从而创建多行字符串。唯一的区别是是否对块引号值进行操作：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `\n` character in the returned line signifies a line feed or a new line.
    The output in the interpreter displays these newline characters as `\n`, though
    when fed into a file or console, a new line is created. The `\n` character is
    one of the common escape characters in Python. Escape characters are denoted by
    a backslash following a specific character. Other common escape characters include
    `\t` for horizontal tabs, `\r` for carriage returns, `\'`, `\"`, and `\\` for
    literal single quotes, double quotes, and backslashes, among others. Literal characters
    allow us to use these characters without unintentionally using their special meaning
    in Python's context.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 返回行中的`\n`字符表示换行或新的一行。在解释器中，输出会显示这些换行符为`\n`，但当它被输入到文件或控制台时，会创建一个新行。`\n`字符是Python中的常见转义字符之一。转义字符由反斜杠和特定字符组合表示。其他常见的转义字符包括`\t`表示水平制表符，`\r`表示回车符，`\'`、`\"`和`\\`分别表示字面上的单引号、双引号和反斜杠等。字面字符让我们能够使用这些字符，而不会无意中触发它们在Python上下文中的特殊含义。
- en: 'We can also use the add (`+`) or multiply (`*`) operators with strings. The
    add operator is used to concatenate strings together, and the multiply operator
    will repeat the provided string values:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用加法（`+`）或乘法（`*`）运算符对字符串进行操作。加法运算符用于连接字符串，而乘法运算符则会重复提供的字符串值：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at some common functions we use with strings. We can remove characters
    from the beginning or end of a string using the `strip()` function. The `strip()`
    function requires the character we want to remove as its input, otherwise it will
    replace whitespace by default. Similarly, the `replace()` function takes two inputs
    the character to replace and what to replace it with. The major difference between
    these two functions is that `strip()` only looks at the beginning and end of a
    string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些常见的字符串操作函数。我们可以使用`strip()`函数从字符串的开头或结尾删除字符。`strip()`函数需要我们提供要删除的字符作为输入，否则默认会删除空白字符。类似地，`replace()`函数接受两个输入：要替换的字符和替换后的字符。这两个函数的主要区别在于，`strip()`只处理字符串的开头和结尾：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can check if a character or characters are in a string using the `in` statement.
    Or, we can be more specific, and check if a string `startswith()` or `endswith()`
    a specific character(s) instead (you know a language is easy to understand when
    you can create sensible sentences out of functions). These methods return `True`
    or `False` Boolean objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`in`语句检查某个字符或字符是否存在于字符串中。或者，我们可以更具体地检查字符串是否`startswith()`或`endswith()`某个特定字符（你知道一个语言是否容易理解，就看你能否用函数创造出通顺的句子）。这些方法会返回`True`或`False`布尔值：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can quickly split a string into a list based on some delimiter. This can
    be helpful to quickly convert data separated by a delimiter into a list. For example,
    **comma-separated values** (**CSV**) data is separated by commas and could be
    split on that value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据某些分隔符快速将一个字符串拆分为一个列表。这对于将以分隔符分隔的数据快速转换为列表非常有帮助。例如，**逗号分隔值**（**CSV**）数据是以逗号分隔的，可以在该值上进行拆分：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Formatting parameters can be used on strings to manipulate them and convert
    them based on provided values. With the `.format()` function, we can insert values
    into strings, pad numbers, and display patterns with simple formatting. This chapter
    will highlight a few examples of the `.format()` method, and we will introduce
    more complex features of it throughout this book. The `.format()` method replaces
    curly brackets with the provided values in order.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化参数可以应用于字符串，以根据提供的值操作和转换它们。使用`.format()`函数，我们可以将值插入到字符串中、填充数字并显示简单格式的模式。本章将展示一些`.format()`方法的示例，后续章节会介绍它的更复杂功能。`.format()`方法按照顺序用提供的值替换大括号中的内容：
- en: 'This is the most basic operation for inserting values into a string dynamically:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将值动态插入字符串中的最基本操作：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our second example displays some of the expressions we can use to manipulate
    a string. Inside the curly brackets, we place a colon, which indicates that we
    are going to specify a format for interpretation. Following this colon, we specify
    that there should be at least six characters printed. If the supplied input is
    not six characters long, we prepend zeroes to the beginning of the input. Lastly,
    the `d` character specifies that the input will be a base 10 decimal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个示例展示了一些可以用来操作字符串的表达式。在大括号内，我们放置一个冒号，表示我们将为解释指定一个格式。在冒号后，我们指定应该打印至少六个字符。如果提供的输入不足六个字符，我们会在输入的前面添加零。最后，`d`字符表示输入将是一个十进制数：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our last example demonstrates how we can easily print a string of `20` equal
    signs by stating that our fill character is the equals symbol, followed by the
    caret (to center the symbols in the output), and the number of times to repeat
    the symbol. By providing this format string, we can quickly create visual separators
    in our outputs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的例子演示了如何通过设置填充字符为等号符号，并加上插入符号（以将符号居中显示），以及重复符号的次数，轻松打印出一串`20`个等号字符。通过提供这个格式化字符串，我们可以快速在输出中创建可视化分隔符：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While we will introduce more advanced features of the `.format()` method, the
    site [https://pyformat.info/](https://pyformat.info/) is a great resource for
    learning more about the capabilities of Python's string formatting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将介绍`.format()`方法的更多高级特性，但[https://pyformat.info/](https://pyformat.info/)网站是学习Python字符串格式化能力的一个很好的资源。
- en: Integers and floats
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数和浮动数
- en: 'The integer is another valuable data type that is frequently used—an integer
    is any whole positive or negative number. The float data type is similar, but
    allows us to use numbers requiring decimal-level precision. With integers and
    floats, we can use standard mathematical operations, such as: `+`, `-`, `*`, and
    `/`. These operations return slightly different results based on the object''s
    type (for example, `integer` or `float`).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是另一种常用的有价值数据类型——整数是任何完整的正数或负数。浮动数数据类型类似，但允许我们使用需要小数精度的数字。通过整数和浮动数，我们可以使用标准的数学运算，如：`+`、`-`、`*`和`/`。这些运算会根据对象的类型（例如，`integer`或`float`）返回稍微不同的结果。
- en: 'An integer uses whole numbers and rounding, for example dividing two integers
    will result in another whole number integer. However, by using one float in the
    equation, even one that has the same value as the integer will result in a float;
    for example, `3/2=1` and `3/2.0=1.5` in Python. The following are examples of
    integer and float operations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 整数使用整数和四舍五入运算，例如，两个整数相除将得到另一个整数。但如果方程式中使用了浮动数，即使它的值与整数相同，结果也会是浮动数；例如，在Python中，`3/2=1`和`3/2.0=1.5`。以下是整数和浮动数运算的示例：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use `**` to raise an integer by a power. For example, in the following
    section, we raise `11` by the power of `2`. In programming, it can be helpful
    to determine the numerator resulting from the division between two integers. For
    this, we use the modulus or percent (`%`) symbol. With Python, negative numbers
    are those with a dash character (`-`) preceding the value. We can use the built-in
    `abs()` function to get the absolute value of an integer or float:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`**`将整数提升为某个幂。例如，在接下来的部分中，我们将`11`提高到`2`的幂。在编程中，确定两个整数之间除法的结果（即分子）是有帮助的。为此，我们使用模运算符或百分号（`%`）。在Python中，负数是带有负号字符（`-`）的数值。我们可以使用内置的`abs()`函数来获取整数或浮动数值的绝对值：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A float is defined by any number with a decimal. Floats follow the same rules
    and operations as we saw with integers, with the exception of the division behavior
    described previously:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动类型（float）是由任何带有小数的数字定义的。浮动类型遵循与整数相同的规则和操作，唯一的例外是之前提到的除法行为：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Boolean and none
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值和空值
- en: The integers `0` and `1` can also represent Boolean values in Python. These
    values are the Boolean `False` or `True` objects, respectively. To define a Boolean,
    we can use the `bool()` constructor statement. These data types are used extensively
    in program logic to evaluate statements for conditionals, as covered later in
    this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 整数`0`和`1`也可以在Python中表示布尔值。这些值分别是布尔值`False`或`True`对象。要定义布尔值，我们可以使用`bool()`构造函数语句。这些数据类型在程序逻辑中被广泛使用，用于评估条件语句，如本章后面所述。
- en: 'Another built-in data type is the null type, which is defined by the keyword
    `None`. When used, it represents an empty object, and when evaluated will return
    `False`. This is helpful when initializing a variable that may use several data
    types throughout execution. By assigning a null value, the variable remains sanitized
    until reassigned:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个内置的数据类型是空值类型，它由关键字`None`定义。当使用时，它表示一个空对象，并且当评估时返回`False`。这在初始化一个可能在执行过程中使用多种数据类型的变量时很有用。通过赋予一个空值，变量在重新赋值之前保持清洁：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Structured data types
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化数据类型
- en: There are several data types that are more complex and allow us to create structures
    of raw data. This includes lists, dictionaries, sets, and tuples. Most of these
    structures are comprised of the previously mentioned data types. These structures
    are very useful in creating powerful units of values, allowing raw data to be
    stored in a manageable manner.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种更复杂的数据类型，允许我们创建原始数据的结构。这些包括列表、字典、集合和元组。大多数这些结构是由前述的数据类型组成的。这些结构在创建强大的值单元时非常有用，可以以可管理的方式存储原始数据。
- en: Lists
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are a series of ordered elements. Lists support any data type as an element
    and will maintain the order of data as it is appended to the list. Elements can
    be called by position or a loop can be used to step through each item. In Python,
    unlike other languages, printing a list takes one line. In languages like Java
    or C++, it can take three or more lines to print a list. Lists in Python can be
    as long as needed and can expand or contract on the fly, another feature uncommon
    in other languages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个有序的元素集合。列表支持任何数据类型作为元素，并会保持数据在添加到列表时的顺序。元素可以通过位置调用，也可以使用循环逐个访问每个项目。在 Python
    中，不像其他语言，打印一个列表只需要一行代码。在像 Java 或 C++ 这样的语言中，打印一个列表可能需要三行或更多的代码。Python 中的列表可以根据需要任意长，并且可以动态扩展或收缩，这是其他语言中不常见的特性。
- en: 'We can create lists by using brackets with elements separated by commas. Or,
    we can use the `list()` class constructor with an iterable object. List elements
    can be accessed by index where `0` is the first element. To access an element
    by position, we place the desired index in brackets following the list object.
    Rather than needing to know how long a list is (which can be accomplished with
    the `len()` function), we can use negative index numbers to access list elements
    in reference to the end (that is, `-3` would retrieve the third to last element):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用方括号并用逗号分隔元素来创建列表。或者，我们可以使用 `list()` 类构造函数并传入一个可迭代对象。列表元素可以通过索引访问，其中
    `0` 是第一个元素。要通过位置访问元素，我们将所需的索引放在方括号内，紧跟在列表对象后面。我们不需要知道列表的长度（可以通过 `len()` 函数获取），可以使用负数索引来根据列表末尾访问元素（即，`-3`
    会获取倒数第三个元素）：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can add, remove, or check if a value is in a list using a couple of different
    functions. The `append()` method adds data to the end of the list. Alternatively,
    the `insert()` method allows us to specify an index when adding data to the list.
    For example, we can add the string `fish` to the beginning, or `0` index, of our
    list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种不同的函数来添加、删除或检查一个值是否在列表中。`append()` 方法将数据添加到列表的末尾。或者，`insert()` 方法允许我们在添加数据到列表时指定索引。例如，我们可以将字符串
    `fish` 添加到列表的开头，或者 `0` 索引位置：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `pop()` and `remove()` functions delete data from a list either by index
    or by a specific object, respectively. If an index is not supplied with the `pop()`
    function, the last element in the list is popped. Note that the `remove()` function
    only gets rid of the first instance of the supplied object in the list:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()` 和 `remove()` 函数可以分别通过索引或特定对象从列表中删除数据。如果在 `pop()` 函数中没有提供索引，则默认弹出列表中的最后一个元素。需要注意的是，`remove()`
    函数只会删除列表中第一个匹配的对象：'
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use the `in` statement to check if some object is in the list. The `count()`
    function tells us how many instances of an object are in the list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `in` 语句来检查某个对象是否在列表中。`count()` 函数告诉我们某个对象在列表中出现了多少次：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we want to access a subset of elements, we can use list slice notation.
    Other objects, such as strings, also support this same slice notation to obtain
    a subset of data. Slice notation has the following format, where `a` is our list
    or string object:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想访问元素的子集，可以使用列表切片表示法。其他对象，如字符串，也支持这种切片表示法来获取数据的子集。切片表示法具有以下格式，其中 `a` 是我们的列表或字符串对象：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, `x` represents the start of the slice, `y` represents
    the end of the slice, and `z` represents the step of the slice. Note that each
    segment is separated by colons and enclosed in square brackets. A negative step
    is a quick way to reverse the contents of an object that supports slice notation and
    would be triggered by a negative number as `*z*`. Each of these arguments is optional.
    In the first example, our slice returns the second element and up to, but not
    including, the fifth element in the list. Using just one of these slice elements
    returns a list containing everything from the second index forward or everything
    up to the fifth index:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`x`表示切片的起始位置，`y`表示切片的结束位置，`z`表示切片的步长。请注意，每个部分由冒号分隔并括在方括号中。负步长是快速反转支持切片表示法的对象内容的方式，并由负数`*z*`触发。每个参数都是可选的。在第一个示例中，我们的切片返回从第二个元素到第五个元素（但不包括第五个元素）的子列表。只使用这些切片元素中的一个，则会返回一个包含从第二个索引开始或到第五个索引为止的所有元素的列表：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the third slice element, we can skip every other element or simply reverse
    the list with a negative one. We can use a combination of these slice elements
    to specify how to carve a subset of data from the list:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三种切片元素，我们可以跳过每个其他元素，或者简单地通过负数反转列表。我们可以通过组合这些切片元素来指定如何从列表中提取数据子集：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Dictionaries
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries, otherwise known as `dict`, are another common Python data container.
    Unlike lists, this object does not add data in a linear fashion. Instead, data
    is stored as key and value pairs, where you can create and name unique keys to
    act as an index for stored values. It is important to note that, in Python 2,
    dictionaries do not preserve the order in which items are added to it. This is
    no longer true as of Python 3.6.5, though in general, we should not rely on the
    `dict()` object maintaining order for us. These objects are used heavily in forensic
    scripting, as they allow us to store data by name in a single object; otherwise,
    we may be left assigning a lot of new variables. By storing data in dictionaries,
    it is possible to have one variable contain very structured data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 字典，也称为`dict`，是另一种常见的 Python 数据容器。与列表不同，这种对象不会按线性方式添加数据。相反，数据以键值对的形式存储，您可以创建和命名唯一的键，以便作为存储值的索引。需要注意的是，在
    Python 2 中，字典不会保留添加项的顺序。而从 Python 3.6.5 开始，字典会保持插入顺序，尽管通常我们不应依赖`dict()`对象为我们维持顺序。这些对象在取证脚本中被大量使用，因为它们允许我们通过名称在单一对象中存储数据；否则，我们可能不得不分配许多新变量。通过将数据存储在字典中，我们可以使一个变量包含非常结构化的数据。
- en: 'We can define a dictionary by using curly braces (`{}`), where each key and
    value pair is delimited by a colon. Additionally, we can use the `dict()` class
    constructor to instantiate dictionary objects. Calling a value from a dictionary
    is accomplished by specifying the key in brackets following the dictionary object.
    If we supply a key that does not exist, we will receive a `KeyError` (notice that
    we have assigned our dictionary to a variable, `a`). While we have not introduced
    variables at this point, it is necessary to highlight some of the functions that
    are specific to dictionaries:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用大括号（`{}`）来定义字典，其中每个键值对由冒号分隔。此外，我们还可以使用`dict()`类构造函数来实例化字典对象。调用字典中的值是通过在字典对象后指定键并放在方括号中完成的。如果我们提供一个不存在的键，则会收到`KeyError`（请注意我们将字典赋值给了一个变量`a`）。虽然我们尚未介绍变量，但需要突出一些特定于字典的函数：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can add or modify the value of a preexisting key in a dictionary by specifying
    a key and setting it equal to another object. We can remove objects using the
    `pop()` function, similar to the list `pop()` function, to remove an item in a
    dictionary by specifying its key instead of an index:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定一个键并将其设置为另一个对象来添加或修改字典中现有键的值。我们可以使用`pop()`函数删除对象，类似于列表的`pop()`函数，通过指定键而不是索引来从字典中删除项：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `keys()` and `values()` functions return a list of keys and values in the
    dictionary. We can use the `items()` function to return a list of tuples containing
    each key and value pair. These three functions are often used for conditionals
    and loops:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()`和`values()`函数返回字典中键和值的列表。我们可以使用`items()`函数返回包含每个键值对的元组列表。这三个函数通常用于条件语句和循环：'
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Sets and tuples
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和元组
- en: 'Sets are similar to lists in that they contain a list of elements, though they
    must be unique items. With this, the elements must be immutable, meaning that
    the value must remain constant. For this, sets are best used on integers, strings,
    Boolean, floats, and tuples as elements. Sets do not index the elements, and therefore
    we cannot access the elements by their location in the `set`. Instead, we can
    access and remove elements through the use of the `pop()` method mentioned for
    the list method. Tuples are also similar to lists, though they are immutable.
    Built using parenthesis in lieu of brackets, elements do not have to be unique
    and of any data type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 集合与列表类似，它们包含一组元素，但集合中的元素必须是唯一的。因此，元素必须是不可变的，这意味着其值必须保持恒定。因此，集合最适合用于整数、字符串、布尔值、浮动值和元组作为元素。集合不对元素进行索引，因此我们不能通过它们在`set`中的位置访问元素。相反，我们可以通过使用与列表方法相同的`pop()`方法来访问和移除元素。元组也类似于列表，但它们是不可变的。使用括号而非方括号构建，元素不必是唯一的，可以是任何数据类型：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The important difference between a tuple and a list is that a tuple is immutable.
    This means that we cannot change a tuple object. Instead, we must replace the
    object completely or cast it to a list, which is mutable. This casting process
    is described in the next section. Replacing an object is very slow since the operation
    to add a value to a tuple is `tuple = tuple + ('New value',)`, noting that the
    trailing comma is required to denote that this addition is a tuple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和列表的一个重要区别是元组是不可变的。这意味着我们不能改变元组对象。相反，我们必须完全替换该对象，或者将其转换为可变的列表。这个转换过程将在下一节中描述。替换对象非常慢，因为向元组添加值的操作是`tuple
    = tuple + ('新值',)`，请注意，尾随的逗号是必需的，用于表示这是一个元组的添加操作。
- en: Data type conversions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型转换
- en: 'In some situations, the initial data type might not be the desired data type
    and needs to be changed while preserving its content. For example, when a user
    inputs arguments from the command line, they are commonly captured as strings
    and sometimes that user input needs to be, for example, an integer. We would need
    to use the integer class constructor to convert that string object before processing
    the data. Imagine we have a simple script that returns the square of a user-supplied
    integer; we would need to first convert the user input to an integer prior to
    squaring the input. One of the most common ways to convert data types is to wrap
    the variable or string with the constructor method, as shown here, for each of
    the data types:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，初始数据类型可能不是所需的数据类型，并且需要在保留其内容的同时进行更改。例如，当用户从命令行输入参数时，这些输入通常会作为字符串捕获，有时这些用户输入需要变成整数。我们需要使用整数类构造函数来转换该字符串对象，然后再处理数据。假设我们有一个简单的脚本，它返回用户提供的整数的平方；我们需要先将用户输入转换为整数，然后再计算平方。最常见的数据类型转换方法之一是使用构造函数方法包装变量或字符串，如下所示，适用于每种数据类型：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Invalid conversions, for example, converting the letter `''a''` to an integer,
    will raise a `ValueError`. This error will state that the specified value cannot
    be converted to the desired type. In this case, we would want to use the built-in
    `ord()` method, which converts a character to its integer equivalent based on
    the ASCII value. In other scenarios, we may need to use other methods to convert
    between data types. The following is a table of common built-in data type conversion
    methods we can utilize for most scenarios:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的转换，例如将字母`'a'`转换为整数，将引发`ValueError`。该错误将指出指定的值无法转换为所需的类型。在这种情况下，我们需要使用内建的`ord()`方法，它将字符转换为基于ASCII值的整数等效值。在其他情况下，我们可能需要使用其他方法在数据类型之间进行转换。以下是我们可以在大多数场景中使用的常见内建数据类型转换方法的表格：
- en: '| **Method** | **Description** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `str()`, `int()`, `float()`, `dict()`, `list()`, `set()`, `tuple()` | Class
    constructor methods |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `str()`、`int()`、`float()`、`dict()`、`list()`、`set()`、`tuple()` | 类构造函数方法 |'
- en: '| `hex()`, `oct()` | Converts an integer into a base 16 (hex) or base 8 (octal)
    representation |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `hex()`、`oct()` | 将整数转换为16进制（hex）或8进制（octal）表示 |'
- en: '| `chr()`, `unichr()` | Converts an integer into an ASCII or Unicode character
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `chr()`、`unichr()` | 将整数转换为ASCII或Unicode字符 |'
- en: '| `ord()` | Converts a character into an integer |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `ord()` | 将字符转换为整数 |'
- en: 'We can also interchange the type or ordered collections found in our list,
    set, and tuple types. Since sets have requirements for what data may be inserted,
    we generally do not cast anything to a set. It is more common, instead, to case
    a set to a list so that we can access values by position:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以互换列表、集合和元组类型中的有序集合或类型。由于集合对插入的数据有要求，通常我们不会将任何东西强制转换为集合。相反，更常见的做法是将集合转换为列表，以便按位置访问值：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Files
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: 'We will often create file objects to read or write data from a file. File objects
    can be created using the built-in `open()` method. The `open()` function takes
    two arguments, the name of the file and the mode. These modes dictate how we can
    interact with the file object. The mode argument is optional, and if left blank defaults
    to read-only. The following table illustrates the different file modes available
    for use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常创建文件对象来从文件中读取或写入数据。文件对象可以使用内置的 `open()` 方法创建。`open()` 函数接受两个参数：文件名和模式。这些模式决定了我们如何与文件对象进行交互。模式参数是可选的，如果未指定，则默认为只读模式。以下表格列出了可用的不同文件模式：
- en: '| **File Mode** | **Description** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **文件模式** | **描述** |'
- en: '| `r` | Opens the file for read-only mode (default). *This does not offer forensic
    write protection! Please always use a certified process to protect evidence from
    modification.* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 以只读模式打开文件（默认模式）。*这并不提供法医写保护！请始终使用经过认证的过程来保护证据不被修改。* |'
- en: '| `w` | Creates, or overwrites the file if it exists, for writing. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 如果文件存在，则创建或覆盖该文件进行写入。 |'
- en: '| `a` | Creates a file if it doesn''t exist for writing. If the file does exist,
    the file pointer is placed at the end of the file to append writes to the file.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 如果文件不存在，则创建该文件以进行写入。如果文件存在，则将文件指针置于文件末尾以附加写入内容。 |'
- en: '| `rb`, `wb`, or `ab` | Opens the file for reading or writing in binary mode.
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `rb`, `wb`, 或 `ab` | 以二进制模式打开文件进行读写。 |'
- en: '| `r+`, `rb+`, `w+`, `wb+`, `a+`, or `ab+` | Opens the file for reading and
    writing in either standard or binary mode. If the file does not exist, the `w`
    or `a` modes create the file. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `r+`, `rb+`, `w+`, `wb+`, `a+`, 或 `ab+` | 以标准模式或二进制模式打开文件进行读写。如果文件不存在，`w`
    或 `a` 模式会创建文件。 |'
- en: 'Most often, we will use read and write in standard or binary mode. Let''s take
    a look at a few examples and some of the common functions we might use. For this
    section, we will create a text file called `file.txt` with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最常使用标准模式或二进制模式进行读写。让我们来看几个示例以及可能使用的一些常见函数。在本节中，我们将创建一个名为 `file.txt` 的文本文件，内容如下：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the following example, we open a file object that exists, `file.txt`, and
    assign it to a variable, `in_file`. Since we do not supply a file mode, it is
    opened in read-only mode by default. We can use the `read()` method to read all
    lines as a continuous string. The `readline()` method can be used to read individual
    lines as a string. Alternatively, the `readlines()` method creates a string for
    each line and stores it in a list. These functions take an optional argument,
    specifying the size of bytes to read.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们打开一个已存在的文件对象 `file.txt`，并将其赋值给变量 `in_file`。由于未提供文件模式，文件默认以只读模式打开。我们可以使用
    `read()` 方法将所有行作为一个连续的字符串读取。`readline()` 方法可用于逐行读取字符串。或者，`readlines()` 方法会为每一行创建一个字符串，并将其存储在列表中。这些函数接受一个可选参数，指定要读取的字节数。
- en: The `readline()` and `readlines()` functions use the `\n` or `\r` newline characters
    to segment the lines of a file. This is good for most files, though may not always
    work based on your input data. As an example, CSV files with multiple lines in
    a single cell would not display properly with this type of file-reading interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline()` 和 `readlines()` 函数使用 `\n` 或 `\r` 换行符将文件的行分段。这对于大多数文件来说是有效的，但根据输入数据的不同，可能并不总是适用。例如，包含多行内容在单一单元格中的
    CSV 文件，使用此类文件读取接口时可能无法正确显示。'
- en: 'Python keeps track of where we currently are in the file. To illustrate the
    examples we''ve described, we need to use the `seek()` operation to bring us back
    to the start of the file before we run our next example. The `seek()` operation
    accepts a number and will navigate to that decimal character offset within the
    file. For example, if we tried to use the `read()` method before seeking back
    to the start, our next print function (showcasing the `readline()` method) would
    not return anything. This is because the cursor would be at the end of the file
    as a result of the `read()` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会跟踪我们在文件中的当前位置。为了说明我们描述的例子，我们需要使用`seek()`操作将光标移回文件开头，然后再运行下一个示例。`seek()`操作接受一个数字并将光标移动到该文件中的字符偏移量。例如，如果我们在没有将光标移动回文件开头的情况下使用`read()`方法，接下来的打印函数（展示`readline()`方法）将不会返回任何内容。这是因为光标在使用`read()`方法后已经位于文件的末尾：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In a similar fashion, we can create, or open and overwrite, an existing file
    using the `w` file mode. We can use the `write()` function to write an individual
    string or the `writelines()` method to write any iterable object to the file.
    The `writelines()` function essentially calls the `write()` method for each element
    of the iterable object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`w`文件模式来创建、打开并覆盖现有文件。我们可以使用`write()`函数写入单个字符串，或使用`writelines()`方法将任何可迭代对象写入文件。`writelines()`函数本质上是对可迭代对象的每个元素调用`write()`方法。
- en: 'For example, this is tantamount to calling `write()` on each element of a list:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这相当于对列表的每个元素调用`write()`方法：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Python does a great job of closing connections to a file object automatically.
    However, best practice dictates that we should use the `flush()` and `close()`
    methods after we finish writing data to a file. The `flush()` method writes any
    data remaining in a buffer to the file, and the `close()` function closes our
    connection to the file object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Python 能够自动很好地关闭文件对象的连接。然而，最佳实践要求我们在写入数据到文件后，应该使用`flush()`和`close()`方法。`flush()`方法将缓冲区中剩余的数据写入文件，而`close()`方法则关闭与文件对象的连接：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Variables
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'We can assign values to variables using the data types we just covered. By
    assigning values to variables, we can refer to that value, which could be a large
    100-element list, by its variable name. This not only saves the programmer from
    re-typing out the value over and over again, but helps enhance the readability
    of the code and allows us to change the values of a variable over time. Throughout
    this chapter, we have already assigned objects to variables using the `=` sign.
    Variable names can technically be anything, although we recommend the following
    guidelines:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用刚才介绍的数据类型为变量赋值。通过给变量赋值，我们可以通过变量名引用该值，无论它是一个包含 100 个元素的大列表。这不仅避免了程序员一遍又一遍地重复输入相同的值，还增强了代码的可读性，并且使得我们能够随着时间的推移更改变量的值。在本章中，我们已经通过`=`符号为变量赋值。技术上讲，变量名可以是任何东西，但我们建议遵循以下准则：
- en: Variable names should be short and descriptive of the stored content or purpose.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名应该简短并且描述存储的内容或目的。
- en: Begin with a letter or underscore.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名应以字母或下划线开头。
- en: Constant variables should be denoted by capitalized words.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量变量应由大写字母组成。
- en: Dynamic variables should be lowercase words separated by underscores.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态变量应该是由下划线分隔的小写字母单词。
- en: 'Never be one of the following or any Python-reserved name: `input`, `output`,
    `tmp`, `temp`, `in`, `for`, `next`, `file`, `True`, `False`, `None`, `str`, `int`,
    `list`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名永远不要是以下保留字或任何 Python 保留的名称：`input`、`output`、`tmp`、`temp`、`in`、`for`、`next`、`file`、`True`、`False`、`None`、`str`、`int`、`list`。
- en: Never include a space in a variable name. Python thinks two variables are being
    defined and will raise a syntax error. Use underscores to separate words.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名中永远不要包含空格。Python 会认为定义了两个变量，并会抛出语法错误。使用下划线来分隔单词。
- en: Generally, programmers use memorable and descriptive names that indicate the
    data they hold. For example, in a script that prompts for the phone number of
    the user, the variable should be `phone_number`, which clearly indicates the purpose
    and contents of this variable. Another popular naming style is `CamelCase`, where
    every word is capitalized. This naming convention is often used in conjunction
    with class names (more on those later in this book).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员使用易记且具有描述性的名称，以表明它们所包含的数据。例如，在一个提示用户输入电话号码的脚本中，变量应为`phone_number`，这清楚地表明了该变量的目的和内容。另一种流行的命名风格是`CamelCase`，其中每个单词的首字母大写。这种命名约定通常与类名一起使用（本书稍后会介绍）。
- en: 'A variable assignment allows the value to be modified as the script runs. The
    general rule of thumb is to assign a value to a variable if it will be used again.
    Let''s practice by creating variables and assigning them data types we have just
    learned about. While this is simple, we recommend following along in the interactive
    prompt to get in the habit of assigning variables. In the first example here,
    we assign a string to a variable before printing the variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 变量赋值允许在脚本运行时修改值。一般的经验法则是，如果一个变量会再次使用，就将一个值分配给它。让我们通过创建变量并为其分配我们刚学到的数据类型来练习。虽然这很简单，但我们建议在交互式提示中跟着做，以养成分配变量的习惯。在这里的第一个示例中，我们将一个字符串分配给变量，然后打印该变量：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second example introduces some new operators. First, we assign the integer,
    `5`, to the variable, `our_number`. Then, we use the plus-gets (`+=`) as a built-in
    shorthand for `our_number = our_number + 20`. In addition to plus-gets, there
    is minus-gets (`-=`), multiply-gets (`*=`), and divide-gets (`/=`):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例引入了一些新的运算符。首先，我们将整数 `5` 分配给变量 `our_number`。然后，我们使用加法赋值运算符 (`+=`)，作为 `our_number
    = our_number + 20` 的简写形式。除了加法赋值外，还有减法赋值 (`-=`)、乘法赋值 (`*=`) 和除法赋值 (`/=`)：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the following code block, we assign a series of variables before printing
    them. The data types used for our variables are `string`, `integer`, `float`,
    `list`, and `Boolean`, respectively:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们在打印之前分配了一系列变量。我们为变量使用的数据类型分别是 `string`、`integer`、`float`、`list` 和
    `Boolean`：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice the `BOOK_TITLE` and `AUTHOR_NAMES` variables. When a variable is static,
    for instance, non-changing throughout the execution of a script, it is referred
    to as a constant variable. Unlike other programming languages, there is not a
    built-in method for protecting constants from being overwritten, so we use naming
    conventions to assist in reminding us not to replace the value. While some variables
    such as the edition of the book, language, or version of Python might change,
    the title and authors should be constants (we hope). If there is ever confusion
    when it comes to naming and styling conventions in Python, try running the following
    statement in an interpreter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `BOOK_TITLE` 和 `AUTHOR_NAMES` 变量。当一个变量是静态的，比如在脚本执行过程中不发生变化时，它被称为常量变量。与其他编程语言不同，Python
    没有内置的保护常量不被覆盖的方法，因此我们使用命名约定来提醒自己不要替换其值。虽然一些变量如书籍的版本、语言或 Python 的版本可能会变化，但标题和作者应该是常量（我们希望如此）。如果在命名和样式约定上存在困惑，可以尝试在解释器中运行以下语句：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As we saw previously, we can use the `split()` method on a string to convert
    it into a list. We can also convert a list into a string using the `join()` method.
    This method follows a string containing the desired common denominator and the
    list as its only argument. In the following example, we are taking list containing
    two strings and joining them into one string, where the elements are separated
    by a comma:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们可以对字符串使用 `split()` 方法将其转换为列表。我们还可以使用 `join()` 方法将列表转换为字符串。该方法包含一个包含所需公分母的字符串和列表作为唯一参数。在以下示例中，我们取一个包含两个字符串的列表，并将它们合并成一个字符串，元素之间由逗号分隔：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Understanding scripting flow logic
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解脚本流程逻辑
- en: 'Flow control logic allows us to create dynamic operations by specifying different
    routes of program execution based upon a series of circumstances. In any script
    worth its salt, some manner of flow control is present. For example, flow logic
    would be required to create a dynamic script that returns different results based
    on options selected by the user. In Python, there are two basic sets of flow logic:
    conditionals and loops.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制逻辑允许我们通过根据一系列情况指定不同的程序执行路线来创建动态操作。在任何有价值的脚本中，都会有某种形式的流程控制。例如，创建一个根据用户选择的选项返回不同结果的动态脚本时，就需要流程逻辑。在
    Python 中，有两种基本的流程逻辑：条件语句和循环语句。
- en: 'Flow operators are frequently accompanied by flow logic. These operators can
    be strung together to create more complicated logic. The following table represents
    a *truth table* and illustrates the value of various flow operators based on the
    *A* or *B* variable Boolean state:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 流程运算符通常与流程逻辑一起使用。这些运算符可以串联在一起，创建更复杂的逻辑。下表展示了一个 *真值表*，并说明了基于 *A* 或 *B* 变量布尔状态的各种流程运算符的值：
- en: '| **A** | **B** | **A and B** | **A or B** | **not A** | **not B** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A 和 B** | **A 或 B** | **非 A** | **非 B** |'
- en: '| F | F | F | F | T | T |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| F | F | F | F | T | T |'
- en: '| T | F | F | T | F | T |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F | T | F | T |'
- en: '| F | T | F | T | T | F |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| F | T | F | T | T | F |'
- en: '| T | T | T | T | F | F |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| T | T | T | T | F | F |'
- en: The logical `AND` and `OR` operators are the third and fourth columns in the
    table. Both *A* and *B* must be `True` for the `AND` operator to return `True`.
    Only one of the variables needs to be `True` for the `OR` operator to be `True`.
    The `not` operator simply switches the Boolean value of the variable to its opposite
    (for example, `True` becomes `False` and vice versa).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 `AND` 和 `OR` 运算符是表格中的第三和第四列。只有当 *A* 和 *B* 都为 `True` 时，`AND` 运算符才会返回 `True`。对于
    `OR` 运算符，只需要其中一个变量为 `True`，它就会返回 `True`。`not` 运算符只是将变量的布尔值切换为其相反值（例如，`True` 变为
    `False`，反之亦然）。
- en: Mastering conditionals and loops will take our scripts to another level. At
    its core, flow logic relies on only two values, `True` or `False`. As noted earlier,
    in Python, these are represented by the Boolean `True` and `False` data types.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握条件语句和循环将使我们的脚本达到一个新的层次。其核心是，流程逻辑仅依赖于两个值：`True` 或 `False`。如前所述，在 Python 中，这两个值由布尔类型
    `True` 和 `False` 表示。
- en: Conditionals
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: When a script hits a conditional, it's much like standing at a fork in the road.
    Depending on some factor, say a more promising horizon, you may decide to go east
    over west. Computer logic is less arbitrary in that if something is true the script
    proceeds one way, and if it is false then it will go another. These junctions
    are critical; if the program decides to go off the path we've developed for it,
    we'll be in serious trouble.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本遇到条件语句时，就像是站在一条岔路口。根据某些因素，比如更有前景的远方，你可能决定朝东而不是朝西走。计算机逻辑不那么任意，如果某件事为真，脚本就会按一种方式执行，如果为假，则按另一种方式执行。这些分岔口非常关键；如果程序决定偏离我们为它设计的路径，我们就会陷入严重的麻烦。
- en: 'There are three statements that are used to form a conditional block: `if`,
    `elif`, and `else`. The conditional block refers to the conditional statements,
    their flow logic, and code. A conditional block starts with an `if` statement
    followed by flow logic, a colon, and indented line(s) of code. If the flow logic
    evaluates to `True`, then the indented code following the `if` statement will
    be executed. If it does not evaluate to `True`, the **Python virtual machine**
    (**PVM**) will skip those lines of code and go to the next line on the same level
    of indentation as the `if` statement. This is usually a corresponding `elif` (else-if)
    or `else` statement.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个语句用于构成条件块：`if`、`elif` 和 `else`。条件块指的是条件语句、它们的流程逻辑和代码。一个条件块以 `if` 语句开始，后面跟着流程逻辑、冒号和缩进的代码行。如果流程逻辑计算结果为
    `True`，那么 `if` 语句后面缩进的代码将会被执行。如果计算结果不是 `True`，**Python 虚拟机**（**PVM**）将跳过这些代码行并转到与
    `if` 语句相同缩进级别的下一行。这通常是相应的 `elif`（else-if）或 `else` 语句。
- en: Indentation is very important in Python. It is used to demarcate code to be
    executed within a conditional statement or loop. A standard of four spaces for
    indentation is used in this book, though you may encounter code that uses a two-space
    indentation or uses tab characters. While all three of these practices are allowed
    in Python, four spaces are preferred and easier to read.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，缩进非常重要。它用于标识在条件语句或循环中要执行的代码。本书中采用了四个空格的缩进标准，尽管你可能会遇到使用两个空格或使用制表符的代码。虽然这三种做法在
    Python 中都被允许，但四个空格的缩进更受推崇，且更容易阅读。
- en: In a conditional block, once one of the statements evaluates to `True`, the
    code is executed and the PVM exits the block without evaluating the other statements.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个条件块中，一旦某个语句计算结果为 `True`，代码就会被执行，且 PVM 会退出该块，而不再评估其他语句。
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Until we define functions, we will stick to simple `if` statement examples:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义函数之前，我们将坚持使用简单的 `if` 语句示例：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice how when the flow logic evaluates to `True`, then the code indented following
    the `if` statement is executed. When it evaluates to `False`, the code is skipped.
    Typically, when the `if` statement is false, you will have a secondary statement,
    such as an `elif` or `else` to catch other possibilities, such as when `a` is
    less than or equal to `b`. However, it is important to note that we can just use
    an `if` statement without any `elif` or `else` statements.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当流程逻辑计算结果为 `True` 时，`if` 语句后面缩进的代码会被执行。当其结果为 `False` 时，代码会被跳过。通常，当 `if` 语句为假时，你会有一个辅助语句，比如
    `elif` 或 `else`，用于捕捉其他可能性，例如当 `a` 小于或等于 `b` 时。然而，值得注意的是，我们可以只使用 `if` 语句，而不使用任何
    `elif` 或 `else` 语句。
- en: The difference between `if` and `elif` is subtle. We can only functionally notice
    a difference when we use multiple `if` statements. The `elif` statement allows
    for a second condition to be evaluated in the case that the first isn't successful.
    A second `if` statement will be evaluated regardless of the outcome of the first
    `if` statement.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 和 `elif` 之间的区别很微妙。只有在我们使用多个 `if` 语句时，才能明显感觉到区别。`elif` 语句允许在第一个条件不成功时评估第二个条件。而第二个
    `if` 语句会在第一个 `if` 语句的结果无论如何都被执行。'
- en: The `else` statement does not require any flow logic and can be treated as a
    catch-all case for any remaining or unaccounted for case. This does not mean,
    however, errors will not occur when the code in the `else` statement is executed.
    Do not rely on `else` statements to handle errors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 语句不需要任何流程逻辑，可以作为一种通用情况处理任何剩余的或未处理的情况。然而，这并不意味着在执行 `else` 语句中的代码时不会发生错误。不要依赖
    `else` 语句来处理错误。'
- en: 'Conditional statements can be made more comprehensive by using the logical
    `and` or `or` operators. These allow for more complex logic in a single conditional
    statement:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用逻辑运算符 `and` 或 `or` 来使条件语句更具综合性。这些运算符允许在单个条件语句中实现更复杂的逻辑：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following table can be helpful to understand how common operators work:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格有助于理解常见操作符的工作方式：
- en: '| **Operator** | **Description** | **Example** | **Evaluation** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **描述** | **示例** | **结果** |'
- en: '| `<`, `>` | less than, greater than | `8 < 3` | `False` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `>` | 小于，大于 | `8 < 3` | `False` |'
- en: '| `<=`, `>=` | less than equal to, greater than equal to | `5 =< 5` | `True`
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `<=`, `>=` | 小于等于，大于等于 | `5 =< 5` | `True` |'
- en: '| `==`, `!=` | equal to, not equal to | `2 != 3` | `True` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `==`, `!=` | 等于，不等于 | `2 != 3` | `True` |'
- en: '| `not` | switches Boolean value | `not True` | `False` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `not` | 切换布尔值 | `not True` | `False` |'
- en: Loops
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loops provide another method of flow control, and are suited to perform iterative
    tasks. A loop will repeat inclusive code until the provided condition is no longer
    `True` or an exit signal is provided. There are two kinds of loops: `for` and
    `while`. For most iterative tasks, a `for` loop will be the best option to use.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 循环提供了另一种流程控制的方法，适用于执行迭代任务。循环会重复执行包含的代码，直到提供的条件不再为`True`或出现退出信号。有两种类型的循环：`for`
    和 `while`。对于大多数迭代任务，`for` 循环通常是最合适的选择。
- en: The for loop
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`for` loops are the most common and, in most cases, the preferred method to
    perform a task over and over again. Imagine a factory line; for each object on
    the conveyor belt, a `for` loop could be used to perform some task on it, such
    as placing a label on the object. In this manner, multiple `for` loops can come
    together in the form of an assembly line, processing each object, until they are
    ready to be presented to the user.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是最常见的循环方式，在大多数情况下，它是执行重复任务的首选方法。想象一下一个工厂流水线；对于传送带上的每个物品，都可以使用 `for`
    循环对其执行某项任务，比如给物品贴上标签。通过这种方式，多个 `for` 循环可以在流水线的形式下协同工作，处理每个物品，直到它们准备好展示给用户。'
- en: Much like the rest of Python, the `for` loop is very simple syntactically, yet
    powerful. In some languages, a `for` loop needs to be initialized, have a counter
    of sorts, and a termination case. Python's `for` loop is much more dynamic and
    handles these tasks on its own. These loops contain indented code that is executed
    line by line. If the object being iterated over still has elements (for example,
    more items to process) at the end of the indented block, the PVM will position
    itself at the beginning of the loop and repeat the code again.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Python 中的其他部分一样，`for` 循环在语法上非常简单，但功能强大。在一些语言中，`for` 循环需要初始化、计数器以及终止条件。而 Python
    的 `for` 循环则更加动态，能够自动处理这些任务。这些循环包含缩进的代码，按行执行。如果被迭代的对象仍然有元素（例如，更多需要处理的项目），则 PVM
    会将执行指针移回到循环的开头，并重复执行代码。
- en: 'The `for` loop syntax will specify the object to iterate over and what to call
    each of the elements within the object. Note that the object must be iterable.
    For example, `lists`, `sets`, `tuples`, and `strings` are iterable, but an integer
    is not. In the following example, we can see how a `for` loop treats strings and
    lists and helps us iterate over each element in iterable objects:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的语法会指定要迭代的对象，并定义如何调用对象中的每个元素。请注意，迭代对象必须是可迭代的。例如，`lists`、`sets`、`tuples`
    和 `strings` 都是可迭代的，但整数不是。在下面的例子中，我们可以看到 `for` 循环如何处理字符串和列表，并帮助我们迭代可迭代对象中的每个元素：'
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There are additional, more advanced, ways to call a `for` loop. The `enumerate()`
    function can be used to start an index. This comes in handy when you need to keep
    track of the index of the current loop. Indexes are incremented at the beginning
    of the loop. The first object has an index of `0`, the second has an index of
    `1`, and so on. The `range()` function can execute a loop a certain number of
    times and provide an index:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他更高级的方式来调用 `for` 循环。可以使用 `enumerate()` 函数来开始一个索引。当你需要跟踪当前循环的索引时，这个方法很有用。索引会在循环开始时递增。第一个对象的索引是
    `0`，第二个是 `1`，依此类推。`range()` 函数可以执行一定次数的循环，并提供索引：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The while loop
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`while` loops are not encountered as frequently in Python. A `while` loop executes
    as long as a statement is true. The simplest `while` loop would be a `while True`
    statement. This kind of loop would execute forever since the Boolean object `True` is
    always `True` and so the indented code would continually execute.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环在 Python 中的出现频率较低。`while` 循环会在某个条件为真时一直执行。最简单的 `while` 循环就是 `while
    True` 语句。这种循环会永远执行，因为布尔值 `True` 始终为 `True`，所以缩进的代码会不断执行。'
- en: 'If you are not careful, you can inadvertently create an infinite loop, which
    will wreak havoc on your script''s intended functionality. It is imperative to
    utilize conditionals to cover all your bases such as `if`, `elif`, and `else`
    statements. If you fail to do so, your script can enter an unaccounted situation
    and crash. This is not to say that `while` loops are not worth using. `while`
    loops are quite powerful and have their own place in Python:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心，可能会不经意地创建一个无限循环，这会破坏你脚本的预期功能。必须利用条件语句来覆盖所有的情况，如 `if`、`elif` 和 `else`
    语句。如果没有做到这一点，脚本可能会进入一个无法预料的情况并崩溃。这并不是说 `while` 循环不值得使用。`while` 循环非常强大，并且在 Python
    中有它自己的作用。
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `break`, `continue`, and `pass` statements are used in conjunction with
    `for` and `while` loops to create more dynamic loops. The `break` escapes from
    the current loop, while the `continue` statement causes the PVM to begin executing
    code at the beginning of the loop, skipping any indented code following the `continue`
    statement. The `pass` statement literally does nothing and acts as a placeholder.
    If you're feeling brave or bored, or worse, both, remove the `break` statement
    from the previous example and note what happens.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`、`continue` 和 `pass` 语句与 `for` 和 `while` 循环一起使用，可以创建更动态的循环。`break` 用于退出当前循环，而
    `continue` 语句会导致 PVM 从循环的开头开始执行代码，跳过 `continue` 语句后的任何缩进代码。`pass` 语句字面上什么都不做，它作为占位符。如果你敢于尝试，或者无聊，或者更糟，二者兼而有之，移除前一个例子中的
    `break` 语句，看看会发生什么。'
- en: Functions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are the first step to creating more complex Python code. At a high
    level, they are containers of Python code that can be bundled together into a
    callable block. A simple model function requires a single input, performs an operation
    on the provided data, and returns a single output. However, this quickly becomes
    more complicated as functions can run without inputs or optional inputs or do
    not need to return an output at all.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是创建更复杂 Python 代码的第一步。从高层次来看，它们是可以打包成可调用代码块的 Python 代码容器。一个简单的模型函数需要一个输入，对提供的数据进行操作，并返回一个输出。然而，这很快会变得更复杂，因为函数可以在没有输入或有可选输入的情况下运行，或者根本不需要返回输出。
- en: Functions are an integral component of any programming language and have already
    been encountered many times in this chapter. For example, the append from `list.append()`
    is a function that requires input to add to a list. Once a function is created,
    you can invoke it by its name and pass any required inputs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何编程语言的一个重要组成部分，并且在本章中已经多次出现。例如，`list.append()` 中的 append 是一个需要输入以添加到列表中的函数。函数一旦创建，你可以通过它的名称调用它，并传递任何需要的输入。
- en: When it comes to writing functions, more is better. It is much easier to handle
    and troubleshoot a bug in a program with many small functions than one big function.
    Smaller functions make your code more readable and make it easier to find troublesome
    logic. That being said, functions should contain code for a singular purpose,
    such as accessing a certain key in a registry file. There is no need to create
    functions for each line of code in your script. Consider using functions as logical
    blocks of code. Sometimes that is three lines, sometimes that is 50 lines; what's
    important is that the purpose and operation of the functional unit of code is
    clear.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，多一些总是更好的。相比于一个大型函数，处理和排查程序中的bug要容易得多，尤其是当程序有许多小型函数时。小函数使得代码更具可读性，也更容易找到问题逻辑。话虽如此，函数应该包含单一目的的代码，例如访问注册表文件中的某个键。没有必要为脚本中的每一行代码都创建函数。可以将函数视为逻辑代码块。有时它可能只有三行，有时则有50行；重要的是，函数的目的和操作应当清晰。
- en: 'The function syntax starts with a definition, `def`, followed by the name of
    the function, any inputs in parenthesis, and a colon. Following this format are
    indented lines of code that will run when the function is called. Optionally,
    a function may have a return statement to pass information back to the instance
    where it was called from:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 函数语法以定义开始，`def`，后面跟着函数名、括号内的输入参数以及冒号。按照这个格式，后面是缩进的代码行，当函数被调用时这些代码会执行。可选地，函数可以有一个返回语句，将信息传递回调用它的实例：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the example we've just seen, we've created a function named `simple_function()`
    that takes no inputs. This function does not return anything and instead prints
    a string. Let's take a look at more complicated examples.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才看到的例子中，我们创建了一个名为`simple_function()`的函数，它不接收任何输入。这个函数不会返回任何东西，而是打印一个字符串。接下来，让我们看看更复杂的例子。
- en: 'Our first function, `square()`, takes one input and squares it. As this function
    returns a value, we catch it by assigning it to a variable when invoking the function.
    This variable, `squared_number`, will be equal to the returned value of the function.
    While this is a very succinct function, it is very easily broken if given the
    wrong input. Give the square function some other data type, such as a string,
    and you will receive a `TypeError`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数，`square()`，接收一个输入并对其进行平方。由于这个函数会返回一个值，因此我们在调用该函数时将其赋值给一个变量来捕获返回值。这个变量，`squared_number`，将等于函数返回的值。虽然这是一个非常简洁的函数，但如果给它传入错误的输入，函数会很容易出错。传入一个其他数据类型（如字符串）时，你将会收到一个`TypeError`：
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our second function, `even_or_odd`, is slightly more advanced. This function
    first checks if it is passed an input that is of type integer. If not, it returns
    immediately, which causes the function to exit. If it is an integer, it performs
    some logic that displays to the user whether the integer is even or odd. Notice
    that when we try to give the function the string, `''5''`, not to be confused
    with the integer, `5`, it returns nothing, whereas in the square function, which
    lacks any input validation checks, this would have caused an error:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个函数，`even_or_odd`，稍微复杂一点。这个函数首先检查传入的参数是否为整数类型。如果不是，它会立即返回并退出。如果是整数，它会执行一些逻辑，向用户显示该整数是偶数还是奇数。注意，当我们尝试给函数传入字符串`'5'`（与整数`5`不同）时，它什么也不返回，而在`square`函数中，由于缺乏输入验证检查，这将导致错误：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Aspiring developers should get in the habit of writing functions. As always,
    functions should be well-commented to help explain their purpose. Functions will
    be used throughout this book, especially as we begin to develop our forensic scripts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 渴望成为开发者的人应该养成写函数的习惯。像往常一样，函数应当有良好的注释，以帮助解释其目的。函数将在本书中频繁使用，尤其是在我们开始开发法医脚本时。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has covered a wide range of introductory content that provides
    a foundation to be built upon throughout the duration of this book; by the end,
    you will become well-versed in Python development. These topics have been handpicked
    as the most important items to comprise a basic understanding of the language
    as we move forward. We have covered data types, what they are and when they are
    used, variable naming and the associated rules and guidelines, logic and operations
    to manipulate and make decisions based on values, and conditions and loops that
    provide a sequential organization for our scripts and form the baseline of everything
    we develop. The code for this project can be downloaded from GitHub or Packt,
    as described in the *Preface*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了广泛的入门内容，为本书的后续章节提供了基础；到最后，你将熟练掌握 Python 开发。这些主题已被精心挑选，作为理解语言的基本内容，供我们向前推进时使用。我们已经涵盖了数据类型，它们是什么以及何时使用，变量命名及其相关规则和准则，逻辑与操作，基于值进行决策并进行处理，以及条件和循环，它们为我们的脚本提供了顺序组织，并构成了我们开发的基线。此项目的代码可以从
    GitHub 或 Packt 下载，如*前言*所述。
- en: Please consider re-reading this chapter and working through the examples multiple
    times to help with comprehension. Just like anything else, learning a new language
    requires a lot of practice.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑重新阅读本章，并多次练习示例以帮助理解。就像任何事情一样，学习一门新语言需要大量的练习。
- en: Through these features alone, we can create basic scripts. Python is a very
    powerful and complex language belying its simplistic syntax. In the next chapter,
    we will explore more complex foundational items and continue expanding upon knowledge
    established in this chapter, prior to moving on to real-world examples.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过这些特性，我们就能创建基本的脚本。Python 是一种非常强大且复杂的语言，尽管其语法看起来简单。接下来的章节，我们将探讨更复杂的基础内容，并在此章节中建立的知识基础上继续扩展，然后再进行现实世界的例子。
