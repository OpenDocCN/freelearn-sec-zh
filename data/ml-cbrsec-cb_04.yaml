- en: Machine Learning for Social Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于社会工程学的机器学习
- en: There are a lot of cool new applications of **machine learning** (**ML**), and
    nowhere do these shine as much as they do in social engineering. ML has enabled
    hugely successful automated spear phishing, as we will learn via a Twitter spear
    phishing bot recipe. It has also been used to generate fake, but realistic, videos
    and, at the same time, to discover when these are fake. It offers the ability
    to voice transfer, detect lies, and many other handy tools that you will see in
    this chapter's recipes, designed to step up your social engineering game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多酷炫的机器学习（**ML**）应用，它们在社会工程学中尤其突出。机器学习使得自动化钓鱼攻击取得了巨大的成功，正如我们将通过 Twitter 钓鱼机器人教程所学到的那样。它还被用于生成假冒但逼真的视频，同时也能发现这些视频是假的。机器学习提供了语音传输、谎言检测等多种实用工具，这些工具将出现在本章的教程中，旨在提升你的社会工程学技能。
- en: 'This chapter covers the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Twitter spear phishing bot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter 钓鱼机器人
- en: Voice impersonation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音伪装
- en: Speech recognition for **Open Source Intelligence** (**OSINT**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 **开源情报**（**OSINT**）的语音识别
- en: Facial recognition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面部识别
- en: Deepfake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度伪造
- en: Deepfake recognition
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度伪造识别
- en: Lie detection using ML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器学习进行谎言检测
- en: Personality analysis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性分析
- en: Social Mapper
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社会化映射工具
- en: Training a fake review generator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练虚假评论生成器
- en: Generating fake reviews
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成虚假评论
- en: Fake news
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假新闻
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下内容：
- en: Markovify
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Markovify
- en: Twitter developer account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter 开发者账号
- en: Tweepy
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweepy
- en: PyTorch
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyTorch
- en: OpenCV
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV
- en: Keras
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras
- en: TensorFlow
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow
- en: IBM's Watson
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM 的 Watson
- en: The code and datasets may be found at [https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter04](https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter04).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和数据集可以在 [https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter04](https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter04)
    找到。
- en: Twitter spear phishing bot
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter 钓鱼机器人
- en: In this recipe, we are going to use machine learning to build a Twitter spear
    phishing bot. The bot will utilize artificial intelligence to mimic its targets'
    tweets, hence creating interesting and enticing content for its own tweets. Also,
    the tweets will contain embedded links, resulting in targets clicking these phishing
    links. Of course, we will not be utilizing this bot for malicious purpose, and
    our links will be dummy links. The links themselves will be obfuscated, so a target
    will not be able to tell what is really hidden behind them until after they click.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用机器学习来构建一个 Twitter 钓鱼机器人。该机器人将利用人工智能模拟目标的推文，从而为自己的推文创造有趣且吸引人的内容。此外，这些推文将包含嵌入的链接，导致目标点击这些钓鱼链接。当然，我们不会将此机器人用于恶意目的，我们的链接将是虚拟链接。链接本身将被模糊化，直到目标点击之后才会发现实际隐藏的内容。
- en: Experimentally, it has been shown that this form of attack has a high percentage
    success rate, and by simulating this form of attack, you can test and improve
    the security posture of your client or organization.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结果表明，这种攻击形式具有较高的成功率，通过模拟这种攻击，你可以测试并提高客户或组织的安全防护能力。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing the `tweepy` and `markovify` packages in
    `pip`. The instructions are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的准备工作包括在 `pip` 中安装 `tweepy` 和 `markovify` 包。具体步骤如下：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, you will need to set up a developer account on Twitter. The process is
    relatively simple and account creation is free.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要在 Twitter 上设置一个开发者账号。过程相对简单，且账号创建是免费的。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we demonstrate how to use machine learning to create
    a spear phishing Twitter bot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将展示如何利用机器学习创建一个 Twitter 钓鱼机器人：
- en: Set up a developer account on Twitter.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Twitter 开发者账号。
- en: Create a new app and obtain your consumer API keys, access token, and access
    token secret.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新应用并获取你的消费者 API 密钥、访问令牌和访问令牌密钥。
- en: 'Import the `tweepy` library and fill in your credentials to access the Twitter
    API:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `tweepy` 库并填写你的凭证，以便访问 Twitter API：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We select a user we would like to target or imitate. In this case, I chose
    a prominent figure in technology, active on Twitter:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择一个目标用户或要模仿的人物。在本例中，我选择了一位活跃在 Twitter 上的科技领域知名人物：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Collect the user''s latest `count = 200` tweets:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集用户最近的 `count = 200` 条推文：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Collect all of the user''s Tweets into one large text:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户的所有推文收集成一大段文本：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now proceed to process the text. We define a function that will replace
    any found instance of a URL with a new URL:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们开始处理文本。我们定义一个函数，将找到的任何URL实例替换为新的URL：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a phishing link and insert it into the tweets. In our case, we used
    a URL shortener to obfuscate the fact that the link takes a user to [google.com](http://google.com):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个网络钓鱼链接并将其插入到推文中。在我们的情况下，我们使用了一个URL缩短服务来隐藏链接的目的地，其实只是Google。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Train a Markov model on the processed text and generate tweets:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理文本后训练一个马尔科夫模型并生成推文：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Generate the desired number of tweets that contains the phishing link:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成包含网络钓鱼链接的所需数量的推文：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will see the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '![](assets/3e7aedd3-3037-46ce-b1d1-73ed514502ef.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e7aedd3-3037-46ce-b1d1-73ed514502ef.png)'
- en: 'Publish your tweets and target either the user, followers of the user, or friends
    of the user. For instance, this code obtains the user''s friends:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布你的推特并定位到用户、用户的关注者或用户的朋友。例如，这段代码获取用户的朋友：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output we''ll see is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的输出如下：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In steps 1 and 2, you will want to go onto the Twitter developer web page to
    create your API account, which will be free. To access the Twitter API through
    Python, we use the `tweepy` library (step 3). Our goal is to learn from the tweets
    of a target Twitter user so that our tweets have the same style and topics as
    that user. Such tweets then form likely bait for anyone interested in the same
    topics and style. We chose to imitate Elon Musk's style for our tweets (step 4).
    We proceed to collect the last 200 tweets that Elon has released (steps 5 and
    6). Generally speaking, the more tweets from the user you can obtain, the more
    convincing the model will be. However, it may be important to account for time
    and relevancy—that is, that users are more likely to click on timely and relevant
    tweets than those dealing with aged topics.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1和2中，您需要访问Twitter开发者网页以创建您的API账户，这是免费的。要通过Python访问Twitter API，我们使用`tweepy`库（步骤3）。我们的目标是从目标Twitter用户的推文中学习，以便我们的推文具有相同的风格和主题。这样的推文然后成为任何对相同主题和风格感兴趣的人可能点击的诱饵。我们选择模仿埃隆·马斯克的风格来发布我们的推文（步骤4）。接着我们收集埃隆发布的最后200条推文（步骤5和6）。一般来说，您能够获取的用户推文越多，模型就越有说服力。然而，考虑时间和相关性也很重要，即用户更有可能点击及时和相关的推文，而不是与老旧话题有关的推文。
- en: We define a function to process the text so that all the URLs are replaced with
    the desired URL (step 7) and then apply it to our text (step 8). We used a URL
    shortener to hide the destination of the phishing link, which is just Google.
    There is great room for creativity at this stage of processing the tweets. For
    instance, we may customize the `@` screen names so they are more relevant to our
    target. In steps 9 and 10, we train a Markov model on the tweets we have processed
    and then generate several tweets with the phishing link embedded in them. Finally,
    concerning step 11, keep in mind that other modifications to make the bot more
    effective include picking the optimal time of day, week, month, or other (for
    example, event-related timing) to send the tweet or adding photos with links into
    the tweet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个处理文本的函数，使所有的URL都替换为所需的URL（步骤7），然后将其应用于我们的文本（步骤8）。在处理推文的这个阶段，有很大的创意空间。例如，我们可以自定义`@`屏幕名称，使其与我们的目标更相关。在步骤9和10中，我们对处理后的推文训练了一个马尔科夫模型，然后生成了几条包含网络钓鱼链接的推文。最后，在步骤11中，请记住，使机器人更有效的其他修改包括选择发送推文的最佳时间，例如一天、一周、一个月或其他（例如与事件相关的时机），或在推文中添加带有链接的照片。
- en: Voice impersonation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音模仿
- en: Using the new technology of voice style transfer via neural networks, it is
    becoming easier and easier to convincingly impersonate a target's voice. In this
    section, we show you how to use deep learning to have a recording of a target
    saying whatever you want them to say, for example, to have a target's voice used
    for social engineering purposes or, a more playful example, using Obama's voice
    to sing Beyoncé songs. We selected the architecture in `mazzzystar/randomCNN-voice-transfer`
    that allows for fast results with high quality. In particular, there is no need
    to pre-train the model on a large dataset of recorded audio.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过神经网络的语音风格迁移新技术，现在越来越容易逼真地模仿目标的声音。在本节中，我们将向你展示如何使用深度学习制作一段目标说出你希望他们说的内容的录音，例如，利用目标的声音进行社会工程学攻击，或者一个更有趣的例子，用奥巴马的声音来唱碧昂丝的歌曲。我们选择了`mazzzystar/randomCNN-voice-transfer`中的架构，它可以快速获得高质量的结果。特别地，模型不需要在大量录音数据集上进行预训练。
- en: In the accompanying code for this book, you will find two versions of the voice
    transfer neural network code, one for GPU and one for CPU. We describe here the
    one for CPU, though the one for GPU is very similar.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的附带代码中，你将找到两个版本的语音转移神经网络代码，一个是GPU版本，一个是CPU版本。我们在这里描述的是CPU版本，虽然GPU版本非常相似。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing `pytorch` and `librosa`
    in `pip`. The instructions are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本方案的准备工作包括在`pip`中安装`pytorch`和`librosa`。安装步骤如下：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Also, place two files in the `voice_impersonation_input` folder. One file will
    be an audio recording of the message you would like to vocalize and another file
    will be the voice in which you would like to vocalize that message.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，将两个文件放入`voice_impersonation_input`文件夹中。一个文件是你希望目标表达的信息的音频录音，另一个文件是你希望目标使用的语音。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we provide a recipe for transferring the voice of one
    speaker to the recording of another speaker. The code is structured in three parts:
    Voice Impersonation for CPU (main), a model, and utilities. We will discuss how
    to run the main and explain what it is doing. Whenever a reference occurs to the
    other parts of the code, we will provide a high-level explanation of what the
    referenced method does, but leave the details out for the sake of brevity.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们提供了一个将一个说话者的声音转移到另一个说话者录音的方案。代码结构分为三部分：CPU上的语音模仿（主程序）、模型和工具。我们将讨论如何运行主程序，并解释它的功能。每当涉及到代码的其他部分时，我们将提供一个高层次的解释，但为了简洁起见，省略细节。
- en: 'The following code can be found in `Voice Impersonation.ipynb`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在`Voice Impersonation.ipynb`中找到：
- en: 'Import PyTorch utilities, the neural network model, and `math` for some basic
    computations:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入PyTorch工具、神经网络模型和用于一些基本计算的`math`模块：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Specify the voice we wish to use in `style_file` and the audio we wish to utter
    in that voice in `content_file`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定我们希望在`style_file`中使用的声音和我们希望用该声音表达的音频`content_file`：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We extract the spectra of the content and style files and convert these into
    PyTorch tensors:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提取内容和风格文件的频谱，并将其转换为PyTorch张量：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We instantiate a Random CNN model and set it to `eval` mode:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实例化一个随机CNN模型并将其设置为`eval`模式：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We prepare the tensors for the upcoming training of the neural network and
    select the Adam optimizer and a learning rate:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为即将进行的神经网络训练准备张量，并选择Adam优化器和学习率：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We specify `style` and `content` parameters and how long we wish to train our
    model:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定`style`和`content`参数，以及我们希望训练模型的时间长度：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We train our model:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们训练我们的模型：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We print the ongoing progress of the training, specify the output file''s name,
    and, finally, convert the neural network''s output spectrum into an audio file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印训练过程中的进度，指定输出文件的名称，最后将神经网络的输出谱转换成音频文件：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The final result of our computation can be seen in the audio file with the name
    `Eleanor_saying_there_was_a_change_now.wav`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算的最终结果可以在名为`Eleanor_saying_there_was_a_change_now.wav`的音频文件中看到。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We begin by importing PyTorch, the neural network model, and `math` for some
    basic computations (step 1). More interestingly, in step 2, we specify content
    and style audio. In the content file, you can utter whatever phrase you wish,
    for example, *you can't do cybersecurity without machine learning*. Then, in the
    style file, you select a recording of someone's voice, for example, a recording
    of a famous individual such as Elon Musk. The final result of the voice impersonation
    is that Elon Musk says that *you can't do cybersecurity without machine learning*.
    Steps 3, 4, and 5 involve some legwork to prepare our data to be fed into our
    model and then instantiate a Random CNN model and its optimizer. The main feature
    of the model is that it uses a 2D convolutional layer rather than a 1D layer for
    the audio spectrogram and it computes `grams` over the time axis. Setting the
    model to evaluation mode (to be contrasted with training mode) affects the behavior
    of certain layers, such as dropout and batch norm, that are used differently in
    training versus testing. In the next step (step 6), we define the `style` and
    `content` parameters, which assign relative weights to style and content. In particular,
    these determine how strongly the final audio will inherit the style versus content
    from the respective files. We are now ready to train our model, which we do in
    step 7 by performing forward and back propagation. We monitor the progress of
    the training (step 8), and then finally output an audio file to disk that pronounces
    the content file using the style of the style file. You may find this file in
    the repository for this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 PyTorch 神经网络模型，并引入`math`库进行一些基本计算（步骤 1）。更有趣的是，在步骤 2 中，我们指定了内容和风格音频。在内容文件中，你可以说出任何你希望表达的短语，例如，*没有机器学习，你做不了网络安全*。然后，在风格文件中，你选择一个人的声音录音，例如，名人如埃隆·马斯克的录音。最终的语音模仿结果是，埃隆·马斯克说了*没有机器学习，你做不了网络安全*。步骤
    3、4 和 5 涉及一些准备工作，将数据准备好并输入我们的模型，然后实例化一个随机 CNN 模型及其优化器。该模型的主要特点是它使用 2D 卷积层而不是 1D
    层来处理音频频谱图，并且在时间轴上计算`grams`。将模型设置为评估模式（与训练模式对比）会影响某些层的行为，比如 dropout 和 batch norm，它们在训练和测试时的使用方式不同。在接下来的步骤（步骤
    6）中，我们定义了`style`和`content`参数，这些参数为风格和内容赋予相对的权重。特别是，它们决定了最终音频在多大程度上继承了来自相应文件的风格和内容。现在我们准备好训练模型，在步骤
    7 中通过进行前向传播和反向传播来训练它。我们在步骤 8 中监控训练进度，最后输出一个音频文件到磁盘，该文件使用风格文件中的风格发音内容文件中的内容。你可以在本书的代码库中找到这个文件。
- en: Speech recognition for OSINT
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向 OSINT 的语音识别
- en: The story goes that a pen tester was performing intelligence gathering on the
    at-the-time director of the FBI, James Comey. By listening to footage from Comey,
    the pen tester noted that Comey mentioned having several social media accounts,
    including a Twitter account. However, at the time, no account of his was known.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 故事是这样的，渗透测试员当时正在对 FBI 时任局长詹姆斯·科米进行情报收集。通过听科米的录音，渗透测试员注意到科米提到自己有几个社交媒体账户，包括一个推特账户。然而，当时没有人知道他的任何账户。
- en: Through thorough investigation, the pen tester eventually discovered Comey's
    secret Twitter account, screen name Reinhold Niebuhr. The goal of this recipe
    is to help the pen tester to automate and expedite the sifting through large amounts
    of audio/video footage about a target in the search of keywords. Specifically,
    we use machine learning to convert speech into text, collect this text, and then
    search for keywords of interest.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过彻底的调查，渗透测试员最终发现了科米的秘密推特账户，屏幕名称为 Reinhold Niebuhr。这个方案的目标是帮助渗透测试员自动化并加速筛选大量关于目标的音频/视频镜头，以寻找关键词。具体来说，我们使用机器学习将语音转换为文本，收集这些文本，然后搜索感兴趣的关键词。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing the `speechrecognition`
    package in `pip`. The instructions are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本方案的准备工作包括在 `pip` 中安装 `speechrecognition` 包。安装说明如下：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In addition, collect a number of audio files whose speech you would like to
    recognize.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，收集一些你想要识别的语音音频文件。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we show how to use the speech recognition library to
    convert audio recordings of speech into text and then search through these texts
    for desired keywords:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们展示了如何使用语音识别库将语音录音转换为文本，然后在这些文本中搜索所需的关键词：
- en: 'Import the speech recognition library and select a list of audio files whose
    speech we wish to convert into text. Also, create a list of keywords you would
    like to automatically detect in these audio files:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入语音识别库，并选择一系列我们希望转换为文本的音频文件。同时，创建一个关键词列表，您希望在这些音频文件中自动检测到这些关键词：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define a function that uses the Google speech recognition API to convert the
    audio file into text:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个使用Google语音识别API将音频文件转换为文本的函数：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Convert the audio files into text and create a dictionary to remember which
    audio file the text came from:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将音频文件转换为文本，并创建一个字典来记录文本来自哪个音频文件：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The corpus output is as the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 语料库输出如下所示：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Search through the corpus of text for the keywords and print out which audio
    files had those keywords:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在语料库中搜索关键词，并打印出包含这些关键词的音频文件：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our run has detected the keyword `Twitter`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行已检测到关键词`Twitter`：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We begin by importing the speech recognition library and selecting a list of
    audio files whose speech we wish to convert into text. Also, we create a list
    of keywords we would like to automatically detect in these audio files (step 1).
    The approach taken, of detecting the utterance of these keywords, can be made
    more robust through stemming or lemmatization, which effectively accounts for
    variants of the keywords that have the same meaning. For example, Twitter, Twitted,
    and Tweet would all be detected if this approach is properly implemented. In step
    2, we specify that we will use Google's Speech Recognition API to transcribe the
    audio. Other speech recognition services, such as pocketsphinx, are available
    as well. We are now ready to transcribe our audio files, which we do in step 3\.
    Now we have our audio in text format, and it's smooth sailing from here. Simply
    search for the keywords of interest (step 4). An additional optimization that
    may be fruitful when the corpus and text grow larger is to print the sentence
    where the keyword was found, to make it easier to understand the context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入语音识别库，并选择一系列我们希望转换为文本的音频文件。同时，我们创建一个我们希望在这些音频文件中自动检测的关键词列表（步骤1）。检测这些关键词的发音可以通过词干提取或词形还原技术使其更加稳健，这有效地涵盖了具有相同含义的关键词变体。例如，如果该方法得到适当实施，Twitter、Twitted和Tweet都将被检测到。在步骤2中，我们指定将使用Google的语音识别API来转录音频。也可以使用其他语音识别服务，例如pocketsphinx。现在我们已经准备好转录我们的音频文件，这将在步骤3中完成。现在我们已经将音频转换为文本，接下来的操作就顺利多了。只需搜索感兴趣的关键词（步骤4）。当语料库和文本规模变大时，另一个可能有用的优化是打印出找到关键词的句子，以便更容易理解上下文。
- en: Facial recognition
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部识别
- en: A facial recognition system is a technology for identifying or verifying a person
    in images or videos. When performing OSINT on a target or potential targets, a
    facial recognition system can be invaluable. In this recipe, you will learn how
    to use the well-developed `face_recognition` Python library.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 面部识别系统是一种用于识别或验证图像或视频中的人脸的技术。在对目标或潜在目标进行OSINT时，面部识别系统可能是无价的。在这个教程中，您将学习如何使用成熟的`face_recognition`
    Python库。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Preparation for this recipe consists of installing the `face_recognition` and
    OpenCV packages in `pip`. The instructions are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的准备工作包括通过`pip`安装`face_recognition`和OpenCV库。安装说明如下：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, you will want a portrait of an individual and a collection of images
    through which you would like to search for that individual.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要一张个体的肖像以及一系列您希望在其中搜索该个体的图片。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'In the following steps, you will train `face_recognition` to find and label
    a given individual in a series of images:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，您将训练`face_recognition`库，在一系列图片中找到并标记给定的个体：
- en: 'Begin by importing the `face_recognition` library:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时导入`face_recognition`库：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Start by loading in a labeled portrait of the individual on which you will
    perform OSINT:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先加载该个体的标记肖像，并对其进行OSINT分析：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The face of the individual must be clearly visible:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该个体的面部必须清晰可见：
- en: '![](assets/ab1cb3f4-c88f-407d-854f-84fdda2fe552.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab1cb3f4-c88f-407d-854f-84fdda2fe552.png)'
- en: 'Next, load in an `unknown` image, in which you would like to automatically
    detect the face of the individual:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，加载一张`unknown`图片，您希望在其中自动检测该个体的面部：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The individual whose face is being searched for is present in this screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该截图中展示的是正在被搜索的个体的面部：
- en: '![](assets/6dc5fd33-e04a-4c6a-b76b-342c63c0e8c3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6dc5fd33-e04a-4c6a-b76b-342c63c0e8c3.png)'
- en: 'Encode the face of the individual:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码该个体的面部：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Encode the faces of all individuals in the unknown image:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码未知图像中所有个人的面部：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Perform a search for the face of the individual:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找个人脸部的图像：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Load the locations of all faces in the unknown image and save the location
    of the match into a variable:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载未知图像中所有脸部的位置，并将匹配位置保存到一个变量中：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Read in the unknown image into `cv2`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将未知图像读入 `cv2`：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Draw a rectangle on the unknown image for where the matching face is:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在未知图像上画一个矩形，用于匹配脸部位置：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Label the rectangle:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给矩形标上标签：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Display the image with the labeled rectangle:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示带有标记矩形的图像：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following screenshot shows us that the output has been successful:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示我们已经成功地输出了结果：
- en: '![](assets/a50ba5dd-c7f1-4134-bdb9-bf958eea114b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a50ba5dd-c7f1-4134-bdb9-bf958eea114b.png)'
- en: It is straightforward to automate this searching and labeling process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化这个搜索和标注过程是很简单的。
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运作…
- en: Begin simply by importing the facial recognition library (step 1). In the next
    step, we load the image of the target we wish to locate in a collection of images
    in our pen test. Next, prepare an example image that we would like to scan for
    the presence of the target's face (step 3). Encode all found faces in images (steps
    4 and 5) and then search for the face of the target (step 6). For convenience,
    we print out the results of seeking a match with the target's face. In steps 7-10,
    we wish to demonstrate that we have found a match. To that end, we load the image
    we have scanned. We then draw a rectangle and a label where our classifier has
    detected the target's face. Looking at the result in step 11, we see a massive
    success. We made a successful detection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入人脸识别库（步骤 1）。在接下来的步骤中，我们加载目标图像，该图像位于我们的渗透测试图像集合中。接下来，准备一个我们想要扫描其目标脸部存在的示例图像（步骤
    3）。对所有发现的脸部进行编码（步骤 4 和 5），然后搜索目标脸部（步骤 6）。为了方便起见，我们打印出寻找与目标脸部匹配的结果。在步骤 7-10 中，我们希望展示我们已经找到了匹配。为此，我们加载了我们扫描的图像。然后，我们在分类器检测到目标脸部的地方画一个矩形和一个标签。查看第
    11 步的结果，我们看到了巨大的成功。我们成功地进行了检测。
- en: In passing, note that the technology behind the `face_recognition` tool is deep
    learning, and, as a corollary, a search process for faces can be expedited using
    a GPU.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`face_recognition` 工具背后的技术是深度学习，作为推论，使用 GPU 可以加速人脸搜索过程。
- en: Deepfake
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deepfake
- en: '**Deepfake** is the technique of using a neural network to take a video or
    image, superimpose some content onto it, and make the result look realistic. For
    example, the technique can take a video of Alice saying she supports a movement,
    and then, replacing Alice with Bob, create a realistic-looking video of Bob saying
    he supports the movement. Clearly, this technique has deep implications on the
    trust we can place on videos and images, while also providing a useful tool for
    social engineers.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deepfake** 是利用神经网络对视频或图像进行处理，将一些内容叠加到其中，并使结果看起来逼真的技术。例如，这种技术可以获取艾丽斯说她支持某一运动的视频，并用鲍勃替换艾丽斯，创造出一个看起来逼真的鲍勃支持该运动的视频。显然，这种技术对我们对视频和图像的信任有深远的影响，同时也为社会工程师提供了一个有用的工具。'
- en: In this recipe, we use a Deepfake variant to take the image of the face of one
    target and realistically superimpose it onto the image of another target's face.
    The recipe is a refactored and simplified version of the code in the GitHub repository,
    `wuhuikai/FaceSwap`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了 Deepfake 变种，将一个目标的面部图像逼真地叠加到另一个目标面部图像上。该配方是 GitHub 仓库 `wuhuikai/FaceSwap`
    中代码的重构和简化版本。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing `opencv`, `dlib`, and `scipy`
    in `pip`. The instructions are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的准备工作包括在 `pip` 中安装 `opencv`、`dlib` 和 `scipy`。操作指南如下：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Also, you will want two images; one is a portrait of an individual and one is
    an image containing a face. The former face will be transferred onto the latter.
    A sample has been provided for you in the `deepfake_input` folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将需要两张图像；一张是个人的肖像，另一张是包含脸部的图像。前者的面部将被转移到后者上。在 `deepfake_input` 文件夹中为您提供了一个样本。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the following steps, we provide a recipe for replacing the face of one individual
    in an image with that of another. The code is structured in five parts: `Deepfake.ipynb`
    (main), the `deepfake_config` configuration file, `deepfake_face_detection`, `deepfake_face_points_detection`,
    and `deepfake_face_swap`. Also, a models folder is included.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们提供了一个将图像中一个人的面部替换为另一个人的面部的配方。代码分为五个部分：`Deepfake.ipynb`（主要部分），`deepfake_config`配置文件，`deepfake_face_detection`，`deepfake_face_points_detection`，以及`deepfake_face_swap`。另外，还包括一个模型文件夹。
- en: 'The following code can be found in `Deepfake.ipynb`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在`Deepfake.ipynb`中找到：
- en: 'Import `opencv` for image operations and the methods needed to swap faces from
    the associated code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`opencv`以进行图像操作，并导入关联代码中需要的面部交换方法：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Specify the image containing the face we wish to use in `content_image` and
    the image where we want the face to be transferred to in `target_image`. Finally,
    specify where you''d like the result created:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`content_image`中指定包含我们希望使用的面部的图像，并在`target_image`中指定我们希望将面部转移到的图像。最后，指定您希望在哪里创建结果：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the running example, the source image is a picture of the author''s face:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例中，源图像是作者的面部照片：
- en: '![](assets/496dcb42-9f33-42d4-a495-d0a6af15168c.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/496dcb42-9f33-42d4-a495-d0a6af15168c.png)'
- en: 'The destination image is a picture of a gymnast mid-performance:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目标图像是一个体操运动员在表演中的照片：
- en: '![](assets/2bb0fc84-9761-4944-89fe-61015978deb6.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2bb0fc84-9761-4944-89fe-61015978deb6.png)'
- en: 'Read in the images into `opencv` and then extract the source and destination
    faces:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像读入`opencv`，然后提取源面部和目标面部：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compute a transformed version of the source face:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算源面部的变换版本：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Draw the transformed face into the destination image and write the file to
    disk:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变换后的面部绘制到目标图像中，并将文件写入磁盘：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The final result of the `deepfake` operation in this example is an image with
    the gymnast''s body and author''s face:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中`deepfake`操作的最终结果是一个体操运动员的身体和作者的面部：
- en: '![](assets/cb7b4948-d6ec-482f-a1fa-4f3a56f0558e.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb7b4948-d6ec-482f-a1fa-4f3a56f0558e.png)'
- en: By applying the method frame by frame, it can be extended to videos.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐帧应用该方法，它可以扩展到视频中。
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Begin, as usual, by importing the appropriate libraries (step 1). Specify, in
    step 2, the style and content images. Here, the content is the target image while
    the style is the face to draw in. In step 3, note that if there are several faces
    in the image, a screen will be presented to you asking which of the faces you
    would like to use. The next step is a computation to determine how to draw the
    superimposed face (step 4). Having completed this step, we can now draw out and
    display the `deepfake` superimposed face in step 5\. Evidently, this implementation
    has room for improvement but does an OK job.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，首先导入适当的库（第1步）。在第2步中，指定样式图像和内容图像。这里，内容是目标图像，而样式是需要绘制的面部。在第3步中，如果图像中有多个面部，将会显示一个屏幕，询问您希望使用哪一张面部。下一步是进行计算，以确定如何绘制叠加的面部（第4步）。完成这一步后，我们可以在第5步绘制并显示`deepfake`叠加的面部。显然，这种实现还有改进的空间，但也做得还不错。
- en: Deepfake recognition
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度伪造识别
- en: With the advent of deepfake and similar image forgery technology, it is becoming
    more and more difficult to differentiate between forgery and real media. Fortunately,
    just as neural networks can compose fake media, they can also detect it. In this
    recipe, we will utilize a deep neural network to detect fake images. The recipe
    utilizes the MesoNet architecture, found in the GitHub repository, `DariusAf/MesoNet`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着深度伪造和类似图像伪造技术的出现，越来越难以区分伪造媒体和真实媒体。幸运的是，正如神经网络可以合成伪造的媒体一样，它们也可以检测伪造的媒体。在这个配方中，我们将利用深度神经网络来检测伪造图像。这个配方使用了`MesoNet`架构，该架构可以在GitHub仓库`DariusAf/MesoNet`中找到。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Preparation for this recipe consists of installing `keras`, `tensorflow`, and
    `pillow` in `pip`. The instructions are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的准备工作包括在`pip`中安装`keras`、`tensorflow`和`pillow`。安装说明如下：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In addition, a collection of fake and real images has been provided for you
    in the `mesonet_test_images` folder, to which you may add additional images.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还为您提供了一组伪造和真实的图像，保存在`mesonet_test_images`文件夹中，您可以在其中添加更多图像。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following steps, we provide a recipe for detecting when an image is
    produced by deepfake. The code is structured in four parts: Deepfake `Recognition.ipynb`
    (main), the `mesonet_classifiers.py` file defining the MesoNet classifier, the `mesonet_weights`
    folder holding the trained weights, and the `mesonet_test_images` folder containing
    our test images.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们提供了一个检测图像是否由深度伪造技术生成的操作步骤。代码分为四个部分：Deepfake `Recognition.ipynb`（主文件），定义
    MesoNet 分类器的 `mesonet_classifiers.py` 文件，包含训练权重的 `mesonet_weights` 文件夹，以及包含测试图像的
    `mesonet_test_images` 文件夹。
- en: 'The following code can be found in Deepfake `Recognition.ipynb`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在 Deepfake `Recognition.ipynb` 中找到：
- en: 'Import the MesoNet neural network and the image data generator from `keras`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `keras` 导入 MesoNet 神经网络和图像数据生成器：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Instantiate MesoNet and load its weights:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化 MesoNet 并加载其权重：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create an image data generator to read in images from a directory and specify
    the path where the unknown images are stored:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图像数据生成器来读取目录中的图像，并指定存放未知图像的路径：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define a dictionary to translate numerical labels to the text labels, `"real"`
    and `"fake"`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个字典，将数字标签转换为文本标签，`"real"` 和 `"fake"`：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In our example, we place three images in the folder, one real and two fake:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将三张图片放入文件夹中，其中一张是真实的，另外两张是伪造的：
- en: '![](assets/3d2752b4-ff56-4583-b0a1-5d89d389546f.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d2752b4-ff56-4583-b0a1-5d89d389546f.png)'
- en: Can you tell which ones are which?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你能分辨出哪些是真，哪些是假吗？
- en: 'Running MesoNet reveals the following output:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 MesoNet 会显示以下输出：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is the output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As for most recipes, we begin by importing the necessary libraries. We then
    load up a MesoNet model in step 2, that is, load up its structure and pre-trained
    weights. For clarity, the architecture may be found in the `MesoNet_classifiers`
    file and is given by the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数操作步骤一样，我们首先导入必要的库。然后在步骤 2 中加载 MesoNet 模型，即加载其结构和预训练权重。为了清晰起见，架构可以在 `MesoNet_classifiers`
    文件中找到，结构如下：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In step 3, we define and use an `ImageDataGenerator`, a convenient `keras` object
    that allows us to perform image processing in one place—in the case at hand, to
    rescale and normalize the numerical values of pixels. It is hard to tell what
    the labels `0` and `1` represent. For that reason, for readability purposes, we
    define a dictionary to translate 0s and 1s into the words, `real` and `fake` (step
    4). Finally, in step 5, we see that the MesoNet model was able to correctly predict
    the labels of the test images.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们定义并使用了一个 `ImageDataGenerator`，这是一个方便的 `keras` 对象，允许我们在一个地方执行图像处理——在此例中，用于重新缩放和归一化像素的数值。很难判断标签
    `0` 和 `1` 代表什么。因此，为了便于阅读，我们定义了一个字典将 0 和 1 转换为单词 `real` 和 `fake`（步骤 4）。最后，在步骤 5
    中，我们看到 MesoNet 模型能够正确预测测试图像的标签。
- en: Lie detection using machine learning
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习进行谎言检测
- en: When gathering intelligence for social engineering purposes, it is crucial to
    be able to tell when an individual is telling the truth and when they are lying.
    To this end, machine learning can come to our aid. By analyzing a video for microexpressions
    and vocal quality, a machine learning system can help to identify untruthful actors.
    In this recipe, we will be running through a lie detection cycle, using a slightly
    modified version of Lie To Me, a lie detection system that uses facial and vocal
    recognition.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行社会工程学情报收集时，能够判断一个人是在说真话还是在说谎是至关重要的。为此，机器学习可以为我们提供帮助。通过分析视频中的微表情和声音质量，机器学习系统可以帮助识别不诚实的行为者。在本教程中，我们将运行一个谎言检测流程，使用稍作修改的《Lie
    To Me》——一个结合面部和声音识别的谎言检测系统。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Preparation for this recipe consists of installing several packages in `pip`.
    The list of packages can be found in the `requirements.txt` file. To install all
    of these at once, run the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 准备此操作步骤需要在 `pip` 中安装多个包。包的列表可以在 `requirements.txt` 文件中找到。要一次性安装所有这些包，可以运行以下命令：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You will need one video file with audio to analyze.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个带有音频的视频文件进行分析。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we provide a recipe for analyzing a video for lying
    behavior:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们提供了一个分析视频中谎言行为的操作步骤：
- en: 'Run the Lie To Me application:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Lie To Me 应用：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open the portal for Lie To Me by going to the IP address specified, for example,
    `127.0.0.1:5000`, by opening a web browser and typing this address.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Lie To Me 门户，方法是访问指定的 IP 地址，例如 `127.0.0.1:5000`，在浏览器中输入该地址。
- en: 'Click on **UPLOAD** and select a video you would like to analyze:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **上传** 并选择一个你想分析的视频：
- en: '![](assets/11288da4-2f84-4c91-95d7-ff9c6755378a.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11288da4-2f84-4c91-95d7-ff9c6755378a.png)'
- en: Once the analysis is complete, you will notice the following.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析完成后，您将注意到以下内容。
- en: 'The following screenshot shows the variation happening in the **Blink Analysis**
    graph:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**眨眼分析**图表中的变化：
- en: '![](assets/f8a14ee8-ae4a-41f8-9d12-6a382936c6d3.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8a14ee8-ae4a-41f8-9d12-6a382936c6d3.png)'
- en: 'The following screenshot shows the variation happening in the **Micro Expression
    Analysis** graph:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**微表情分析**图表中的变化：
- en: '![](assets/37cbad82-7c4f-49c9-9244-4833f8a0d7be.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37cbad82-7c4f-49c9-9244-4833f8a0d7be.png)'
- en: 'The following screenshot shows the variation happening in the **Voice Energy
    Analysis** graph:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**语音能量分析**图表中的变化：
- en: '![](assets/3cbcdef4-2f40-424e-a442-d6ac9641429b.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3cbcdef4-2f40-424e-a442-d6ac9641429b.png)'
- en: 'The following screenshot shows the variation happening in the **Voice Pitch
    Analysis** graph:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**语音音高分析**图表中的变化：
- en: '![](assets/c1a025b9-ed03-47e4-9627-24da5b18cde5.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1a025b9-ed03-47e4-9627-24da5b18cde5.png)'
- en: 'The following screenshot shows the variation happening in the **Voice Pitch
    Contour Analysis** graph:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**语音音高轮廓分析**图表中的变化：
- en: '![](assets/d7763af6-b146-4219-bc7d-117c4858eb58.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d7763af6-b146-4219-bc7d-117c4858eb58.png)'
- en: 'The following screenshot shows the variation happening in the **Vowel Duration
    Analysis** graph:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**元音持续时间分析**图表中的变化：
- en: '![](assets/47bdbdee-d25d-4d57-87ce-590541dc5efd.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47bdbdee-d25d-4d57-87ce-590541dc5efd.png)'
- en: 'Finally, clicking on results shows an analysis of the lies detected in the
    video:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击结果将显示视频中检测到的谎言分析：
- en: '![](assets/12a286af-cc3f-41bf-af79-068412c04c50.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12a286af-cc3f-41bf-af79-068412c04c50.png)'
- en: How it works…
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1, we run the Lie To Me application using Python. We enter the application's
    portal and upload a candidate video (steps 2 and 3). Upon completion of the analysis
    of the video, the Lie To Me application shows several exploratory screens (step
    4). These represent features that may be indicative of lying. Finally, in step
    5, we see a screen that reveals whether the video contained any lying individuals,
    and if so, when and how many times a lie has been spoken.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们使用 Python 运行 "Lie To Me" 应用程序。我们进入应用程序的门户并上传候选视频（步骤 2 和 3）。视频分析完成后，"Lie
    To Me" 应用程序会显示几个探索性屏幕（步骤 4）。这些屏幕代表了可能表明撒谎的特征。最后，在步骤 5 中，我们看到一个屏幕，显示视频中是否包含撒谎的人，如果有，谎言是何时说的，且撒谎次数是多少。
- en: Personality analysis
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个性分析
- en: Knowing a target's personality type and communication style greatly increases
    the potential to influence. For this reason, a personality analysis is a nice
    tool to have in the social engineer's toolbelt. In this recipe, we will utilize
    IBM Watson's Personality Insights API to analyze a target's Tweets to obtain a
    personality profile.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 了解目标的个性类型和沟通风格大大增加了影响力的潜力。因此，个性分析是社会工程师工具箱中的一项有用工具。在本食谱中，我们将利用 IBM Watson 的
    Personality Insights API 来分析目标的推文，从而获取个性报告。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing the IBM Watson package in
    `pip`. The instructions are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的准备工作包括在 `pip` 中安装 IBM Watson 包。具体步骤如下：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In addition, you will want to sign up for a Watson Personality Insights account.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要注册一个 Watson Personality Insights 账户。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we set up an API call to analyze the personality of
    an author of tweets:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们设置一个 API 调用来分析推文作者的个性：
- en: Sign up for a Watson Personality Insights account. It is quick and free.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个 Watson Personality Insights 账户，过程简单且免费。
- en: 'Import the Python library for Watson and record today''s date:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 Watson 的 Python 库并记录今天的日期：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Specify your API key, which you have obtained in step 1, and declare the Personality
    Insights instance:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定您的 API 密钥，该密钥在第 1 步中已获得，并声明 Personality Insights 实例：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Curate a text file, for example, a collection of tweets:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件，例如一组推文：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Call the Personality Insights API on the text file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本文件上调用 Personality Insights API：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, print out the personality profile:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印出个性分析报告：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Start by signing up for a Watson Personality Insights account. There are different
    tiers for the service, with different limits on API call rates and different prices,
    but the lowest tier is easy to set up, free, and sufficient enough for this recipe.
    We save today's date into a variable and import the IBM Watson library (step 2).
    By specifying the latest date, we are ensuring that we will be employing the latest
    version of Watson. In the next step, we instantiate IBM Watson personality insights
    using our API key.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注册 Watson 人格洞察账户。该服务有不同的层次，对 API 调用速率有不同的限制和不同的价格，但最低层次易于设置，免费，并且足够用于此方法。我们将今天的日期保存到一个变量中，并导入
    IBM Watson 库（第 2 步）。通过指定最新日期，我们确保将使用最新版本的 Watson。在下一步中，我们使用我们的 API 密钥实例化 IBM Watson
    人格洞察。
- en: For step 4, we must collate a text dataset produced by the target. It may be
    helpful to utilize the recipe from the Twitter spear phishing bot to gather a
    user's Tweets. In step 5, we run the personality insights application on our text
    set, consisting of Elon Musk's recent tweets. We elected to display the personality
    profile as a JSON. It is also possible to display in other formats, such as CSV,
    and details may be found in the personality insights' API documentation. Finally,
    in step 6, we print a small snippet from the personality profile. As you can see,
    it even provides actionable insights, such as how likely the target is to agree
    to volunteer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，我们必须整理目标生成的文本数据集。利用 Twitter 鱼叉式网络钓鱼机器人的方法收集用户的推文可能会有所帮助。在第 5 步中，我们对我们的文本集运行人格洞察应用程序，其中包括埃隆·马斯克最近的推文。我们选择将人格概况显示为
    JSON。也可以显示为其他格式，如 CSV，详细信息可以在人格洞察的 API 文档中找到。最后，在第 6 步中，我们打印人格概况的一个小片段。正如您所看到的，它甚至提供可操作的见解，比如目标愿意自愿参与的可能性有多大。
- en: Social Mapper
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Social Mapper
- en: '**Social Mapper** is an OSINT tool that allows you to correlate the multitude
    of social media profiles of a target using facial recognition. It automatically
    searches popular social media sites for the target''s name and pictures to effortlessly
    find the user''s social media profiles and then outputs the results into a report
    that you can use to take your investigations further.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**Social Mapper** 是一款 OSINT 工具，可以利用面部识别技术相关联目标的众多社交媒体资料。它会自动在流行的社交媒体网站上搜索目标的姓名和照片，轻松地找到用户的社交媒体资料，然后将结果输出到报告中，供您进一步调查使用。'
- en: The largest benefit of Social Mapper is that by combining name search with image
    recognition, as opposed to just name search, it can eliminate false positives,
    saving the social engineer valuable time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Social Mapper 的最大优势在于通过将姓名搜索与图像识别相结合，而不仅仅是姓名搜索，可以消除误报，节省社交工程师宝贵的时间。
- en: Social Mapper currently supports LinkedIn, Facebook, Twitter, Google Plus, Instagram,
    VKontakte, Weibo, and Douban.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Social Mapper 目前支持 LinkedIn、Facebook、Twitter、Google Plus、Instagram、VKontakte、微博和豆瓣。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, it is recommended that you prepare a Python 2.7 environment.
    Social Mapper has been designed to be used on Python 2.7 and may not work with
    other Python environments. The prerequisites for installation are delineated in
    [https://github.com/Greenwolf/social_mapper](https://github.com/Greenwolf/social_mapper).
    Also, you will want to use a Mac or Linux machine for this recipe.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此方法，建议您准备一个 Python 2.7 环境。Social Mapper 已经设计用于 Python 2.7，并且可能无法在其他 Python
    环境中运行。安装的先决条件在 [https://github.com/Greenwolf/social_mapper](https://github.com/Greenwolf/social_mapper)
    中有详细说明。此外，您将需要在 Mac 或 Linux 机器上使用此方法。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we provide a recipe for using Social Mapper to correlate
    the social media accounts of an individual:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们提供了一个使用 Social Mapper 相关联个人社交媒体账户的方法：
- en: Following the instructions on the GitHub page at [https://github.com/Greenwolf/social_mapper](https://github.com/Greenwolf/social_mapper),
    install Social Mapper and its prerequisites.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照 GitHub 页面上的说明在 [https://github.com/Greenwolf/social_mapper](https://github.com/Greenwolf/social_mapper)
    上安装 Social Mapper 及其先决条件。
- en: 'Place an image of the face of your target into `Input, Examples/imagefolder/`
    with the name of the file and the full name of the target:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您目标的面部图像放入 `Input, Examples/imagefolder/` 中，文件名和目标的全名一致：
- en: '![](assets/886752a2-59ff-46f1-bd42-96828f5dfa22.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/886752a2-59ff-46f1-bd42-96828f5dfa22.png)'
- en: Create throwaway accounts for the social media websites you wish to search your
    target on. For example, create throwaway Facebook, LinkedIn, and Twitter accounts.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您希望在其中搜索目标的社交媒体网站创建一次性账户。例如，创建一次性 Facebook、LinkedIn 和 Twitter 账户。
- en: 'Open the `social_mapper.py` file and fill in your throwaway accounts credentials.
    For instance, you may only be interested in Twitter:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`social_mapper.py`文件，并填写你的临时账号凭证。例如，你可能只对Twitter感兴趣：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In Terminal, run the command to search for the target''s social media profiles:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行命令来搜索目标的社交媒体资料：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Examine the output in the `social_mapper/results-social-mapper.html` file:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`social_mapper/results-social-mapper.html`文件中检查输出：
- en: '![](assets/d22a0574-be38-4681-b197-c5c9a9e765db.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d22a0574-be38-4681-b197-c5c9a9e765db.png)'
- en: With each target individual, an additional row is added having that individual's
    social network data.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个目标个体，会增加一行，包含该个体的社交网络数据。
- en: How it works…
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Start by preparing Social Mapper in your environment (step 1). Place an image
    of your target in the inputs directory (step 2). The image must be named after
    the target's full name; otherwise, the application will not be able to find the
    target's accounts. Next, in step 3, create throwaway accounts for the social media
    websites you wish to search your target on and fill these into the appropriate
    place in `social_mapper.py` (step 4). Note that the more different accounts you
    have, the more data you can gather on the target via Social Mapper. You are ready
    now to perform the search on the target. In Terminal, run the command to search
    for the target's social media profiles (step 5). There are many variations on
    the arguments and options you may wish to use. For instance, we have specified
    Twitter using the `-tw` argument. However, you may wish to add in additional social
    media sites, such as LinkedIn (`-li`) or Instagram (`-ig`). Finally, in step 6,
    observe that Social Mapper was able to find Bill Gates's Twitter account.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的环境中准备Social Mapper（步骤1）。将目标的图片放置在输入目录（步骤2）。图片必须以目标的全名命名，否则应用程序无法找到目标的账户。接下来，在步骤3中，为你希望在其上搜索目标的社交媒体网站创建临时账户，并将这些账户信息填入`social_mapper.py`中的相应位置（步骤4）。注意，你拥有的账户越多，通过Social
    Mapper能收集到的数据就越多。现在，你可以开始对目标进行搜索。在终端中运行命令来搜索目标的社交媒体资料（步骤5）。你可以根据需要使用许多不同的参数和选项。例如，我们使用`-tw`参数指定了Twitter。然而，你也可以选择添加其他社交媒体网站，如LinkedIn（`-li`）或Instagram（`-ig`）。最后，在步骤6中，你会看到Social
    Mapper成功找到了比尔·盖茨的Twitter账户。
- en: Fake review generator
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假评论生成器
- en: An important part of social engineering is impersonation. A social engineer
    may want to pretend to represent a company or business that doesn't currently
    exist. By creating a profile and populating it with convincing reviews, the social
    engineer can add credibility to the fake business. In this recipe, we show how
    to train an RNN so that it can generate new reviews, similar to the ones in the
    training dataset.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 社会工程学的重要部分是冒充。社会工程师可能希望假装代表一家目前不存在的公司或商业。通过创建一个个人资料并用可信的评论填充它，社会工程师可以为虚假的商业增加可信度。在本方案中，我们展示了如何训练一个RNN，使其能够生成新的评论，类似于训练数据集中的评论。
- en: Training a fake review generator
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练一个假评论生成器
- en: Our first step is to train the model. Later, we will utilize it to produce new
    reviews.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是训练模型。之后，我们将利用它来生成新的评论。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Preparation for this recipe consists of installing `keras` and `tensorflow`
    in `pip`. The instructions are as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本方案的准备工作包括在`pip`中安装`keras`和`tensorflow`。安装步骤如下：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps, we provide a recipe for training a Recurrent Neural
    Network (RNN) using a corpus of reviews:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们提供了一个使用评论语料库训练循环神经网络（RNN）的方案：
- en: 'Collect the types of reviews you wish to imitate. For more on this, see the
    discussion in the *How it works...* section:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集你希望模仿的评论类型。更多内容请参见*工作原理…*部分的讨论：
- en: '[PRE66]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a dictionary to vectorize the characters of the text:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字典来将文本中的字符向量化：
- en: '[PRE67]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The dictionary might look like so, depending on which characters your corpus
    contains:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的语料库包含的字符，字典可能是这样的：
- en: '[PRE68]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Construct an RNN to learn and predict the sequence of characters:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个RNN来学习并预测字符序列：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Select an optimizer and compile the model:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个优化器并编译模型：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a convenience function to vectorize text:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个便捷的函数来将文本向量化：
- en: '[PRE71]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Vectorize our sample input text and train the model in batches:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量化我们的示例输入文本，并分批训练模型：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Finally, save the model's weights for future use.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存模型的权重以供将来使用。
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works…
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Start by collecting a dataset of reviews you''d like to imitate (step 1). A
    practical example would require a large corpus of reviews. There are many such
    datasets available, such as the Yelp reviews dataset. Proceeding to step 2, we
    create a mapping between characters and numbers. This will allow us to vectorize
    the text. Depending on your application, you may want to use the standard ASCII
    code. However, if you are using only a small number of characters, then this will
    unnecessarily slow down your model. We go on to declare the architecture of an
    RNN to learn and predict the sequence of characters (step 3). We used a relatively
    simple architecture. As will be shown in the next section, it nonetheless provides
    convincing results. The motivated reader is free to experiment with other architectures.
    Next, we declare a (standard) optimizer (step 4), define a function to take in
    text, and then vectorize it so we can feed it into our neural network (step 5).
    In step 5, note the shape of the vectors is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先收集您想模仿的评论数据集（第1步）。一个实际的例子可能需要一个大型的评论语料库。有许多这样的数据集可用，比如 Yelp 评论数据集。继续到第2步，我们创建字符和数字之间的映射。这将允许我们对文本进行向量化。根据您的应用程序，您可能希望使用标准的
    ASCII 码。但是，如果您只使用少量字符，那么这将不必要地减慢您的模型。我们继续声明一个 RNN 的架构来学习和预测字符序列（第3步）。我们使用了一个相对简单的架构。如下一节所示，它仍然提供令人信服的结果。有兴趣的读者可以自由尝试其他架构。接下来，我们声明一个（标准的）优化器（第4步），定义一个函数来接受文本，然后将其向量化，以便我们可以将其馈送到我们的神经网络中（第5步）。在第5步中，注意向量的形状如下：
- en: '**X**: (number of reviews, `maxlen`, number of characters)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X**：（评论数量，`maxlen`，字符数量）'
- en: '**Y**: (number of reviews, number of characters)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y**：（评论数量，字符数量）'
- en: In particular, we set `max_length=40` to simplify computation by indicating
    that we will only be considering the first `40` characters of a review. Having
    made all the needed preparations, we now pass in our text to be vectorized and
    then train our model on it (step 6). Specifically, our `text_to_vector` function
    takes the text and converts it into vectorized sentences, as well as a vectorized
    label, which is the following character. Finally, we save our model's weights
    so that we do not have to retrain it in the future (step 7).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们设置`max_length=40`以简化计算，表示我们只考虑评论的前`40`个字符。做好所有准备工作后，我们现在将我们的文本传入进行向量化，然后在此基础上训练我们的模型（第6步）。具体来说，我们的`text_to_vector`函数接受文本并将其转换为向量化的句子，以及一个向量化的标签，即下一个字符。最后，我们保存我们模型的权重，这样我们将来就不必重新训练它了（第7步）。
- en: Generating fake reviews
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成虚假评论
- en: Having trained a network, our next step is to utilize it to generate new fake
    reviews.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完网络后，我们的下一步是利用它生成新的虚假评论。
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Preparation for this recipe consists of installing `keras` and `tensorflow`
    in `pip`. The instructions are as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作包括在`pip`中安装`keras`和`tensorflow`。具体指令如下：
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we provide a recipe for using a previously trained
    RNN to generate reviews:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们提供了一个使用先前训练过的 RNN 生成评论的方法：
- en: 'We will start by importing `keras`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从导入`keras`开始：
- en: '[PRE75]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a dictionary of indices for the characters or load up the one from the
    previous recipe:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符索引的字典或加载上一个配方中的字典：
- en: '[PRE76]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Read in a seed text and declare `max_length` of a sentence taken in by the
    neural network:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读入一个种子文本并声明神经网络接收的句子的`max_length`：
- en: '[PRE77]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Construct an RNN model and load in your pre-trained weights:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个 RNN 模型并加载您预先训练的权重：
- en: '[PRE78]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Define a function for sampling from a probability vector:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个从概率向量中抽样的函数：
- en: '[PRE79]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Generate random reviews from the initial seed text:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从初始种子文本生成随机评论：
- en: '[PRE80]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here is the review output from a run of the code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码运行的评论输出：
- en: '![](assets/76e836af-49a3-417c-8a78-83248d10534e.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76e836af-49a3-417c-8a78-83248d10534e.png)'
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our initial steps (steps 1, 2, and 4) are operations we have performed during
    the training phase, which we reproduce here to allow the recipe to be self-contained.
    In step 3, we read in a seed text to initialize our RNN. The seed text can be
    any text consisting of the listed characters, as long as it is longer than `max_length`.
    Now, we must be able to create interesting text using our pre-trained, pre loaded,
    and initialized-on-a-seed-text neural network. To this end, we define a convenience
    function to sample the consequent character that the neural network will generate
    (step 5). Sampling from the probability vector ensures that the RNN does not simply
    select the most likely subsequent character, leading to repetitive generated text.
    There are more clever ways to sample, employing a temperature parameter and exponential
    weighing, but this one addresses the basics. Finally, in step 6, we go ahead and
    generate text using our neural network. We specify 1,000 as the number of characters
    to generate. Varying this parameter will alter the number of reviews in the output.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始步骤（步骤1、2和4）是我们在训练阶段执行过的操作，我们在此处重新执行这些操作，以便让食谱保持自包含。在步骤3中，我们读取种子文本以初始化我们的RNN。种子文本可以是任何包含已列出字符的文本，只要它的长度超过`max_length`。现在，我们必须能够使用我们预训练、预加载并基于种子文本初始化的神经网络生成有趣的文本。为此，我们定义了一个方便的函数来采样神经网络将生成的后续字符（步骤5）。从概率向量中进行采样可以确保RNN不会仅选择最可能的后续字符，避免生成重复的文本。还有一些更巧妙的采样方法，如使用温度参数和指数加权，但这一方法涵盖了基本原理。最后，在步骤6中，我们开始使用我们的神经网络生成文本。我们指定生成1,000个字符。调整这个参数将改变输出中的评论数量。
- en: Fake news
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假新闻
- en: Fake news is a type of disinformation or propaganda that is spread via traditional
    news media or online social media. Like any disinformation campaign, its effects
    can be devastating. In this recipe, you will load a dataset of real and fake news,
    and utilize ML to determine when a news story is fake.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 假新闻是一种通过传统新闻媒体或在线社交媒体传播的虚假信息或宣传。像任何虚假信息运动一样，它的影响可能是毁灭性的。在本食谱中，您将加载一个真实与假新闻的数据集，并利用机器学习来判断一篇新闻故事是否是假新闻。
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing `pandas` and scikit-learn
    in `pip`. The instructions are as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的准备工作包括在`pip`中安装`pandas`和scikit-learn。具体步骤如下：
- en: '[PRE81]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Also, extract `fake_news_dataset.7z`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，提取`fake_news_dataset.7z`。
- en: How to do it…
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'In the following steps, you will read in the fake news dataset, preprocess
    it, and then train a Random Forest classifier to detect fake news:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，您将读取假新闻数据集，进行预处理，然后训练一个随机森林分类器来检测假新闻：
- en: 'Import `pandas` and read in the CSV file, `fake_news_dataset.csv`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`并读取CSV文件`fake_news_dataset.csv`：
- en: '[PRE82]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Preprocess the dataset by focusing on articles in English and dropping rows
    with missing values:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过聚焦于英文文章并删除缺失值的行来预处理数据集：
- en: '[PRE83]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Define a convenience function to convert categorical features into numerical:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方便的函数，将分类特征转换为数字：
- en: '[PRE84]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Convert the `"fake"` and `"real"` features into numerical:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“`fake`”和“`real`”特征转换为数字：
- en: '[PRE85]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Define a function that will convert all labels into `real` or `fake`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，将所有标签转换为`real`或`fake`：
- en: '[PRE86]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Apply the function to the DataFrame to convert the labels into 0s and 1s:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该函数应用于DataFrame，将标签转换为0和1：
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create a train-test split on the DataFrame:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DataFrame上创建训练-测试分割：
- en: '[PRE88]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Instantiate two Tf-Idf vectorizers, one for the text of the article and one
    for its headline:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化两个Tf-Idf向量化器，一个用于文章的文本，另一个用于其标题：
- en: '[PRE89]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Fit and transform the text and headline data using the Tf-Idf vectorizers:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Tf-Idf向量化器拟合并转换文本和标题数据：
- en: '[PRE90]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Convert the remaining numerical fields of the DataFrame into matrices:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将DataFrame中剩余的数字字段转换为矩阵：
- en: '[PRE91]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Merge all of the matrices into one feature matrix and create a set of labels:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有矩阵合并为一个特征矩阵，并创建一组标签：
- en: '[PRE92]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Instantiate a Random Forest classifier and train it on the training data:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个随机森林分类器，并在训练数据上训练它：
- en: '[PRE93]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Transform the text and headlines of the testing data into numerical form using
    the previously trained Tf-Idf vectorizers:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前训练的Tf-Idf向量化器，将测试数据的文本和标题转换为数字形式：
- en: '[PRE94]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As before, combine all numerical features into one feature matrix:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如之前所述，将所有数字特征合并为一个特征矩阵：
- en: '[PRE95]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Test the Random Forest classifier:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试随机森林分类器：
- en: '[PRE96]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is the output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE97]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works…
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Our initial steps are to import our dataset of fake news and perform basic data
    munging (steps 1-6), such as converting the target into a numeric type. Next,
    in step 7, we train-test split our dataset in preparation for constructing a classifier.
    Since we are dealing with textual data, we must featurize these. To that end,
    in steps 8 and 9, we instantiate Tf-Idf vectorizers for NLP on the text and fit
    these. Other NLP approaches may be fruitful here. Continuing to featurize, we
    extract the numerical features of our DataFrame (steps 10 and 11). Having finished
    featurizing the dataset, we can now instantiate a basic classifier and fit it
    on the dataset (step 12). In steps 13-15, we repeat the process on the testing
    set and measure our performance. Observe the remarkable performance. Even now, possible
    steps for increasing the performance of the classifier include accounting for
    the source of the article, including images, and performing more sophisticated
    correlations with other events.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始步骤是导入虚假新闻数据集并进行基本的数据处理（步骤1-6），例如将目标转换为数值类型。接下来，在步骤7中，我们对数据集进行训练-测试划分，为构建分类器做准备。由于我们处理的是文本数据，我们必须对其进行特征化。为此，在步骤8和9中，我们实例化了用于自然语言处理（NLP）的Tf-Idf向量化器，并对其进行了拟合。其他NLP方法在这里可能也会有所帮助。继续特征化，我们提取了数据框的数值特征（步骤10和11）。完成数据集的特征化后，我们可以实例化一个基础分类器，并在数据集上进行拟合（步骤12）。在步骤13-15中，我们对测试集重复这一过程并衡量我们的性能。观察到显著的性能表现。即使现在，提升分类器性能的可能步骤包括考虑文章来源、加入图片以及与其他事件进行更复杂的相关性分析。
