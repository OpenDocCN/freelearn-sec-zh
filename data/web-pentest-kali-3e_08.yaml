- en: Attacking Flaws in Cryptographic Implementations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击密码实现中的缺陷
- en: One of the main objectives of information security is to protect the confidentiality
    of data. In a web application, the goal is to ensure that the data exchanged between
    the user and the application is secure and hidden from any third party. When stored
    on the server, the data also needs to be secured from hackers. **Cryptography**,
    the practice of communicating through and deciphering secret writings or messages,
    is used to protect the confidentiality as well as the integrity of the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全的主要目标之一是保护数据的机密性。在Web应用程序中，目标是确保用户和应用程序之间交换的数据是安全的，并且对任何第三方隐藏。当存储在服务器上时，数据还需要免受黑客的攻击。**密码学**是通过和解密秘密书写或消息来保护数据的机密性和完整性的实践。
- en: Current standard cryptographic algorithms have been designed, tested, and corrected
    at length by highly specialized teams of mathematicians and computer scientists.
    Examining their work in depth is beyond the scope of this book; also, trying to
    find vulnerabilities inherent in these algorithms is not the goal of this book.
    Instead, we will focus on certain implementations of these algorithms and how
    you can detect and exploit implementation failures, including those custom implementations
    which have not undergone the same level of design and testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当前标准的密码算法由高度专业的数学家和计算机科学家组成的团队进行了设计、测试和修正。深入研究他们的工作超出了本书的范围；寻找这些算法固有的漏洞也不是本书的目标。相反，我们将重点关注这些算法的某些实现以及如何检测和利用实现失败，包括那些没有经过相同设计和测试水平的自定义实现。
- en: Attackers will try to find different ways to defeat layers of encryption and
    expose plaintext data. They use different techniques, such as exploiting design
    flaws in the encryption protocol or tricking the user into sending data over a
    nonencrypted channel, circumventing the encryption itself. As a penetration tester,
    you need to be aware of such techniques and be able to identify the lack of encryption
    or a flawed implementation, exploit such flaws, and issue a recommendation to
    fix the issue as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者将尝试找到不同的方法来破解加密层并暴露明文数据。他们使用不同的技术，例如利用加密协议中的设计缺陷或诱使用户通过非加密通道发送数据，绕过加密本身。作为渗透测试人员，您需要了解这些技术，并能够识别缺乏加密或有缺陷的实现，利用这些缺陷，并提出修复问题的建议。
- en: In this chapter, we will analyze how cryptography works in web applications
    and explore some of the most common issues found in its implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析密码学在Web应用程序中的工作原理，并探讨其实现中常见的一些问题。
- en: A cryptography primer
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学入门
- en: 'First, we need to establish a clear differentiation between concepts that are
    often confused when talking about cryptography: encryption, encoding, obfuscation,
    and hashing:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在谈论密码学时明确区分常常混淆的概念：加密、编码、混淆和哈希：
- en: '**Encryption**: This is the process of altering data through mathematical algorithms
    in order to make it unintelligible to unauthorized parties. Authorized parties
    are able to decrypt the message back to cleartext using a key. AES, DES, Blowfish,
    and RSA are well-known encryption algorithms.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：这是通过数学算法来改变数据以使其对未经授权的方​​式不可理解的过程。授权方可以使用密钥将消息解密回明文。AES、DES、Blowfish和RSA是众所周知的加密算法。'
- en: '**Encoding**: This also alters the message, but its main goal is to allow that
    message to be processed by a different system. It doesn''t require a key, and
    it''s not considered a proper way of protecting information. Base64 encoding is
    commonly used in modern web applications to allow the transmission of binary data
    through HTTP.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码**：这也改变了消息，但其主要目标是允许该消息被不同的系统处理。它不需要密钥，并且不被视为保护信息的正确方式。Base64编码通常用于现代Web应用程序，以通过HTTP传输二进制数据。'
- en: '**Obfuscation**: This makes the original message harder to read by transforming
    the message. JavaScript code obfuscation is used to prevent debugging and/or protect
    intellectual property and its most common use is in web applications. It is not
    considered a way of protecting information from third parties.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混淆**：这使原始消息更难阅读，通过转换消息来实现。JavaScript代码混淆用于防止调试和/或保护知识产权，其最常见的用途是在Web应用程序中。它不被视为保护信息免受第三方侵害的方式。'
- en: '**Hashing**: A hashing function is the calculation of a fixed length, a unique
    number that represents the contents of the message. The same message must always
    result in the same hash, and no two messages can share hash values. Hash functions
    are theoretically nonreversible, which means that you cannot recover a message
    from its hash. Due to this constraint, they are useful as signatures and integrity
    checks, but not to store information that will need to be recovered at some point.
    Hashing functions are also widely used to store passwords. Common hash functions
    are MD5, SHA1, SHA-512, and bcrypt.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希**：哈希函数是计算消息内容的固定长度唯一数字。相同的消息必须始终产生相同的哈希值，而且没有两个消息可以共享哈希值。哈希函数在理论上是不可逆的，这意味着您无法从其哈希中恢复消息。由于这个限制，它们用作签名和完整性检查非常有用，但不能用于存储需要在某个时候恢复的信息。哈希函数也广泛用于存储密码。常见的哈希函数有MD5、SHA1、SHA-512和bcrypt。'
- en: Algorithms and modes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法和模式
- en: 'A cryptographic algorithm or cipher is one that takes cleartext and converts
    it into ciphertext through some calculations. These algorithms can be broadly
    classified in two different ways as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 密码算法或密码是通过一些计算将明文转换为密文的算法。这些算法可以广泛分为以下两种方式：
- en: By their use of public and private keys or shared secrets, they can be either
    **asymmetric** or **symmetric**
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据它们使用的公钥和私钥或共享密钥，它们可以是**非对称**或**对称**的。
- en: By how they process the original message, they can be either **stream** or **block
    ciphers**
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据它们处理原始消息的方式，它们可以是**流密码**或**块密码**
- en: Asymmetric encryption versus symmetric encryption
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密与对称加密
- en: '**Asymmetric encryption** uses a combination of public-private keys and is
    more secure than symmetric encryption. The public key is shared with everyone,
    and the private key is stored separately. Encrypted data with one key can only
    be decrypted with other key, which makes it very secure and efficient to implement
    on a larger scale.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**非对称加密**使用公私钥的组合，比对称加密更安全。公钥与所有人共享，私钥单独存储。使用一个密钥加密的加密数据只能使用另一个密钥解密，这使得它在更大范围内实施非常安全和高效。'
- en: '**Symmetric encryption**, on the other hand, uses the same key to encrypt and
    decrypt the data, and you''ll need to find a safe method to share the symmetric
    key with the other party.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**对称加密**使用相同的密钥对数据进行加密和解密，您需要找到一种安全的方法与其他方共享对称密钥。
- en: A question that is often asked is why isn't the public-private key pair used
    to encrypt the data stream and instead a session key generated, which uses symmetric
    encryption. The combination of the public-private key is generated through a complex
    mathematical process, which is a processor-intensive and time-consuming task.
    Therefore, it is only used to authenticate the endpoints and to generate and protect
    the session key, which is then used in the symmetric encryption that encrypts
    the bulk data. The combination of the two encryption techniques results in a faster
    and more efficient encryption of the data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 经常被问到的一个问题是为什么不使用公私钥对来加密数据流，而是生成一个使用对称加密的会话密钥。公私钥的组合是通过复杂的数学过程生成的，这是一个处理器密集型和耗时的任务。因此，它仅用于验证端点并生成和保护会话密钥，然后在对称加密中使用该会话密钥对大量数据进行加密。这两种加密技术的组合结果是更快速和更高效的数据加密。
- en: 'The following are examples of asymmetric encryption algorithms:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非对称加密算法的例子：
- en: '**Diffie-Hellman key exchange**: This was the first asymmetric encryption algorithm
    developed in 1976, which used discrete logarithms in a finite field. It allows
    two endpoints to exchange secret keys on an insecure medium without any prior
    knowledge of each other.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Diffie-Hellman密钥交换**：这是1976年开发的第一个非对称加密算法，它在有限域中使用离散对数。它允许两个端点在不了解对方的情况下，在不安全的介质上交换秘密密钥。'
- en: '**Rivest Shamir Adleman (RSA)**: This is the most widely used asymmetric algorithm.
    The RSA algorithm is used for both encrypting data and for signing, providing
    confidentiality, and nonrepudiation. The algorithm uses a series of modular multiplications
    to encrypt the data.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rivest Shamir Adleman（RSA）**：这是最广泛使用的非对称算法。RSA算法用于加密数据和签名，提供机密性和不可否认性。该算法使用一系列模乘法来加密数据。'
- en: '**Elliptic Curve Cryptography (ECC)**: This is primarily used in handheld devices
    such as smartphones, as it requires less computing power for its encryption and
    decryption process. The ECC functionality is similar to the RSA functionality.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**椭圆曲线密码学（ECC）**：这主要用于手持设备，如智能手机，因为它在加密和解密过程中需要较少的计算能力。ECC功能类似于RSA功能。'
- en: Symmetric encryption algorithm
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密算法
- en: In **symmetric encryption**, a shared secret is used to generate an encryption
    key. The same key is then used to encrypt and decrypt the data. This way of encrypting
    the data has been used for ages in various forms. It provides an easy way to encrypt
    and decrypt data, since the keys are identical. Symmetric encryption is simple
    and easier to implement, but it comes with the challenge of sharing the key with
    the users in a secure way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在**对称加密**中，使用共享密钥生成加密密钥。然后使用相同的密钥对数据进行加密和解密。这种加密数据的方式在各种形式中已经被使用了很长时间。它提供了一种简单的加密和解密数据的方法，因为密钥是相同的。对称加密简单且易于实现，但是它需要以安全的方式与用户共享密钥。
- en: 'Some examples of symmetric algorithms are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对称算法的例子如下：
- en: '**Data Encryption Standard (DES)**: This algorithm uses the DEA cipher. DEA
    is a block cipher that uses a key size of 64 bits; 8 bits being for error detection
    and 56 bits for the actual key. Considering the computing power of today''s computers,
    this encryption algorithm is easily breakable.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据加密标准（DES）**：该算法使用DEA密码。DEA是一种分组密码，使用64位密钥大小；其中8位用于错误检测，56位用于实际密钥。考虑到今天计算机的计算能力，这种加密算法很容易被破解。'
- en: '**Triple DES (3DES)**: This algorithm applies the DES algorithm three times
    to each block. It uses three, 56-bit keys.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三重DES（3DES）**：该算法将DES算法应用于每个分组三次。它使用三个56位密钥。'
- en: '**Advanced Encryption Standard (AES)**: This standard was first published in
    1998, and it is considered to be more secure than other symmetric encryption algorithms.
    AES uses the Rijndael cipher, which was developed by two Belgian cryptographers,
    Joan Daemen and Vincent Rijmen. It replaces the DES algorithm. It can be configured
    to use a variable key size with a minimum size of 128 bits, up to a maximum size
    of 256 bits.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级加密标准（AES）**：该标准首次发布于1998年，被认为比其他对称加密算法更安全。AES使用了由两位比利时密码学家Joan Daemen和Vincent
    Rijmen开发的Rijndael密码。它取代了DES算法。它可以配置为使用可变的密钥大小，最小为128位，最大为256位。'
- en: '**Rivest Cipher 4 (RC4)**: RC4 is a widely used stream cipher, and it has a
    variable key size of 40 to 2,048 bits. RC4 has some design flaws that makes it
    susceptible to attacks, although such attacks may not be practical to perform
    and require a huge amount of computing power. RC4 has been widely used in the
    SSL/TLS protocol. Many organizations, however, have started to move to AES instead
    of RC4.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rivest Cipher 4 (RC4)**: RC4是一种广泛使用的流密码，其密钥大小可变，范围从40到2048位。RC4存在一些设计缺陷，使其容易受到攻击，尽管这些攻击可能不实际且需要大量的计算能力。RC4在SSL/TLS协议中被广泛使用。然而，许多组织已经开始使用AES代替RC4。'
- en: Stream and block ciphers
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流密码和分组密码
- en: 'Symmetric algorithms are divided into two major categories:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对称算法分为两个主要类别：
- en: '**Stream ciphers:** This algorithm encrypts individual bits at a time and therefore
    requires more processing power. It also requires a lot of randomness, as each
    bit is to be encrypted with a unique key stream. Stream ciphers are more suitable
    to be implemented at the hardware layer and are used to encrypt streaming communication,
    such as audio and video, as it can quickly encrypt and decrypt each bit. The ciphertext
    resulting from the use of this kind of algorithm is the same size as the original
    cleartext.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流密码：**该算法一次加密一个比特，因此需要更多的处理能力。它还需要大量的随机性，因为每个比特都要用唯一的密钥流进行加密。流密码更适合在硬件层实现，并用于加密流式通信，如音频和视频，因为它可以快速加密和解密每个比特。使用这种算法产生的密文与原始明文的大小相同。'
- en: '**Block ciphers:** With this algorithm, the original message is divided into
    fixed-length blocks and padded (extended to fulfill the required length) in the
    last one. Then each block is processed independently depending on the mode utilized.
    We will discuss cipher modes further in the subsequent sections. The size of the
    ciphertext resulting from a block cipher is always a multiple of the block size.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块密码：**使用这种算法，原始消息被分成固定长度的块，并在最后一个块中填充（扩展到满足所需的长度）。然后，根据所使用的模式，独立处理每个块。我们将在后续章节中进一步讨论密码模式。块密码产生的密文大小始终是块大小的倍数。'
- en: Initialization Vectors
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化向量
- en: Encryption algorithms are *deterministic*. This means that the same input will
    always result in the same output. This is a good thing, given that, when decrypting,
    you want to be able to recover the exact same message that was encrypted. Unfortunately,
    this makes encryption weaker, as it makes it vulnerable to cryptanalysis and known-text
    attacks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法是*确定性的*。这意味着相同的输入将始终产生相同的输出。这是一件好事，因为在解密时，您希望能够恢复与加密的完全相同的消息。不幸的是，这使得加密变得更弱，因为它容易受到密码分析和已知明文攻击的攻击。
- en: To face this issue, **Initialization Vectors** (**IVs**) were implemented. An
    IV is an extra piece of information that is different each time the algorithm
    is executed. It is used to generate the encryption key or to preprocess the cleartext,
    usually through an XOR operation. This way, if two messages are encrypted with
    the same algorithm and the same key, but a different IV, the resulting ciphertexts
    will be different. IVs are attached to the ciphertext, as the recipient has no
    way of knowing them beforehand.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，实现了**初始化向量**（**IVs**）。IV是每次执行算法时都不同的额外信息。它用于生成加密密钥或预处理明文，通常通过异或操作进行。这样，如果两条消息使用相同的算法和相同的密钥加密，但使用不同的IV，得到的密文将不同。IV附加在密文上，因为接收者事先无法知道它们。
- en: The golden rule, especially for stream ciphers, is never to repeat IVs. The
    RC4 implementation of the **Wired Equivalent Privacy** (**WEP**) authentication
    in wireless networks uses a 24-bit (3 bytes) IV that permits duplicated keystreams
    in a short period of time. Having a known text, such as a DHCP request, sent through
    the network multiple times with the same IV allows an attacker to recover the
    keystreams, and multiple keystreams/IV pairs can be used to recover the shared
    secret.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金法则，特别是对于流密码，永远不要重复使用IV。无线网络中的**Wired Equivalent Privacy**（**WEP**）身份验证的RC4实现使用一个24位（3字节）的IV，允许在短时间内重复使用密钥流。通过多次使用相同IV发送已知文本（例如DHCP请求）通过网络，攻击者可以恢复密钥流，并且可以使用多个密钥流/IV对来恢复共享密钥。
- en: Block cipher modes
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块密码模式
- en: 'A **mode of operation** is how an encryption algorithm uses the IV and how
    it implements the encryption of each block of cleartext. Next, we will talk about
    the most common modes of operation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作模式**是加密算法如何使用IV以及如何实现对每个明文块的加密。接下来，我们将讨论最常见的操作模式：'
- en: '**Electronic Code Book (ECB)**: With this mode of operation, there is no use
    of IV and each block is encrypted independently. Thus, when blocks that contain
    the same information result in the same ciphertext, they make analysis and attacks
    easier.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子密码本（ECB）：**在这种操作模式下，没有使用IV，每个块都是独立加密的。因此，包含相同信息的块导致相同的密文，这使得分析和攻击更容易。'
- en: '**Cipher Block Chaining (CBC)**: With the CBC mode, blocks are encrypted sequentially;
    an IV is applied to the first block, and the resulting ciphertext in each block
    is used as the IV to encrypt the next one. CBC mode ciphers may be vulnerable
    to padding oracle attacks, where the padding done to the last block may be used
    to recover the keystream provided that the attacker can recover large amounts
    of encrypted packages and that there is a way of knowing if a package has the
    correct padding (an oracle).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码块链接（CBC）：**使用CBC模式，块按顺序加密；一个IV应用于第一个块，每个块的结果密文用作下一个块的IV。CBC模式密码可能容易受到填充预言攻击的影响，其中对最后一个块的填充可能被用来恢复密钥流，前提是攻击者能够恢复大量加密包并且有一种方法可以知道一个包是否具有正确的填充（预言）。'
- en: '**Counter (CTR)**: This is probably the most convenient and secure method,
    if implemented correctly. Blocks are encrypted independently using the same IV
    plus a counter that is different for each block. This makes the mode capable of
    processing all blocks of a message in parallel and having different ciphertext
    for each block, even if the cleartext is the same.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器（CTR）：**如果正确实现，这可能是最方便和安全的方法。使用相同的IV加上每个块不同的计数器，独立加密块。这使得该模式能够并行处理消息的所有块，并且每个块都有不同的密文，即使明文相同。'
- en: Hashing functions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希函数
- en: '**Hashing functions** are commonly used to ensure the integrity of the message
    transmitted and as an identifier to determine quickly if two pieces of information
    are the same. A hashing function generates a fixed-length value (hash) that represents
    the actual data.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希函数**通常用于确保传输的消息的完整性，并作为确定两个信息是否相同的标识符。哈希函数生成一个表示实际数据的固定长度值（哈希）。'
- en: Hashing functions are suitable to those tasks, because, by definition, no two
    different pieces of information should have the same resulting hash (collision),
    and the original information should not be recoverable from the hash alone (that
    is, hashing functions are not reversible).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数适用于这些任务，因为根据定义，没有两个不同的信息片段应该具有相同的哈希结果（碰撞），并且原始信息不应该仅通过哈希来恢复（即，哈希函数不可逆）。
- en: 'Some of the most common hashing functions are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最常见的哈希函数：
- en: MD5 (Message Digest 5)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MD5（消息摘要5）
- en: SHA (Secure Hashing Algorithm) versions 1 and 2
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA（安全散列算法）版本1和2
- en: NT and NTLM, used by Microsoft Windows to store passwords, based on MD4
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NT和NTLM是Microsoft Windows用于存储密码的基于MD4的方法
- en: Salt values
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盐值
- en: When used to store secrets, such as passwords, hashes are vulnerable to dictionary
    and brute-force attacks. An attacker that captures a set of password hashes may
    try to use a dictionary of known common passwords, hash them, and compare the
    results to the captured hashes, when looking for matches and discovering the cleartext
    passwords when found. Once a hash-password pair is found, all other users or accounts
    using the same password will also be discovered, as all hashes would be the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于存储密码等秘密信息时，哈希容易受到字典和暴力攻击的攻击。攻击者捕获一组密码哈希值后，可以尝试使用已知常见密码的字典对其进行哈希，并将结果与捕获的哈希进行比较，以寻找匹配并发现明文密码。一旦找到哈希-密码对，所有使用相同密码的其他用户或账户也会被发现，因为所有哈希值都是相同的。
- en: '**Salt values** are used to make this task more difficult by appending a random
    value to the information to be hashed and causing the hashing of the same piece
    of data with different salts to result in different hashes. In our previous hypothetical
    case, an attacker recovering the plaintext for one hash would not have recovered
    all of the other instances of the same password automatically.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过附加一个随机值到要进行哈希的信息上，并导致使用不同的盐对相同数据进行哈希得到不同的哈希值，**盐值**用于使这个任务更加困难。在我们之前的假设情况中，恢复一个哈希的明文的攻击者不会自动恢复所有其他相同密码的实例。
- en: As is the case with IVs, salts are stored and sent along with the hashes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与初始化向量（IV）一样，盐值也会与哈希一起存储和发送。
- en: Secure communication over SSL/TLS
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过SSL/TLS进行安全通信
- en: '**Secure Sockets Layer** (**SSL**) is an encryption protocol designed to secure
    communications over the network. Netscape developed the SSL protocol in 1994\.
    In 1999, the **Internet Engineering Task Force** (**IETF**) released the **Transport
    Layer Security** (**TLS**) protocol, superseding SSL protocol version 3\. SSL
    is now considered insecure because of multiple vulnerabilities identified over
    the years. The POODLE and BEAST vulnerabilities, which we will discuss further
    in later sections, expose flaws in the SSL protocol itself and hence cannot be
    fixed with a software patch. SSL was declared deprecated by the IETF, and upgrading
    to TLS was suggested as the protocol to use for secure communications. The most
    recent version of TLS is version 1.2\. We always recommend that you use the latest
    version of TLS and avoid allowing connections from clients using older versions
    or the SSL protocol.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全套接字层**（**SSL**）是一种设计用于保护网络通信的加密协议。Netscape于1994年开发了SSL协议。1999年，**互联网工程任务组**（**IETF**）发布了**传输层安全**（**TLS**）协议，取代了SSL协议的第3版。由于多年来发现了多个漏洞，SSL现在被认为是不安全的。POODLE和BEAST漏洞在SSL协议本身中暴露了缺陷，因此无法通过软件补丁修复。IETF宣布SSL已被弃用，并建议升级到TLS作为安全通信的协议。TLS的最新版本是1.2。我们始终建议您使用最新版本的TLS，并避免允许使用旧版本或SSL协议的客户端连接。'
- en: Most websites have migrated to and have started using the TLS protocol, but
    the encrypted communication is still commonly referred to as an SSL connection.
    SSL/TLS not only provides confidentiality, but it also helps to maintain the integrity
    of the data and to achieve nonrepudiation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站已经迁移到并开始使用TLS协议，但加密通信仍然通常被称为SSL连接。SSL/TLS不仅提供机密性，还有助于维护数据的完整性和实现不可否认性。
- en: 'Securing the communication between the client and the web application is the
    most common use of TLS/SSL, and it is known as **HTTP over SSL** or **HTTPS**.
    TLS is also used to secure the communication channel used by other protocols in
    the following ways:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 保护客户端和Web应用程序之间的通信是TLS/SSL的最常见用途，也被称为**HTTPS**。TLS还用于以下方式中其他协议使用的通信通道的安全保护：
- en: It is used by mail servers to encrypt emails between two mail servers and also
    between the client and the mail server
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被邮件服务器用于加密两个邮件服务器之间以及客户端和邮件服务器之间的电子邮件
- en: TLS is used to secure communication between database servers and LDAP authentication
    servers
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS用于保护数据库服务器和LDAP认证服务器之间的通信
- en: It is used to encrypt **Virtual Private Network** (**VPN**) connections known
    as **SSL VPN**
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被用于加密称为**SSL VPN**的**虚拟专用网络**（**VPN**）连接
- en: Remote desktop services in the Windows operating system use TLS to encrypt and
    authenticate the client connecting to the server
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows操作系统中的远程桌面服务使用TLS对连接到服务器的客户端进行加密和认证
- en: There are several other applications and implementations where TLS is used to
    secure the communication between two parties. In the following sections, we will
    refer to the protocol used by HTTPS as TLS and we will specify when something
    only applies either to SSL or TLS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TLS被用于保护两方之间的通信的几个其他应用和实现。在接下来的章节中，我们将把HTTPS使用的协议称为TLS，并在只适用于SSL或TLS的情况下进行说明。
- en: Secure communication in web applications
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序中的安全通信
- en: TLS uses the public-private key encryption mechanism to scramble data, which
    helps protect it from third parties listening in on the communication. Sniffing
    the data over the network would only reveal the encrypted information, which is
    of no use without access to the corresponding key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TLS使用公钥-私钥加密机制来加密数据，从而保护其免受第三方监听通信的影响。在网络上嗅探数据只会显示加密的信息，没有对应密钥的访问是无用的。
- en: 'The TLS protocol is designed to protect the three facets of the CIA triad—confidentiality,
    integrity, and availability:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TLS协议旨在保护CIA三要素（机密性、完整性和可用性）：
- en: '**Confidentiality**: Maintaining the privacy and secrecy of the data'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：保持数据的隐私和保密性'
- en: '**Integrity**: Maintaining the accuracy and consistency of the data, and the
    assurance that it is not altered in transit'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：保持数据的准确性和一致性，并确保在传输过程中未被更改'
- en: '**Availability**: Preventing data loss and maintaining access to data'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：防止数据丢失并保持对数据的访问'
- en: 'Web server administrators implement TLS to make sure that sensitive user information
    shared between the web server and the client is secure. In addition to protecting
    the confidentiality of the data, TLS also provides nonrepudiation using TLS certificates
    and digital signatures. This provides the assurance that the message is indeed
    sent by the party who is claiming to have sent it. This is similar to how a signature
    works in our day-to-day life. These certificates are signed, verified, and issued
    by an independent third-party known as **Certificate Authority** (**CA**). Some
    of the well-known certificate authorities are listed here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器管理员实施TLS以确保在Web服务器和客户端之间共享的敏感用户信息是安全的。除了保护数据的机密性外，TLS还使用TLS证书和数字签名提供不可否认性。这提供了确保消息确实由声称发送它的一方发送的保证。这类似于我们日常生活中签名的工作方式。这些证书由独立的第三方机构，即**证书颁发机构**（**CA**）签署、验证和颁发。以下是一些知名的证书颁发机构：
- en: VeriSign
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VeriSign
- en: Thawte
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thawte
- en: Comodo
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Comodo
- en: DigiCert
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigiCert
- en: Entrust
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entrust
- en: GlobalSign
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlobalSign
- en: If an attacker tries to fake the certificate, the browser displays a warning
    message informing the user that an invalid certificate is being used to encrypt
    the data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者试图伪造证书，浏览器将显示警告消息，通知用户正在使用无效证书加密数据。
- en: Data integrity is achieved by calculating a message digest using a hashing algorithm,
    which is attached to the message and verified at the other end.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用哈希算法计算消息摘要来实现数据完整性，该摘要附加到消息上并在另一端进行验证。
- en: TLS encryption process
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS加密过程
- en: 'Encryption is a multistep process, but it is a seamless experience for end
    users. The entire process can be broken down into two parts: the first part of
    encryption is done using the asymmetric encryption technique, and the second part
    is done using the symmetric encryption process. Here is a description of the major
    steps to encrypt and transmit data using SSL:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是一个多步骤的过程，但对于最终用户来说是一个无缝的体验。整个过程可以分为两个部分：第一部分使用非对称加密技术进行加密，第二部分使用对称加密过程进行加密。以下是使用SSL加密和传输数据的主要步骤的描述：
- en: The handshake between the client and the server is the initial step in which
    the client presents the SSL/TLS version number and the encryption algorithms that
    it supports.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的握手是初始步骤，客户端在其中呈现SSL/TLS版本号和支持的加密算法。
- en: The server responds by identifying the SSL version and encryption algorithm
    that it supports, and both parties agree on the highest mutual value. The server
    also responds with the SSL certificate. This certificate contains the server's
    public key and general information about the server.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过识别其支持的SSL版本和加密算法来响应，并且双方就最高的共同值达成一致。服务器还会响应SSL证书。该证书包含服务器的公钥和有关服务器的一般信息。
- en: 'The client then authenticates the server by verifying the certificate against
    the list of root certificates stored on the local computer. The client checks
    with the certificate CA that the signed certificate issued to the website is stored
    in the list of trusted CAs. In Internet Explorer, the list of trusted CAs can
    be viewed by navigating to Tools | Internet options | Content | Certificates |
    Trusted Root Certification Authorities, as seen in the following screenshot:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，客户端通过将证书与存储在本地计算机上的根证书列表进行验证来对服务器进行身份验证。客户端与证书颁发机构（CA）检查，以确保颁发给网站的签名证书存储在受信任的CA列表中。在Internet
    Explorer中，可以通过导航到“工具”|“Internet选项”|“内容”|“证书”|“受信任的根证书颁发机构”来查看受信任的CA列表，如下图所示：
- en: '![](img/00202.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00202.jpeg)'
- en: Using the information shared during the handshake, the client can generate a
    pre-master secret for the session. It then encrypts the secret with the server's
    public key and sends the encrypted pre-master key back to the server.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用握手期间共享的信息，客户端可以为会话生成一个预主密钥。然后，它使用服务器的公钥加密该密钥，并将加密的预主密钥发送回服务器。
- en: The server decrypts the pre-master key using the private key (since it was encrypted
    with the public key). The server and the client then both generate a session key
    from the pre-master key using a series of steps. This session key encrypts the
    data throughout the entire session, which is called the symmetric encryption.
    A hash is also calculated and appended to the message, which helps test the integrity
    of the message.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器使用私钥解密预主密钥（因为它是使用公钥加密的）。然后，服务器和客户端使用一系列步骤从预主密钥生成会话密钥。该会话密钥在整个会话期间加密数据，这称为对称加密。还计算并附加到消息的哈希有助于测试消息的完整性。
- en: Identifying weak implementations of SSL/TLS
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别SSL/TLS的弱实现
- en: As you learned in the previous section, TLS is a combination of various encryption
    algorithms packaged into one in order to provide confidentiality, integrity, and
    authentication. In the first step, when two endpoints negotiate for an SSL connection,
    they identify the common cipher suites supported by them. This allows SSL to support
    a wide variety of devices, which may not have the hardware and software to support
    the newer ciphers. Supporting older encryption algorithms has a major drawback.
    Most older cipher suites are easily breakable in a reasonable amount of time by
    cryptanalysts using the computing power available today.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一节中学到的，TLS是将各种加密算法打包成一个以提供机密性、完整性和身份验证的组合。在第一步中，当两个端点协商SSL连接时，它们识别出它们支持的公共密码套件。这使得SSL能够支持各种各样的设备，这些设备可能没有硬件和软件来支持较新的密码。支持旧的加密算法有一个主要缺点。大多数旧的密码套件在今天可用的计算能力下，很容易在合理的时间内被密码分析师破解。
- en: The OpenSSL command-line tool
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSL命令行工具
- en: In order to identify the cipher suites negotiated by the remote web server,
    you can use the OpenSSL command-line tool that comes preinstalled on all major
    Linux distributions, and it is also included in Kali Linux. The tool can be used
    to test the various functions of the OpenSSL library directly from the bash shell
    without writing any code. It is also used as a troubleshooting tool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别远程Web服务器协商的密码套件，您可以使用预安装在所有主要Linux发行版上的OpenSSL命令行工具，它也包含在Kali Linux中。该工具可以在bash
    shell中直接测试OpenSSL库的各种功能，而无需编写任何代码。它也被用作故障排除工具。
- en: OpenSSL is a well-known library used in Linux to implement the SSL protocol,
    and **Secure channel** (**Schannel**) is a provider of the SSL functionality in
    Windows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL是一个在Linux中使用的著名库，用于实现SSL协议，而**Secure channel**（**Schannel**）是Windows中提供SSL功能的提供程序。
- en: 'The following example uses the `s_client` command-line option that establishes
    a connection to the remote server using SSL/TLS. The output of the command is
    difficult to interpret for a newbie, but it is useful for identifying the TLS/SSL
    version and cipher suites agreed upon between the server and the client:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`s_client`命令行选项，使用SSL/TLS与远程服务器建立连接。该命令的输出对于新手来说很难解释，但对于识别服务器和客户端之间达成的TLS/SSL版本和密码套件是有用的：
- en: '![](img/00203.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00203.jpeg)'
- en: 'The OpenSSL utility contains various command-line options that can be used
    to test the server using specific SSL versions and cipher suites. In the following
    example, we are trying to connect using TLS version 1.2 and a weak algorithm,
    RC4:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL工具包含各种命令行选项，可用于使用特定的SSL版本和密码套件测试服务器。在以下示例中，我们尝试使用TLS版本1.2和弱算法RC4进行连接：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot shows the output of the command. Since the client
    could not negotiate with the `ECDHE-RSA-AES256-SHA` cipher suite, the handshake
    failed and no cipher was selected:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了命令的输出。由于客户端无法与`ECDHE-RSA-AES256-SHA`密码套件协商，握手失败，没有选择密码套件：
- en: '![](img/00204.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00204.jpeg)'
- en: 'In the following screenshot, we are trying to negotiate a weak encryption algorithm
    with the server. It fails, as Google has rightly disabled the weak cipher suites
    on the server:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们尝试与服务器协商使用弱加密算法。由于谷歌正确地在服务器上禁用了弱密码套件，因此失败了：
- en: '![](img/00205.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00205.jpeg)'
- en: 'To find out the cipher suites that are easily breakable using the computing
    power available today, enter the command shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出使用今天可用的计算能力很容易破解的密码套件，请输入以下屏幕截图中显示的命令：
- en: '![](img/00206.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00206.jpeg)'
- en: 'You will often see cipher suites written as **ECDHE-RSA-RC4-MD5**. The format
    is broken down into the following parts:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会看到密码套件写成**ECDHE-RSA-RC4-MD5**。格式分解为以下部分：
- en: '**ECDHE**: This is a key exchange algorithm'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ECDHE**：这是一种密钥交换算法'
- en: '**RSA**: This is an authentication algorithm'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSA**：这是一种身份验证算法'
- en: '**RC4**: This is an encryption algorithm'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RC4**：这是一种加密算法'
- en: '**MD5**: This is a hashing algorithm'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MD5**：这是一种哈希算法'
- en: A comprehensive list of SSL and TLS cipher suites can be found at [https://www.openssl.org/docs/apps/ciphers.html](https://www.openssl.org/docs/apps/ciphers.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://www.openssl.org/docs/apps/ciphers.html](https://www.openssl.org/docs/apps/ciphers.html)找到SSL和TLS密码套件的全面列表。
- en: SSLScan
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSLScan
- en: Although the OpenSSL command-line tool provides many options to test the SSL
    configuration, the output of the tool is not user friendly. The tool also requires
    a fair amount of knowledge about the cipher suites that you want to test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OpenSSL命令行工具提供了许多选项来测试SSL配置，但该工具的输出对用户来说并不友好。该工具还需要对您要测试的密码套件有相当多的了解。
- en: Kali Linux comes with many tools that automate the task of identifying SSL misconfigurations,
    outdated protocol versions, and weak cipher suites and hashing algorithms. One
    of the tools is **SSLScan**, which can be accessed by going to Applications |
    Information Gathering | SSL Analysis.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux带有许多工具，可以自动化识别SSL配置错误、过时的协议版本以及弱密码套件和哈希算法。其中一个工具是**SSLScan**，可以通过转到应用程序
    | 信息收集 | SSL分析来访问。
- en: 'By default, SSLScan checks if the server is vulnerable to the CRIME and Heartbleed
    vulnerabilities. The `-tls` option will force SSLScan only to test the cipher
    suites using the TLS protocol. The output is distributed in various colors, with
    green indicating that the cipher suite is secure and the sections that are colored
    in red and yellow are trying to attract your attention:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SSLScan会检查服务器是否容易受到CRIME和Heartbleed漏洞的攻击。`-tls`选项将强制SSLScan仅使用TLS协议测试密码套件。输出以各种颜色分布，绿色表示密码套件是安全的，红色和黄色的部分试图吸引您的注意：
- en: '![](img/00207.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00207.jpeg)'
- en: 'The cipher suites supported by the client can be identified by running the
    following command. It will display a long list of ciphers that are supported by
    the client:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令可以识别客户端支持的密码套件。它将显示客户端支持的一长串密码套件：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to analyze the certificate-related data, use the following command
    that will display detailed information on the certificate:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要分析与证书相关的数据，请使用以下命令显示证书的详细信息：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output of the command can be exported in an XML document using the `-xml=<filename>`
    option.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`-xml=<filename>`选项将命令的输出导出为XML文档。
- en: Watch out when `NULL` is pointed out in the names of the supported ciphers.
    If the `NULL` cipher is selected, the SSL/TLS handshake will complete and the
    browser will display the secure padlock, but the HTTP data will be transmitted
    in cleartext.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当在支持的密码名称中指出`NULL`时要小心。如果选择了`NULL`密码，SSL/TLS握手将完成，浏览器将显示安全的挂锁，但HTTP数据将以明文形式传输。
- en: SSLyze
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSLyze
- en: Another interesting tool that comes with Kali Linux, which is helpful in analyzing
    the SSL configuration, is the SSLyze tool released by iSEC Partners. The tool
    is hosted on GitHub at [https://github.com/iSECPartners/sslyze](https://github.com/iSECPartners/sslyze),
    and it can be found in Kali Linux at Applications | Information Gathering | SSL
    Analysis. SSLyze is written in Python.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux还提供了另一个有用的工具，即iSEC Partners发布的SSL配置分析工具SSLyze。该工具托管在GitHub上，网址为[https://github.com/iSECPartners/sslyze](https://github.com/iSECPartners/sslyze)，在Kali
    Linux中可以在Applications | Information Gathering | SSL Analysis中找到。SSLyze是用Python编写的。
- en: 'The tool comes with various plugins, which help in testing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具配备了各种插件，可用于测试以下内容：
- en: Checking for older versions of SSL
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查旧版本的SSL
- en: Analyzing the cipher suites and identifying weak ciphers
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析密码套件并识别弱密码
- en: Scanning multiple servers using an input file
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入文件扫描多个服务器
- en: Checking for session resumption support
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查会话恢复支持
- en: Using the `-regular` option includes all of the common options in which you
    might be interested, such as testing all available protocols (SSL versions 2 and
    3 and TLS 1.0, 1.1, and 1.2), testing for insecure cipher suites, and identifying
    if compression is enabled.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-regular`选项可以包括您可能感兴趣的所有常见选项，例如测试所有可用的协议（SSL版本2和3以及TLS 1.0、1.1和1.2）、测试不安全的密码套件以及识别是否启用了压缩。
- en: 'In the following example, compression is not supported by the server, and it
    is vulnerable to Heartbleed. The output also lists the accepted cipher suites:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，服务器不支持压缩，并且易受Heartbleed漏洞攻击。输出还列出了接受的密码套件。
- en: '![](img/00208.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00208.jpeg)'
- en: Testing SSL configuration using Nmap
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nmap测试SSL配置
- en: Nmap includes a script known as `ssl-enum-ciphers`, which can identify the cipher
    suites supported by the server and also rates them based on their cryptographic
    strength. It makes multiple connections using SSLv3, TLS 1.1, and TLS 1.2\. There
    are also scripts that can identify known vulnerabilities, such as Heartbleed or
    POODLE.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap包含一个名为`ssl-enum-ciphers`的脚本，可以识别服务器支持的密码套件，并根据其加密强度对其进行评级。它使用SSLv3、TLS 1.1和TLS
    1.2进行多次连接。还有一些脚本可以识别已知的漏洞，如Heartbleed或POODLE。
- en: 'We will run Nmap against the target (bee-box v1.6, [https://sourceforge.net/projects/bwapp/files/bee-box/](https://sourceforge.net/projects/bwapp/files/bee-box/))
    using three scripts: `ssl-enum-ciphers`, to list all the ciphers allowed by the
    server—`ssl-heartbleed` and `ssl-poodle`—to test for those specific vulnerabilities:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三个脚本（`ssl-enum-ciphers`、`ssl-heartbleed`和`ssl-poodle`）对目标（bee-box v1.6，[https://sourceforge.net/projects/bwapp/files/bee-box/](https://sourceforge.net/projects/bwapp/files/bee-box/)）进行Nmap扫描，以列出服务器允许的所有密码并测试这些特定的漏洞：
- en: '![](img/00209.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00209.jpeg)'
- en: 'This first screenshot shows the result of `ssl-enum-ciphers`, displaying the
    ciphers allowed for SSLv3\. In the next screenshot, the `ssl-heartbleed` script
    shows that the server is vulnerable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张截图显示了`ssl-enum-ciphers`的结果，显示了SSLv3允许的密码。下一张截图中，`ssl-heartbleed`脚本显示服务器存在漏洞：
- en: '![](img/00210.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00210.jpeg)'
- en: 'Also, the `ssl-poodle` script identifies the server as vulnerable to POODLE:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ssl-poodle`脚本将服务器标识为易受POODLE攻击的脆弱目标：
- en: '![](img/00211.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00211.jpeg)'
- en: Exploiting Heartbleed
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Heartbleed漏洞
- en: Heartbleed was discovered in April 2014\. It consists of a buffer over-read
    situation in the OpenSSL TLS implementation; that is, more data can be read from
    memory than should be allowed. This situation allows an attacker to read information
    from the OpenSSL server's memory in cleartext. This means that there is no need
    to decrypt or even intercept any communication between client and server; you
    simply *ask* the server what's in its memory and it will answer with the unencrypted
    information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed漏洞于2014年4月被发现。它是OpenSSL TLS实现中的缓冲区超读情况，即可以从内存中读取比允许的更多的数据。这种情况允许攻击者以明文形式从OpenSSL服务器的内存中读取信息。这意味着无需解密或拦截客户端和服务器之间的任何通信，您只需向服务器询问其内存中的内容，它将以未加密的信息回答。
- en: In practice, Heartbleed can be exploited over any unpatched OpenSSL server (versions
    1.0.1 through 1.0.1f and 1.0.2-beta through 1.0.2-beta1) that supports TLS, and
    by exploiting, it reads up to 64 KB from the server's memory in plaintext. This
    can be done repeatedly and without leaving any trace or log in the server. This
    means that an attacker may be able to read plaintext information from the server,
    such as the server's private keys or encryption certificates, session cookies,
    or HTTPS requests that may contain the users' passwords and other sensitive information.
    More information on Heartbleed can be found on its Wikipedia page at [https://en.wikipedia.org/wiki/Heartbleed](https://en.wikipedia.org/wiki/Heartbleed).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Heartbleed漏洞可以在任何未修补的支持TLS的OpenSSL服务器上利用（版本1.0.1至1.0.1f和1.0.2-beta至1.0.2-beta1），通过利用可以以明文形式从服务器的内存中读取最多64
    KB的数据。这可以重复进行，而且在服务器中不会留下任何痕迹或日志。这意味着攻击者可能能够从服务器中读取明文信息，例如服务器的私钥或加密证书、会话cookie或可能包含用户密码和其他敏感信息的HTTPS请求。有关Heartbleed的更多信息，请参阅其维基百科页面[https://en.wikipedia.org/wiki/Heartbleed](https://en.wikipedia.org/wiki/Heartbleed)。
- en: 'We will use a Metasploit module to exploit a Heartbleed vulnerability in bee-box.
    First, you need to open the Metasploit console and load the module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Metasploit模块来利用bee-box中的Heartbleed漏洞。首先，您需要打开Metasploit控制台并加载该模块：
- en: '[PRE3]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the `show options` command, you can see the parameters the module requires
    to run.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`show options`命令，您可以查看模块运行所需的参数。
- en: 'Let''s set the host and port to be attacked and run the module. Notice that
    this module can be run against many hosts at once by entering a list of space
    separated IP addresses and hostnames in the `RHOSTS` option:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置要攻击的主机和端口，并运行该模块。请注意，该模块可以通过在`RHOSTS`选项中输入一个以空格分隔的IP地址和主机名列表来同时运行多个主机：
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following executed script shows that the server is vulnerable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面执行的脚本显示服务器存在漏洞：
- en: '![](img/00212.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00212.jpeg)'
- en: However, no relevant information was extracted here. What went wrong?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里没有提取到相关信息。出了什么问题？
- en: 'In fact, the module extracted information from the server''s memory, but there
    are more options to set. You can use `show advanced` for Metasploit to display
    the advanced options of a module. To see the information obtained, set the `VERBOSE`
    option to `true` and run it again:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，该模块从服务器的内存中提取了信息，但还有更多的选项可以设置。您可以使用`show advanced`命令来显示Metasploit模块的高级选项。要查看获取的信息，请将`VERBOSE`选项设置为`true`并再次运行它：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have captured some information:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获取了一些信息：
- en: '![](img/00213.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00213.jpeg)'
- en: If you analyze the result, you'll find that, in this case, the server had a
    password change request in memory, and you can see the previous and current passwords
    as well as a session cookie for the user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您分析结果，您会发现在这种情况下，服务器在内存中有一个密码更改请求，并且您可以看到先前和当前的密码以及用户的会话cookie。
- en: POODLE
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POODLE
- en: '**Padding Oracle On Downgraded Legacy Encryption** (**POODLE**), as its name
    indicates, is a padding oracle attack that abuses the downgrading process from
    TLS to SSLv3.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Padding Oracle On Downgraded Legacy Encryption**（**POODLE**），顾名思义，是一种利用从TLS到SSLv3的降级过程的填充预言攻击。'
- en: Padding oracle attacks require the existence of an oracle, which means a way
    of identifying when the padding of a packet is correct. This could be as simple
    as a *padding error* response from the server. This occurs when an attacker alters
    the last byte of a valid message and the server responds with an error. When the
    message is altered and doesn't result in error, the padding was accepted for the
    value of that byte. Along with the IV, this can reveal one byte of the keystream
    and, with that, the encrypted text can be decrypted. Let's remember that IVs need
    to be sent along with the packages so that the recipient knows how to decrypt
    the information. This works very much like a blind SQL injection attack.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 填充预言攻击需要存在一个预言，也就是一种识别数据包填充是否正确的方法。这可能只是服务器返回的一个*填充错误*响应。当攻击者改变有效消息的最后一个字节时，服务器会返回一个错误。当消息被改变且没有导致错误时，填充被接受为该字节的值。通过IV，这可以揭示一个字节的密钥流，并且通过这个密钥流可以解密加密文本。需要记住的是，IV需要与数据包一起发送，以便接收者知道如何解密信息。这与盲注攻击非常相似。
- en: To achieve this, the attacker would need to achieve a man-in-the-middle position
    between the client and server and have a mechanism to make the client send the
    malicious probes. This last requirement can be achieved by making the client open
    a page that contains JavaScript code that performs that work.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，攻击者需要在客户端和服务器之间实现中间人位置，并且需要一种机制来使客户端发送恶意探测。可以通过让客户端打开包含执行此工作的JavaScript代码的页面来实现这个最后的要求。
- en: 'Kali Linux doesn''t include an out-of-the-box tool to exploit POODLE, but there
    is a **Proof of Concept** (**PoC**) to do this by Thomas Patzke on GitHub: [https://github.com/thomaspatzke/POODLEAttack](https://github.com/thomaspatzke/POODLEAttack).
    It is left to the reader to test this PoC as an exercise.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux没有包含一个开箱即用的工具来利用POODLE，但是GitHub上有一个名为Thomas Patzke的**概念验证**（**PoC**）可以实现这一点：[https://github.com/thomaspatzke/POODLEAttack](https://github.com/thomaspatzke/POODLEAttack)。读者可以自行测试这个PoC作为练习。
- en: Most of the time during web application penetration testing, it will be enough
    for you to see the SSLScan, SSLyze, or Nmap output to know if SSLv3 is allowed,
    so that a server is vulnerable to POODLE; also that no more tests are required
    to prove this fact or to convince your client to disable a protocol that has been
    superseded for nearly 20 years and most recently declared obsolete.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序渗透测试期间，通常只需要查看SSLScan、SSLyze或Nmap的输出，就可以知道是否允许使用SSLv3，从而确定服务器是否容易受到POODLE攻击；此外，不需要进行更多的测试来证明这一事实或者说服客户禁用一个已经过时近20年并且最近被宣布为废弃的协议。
- en: Although POODLE is a serious vulnerability for an encryption protocol such as
    TLS, the complexity of executing it in a real-world scenario makes it much more
    likely that an attacker will use techniques such as SSL Stripping ([https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf))
    to force a victim to browse over unencrypted protocols.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管POODLE对于像TLS这样的加密协议来说是一个严重的漏洞，但在实际场景中执行它的复杂性使得攻击者更有可能使用诸如SSL Stripping（[https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf)）之类的技术来迫使受害者浏览未加密的协议。
- en: Custom encryption protocols
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义加密协议
- en: As penetration testers, it's not uncommon to find applications where developers
    make custom implementations of standard encryption protocols or attempt to create
    their own custom algorithms. In such cases, you need to pay special attention
    to these modules, as they may contain several flaws that could prove catastrophic
    if released into production environments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员，发现开发人员对标准加密协议进行自定义实现或尝试创建自己的自定义算法并不罕见。在这种情况下，您需要特别注意这些模块，因为它们可能包含多个缺陷，如果在生产环境中发布可能会造成灾难性后果。
- en: As stated previously, encryption algorithms are created by information security
    experts and mathematicians specialized in cryptography through years of experimentation
    and testing. It is highly improbable for a single developer or small team to design
    a cryptographically strong algorithm or to improve on an intensively tested implementation
    such as OpenSSL or the established cryptographic libraries of programming languages.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如先前所述，加密算法是由信息安全专家和专门从事密码学的数学家通过多年的实验和测试创建的。对于单个开发人员或小团队来说，设计一个具有密码学强度的算法或改进像OpenSSL这样经过深入测试的实现，是非常不可能的。
- en: Identifying encrypted and hashed information
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别加密和哈希信息
- en: The first step when encountering a custom cryptographic implementation or data
    that cannot be identified as cleartext, is to define the process to which such
    data was submitted. This task is rather straightforward if the source code is
    readily accessible. In the more likely case that it isn't available, the data
    needs to be analyzed in a number of ways.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到自定义的加密实现或无法识别为明文的数据时，首先要做的是定义提交此类数据的过程。如果源代码容易获得，这个任务相当简单。更有可能的情况是源代码不可用，需要通过多种方式分析数据。
- en: Hashing algorithms
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希算法
- en: 'If the result of a process is always the same length irrespective of the amount
    of data provided, you may be facing a hashing function. To determine which function,
    you can use the length of the resulting value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个过程的结果始终是相同的长度，无论提供的数据量如何，那么您可能面临的是一个哈希函数。要确定是哪个函数，可以使用结果值的长度：
- en: '| **Function** | **Length** | **Example, hash ("Web Penetration Testing with
    Kali Linux")** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **长度** | **示例，hash ("Web Penetration Testing with Kali Linux")**
    |'
- en: '| MD5 | 16 bytes | `fbdcd5041c96ddbd82224270b57f11fc` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| MD5 | 16字节 | `fbdcd5041c96ddbd82224270b57f11fc` |'
- en: '| SHA-1 | 20 bytes | `e8dd62289bcff206905cf269c06692ef7c6938a0` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| SHA-1 | 20字节 | `e8dd62289bcff206905cf269c06692ef7c6938a0` |'
- en: '| SHA-2 (256) | 32 bytes | `dbb5195ef411019954650b6805bf66efc5fa5fef4f80a5f4afda702154ee07d3`
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| SHA-2（256）| 32字节 | `dbb5195ef411019954650b6805bf66efc5fa5fef4f80a5f4afda702154ee07d3`
    |'
- en: '| SHA-2 (512) | 64 bytes | `6f0b5c34cbd9d66132b7d3a4484f1a9af02965904de38e3e3c4e66676d9``48f20bd0b5b3ebcac9fdbd2f89b76cfde5b0a0ad9c06bccbc662be420b877c080e8fe`
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| SHA-2（512）| 64字节 | `6f0b5c34cbd9d66132b7d3a4484f1a9af02965904de38e3e3c4e66676d9``48f20bd0b5b3ebcac9fdbd2f89b76cfde5b0a0ad9c06bccbc662be420b877c080e8fe`
    |'
- en: Notice how the preceding examples represent each byte in a hexadecimal codification
    using two hexadecimal digits to represent the value of each byte (0-255). For
    clarification, the 16 bytes in the MD5 hash are fb-dc-d5-04-1c-96-dd-bd-82-22-42-70-b5-7f-11-fc.
    The eleventh byte (`42`), for example, is the decimal value 66, which is the ASCII
    letter `B`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例使用两个十六进制数字来表示每个字节的十六进制编码，以表示每个字节的值（0-255）。为了澄清，MD5哈希中的16个字节是fb-dc-d5-04-1c-96-dd-bd-82-22-42-70-b5-7f-11-fc。例如，第11个字节（`42`）是十进制值66，它是ASCII字母`B`。
- en: 'Also, it is not uncommon to find hashes in base64 encoding. For example, the
    SHA-512 hash in the preceding table could also be presented as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以base64编码形式表示哈希值也是常见的。例如，前面表格中的SHA-512哈希也可以表示为：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Base64 is an encoding technique used to represent binary data using only the
    set of printable ASCII characters, where a base64-encoded byte represents 6 bits
    from the original byte so that 3 bytes (24 bits) can be represented in base64
    with 4 ASCII printable bytes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种编码技术，它使用可打印的ASCII字符集来表示二进制数据，其中一个base64编码的字节表示原始字节的6位，以便用4个ASCII可打印字节表示3个字节（24位）。
- en: hash-identifier
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hash-identifier
- en: 'Kali Linux includes a tool called `hash-identifier`, which has a long list
    of hash patterns and is very useful to determine the type of hash involved:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux包含一个名为`hash-identifier`的工具，它有一个长列表的哈希模式，非常有用来确定所涉及的哈希类型：
- en: '![](img/00214.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00214.jpeg)'
- en: Frequency analysis
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频率分析
- en: A very useful way to tell if a set of data is encrypted, encoded, or obfuscated
    is to analyze the frequency at which each character repeats inside the data. In
    a cleartext message, say a letter for example, the ASCII characters in the alphanumeric
    range (32 to 126) will have a much higher frequency than slashes or nonprintable
    characters, such as the *Escape* (27) or *Delete* (127) keys.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一组数据是否加密、编码或混淆的一个非常有用的方法是分析数据中每个字符重复出现的频率。在明文消息中，比如一个字母，ASCII字符在字母数字范围内（32到126）的频率要比斜杠或不可打印字符（如*Escape*（27）或*Delete*（127）键）高得多。
- en: On the other hand, one would expect that an encrypted file would have a very
    similar frequency for every character from 0 to 255.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，人们预期加密文件的每个字符从0到255都具有非常相似的频率。
- en: 'This can be tested by preparing a simple set of files to compare with. Let''s
    compare a plaintext file as base with two other versions of that file: one obfuscated
    and the other encrypted. First create a plaintext file. Use `dmesg` to send the
    kernel messages to a file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过准备一组简单的文件进行比较来测试这一点。让我们将一个明文文件作为基准文件与该文件的两个其他版本进行比较：一个是混淆的，另一个是加密的。首先创建一个明文文件。使用`dmesg`将内核消息发送到文件中：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00215.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00215.jpeg)'
- en: 'You can also apply an obfuscation technique called **rotation**, which replaces
    one letter by another in a circular manner around the alphabet. We will use *ROT13*,
    rotating 13 places in the alphabet (that is, `a` will change to `n`, `b` will
    change to `o`, and so on). This can be done through programming or using sites
    such as [http://www.rot13.com/](http://www.rot13.com/):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以应用一种名为**旋转**的混淆技术，它以字母表中的循环方式将一个字母替换为另一个字母。我们将使用*ROT13*，在字母表中旋转13个位置（即，`a`将变为`n`，`b`将变为`o`，依此类推）。这可以通过编程或使用网站如[http://www.rot13.com/](http://www.rot13.com/)来完成：
- en: '![](img/00216.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00216.jpeg)'
- en: 'Next, encrypt the cleartext file using the OpenSSL command-line utility with
    the AES-256 algorithm and CBC mode:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用OpenSSL命令行工具和AES-256算法和CBC模式对明文文件进行加密：
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/00217.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00217.jpeg)'
- en: As you can see, OpenSSL's output is base64 encoded. You will need to take that
    into account when analyzing the results.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，OpenSSL的输出是base64编码的。在分析结果时，您需要考虑到这一点。
- en: 'Now, how is a frequency analysis performed on those files? We will use Python
    and the Matplotlib ([https://matplotlib.org/](https://matplotlib.org/)) library,
    preinstalled in Kali Linux, to represent graphically the character frequency for
    each file. The following script takes two command-line parameters, a file name
    and an indicator, if the file is base64 encoded (`1` or `0`), reads that file,
    and decodes it if necessary. Then, it counts the repetitions of each character
    in the ASCII space (0-255) and plots the character count:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何对这些文件进行频率分析？我们将使用Python和Matplotlib（[https://matplotlib.org/](https://matplotlib.org/)）库，在Kali
    Linux中预安装，以图形方式表示每个文件的字符频率。以下脚本接受两个命令行参数，一个文件名和一个指示器，如果文件是base64编码（`1`或`0`），则读取该文件，并在必要时解码。然后，它计算ASCII空间（0-255）中每个字符的重复次数，并绘制字符计数：
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When comparing the frequency of the plaintext (left) and ROT13 (right) files,
    you will see that there is no big difference—all characters are concentrated in
    the printable range:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较明文（左）和ROT13（右）文件的频率时，您会发现没有太大的区别-所有字符都集中在可打印范围内：
- en: '![](img/00218.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00218.jpeg)'
- en: 'On the other hand, when viewing the encrypted file''s plot, the distribution
    is much more chaotic:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，查看加密文件的图表时，分布更加混乱：
- en: '![](img/00219.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00219.jpeg)'
- en: Entropy analysis
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熵分析
- en: A definitive characteristic of encrypted information that helps to differentiate
    it from cleartext or encoding is the randomness found in the data at the character
    level. **Entropy** is a statistical measure of the randomness of a dataset.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 加密信息的一个明确特征是数据在字符级别上的随机性，这有助于将其与明文或编码区分开来。**熵**是数据集随机性的统计度量。
- en: In the case of network communications where file is storage based on the use
    of bytes formed by eight bits, the maximum level of entropy per character is eight.
    This means that all of the eight bits in such bytes are used the same number of
    times in the sample. An entropy lower than six may indicate that the sample is
    not encrypted, but is obfuscated or encoded, or that the encryption algorithm
    used may be vulnerable to cryptanalysis.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于字节的文件存储的网络通信中，每个字符的最大熵级别为八。这意味着这些字节中的所有八位在样本中被使用的次数相同。熵低于六可能表明样本未加密，而是混淆或编码，或者所使用的加密算法可能容易受到密码分析的攻击。
- en: 'In Kali Linux, you can use `ent` to calculate the entropy of a file. It is
    not preinstalled, but it can be found in the `apt` repository:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali Linux中，您可以使用`ent`计算文件的熵。它没有预装，但可以在`apt`存储库中找到：
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a PoC, let''s execute `ent` over a cleartext sample, for example, the output
    of `dmesg` (the kernel message buffer), which contains a large amount of text
    including numbers and symbols:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为PoC，让我们对一个明文样本执行`ent`，例如`dmesg`的输出（内核消息缓冲区），其中包含大量的文本，包括数字和符号：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/00220.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00220.jpeg)'
- en: 'Next, let''s encrypt the same information and calculate the entropy. In this
    example, we''ll use Blowfish with the CBC mode:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们加密相同的信息并计算熵。在这个例子中，我们将使用CBC模式的Blowfish：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/00221.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00221.jpeg)'
- en: 'Entropy is increased, but it is not as high as that for an encrypted sample.
    This may be because of the limited sample (that is, only printable ASCII characters).
    Let''s do a final test using Linux''s built-in random number generator:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 熵增加了，但不像加密样本那样高。这可能是因为样本有限（即只有可打印的ASCII字符）。让我们使用Linux内置的随机数生成器进行最后的测试：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](img/00222.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00222.jpeg)'
- en: Ideally, a strong encryption algorithm should have entropy values very close
    to eight, which would be indistinguishable from random data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，强加密算法的熵值应该非常接近八，这将与随机数据无法区分。
- en: Identifying the encryption algorithm
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别加密算法
- en: 'Once we have done frequency and entropy analyses and can tell that the data
    is encrypted, we need to identify which algorithm was used. A simple way to do
    this is to compare the length of a number of encrypted messages; consider these
    examples:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进行了频率和熵分析，并且可以确定数据已加密，我们需要确定使用了哪种算法。一种简单的方法是比较多个加密消息的长度；考虑以下示例：
- en: If the length is not consistently divisible by eight, you might be facing a
    stream cipher, with RC4 being the most popular
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果长度不能始终被八整除，您可能面临的是流密码，其中RC4是最流行的密码之一
- en: AES is a block cipher whose output's length is always divisible by 16 (128,
    192, 256, and so on)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES是一种分组密码，其输出的长度始终可以被16整除（128、192、256等）
- en: DES is also a block cipher; its output's length is always divisible by 8, but
    not always divisible by 16 (as its keystream is 56 bits)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES也是一种分组密码；其输出的长度始终可以被8整除，但不一定可以被16整除（因为其密钥流为56位）
- en: Common flaws in sensitive data storage and transmission
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏感数据存储和传输中的常见缺陷
- en: As a penetration tester, one of the important things to look for in web applications
    is how they store and transmit sensitive information. The application's owner
    could face a major security problem if data is transmitted in plaintext or stored
    that way.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员，在Web应用程序中寻找的重要事项之一是它们如何存储和传输敏感信息。如果数据以明文形式传输或存储，应用程序的所有者可能面临重大的安全问题。
- en: If sensitive information, such as passwords or credit card data, is stored in
    a database in plaintext, an attacker who exploits a SQL injection vulnerability
    or gains access to the server by any other means will be able to read such information
    and profit from it directly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果敏感信息（如密码或信用卡数据）以明文形式存储在数据库中，那么利用SQL注入漏洞或以其他方式访问服务器的攻击者将能够读取此类信息并直接从中获利。
- en: Sometimes, developers implement their own obfuscation or encryption mechanisms
    thinking that only they know the algorithm, and that nobody else will be able
    to obtain the original information without a valid key. Even though this may prevent
    the occasional random attacker from picking that application as a target, a more
    dedicated attacker, or one that can profit enough from the information, will take
    the time to understand the algorithm and break it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员会实现自己的混淆或加密机制，认为只有他们知道算法，没有其他人能够在没有有效密钥的情况下获取原始信息。尽管这可能阻止偶然的随机攻击者将该应用程序作为目标，但更专注的攻击者或者能够从信息中获得足够利益的攻击者将花时间理解算法并破解它。
- en: 'These custom encryption algorithms often involve some variant of the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义加密算法通常涉及以下变体：
- en: '**XOR**: Performing a bitwise XOR operation between the original text and some
    other text that acts like a key and is repeated enough times to fill the length
    of the text to encrypt. This is easily breakable as follows:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异或**：在原始文本和其他文本之间执行按位异或操作，该文本充当密钥，并重复足够次数以填充要加密的文本的长度。这很容易被破解，如下所示：'
- en: '[PRE14]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Substitution**: This algorithm involves the consistent replacement of one
    character with another, along all of the text. Here, frequency analysis is used
    to decrypt a text (for example, *e* is the most common letter in the English language,
    [https://en.wikipedia.org/wiki/Letter_frequency](https://en.wikipedia.org/wiki/Letter_frequency))
    or to compare the frequencies of known text and its encrypted version to deduce
    the key.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换**：该算法涉及将一个字符一致地替换为另一个字符，应用于所有文本。在这里，使用频率分析来解密文本（例如，*e*是英语中最常见的字母，[https://en.wikipedia.org/wiki/Letter_frequency](https://en.wikipedia.org/wiki/Letter_frequency)）或者比较已知文本和其加密版本的频率以推断密钥。'
- en: '**Scrambling**: This involves changing the positions of the characters. For
    scrambling to work as a way of making information recoverable, this needs to be
    done in a consistent way. This means that it can be discovered and reversed through
    analysis.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混淆**：这涉及改变字符的位置。为了使混淆成为一种可恢复信息的方式，需要以一种一致的方式进行。这意味着它可以通过分析被发现和逆转。'
- en: Another common mistake when implementing encryption in applications is storing
    the encryption keys in unsafe places, such as configuration files that can be
    downloaded from the web server's root directory or other easily accessible locations.
    More often than not, encryption keys and passwords are hardcoded in source files,
    even in the client-side code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中实现加密时，另一个常见错误是将加密密钥存储在不安全的位置，例如可以从Web服务器的根目录或其他易于访问的位置下载的配置文件中。往往加密密钥和密码都是硬编码在源文件中，甚至在客户端代码中也是如此。
- en: Today's computers are much more powerful than those of 10-20 years ago. Thus,
    some algorithms considered cryptographically strong in the past may reasonably
    be broken in a few hours or days, in light of modern CPUs and GPUs. It is not
    uncommon to find information encrypted using DES or passwords hashed with MD5,
    even when those algorithms can be cracked in few minutes, using current technology.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的计算机比10-20年前的计算机更强大。因此，一些在过去被认为是密码学强大的算法可能在几个小时或几天内被破解，考虑到现代CPU和GPU的性能。即使这些算法可以在几分钟内被破解，使用DES加密的信息或使用MD5散列的密码仍然很常见，这在当前技术下可以被破解。
- en: 'Finally, though perhaps the most common flaw around, especially in encrypted
    storage, is the use of weak passwords and keys to protect information. An analysis
    made on passwords found in recent leaks tells us that the most used passwords
    are as follows (refer to [https://13639-presscdn-0-80-pagely.netdna-ssl.com/wp-content/uploads/2017/12/Top-100-Worst-Passwords-of-2017a.pdf](https://13639-presscdn-0-80-pagely.netdna-ssl.com/wp-content/uploads/2017/12/Top-100-Worst-Passwords-of-2017a.pdf)):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管在加密存储中尤其如此，但最常见的缺陷是使用弱密码和密钥来保护信息。对最近泄露的密码进行的分析告诉我们，最常用的密码如下（参考[https://13639-presscdn-0-80-pagely.netdna-ssl.com/wp-content/uploads/2017/12/Top-100-Worst-Passwords-of-2017a.pdf](https://13639-presscdn-0-80-pagely.netdna-ssl.com/wp-content/uploads/2017/12/Top-100-Worst-Passwords-of-2017a.pdf)）：
- en: '`123456`'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`123456`'
- en: '`password`'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`password`'
- en: '`12345678`'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`12345678`'
- en: '`qwerty`'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`qwerty`'
- en: '`12345`'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`12345`'
- en: '`123456789`'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`123456789`'
- en: '`letmein`'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`letmein`'
- en: '`1234567`'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1234567`'
- en: '`football`'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`football`'
- en: '`iloveyou`'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iloveyou`'
- en: '`admin`'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`admin`'
- en: '`welcome`'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`welcome`'
- en: Using offline cracking tools
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用离线破解工具
- en: 'If you are able to retrieve encrypted information from the application, you
    may want to test the strength of the encryption and how effective the key is,
    which is protecting the information. To do this, Kali Linux includes two of the
    most popular and effective offline cracking tools: John the Ripper and Hashcat.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够从应用程序中检索加密信息，您可能希望测试加密的强度以及密钥的有效性，即保护信息的能力。为此，Kali Linux包含了两个最受欢迎和有效的离线破解工具：John
    the Ripper和Hashcat。
- en: In [Chapter 5](part0198.html#5SQFC0-d48f8b63a8cc440fbc92835fec01cc38), *Detecting
    and Exploiting Injection-Based Flaws*, in the *Extracting data with SQL Injection*
    section, we extracted a list of usernames and hashes. Here, we will use John the
    Ripper (or simply John) and Hashcat to try and retrieve the passwords corresponding
    to those hashes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0198.html#5SQFC0-d48f8b63a8cc440fbc92835fec01cc38)中的*检测和利用基于注入的漏洞*一节中，我们提取了一组用户名和哈希值。在这里，我们将使用John
    the Ripper（或简称为John）和Hashcat尝试检索与这些哈希值对应的密码。
- en: 'First, retrieve the hashes and usernames in a file in a `username:hash` format,
    such as the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以`username:hash`格式将哈希值和用户名检索到一个文件中，例如以下内容：
- en: '[PRE15]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using John the Ripper
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用John the Ripper
- en: 'John the Ripper is preinstalled in Kali Linux, and its use is pretty straightforward.
    You can just type `john` to see its basic use:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: John the Ripper已经预装在Kali Linux中，使用非常简单。您只需键入`john`即可查看其基本用法：
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/00223.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00223.jpeg)'
- en: If you just use the command and filename as a parameter, John will try to identify
    the kind of encryption or hashing used in the file, attempt a dictionary attack
    with its default dictionaries, and then go into brute force mode and try all possible
    character combinations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只使用命令和文件名作为参数，John将尝试识别文件中使用的加密或哈希类型，尝试使用其默认字典进行字典攻击，然后进入暴力破解模式并尝试所有可能的字符组合。
- en: 'Let''s do a dictionary attack using the RockYou wordlist included in Kali Linux.
    In the latest versions of Kali Linux, this list comes compressed using GZIP; so
    you will need to decompress it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Kali Linux中包含的RockYou字典进行字典攻击。在Kali Linux的最新版本中，该列表使用GZIP进行压缩；因此您需要对其进行解压缩：
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/00224.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00224.jpeg)'
- en: 'Now you can run John to crack the collected hashes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行John来破解收集到的哈希值：
- en: '[PRE18]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/00225.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00225.jpeg)'
- en: Notice the use of the format parameter. As mentioned earlier, John can try to
    guess the format of the hashes. We already know the hashing algorithm used in
    DVWA and can take advantage of that knowledge to make the attack more precise.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用格式参数。如前所述，John可以尝试猜测哈希的格式。我们已经知道DVWA中使用的哈希算法，并可以利用这些知识使攻击更加精确。
- en: Using Hashcat
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hashcat
- en: In recent versions, Hashcat has merged its two variants (CPU and GPU-based)
    into one, and that is how it's found in Kali Linux. If you are using Kali Linux
    in a virtual machine, as we are in the version used for this book, you may not
    be able to use the full power of GPU cracking, which takes advantage of the parallel
    processing of graphics cards. However, Hashcat will still work in CPU mode.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本中，Hashcat已将其两个变体（基于CPU和GPU的）合并为一个，并且在Kali Linux中可以找到。如果您在虚拟机中使用Kali Linux，就像我们在本书中使用的版本一样，您可能无法使用GPU破解的全部功能，该功能利用了图形卡的并行处理。但是，Hashcat仍然可以在CPU模式下工作。
- en: 'To crack the file using the RockYou dictionary in Hashcat, issue the following
    command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用RockYou字典在Hashcat中破解文件，使用以下命令：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**![](img/00226.jpeg)**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00226.jpeg)**'
- en: 'The parameters used here are as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的参数如下：
- en: '`-m 0`: `0` (zero) is the identifier for the MD5 hashing algorithm'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m 0`：`0`（零）是MD5哈希算法的标识符'
- en: '`--force`: This option forces Hashcat to run even when no GPU devices are found,
    this is useful to run Hashcat inside the virtual machine'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force`：此选项强制Hashcat在找不到GPU设备时运行，这对于在虚拟机中运行Hashcat很有用'
- en: '`--username`: This tells Hashcat that the input file contains not only hashes
    but also usernames; it expects the `username:hash` format'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--username`: 这告诉Hashcat输入文件不仅包含哈希值，还包含用户名；它期望的格式是`username:hash`'
- en: The first filename is always the file to crack, and the next one is the dictionary
    to use
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个文件名始终是要破解的文件，下一个文件名是要使用的字典
- en: 'After a few seconds, you will see the results:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您将看到结果：
- en: '![](img/00227.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00227.jpeg)'
- en: 'To see all of the options and algorithms supported, use the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有支持的选项和算法，请使用以下命令：
- en: '[PRE20]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Preventing flaws in cryptographic implementations
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防加密实现中的缺陷
- en: For HTTPS communication, disable all deprecated protocols, such as any version
    of SSL and even TLS 1.0 and 1.1\. The last two need to be taken into consideration
    for the target users of the application, as TLS 1.2 may not be fully supported
    by older browsers or systems. Also, disabling weak encryption algorithms, such
    as DES and MD5 hashing, and modes, such as ECB, must be considered.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTPS通信，请禁用所有已弃用的协议，例如任何版本的SSL，甚至是TLS 1.0和1.1。最后两个需要考虑到应用程序的目标用户，因为TLS 1.2可能不被旧浏览器或系统完全支持。此外，禁用弱加密算法（如DES和MD5哈希）和模式（如ECB）也必须考虑。
- en: Furthermore, the responses of applications must include the secure flag in cookies
    and the **HTTP Strict-Transport-Security** (**HSTS**) header to prevent SSL Strip
    attacks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应用程序的响应必须在cookie中包含安全标志和**HTTP Strict-Transport-Security**（**HSTS**）头，以防止SSL剥离攻击。
- en: More information about TLS configuration can be found at [https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet](https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关TLS配置的更多信息，请访问[https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet](https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet)。
- en: Passwords must never be stored in cleartext, and it's inadvisable to use encryption
    algorithms to protect them. Rather, a one-way, salted hash function should be
    used. PBKDF2, bcrypt, and SHA-512 are the recommended alternatives. Use of MD5
    is discouraged, as modern GPUs can calculate millions of MD5 hashes per second,
    making it possible to crack any password of less than ten characters in a few
    hours or days with a high-end computer. OWASP also has a useful cheat sheet on
    this subject at [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 密码绝不能以明文形式存储，并且不建议使用加密算法来保护它们。相反，应使用单向的、加盐的哈希函数。PBKDF2、bcrypt和SHA-512是推荐的替代方案。不建议使用MD5，因为现代GPU可以每秒计算数百万个MD5哈希，这使得在几个小时或几天内使用高端计算机破解少于十个字符的任何密码成为可能。OWASP还在这个主题上提供了一个有用的备忘单，网址为[https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet)。
- en: For storing sensitive information that needs to be recoverable, such as payment
    information, use strong encryption algorithms. AES-256, Blowfish, and Twofish
    are good alternatives. If asymmetric encryption, such as RSA, is an option, you
    should prefer that ([https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet)).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要可恢复的敏感信息（如付款信息）的存储，使用强加密算法。AES-256、Blowfish和Twofish是不错的选择。如果对称加密（如RSA）是一个选项，应优先考虑它（[https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet)）。
- en: Avoid using custom implementations or creating custom algorithms. It is much
    better to rely on what has already been used, tested, and attacked multiple times.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用自定义实现或创建自定义算法。更好的做法是依赖已经被使用、测试和多次攻击的内容。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the basic concepts of cryptography, such as symmetric
    and asymmetric encryption, stream and block ciphers, hashing, encoding, and obfuscation.
    You learned how secure communication works in the HTTPS protocol and how to identify
    vulnerabilities in its implementation and configuration. Then we examined the
    common flaws found in the storage of sensitive information and the creation of
    custom encryption algorithms.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了密码学的基本概念，如对称和非对称加密、流密码和块密码、哈希、编码和混淆。您了解了HTTPS协议中安全通信的工作原理以及如何识别其实施和配置中的漏洞。然后，我们研究了在敏感信息存储和自定义加密算法创建中常见的缺陷。
- en: We concluded this chapter with comments on how to prevent such flaws and how
    to make web applications more secure when transmitting and storing sensitive information.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中总结了如何防止此类缺陷以及如何在传输和存储敏感信息时使Web应用程序更安全的方法。
- en: In the next chapter we will learn about AJAX and HTML5 and the challenges and
    opportunities they pose from the security and penetration testing perspective,
    especially when it comes to client-side code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习有关AJAX和HTML5的知识，以及它们从安全和渗透测试的角度带来的挑战和机遇，特别是涉及客户端代码时。
