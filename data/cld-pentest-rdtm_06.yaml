- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Pentesting Containerized Applications in AWS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 中渗透测试容器化应用
- en: One of the most common use cases for cloud networks is the deployment of containerized
    applications. Over the course of your career as a cloud pentester, the likelihood
    that you’ll need to test in containerized environments is very high.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 云网络的最常见应用之一是容器化应用的部署。在你的云渗透测试职业生涯中，你需要在容器化环境中进行测试的可能性非常高。
- en: The popular containerization platforms, Docker and Kubernetes, operate the same
    way within their containerization systems regardless of whether they’re deployed
    in AWS, GCP, Azure, or any other cloud platform. However, the way AWS, GCP, and
    Azure interface with Docker and Kubernetes is a little bit different in each instance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的容器化平台 Docker 和 Kubernetes，在它们的容器化系统内的操作方式是相同的，无论它们是在 AWS、GCP、Azure 还是任何其他云平台上部署。然而，AWS、GCP
    和 Azure 与 Docker 和 Kubernetes 的接口方式在每个实例中都有些不同。
- en: Think of it this way. A slice of buttered toast is the same slice of buttered
    toast whether it’s served on a ceramic dish, an aluminum dish, or a paper dish.
    The toast will taste the same, and you will eat it the same way regardless of
    what kind of dish it’s served on. But after you eat the toast, the way you clean
    or dispose of the dish will be different.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样理解。无论是放在陶瓷盘、铝盘还是纸盘里，一片涂了黄油的烤面包都是同一片涂了黄油的烤面包。无论它放在哪种盘子里，味道都一样，你吃的方式也一样。但在你吃完面包后，清理或处置盘子的方式将会有所不同。
- en: Hopefully, that makes sense! Well, it will make more sense once you’ve read
    this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能让你明白！嗯，等你读完这一章后，你会更能理解它。
- en: 'In this chapter, I will explain the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将解释以下内容：
- en: How containerization works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化如何工作
- en: How Docker works in AWS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 在 AWS 中的工作原理
- en: How Kubernetes works in AWS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 在 AWS 中的工作原理
- en: Docker and Kubernetes pentesting techniques in AWS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AWS 中的 Docker 和 Kubernetes 渗透测试技术
- en: Let’s get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The wonderful thing about using AWS, whether for containerization or anything
    else, is that we get to use the computing power of Amazon’s infrastructure. That
    means you don’t need a really high-end workstation to do any of the exercises
    in this chapter. All you need is the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 的一个好处，无论是用于容器化还是其他任何事情，就是我们能够使用亚马逊基础设施的计算能力。这意味着你不需要一台非常高端的工作站就可以进行本章中的任何练习。你只需要以下这些：
- en: A modern desktop or laptop PC running Windows, macOS, or a common Linux distribution
    such as Ubuntu or Debian. A MacBook or a Windows 11 OEM PC with at least 4 GB
    of RAM works great.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Windows、macOS 或常见 Linux 发行版（如 Ubuntu 或 Debian）的现代桌面或笔记本电脑。一台至少配备 4 GB RAM
    的 MacBook 或 Windows 11 OEM PC 就非常适合。
- en: A well-supported web browser such as Safari 15 or later, Microsoft Edge 83 or
    later, Mozilla Firefox 105 or later, or Google Chrome 115 or later.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个良好支持的网页浏览器，如 Safari 15 或更高版本、Microsoft Edge 83 或更高版本、Mozilla Firefox 105 或更高版本，或
    Google Chrome 115 或更高版本。
- en: A reliable internet connection.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接。
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/46VJSp3](https://bit.ly/46VJSp3)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以观看代码演示：[https://bit.ly/46VJSp3](https://bit.ly/46VJSp3)
- en: How containerization works
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化如何工作
- en: First, there were **virtual machines** (**VMs**). VMs run inside a host operating
    system, and the host operating system is what runs directly on computer hardware.
    As far as the host operating system is concerned, the VM is simply an application
    it’s running that has been allocated a certain amount of memory (RAM) and a certain
    amount of disk space in the form of a virtual disk. VMware and Oracle VirtualBox
    both make virtualization clients that you can easily run and install on a Windows,
    Mac, or Linux PC. With those virtualization clients, you can make a VM that runs
    most versions of Windows, macOS, Linux, or Unix.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有了**虚拟机**（**VMs**）。虚拟机运行在宿主操作系统内，而宿主操作系统直接在计算机硬件上运行。就宿主操作系统而言，虚拟机只是一个它正在运行的应用程序，该应用程序分配了一定数量的内存（RAM）和磁盘空间（以虚拟磁盘的形式）。VMware
    和 Oracle VirtualBox 都提供虚拟化客户端，你可以轻松地在 Windows、Mac 或 Linux PC 上运行和安装这些客户端。使用这些虚拟化客户端，你可以创建一个虚拟机来运行大多数版本的
    Windows、macOS、Linux 或 Unix。
- en: There is a plethora of use cases for VMs. My background is in cybersecurity,
    so the use case I’m most familiar with is malware testing. I can safely execute
    malware in a VM without harming the host operating system or its hardware. That’s
    because the VM assures that the virtual operating system is “sandboxed” from the
    host operating system. In a worst-case scenario where the malware in my virtual
    operating system makes my virtual operating system impossible to boot properly,
    I can go into my host operating system to uninstall the VM and delete its virtual
    disk. Then, I can make a new VM and start all over again.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机有着大量的应用场景。我的背景是网络安全，所以我最熟悉的应用场景是恶意软件测试。我可以在虚拟机中安全地执行恶意软件，而不会对主机操作系统或其硬件造成损害。这是因为虚拟机确保虚拟操作系统与主机操作系统“沙盒化”隔离。在最坏的情况下，如果我的虚拟操作系统中的恶意软件导致虚拟操作系统无法正常启动，我可以进入主机操作系统，卸载虚拟机并删除其虚拟磁盘。然后，我可以创建一个新的虚拟机，重新开始。
- en: An analogy I often hear about host computers and VMs is “a computer and its
    pet computer.” But basically, the host operating system just treats the VM as
    any other sort of application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常听到的关于主机计算机和虚拟机的类比是“计算机和它的宠物计算机”。但基本上，主机操作系统只是将虚拟机当作任何其他类型的应用程序来对待。
- en: Virtualization has been possible in computing for a lot longer than people often
    think. The earliest cases of computer virtualization were found in the late 1960s
    and early 1970s on IBM mainframe computers. Timesharing systems were common on
    mainframes and minicomputers of the era because people didn’t own their own computers
    until PCs were invented.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机虚拟化的实现比人们通常认为的要早得多。最早的计算机虚拟化案例出现在1960年代末和1970年代初的 IBM 大型机上。时代共享系统在当时的主机和小型计算机上很常见，因为直到个人计算机发明之前，人们并没有自己的计算机。
- en: Until the advent of PCs, all computers were shared with multiple people. IBM
    invented virtualization techniques so that multiple users in a timesharing system
    could have a layer of abstraction from the CPU, memory, and disk storage. Each
    user could have their own virtualized computer that could allocate the host computer’s
    real hardware resources without affecting what the other users were doing on the
    same host computer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 直到个人计算机的出现之前，所有计算机都是多人共享的。IBM 发明了虚拟化技术，使得在时代共享系统中的多个用户能够从 CPU、内存和磁盘存储中获得一层抽象。每个用户都可以拥有自己虚拟化的计算机，可以分配主机计算机的真实硬件资源，而不会影响其他用户在同一主机计算机上进行的操作。
- en: As with everything else in computer technology, over the past few decades, virtualization
    has gotten better and better. *Containerization is a similar concept to VMs, but
    it’s not exactly the same thing.* However, progress in the development of virtualization
    technology is what made the invention of containerization possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如计算机技术中的其他一切一样，在过去的几十年中，虚拟化技术变得越来越成熟。*容器化是与虚拟机类似的概念，但并不完全相同*。然而，虚拟化技术的发展进步使得容器化的发明成为可能。
- en: In a nutshell, containerization is similar to VMs, *but much more lightweight*.
    If a VM is a house made of bricks, wood, stone, or concrete, a container is a
    tent that can quickly be erected and taken down as needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，容器化类似于虚拟机，*但更为轻量级*。如果虚拟机是一座由砖块、木材、石头或混凝土建成的房子，那么容器就是一个可以根据需要迅速搭建和拆卸的帐篷。
- en: VMs can be created and removed as needed. But installing and removing a VM isn’t
    an instantaneous process. To install a macOS VM on my Windows PC with Oracle VirtualBox,
    I still need to go through macOS’s installation process for each new macOS VM.
    That takes at least multiple minutes each time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机可以根据需要创建和删除。但安装和删除虚拟机并非即时的过程。要在我的 Windows 电脑上使用 Oracle VirtualBox 安装 macOS
    虚拟机，我仍然需要为每一个新的 macOS 虚拟机经历 macOS 的安装过程。每次至少需要几分钟。
- en: Docker and Kubernetes are both containerization orchestration platforms. Docker
    and Kubernetes have their own systems for allocating hardware resources, load
    balancing, and process isolation. Setting up a Docker or Kubernetes containerization
    orchestration system for the first time does take several minutes for installation
    and configuration. However, once the Docker or Kubernetes containerization orchestration
    system is ready, containers can be deployed and removed very quickly. And if your
    AWS services give you enough disk space and network bandwidth, you could possibly
    run hundreds of containers under the same orchestration platform at any given
    time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Kubernetes 都是容器化编排平台。Docker 和 Kubernetes 各自拥有分配硬件资源、负载均衡和进程隔离的系统。第一次设置
    Docker 或 Kubernetes 容器化编排系统时，确实需要几分钟的安装和配置时间。然而，一旦 Docker 或 Kubernetes 容器化编排系统准备就绪，容器就可以非常快速地部署和移除。如果你的
    AWS 服务提供足够的磁盘空间和网络带宽，你甚至可以在同一个编排平台下同时运行数百个容器。
- en: Your cloud application will immediately benefit from the scalability and efficiency
    containerization gives it. In typical cloud containerization deployments, containers
    are deployed and removed constantly according to an application’s needs at any
    given time. Sometimes, an individual container may only exist for a few days or
    less.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你的云应用将立即受益于容器化所带来的可扩展性和效率。在典型的云容器化部署中，容器会根据应用程序在任意时刻的需求不断地被部署和移除。有时，某个容器可能只会存在几天或更短时间。
- en: Docker was the first containerization platform to become widely popular. Docker
    debuted in 2013, and it made containerization easier than ever for developers,
    enterprises, and hobbyists alike. The Kubernetes team was inspired by Docker,
    and the first version of Kubernetes was released in 2014.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是第一个广泛流行的容器化平台。Docker 于2013年首次亮相，它使得容器化对开发者、企业和爱好者来说比以往任何时候都更容易。Kubernetes
    团队受到 Docker 的启发，Kubernetes 的第一个版本于2014年发布。
- en: VMs can run on PCs, server machines, and in cloud environments alike. But although
    applications such as Docker Desktop make it possible to test multi-container applications
    locally, containerization was really made for the cloud.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机（VM）可以在个人电脑、服务器和云环境中运行。然而，尽管像 Docker Desktop 这样的应用程序使得可以在本地测试多容器应用，容器化技术实际上是为云环境而设计的。
- en: Cloud platforms such as AWS, Azure, and GCP provide organizations with hardware
    and networking scalability because Amazon, Microsoft, and Google operate lots
    of massive data centers on every part of the globe (except for Antarctica) that
    contain millions of server machines and really high-capacity networking infrastructure.
    If an organization needs the capacity of a dozen server machines one day and several
    hundred server machines the next, Amazon, Microsoft, and Google can provide it
    almost instantly for the right amount of money. No hardware resources are wasted,
    and the allocation of hardware resources can be responsive and dynamic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AWS、Azure 和 GCP 等云平台为组织提供了硬件和网络的可扩展性，因为亚马逊、微软和谷歌在全球各地（除了南极洲）运营着大量的庞大数据中心，这些数据中心包含数百万台服务器和极高容量的网络基础设施。如果一个组织一天需要十几台服务器，第二天需要几百台服务器，亚马逊、微软和谷歌几乎可以立即以合适的费用提供这些资源。没有硬件资源被浪费，硬件资源的分配可以灵活且动态地进行。
- en: Thus, containerization is designed to work in the context of cloud environments.
    The cloud platform allocates hardware resources at the macro level, and the containerization
    platform allocates hardware resources at the micro level.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器化技术是为云环境中的应用场景而设计的。云平台在宏观层面分配硬件资源，而容器化平台则在微观层面分配硬件资源。
- en: Developers really like containerization because they can design their software
    to run inside a particular container configuration without having to worry about
    hardware compatibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者非常喜欢容器化技术，因为他们可以设计自己的软件运行在特定的容器配置中，而不必担心硬件兼容性问题。
- en: A container bundles application code with simply the dependencies, libraries,
    and configuration files it needs to run, whereas if they developed their code
    for a VM or a host computer, they’d have to worry about the operating system.
    And if their code was designed to run directly on a host computer, they’d have
    to know its CPU and hardware specifications. When done properly, containerization
    saves developers a lot of frustration. So, their time and energy can be focused
    on making the application better rather than having to waste time troubleshooting
    hardware and operating system problems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将应用程序代码与它运行所需的依赖项、库和配置文件捆绑在一起，而如果他们为虚拟机或主机计算机开发代码，则必须关注操作系统。如果他们的代码是为了直接在主机计算机上运行而设计的，他们还需要了解其
    CPU 和硬件规格。当容器化正确执行时，它能大大减少开发者的挫败感。因此，他们的时间和精力可以集中在改进应用程序上，而不必浪费时间解决硬件和操作系统的问题。
- en: It’s possible to use AWS without containerization. In the previous chapter,
    I installed a Linux operating system directly in AWS in order to produce that
    chapter’s *Code In Action* videos. When I used Prowler, it was vulnerability scanning
    a very simple Linux-in-AWS setup. If an AWS customer just needs one or a few servers
    that they’ll maintain on a constant basis, simply using an operating system directly
    in AWS can fulfill their needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 而不进行容器化是可能的。在上一章中，我直接在 AWS 中安装了 Linux 操作系统，以制作那一章的 *Code In Action* 视频。当我使用
    Prowler 时，它是在扫描一个非常简单的 Linux-in-AWS 设置的漏洞。如果一个 AWS 客户只需要一个或几个他们会持续维护的服务器，直接在 AWS
    中使用操作系统就能满足他们的需求。
- en: However, many AWS customers need to deploy applications that could have thousands—or
    sometimes even hundreds of thousands—of users at any given time. In those situations,
    containerization is by far the most practical choice. Cloud platforms help make
    containerization possible. So, as a pentester, it’s important that you understand
    how to pentest Docker and Kubernetes deployments effectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多 AWS 客户需要部署可能在任何时间都有成千上万，甚至数十万用户的应用程序。在这种情况下，容器化无疑是最实际的选择。云平台帮助实现容器化。因此，作为渗透测试人员，了解如何有效地对
    Docker 和 Kubernetes 部署进行渗透测试是很重要的。
- en: How Docker works in AWS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 在 AWS 中的工作原理
- en: 'The layers in a Docker containerization system look like this, from the bottom
    to the top:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器化系统中的层次结构如下，从底部到顶部：
- en: AWS, Azure, or GCP is the cloud platform.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS、Azure 或 GCP 是云平台。
- en: The cloud platform runs a service, such as **Amazon Elastic Container Service**
    (**Amazon ECS**), that supports the Docker host. The Docker host is a server,
    and the administrator administrates it through their Docker client on their local
    computer.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台运行一个支持 Docker 主机的服务，比如 **Amazon Elastic Container Service** (**Amazon ECS**)。Docker
    主机是一个服务器，管理员通过他们本地计算机上的 Docker 客户端进行管理。
- en: The Docker host runs the Docker daemon, which manages Docker images. The daemon
    can also download images from the Docker Registry. The registry can be the remote
    public Docker Hub or the organization’s own private registry. The daemon also
    handles API requests.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 主机运行 Docker 守护进程，管理 Docker 镜像。守护进程还可以从 Docker 注册中心下载镜像。注册中心可以是远程的公共 Docker
    Hub，也可以是组织自己的私有注册中心。守护进程还处理 API 请求。
- en: Docker images are instructions for creating Docker containers. Containers are
    generated from the images.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像是创建 Docker 容器的指令。容器是从镜像生成的。
- en: 'Here’s an example of what a Docker architecture looks like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Docker 架构的示例：
- en: '![Figure 6.1 – Docker architecture](image/B18672_06_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – Docker 架构](image/B18672_06_01.jpg)'
- en: Figure 6.1 – Docker architecture
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Docker 架构
- en: Docker deployments in AWS use **Amazon Elastic Compute Cloud** (**Amazon EC2**)
    because that’s the main compute platform.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 中的 Docker 部署使用 **Amazon Elastic Compute Cloud** (**Amazon EC2**)，因为那是主要的计算平台。
- en: Amazon ECS is the primary service to run Docker in AWS, regardless of the size
    and scale of your Docker deployment. Amazon ECS is the service you’ll be working
    with directly. It handles the Amazon EC2 work for you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECS 是在 AWS 中运行 Docker 的主要服务，无论 Docker 部署的大小和规模如何。Amazon ECS 是你直接使用的服务，它为你处理
    Amazon EC2 的工作。
- en: 'There are two common ways to install Docker in AWS:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 中安装 Docker 有两种常见方法：
- en: If you prefer to install Docker with the help of a **graphical user interface**
    (**GUI**), you can do so with AWS’s web application.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你更喜欢通过 **图形用户界面** (**GUI**) 安装 Docker，你可以通过 AWS 的 Web 应用程序实现。
- en: Alternatively, if you prefer to work with a **command-line interface** (**CLI**)
    as much as possible or if you’d like to use Docker Desktop to test your containerization
    system locally in addition to deploying it on AWS, you can use the Docker Compose
    CLI to install Docker in AWS. You may need to install the Docker Compose plugin
    if it’s not already included in your version of Docker Desktop. Read the instructions
    in *Docker Docs* at [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢尽可能使用**命令行界面**（**CLI**），或者如果你希望在 AWS 上部署 Docker 之外，还可以使用 Docker Desktop
    在本地测试你的容器化系统，你可以使用 Docker Compose CLI 在 AWS 上安装 Docker。如果你的 Docker Desktop 版本中没有包含
    Docker Compose 插件，可能需要安装它。请参阅 *Docker 文档*，链接：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)。
- en: Whichever way you choose to install Docker, you can still use your choice of
    compatible GUI and CLI applications to use, administrate, and configure your Docker
    deployment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式安装 Docker，你仍然可以使用你选择的兼容 GUI 和 CLI 应用程序来使用、管理和配置 Docker 部署。
- en: Installing a Docker cluster in AWS with Amazon ECS
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 AWS 上使用 Amazon ECS 安装 Docker 集群
- en: 'First, I’ll walk you through installing a Docker cluster through AWS’s web
    application GUI:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将带你通过 AWS 的网页应用程序 GUI 安装 Docker 集群：
- en: Step one is to launch the Amazon ECS first-run wizard. Log in to your AWS account
    through your web browser, and the wizard will make launching Amazon ECS and deploying
    Docker easy.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是启动 Amazon ECS 首次运行向导。通过网页浏览器登录到你的 AWS 账户，向导会让你轻松启动 Amazon ECS 并部署 Docker。
- en: In AWS’s web interface, I like to navigate between different AWS services and
    applications by searching for them by name with the search bar on the top AWS
    application menu. Search for **Amazon ECS**, click on **Elastic Container Service**,
    and you’ll get to the correct screen quickly.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 的网页界面中，我喜欢通过在顶部的 AWS 应用程序菜单的搜索栏中搜索服务和应用程序的名称来进行导航。搜索**Amazon ECS**，点击**弹性容器服务**，你就能快速到达正确的页面。
- en: On the right side, there’s a white box that says **Deploy your containerized
    applications**. Click on the orange **Get** **started** button.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，有一个白色的框框，上面写着**部署你的容器化应用程序**。点击橙色的**开始**按钮。
- en: You’ll be presented with a page that says **Clusters**. Click on the orange
    button in the top-right corner that says **Create cluster**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面上会显示**集群**，点击右上角的橙色按钮，按钮上写着**创建集群**。
- en: Under **Cluster configuration**, give your cluster a name. I chose **AWS-Docker-Test**,
    but you can choose any name you’d like that’s valid.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**集群配置**下，给你的集群命名。我选择了**AWS-Docker-Test**，但你可以选择任何有效的名称。
- en: Under **Networking**, leave the default **virtual private cloud** (**VPC**),
    subnets, and namespace as they are.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**网络**下，保持默认的**虚拟私有云**（**VPC**）、子网和命名空间设置。
- en: Under **Infrastructure**, leave the default **AWS Fargate (serverless)** setting
    as it is. That’s the easiest way to have Amazon ECS allocate the hardware resources
    for your Docker deployment.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**基础设施**下，保持默认的**AWS Fargate（无服务器）**设置。这是让 Amazon ECS 为你的 Docker 部署分配硬件资源的最简单方式。
- en: Likewise, leave the **Monitoring** and **Tags** sections as they are. In the
    lower-right corner, click on the orange **Create** button.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，保持**监控**和**标签**部分的默认设置。在右下角，点击橙色的**创建**按钮。
- en: A blue bar will appear near the top that says cluster creation is in process.
    It could take a few minutes. If all goes well, the blue bar will become green
    and say that the cluster was created successfully. If not, repeat the steps I
    walked you through and try again. When I tested the cluster creation process myself,
    my first attempt returned a red bar that said the creation process failed. But
    on my second attempt, I was successful.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顶部会出现一条蓝色进度条，显示集群创建正在进行中。可能需要几分钟。如果一切顺利，进度条会变成绿色，并显示集群创建成功。如果没有，请重复我带你走过的步骤再试一次。当我自己测试集群创建过程时，第一次尝试返回了一个红色进度条，显示创建过程失败。但第二次尝试成功了。
- en: Now that your cluster was created successfully, you can see the name of your
    new cluster in the list. Click on the name of your cluster.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你的集群已成功创建，你可以在列表中看到新集群的名称。点击集群的名称。
- en: 'You’ll be taken to a new page with the name of your cluster (**AWS-Docker-Test**,
    in my case) at the top. The first section underneath says **Cluster overview**,
    and the next section has six tabs: **Services**, **Tasks**, **Infrastructure**,
    **Metrics**, **Scheduled tasks**, and **Tags**. Under the **Services** tab, click
    on the orange **Create** button in the upper-right corner.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被带到一个新页面，页面顶部会显示您的集群名称（在我的例子中是**AWS-Docker-Test**）。页面下方的第一部分显示**集群概览**，接下来的部分有六个选项卡：**服务**、**任务**、**基础设施**、**指标**、**定时任务**和**标签**。在**服务**选项卡下，点击右上角的橙色**创建**按钮。
- en: On the next page, leave all the default settings in the **Environment** section.
    In the **Deployment configuration** section, leave **Service** as the application
    type. Under that, you’ll see a **Task definition** area where it says **Select
    an existing task definition**. To create a new task definition, go to **Task definitions**,
    and click on **Go to** **Task definitions**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页面中，保持**环境**部分的所有默认设置。在**部署配置**部分，将**应用类型**保留为**服务**。在下方，您将看到一个**任务定义**区域，其中写着**选择现有任务定义**。要创建新的任务定义，请转到**任务定义**，然后点击**转到**任务定义**。
- en: A new page will load in a new tab in your web browser. On the **Task definitions**
    page, click on the orange **Create new task definition** button in the upper-right
    corner. Under **Configure task definition and containers**, give your task definition
    family a name. I chose **Docker-Test-Task-Definition** because I’m so imaginative.
    But you can create whatever name you’d like.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新页面将会在您的网页浏览器的新标签页中加载。在**任务定义**页面中，点击右上角的橙色**创建新任务定义**按钮。在**配置任务定义和容器**部分，给您的任务定义家族命名。我选择了**Docker-Test-Task-Definition**，因为我真是太有创意了。但您可以创建任何您喜欢的名称。
- en: Under **Container – 1**, name your container (I chose **Docker-Container-Test**).
    You will also need to enter an image URI (go to [https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html)
    in the AWS documentation to learn how to select a base image URI if you need help).
    In my case, I’m using Amazon’s **us-east-1** data center. So, my image URI is
    **711395599931.dkr.ecr.us-east-1.amazonaws.com/spark/emr-6.10.0:latest**. Leave
    all the other default settings as they are. Click on the orange **Create** button
    in the lower-right corner.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**容器 - 1**下，给您的容器命名（我选择了**Docker-Container-Test**）。您还需要输入一个镜像 URI（如果需要帮助，可以访问
    [https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html)
    了解如何选择基础镜像 URI）。在我的情况下，我使用的是亚马逊的**us-east-1**数据中心。所以，我的镜像 URI 是 **711395599931.dkr.ecr.us-east-1.amazonaws.com/spark/emr-6.10.0:latest**。将所有其他默认设置保持不变。点击右下角的橙色**创建**按钮。
- en: Under **Family**, enter your new task definition name (mine is **Docker-Test-Task-Definition**).
    Leave **Revision** as is. Create a new name under **Service name**. I chose **Docker-Test-Service**.
    Leave all the other default settings as they are. Click on the orange **Create**
    button in the lower-right corner.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**家族**下，输入您的新任务定义名称（我的名称是**Docker-Test-Task-Definition**）。将**修订版**保持不变。在**服务名称**下创建一个新名称。我选择了**Docker-Test-Service**。将其他所有默认设置保留不变。点击右下角的橙色**创建**按钮。
- en: The deployment of your new service may take a few minutes, as indicated in the
    blue notification at the top of your screen. All services deployed the way I showed
    you with Amazon ECS use Docker by default. So, you’re making a new Docker instance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新服务的部署可能需要几分钟时间，正如屏幕顶部的蓝色通知所示。我向您展示的所有使用 Amazon ECS 部署的服务默认都会使用 Docker。所以，您正在创建一个新的
    Docker 实例。
- en: Deploying Docker with Docker Desktop
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker Desktop 部署 Docker
- en: 'The other main way to deploy Docker in Amazon ECS is to use Docker Desktop.
    If that’s the way you’d prefer, you’ll first need to install Docker Desktop on
    your local computer. Docker Desktop is an application that’s used to run Docker
    CLI commands. To install it, follow the next steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在亚马逊 ECS 中部署 Docker 的另一种主要方式是使用 Docker Desktop。如果您更喜欢这种方式，首先需要在本地计算机上安装 Docker
    Desktop。Docker Desktop 是用于运行 Docker CLI 命令的应用程序。要安装它，请按照以下步骤操作：
- en: 'Visit [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/)
    to install it on Mac, or visit [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)
    to install it on Windows. You may also need to install the Docker Compose plugin
    in Docker Desktop if it’s not already included. There are instructions in *Docker
    Docs* ([https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)).
    If your local computer uses a Linux operating system, you’ll need to install the
    Docker Compose CLI for Linux here: [https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux](https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux).'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/)
    以在 Mac 上安装，或者访问 [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)
    以在 Windows 上安装。如果 Docker Desktop 中没有包含 Docker Compose 插件，你可能还需要安装它。相关安装说明可以参考
    *Docker 文档* ([https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/))。如果你的本地计算机使用的是
    Linux 操作系统，你需要在这里安装 Docker Compose CLI： [https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux](https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux)。
- en: 'Log in to your AWS account through your web browser. You’ll need to make sure
    that your AWS credentials have access to certain AWS **Identity and Access Management**
    (**IAM**) permissions. See the AWS documentation on managing permissions ([https://aws.amazon.com/iam/features/manage-permissions/](https://aws.amazon.com/iam/features/manage-permissions/))
    if you need more help with this. If you only have your root account, you will
    need to create a new IAM account that has the permissions listed next. These are
    the permissions your credentials will need:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过你的网页浏览器登录到 AWS 账户。你需要确保你的 AWS 凭证拥有访问某些 AWS **身份与访问管理** (**IAM**) 权限。如果你需要更多帮助，可以查看
    AWS 的权限管理文档 ([https://aws.amazon.com/iam/features/manage-permissions/](https://aws.amazon.com/iam/features/manage-permissions/))。如果你只有根账户，你将需要创建一个新的
    IAM 账户，并赋予下面列出的权限。这些是你的凭证所需的权限：
- en: '**application-autoscaling:***'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**application-autoscaling:***'
- en: '**cloudformation:***'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cloudformation:***'
- en: '**ec2:AuthorizeSecurityGroupIngress**'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:AuthorizeSecurityGroupIngress**'
- en: '**ec2:CreateSecurityGroup**'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:CreateSecurityGroup**'
- en: '**ec2:CreateTags**'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:CreateTags**'
- en: '**ec2:DeleteSecurityGroup**'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:DeleteSecurityGroup**'
- en: '**ec2:DescribeRouteTables**'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:DescribeRouteTables**'
- en: '**ec2:DescribeSecurityGroups**'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:DescribeSecurityGroups**'
- en: '**ec2:DescribeSubnets**'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:DescribeSubnets**'
- en: '**ec2:DescribeVpcs**'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:DescribeVpcs**'
- en: '**ec2:RevokeSecurityGroupIngress**'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ec2:RevokeSecurityGroupIngress**'
- en: '**ecs:CreateCluster**'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:CreateCluster**'
- en: '**ecs:CreateService**'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:CreateService**'
- en: '**ecs:DeleteCluster**'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:DeleteCluster**'
- en: '**ecs:DeleteService**'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:DeleteService**'
- en: '**ecs:DeregisterTaskDefinition**'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:DeregisterTaskDefinition**'
- en: '**ecs:DescribeClusters**'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:DescribeClusters**'
- en: '**ecs:DescribeServices**'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:DescribeServices**'
- en: '**ecs:DescribeTasks**'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:DescribeTasks**'
- en: '**ecs:ListAccountSettings**'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:ListAccountSettings**'
- en: '**ecs:ListTasks**'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:ListTasks**'
- en: '**ecs:RegisterTaskDefinition**'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:RegisterTaskDefinition**'
- en: '**ecs:UpdateService**'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ecs:UpdateService**'
- en: '**elasticloadbalancing:***'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**elasticloadbalancing:***'
- en: '**iam:AttachRolePolicy**'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iam:AttachRolePolicy**'
- en: '**iam:CreateRole**'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iam:CreateRole**'
- en: '**iam:DeleteRole**'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iam:DeleteRole**'
- en: '**iam:DetachRolePolicy**'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iam:DetachRolePolicy**'
- en: '**iam:PassRole**'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iam:PassRole**'
- en: '**logs:CreateLogGroup**'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logs:CreateLogGroup**'
- en: '**logs:DeleteLogGroup**'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logs:DeleteLogGroup**'
- en: '**logs:DescribeLogGroups**'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logs:DescribeLogGroups**'
- en: '**logs:FilterLogEvents**'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logs:FilterLogEvents**'
- en: '**route53:CreateHostedZone**'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route53:CreateHostedZone**'
- en: '**route53:DeleteHostedZone**'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route53:DeleteHostedZone**'
- en: '**route53:GetHealthCheck**'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route53:GetHealthCheck**'
- en: '**route53:GetHostedZone**'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route53:GetHostedZone**'
- en: '**route53:ListHostedZonesByName**'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**route53:ListHostedZonesByName**'
- en: '**servicediscovery:***'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**servicediscovery:***'
- en: 'Now, you’ll need to run some commands at the Docker Compose CLI. Start with
    this command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要在 Docker Compose CLI 中运行一些命令。首先运行以下命令：
- en: '[PRE0]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following will print on your screen:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下内容将会显示在你的屏幕上：
- en: '[PRE1]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Select **AWS environment variables**. Follow the onscreen instructions to configure
    your ECS context to retrieve AWS credentials. With that, you can now view your
    Docker context with this command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **AWS 环境变量**。按照屏幕上的指示，配置你的 ECS 上下文以获取 AWS 凭证。配置完成后，你可以使用以下命令查看你的 Docker 上下文：
- en: '[PRE2]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now deploy and manage your Docker containerization in Amazon ECS with
    the **docker** **compose** command.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用 **docker** **compose** 命令在 Amazon ECS 中部署和管理你的 Docker 容器化应用。
- en: A guide to Docker Compose CLI commands and configuration help can be found on
    the *Docker Docs* website ([https://docs.docker.com/cloud/ecs-integration/](https://docs.docker.com/cloud/ecs-integration/)).
    I strongly recommend referring to the Docker command-line guide as well ([https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)).
    But I personally prefer the other Docker deployment method that completely uses
    AWS’s web application GUI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Docker Compose CLI 命令和配置的帮助指南可以在 *Docker 文档* 网站上找到 ([https://docs.docker.com/cloud/ecs-integration/](https://docs.docker.com/cloud/ecs-integration/))。我强烈建议同时参考
    Docker 命令行指南 ([https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/))。不过，我个人更喜欢完全使用
    AWS 的 Web 应用 GUI 来部署 Docker 的另一种方式。
- en: 'Refer to the AWS documentation if you ever need to delete your Docker cluster:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要删除 Docker 集群，请参考 AWS 文档：
- en: '[https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html](https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html](https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html)'
- en: 'It’s also possible to remove Docker containers when you’re not using them anymore.
    This command (at the Docker CLI) will remove your Docker container and its volumes
    (**data storage units**, or **DSUs**):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再使用 Docker 容器时，也可以将其移除。以下命令（在 Docker CLI 中）将删除 Docker 容器及其卷（**数据存储单元**，或
    **DSUs**）：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, Docker is one way to deploy containerized applications in AWS. Kubernetes
    is the other way, and it builds upon Docker’s system. But setting it up works
    differently, as you will see.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker 是在 AWS 中部署容器化应用程序的一种方式。Kubernetes 是另一种方式，它建立在 Docker 系统的基础上。但它的设置方式有所不同，正如你将看到的那样。
- en: How Kubernetes works in AWS
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 在 AWS 中的工作方式
- en: 'The layers in a Kubernetes containerization system look like this, from the
    bottom to the top:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 容器化系统的层次结构如下，从底部到顶部：
- en: AWS, Azure, or GCP is the cloud platform.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS、Azure 或 GCP 是云平台。
- en: The cloud platform runs a service, such as **Amazon Elastic Kubernetes Service**
    (**Amazon EKS**), which supports the control plane.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台运行一个服务，如 **Amazon Elastic Kubernetes Service** (**Amazon EKS**)，它支持控制平面。
- en: The next layer is the control plane, which is managed by Kubernetes. This is
    the root of the cluster.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一层是控制平面，由 Kubernetes 管理。它是集群的根节点。
- en: The control plane deploys Pods according to changing network application metrics
    that the cloud administrator can define. Pods are deployed to be able to manage
    the needs of your Kubernetes application at any given time. For instance, more
    users and more bandwidth consumption usually result in more Pods.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面根据云管理员定义的不断变化的网络应用指标部署 Pods。Pods 被部署以随时管理 Kubernetes 应用程序的需求。例如，更多的用户和更高的带宽消耗通常会导致更多的
    Pods。
- en: Pods deploy containers.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods 部署容器。
- en: 'Here’s a sample diagram of Kubernetes architecture:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Kubernetes 架构的示意图：
- en: '![Figure 6.2 – Kubernetes architecture](image/B18672_06_03.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Kubernetes 架构](image/B18672_06_03.jpg)'
- en: Figure 6.2 – Kubernetes architecture
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Kubernetes 架构
- en: Kubernetes Deployments in AWS use Amazon EC2 because that’s the main compute
    platform. It’s possible to manage Kubernetes directly in Amazon EC2\. But more
    often, organizations choose to use Amazon EKS as an interface with Amazon EC2\.
    It spares administrators the hassle of having to manage **etcd** and instances.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在 AWS 中的部署使用 Amazon EC2，因为它是主要的计算平台。也可以直接在 Amazon EC2 中管理 Kubernetes。但更常见的做法是组织选择使用
    Amazon EKS 作为与 Amazon EC2 的接口，这样可以省去管理员需要管理 **etcd** 和实例的麻烦。
- en: All the AWS Kubernetes examples I use in this book assume that Amazon EKS is
    being used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我使用的所有 AWS Kubernetes 示例都假设正在使用 Amazon EKS。
- en: 'The simplest way to create a Kubernetes containerization system with an Amazon
    EKS cluster is to use AWS’s web application. It’s also possible to launch a cluster
    at the AWS CLI, but I found it took a lot of extra time to set up IAM and JSON
    configuration files. If you’d prefer to use the command line, there’s a guide
    in the AWS documentation here: [https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html](https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html).
    But I presume you’re just setting up an environment to practice pentesting. So,
    launching an EKS cluster through the AWS web interface with all of the default
    settings should suffice for that purpose. Follow the next steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 的 Web 应用程序创建 Kubernetes 容器化系统的最简单方式是使用 Amazon EKS 集群。虽然也可以通过 AWS CLI
    启动集群，但我发现设置 IAM 和 JSON 配置文件需要花费额外的时间。如果你更倾向于使用命令行，可以参考 AWS 文档中的指南：[https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html](https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html)。不过，我猜你只是为了练习渗透测试环境的搭建。所以，通过
    AWS Web 界面以默认设置启动 EKS 集群应该足够满足你的需求。接下来，按照以下步骤操作：
- en: Log in to your AWS account through [aws.amazon.com](http://aws.amazon.com) in
    your web browser. In the top menu search bar, enter **EKS** or **Elastic Kubernetes
    Service**. There will be a link to open the Amazon EKS interface. Alternatively,
    you may see a white box on the right side of your screen that says **Add cluster**
    for you to click on.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过浏览器登录到你的 AWS 账户，访问 [aws.amazon.com](http://aws.amazon.com)。在顶部菜单的搜索框中，输入**EKS**或**Elastic
    Kubernetes Service**。会有一个链接，点击打开 Amazon EKS 界面。或者，你也可能会在屏幕右侧看到一个白色框，框中写着**添加集群**，你可以点击它。
- en: You’ll immediately be taken to the **Clusters** page. Click on the orange **Create
    cluster** button in the top-right corner and select **Create** from the drop-down
    menu. Alternatively, you may need to click on the drop-down menu that says **Create**
    and click on **Create Clusters**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会立即带你进入**集群**页面。点击右上角的橙色**创建集群**按钮，从下拉菜单中选择**创建**。或者，你可能需要点击标有**创建**的下拉菜单，然后点击**创建集群**。
- en: Now, you’re on the **Configure cluster** page. Enter an original name for your
    cluster. Choose whatever you’d like. I chose **EKS-Pentest**. Leave the default
    Kubernetes version. Choose a cluster service role from the drop-down menu. If
    there’s no cluster service role to choose from, follow the Amazon EKS user guide
    instructions ([https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role))
    on how to make an AWS IAM role with EKS cluster permissions.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你进入了**配置集群**页面。为你的集群输入一个原始名称，选择你喜欢的名称。我选择了**EKS-Pentest**。保持默认的 Kubernetes
    版本。选择下拉菜单中的集群服务角色。如果没有可选的集群服务角色，请按照 Amazon EKS 用户指南中的说明（[https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role)）创建一个具有
    EKS 集群权限的 AWS IAM 角色。
- en: Leave the rest of the defaults as they are and click on the orange **Next**
    button in the lower-right corner.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他默认设置不变，然后点击右下角的橙色**下一步**按钮。
- en: On the next page, there are **Networking** settings to configure. Leave **VPC**,
    **Subnets**, **Security groups**, and **IP address** at their default settings.
    Leave **Cluster endpoint access** as public and click on the orange **Next** button
    in the lower-right corner.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页面，你需要配置**网络**设置。将**VPC**、**子网**、**安全组**和**IP 地址**保留为默认设置。将**集群端点访问**设置为公共，然后点击右下角的橙色**下一步**按钮。
- en: On the **Configure logging** page, set the control plane to log **API server**,
    **Audit**, **Authenticator**, **Controller manager**, and **Scheduler**. For pentesting
    and red team purposes, more logging is always best! Click on the orange **Next**
    button in the lower-right corner.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置日志记录**页面，将控制平面设置为记录**API 服务器**、**审计**、**身份验证器**、**控制器管理器**和**调度器**。对于渗透测试和红队用途，更多的日志记录永远是最好的！点击右下角的橙色**下一步**按钮。
- en: Leave the Amazon EKS add-ons as the defaults. They include CoreDNS, Amazon VPC
    CNI, and **kube-proxy**. Click on the orange **Next** button in the lower-right
    corner.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持 Amazon EKS 插件为默认设置。它们包括 CoreDNS、Amazon VPC CNI 和**kube-proxy**。点击右下角的橙色**下一步**按钮。
- en: Leave the default versions for the add-ons. Click on the orange **Next** button
    in the lower-right corner.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持插件的默认版本。点击右下角的橙色**下一步**按钮。
- en: Review all of your configurations and click on the orange **Create** button
    in the lower-right corner.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审核你所有的配置，然后点击右下角的橙色**创建**按钮。
- en: You will see a blue notification bar at the top of your screen that says your
    cluster is being created. It may take a few minutes. When you see a green notification
    bar, your Kubernetes cluster has been created. Congratulations!
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在屏幕顶部看到一个蓝色通知条，显示你的集群正在创建。可能需要几分钟时间。当你看到绿色的通知条时，说明你的 Kubernetes 集群已经创建成功，恭喜！
- en: 'If you ever need to delete your Kubernetes cluster, refer to the AWS documentation
    here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要删除 Kubernetes 集群，请参考 AWS 文档：
- en: '[https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html](https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html](https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html)'
- en: So, we’ve now set up Docker and Kubernetes containerization systems in AWS.
    Now, it’s time to pentest them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在已经在 AWS 上设置了 Docker 和 Kubernetes 容器化系统。接下来，是时候进行渗透测试了。
- en: Docker and Kubernetes pentesting techniques in AWS
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 中进行 Docker 和 Kubernetes 渗透测试技术
- en: In the previous chapter, I walked you through using Prowler to pentest AWS deployments.
    I’ll show you some scripts and vulnerability checks you can execute to find Docker
    and Kubernetes vulnerabilities with a few different tools. But first, it’s worthwhile
    mentioning here that Prowler can be executed from a Docker instance! You can use
    Prowler from Docker containers to help pentest your organization’s entire AWS
    network. *Running Prowler from Docker isn’t just for vulnerability* *assessing
    Docker.*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我带你使用 Prowler 来进行 AWS 部署的渗透测试。我将向你展示一些脚本和漏洞检查，你可以执行这些操作来查找 Docker 和 Kubernetes
    漏洞，使用不同的工具。但首先，值得在这里提到的是，Prowler 可以从 Docker 实例中执行！你可以使用 Docker 容器中的 Prowler 来帮助渗透测试你组织的整个
    AWS 网络。*从 Docker 运行 Prowler 不仅仅是为了评估 Docker 的漏洞。*
- en: The same Prowler CLI commands from the previous chapter can be used when you
    run Prowler from Docker.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章中得到的相同 Prowler CLI 命令，可以在你从 Docker 运行 Prowler 时使用。
- en: Installation in Docker
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Docker 中的安装
- en: 'Here’s how to install Prowler from Docker:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Docker 安装 Prowler 的方法：
- en: 'Make sure that Docker Desktop is installed on your local computer. Find the
    Docker Desktop Windows, Mac, and Linux clients here: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的本地计算机上安装了 Docker Desktop。你可以在这里找到 Docker Desktop 的 Windows、Mac 和 Linux 客户端：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。
- en: Have your AWS credentials ready. You can verify them by logging in to your AWS
    account from your web browser. On the top menu bar, look at the far-right drop-down
    menu with your username. Click on **Security credentials** to navigate to the
    correct AWS IAM page. At the top, it should say **My security credentials (root
    user)**. Make a note of your AWS account ID, access key ID, and secret access
    key.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好你的 AWS 凭证。你可以通过在浏览器中登录 AWS 账户来验证它们。在顶部菜单栏，查看最右侧的下拉菜单，点击你的用户名。然后点击 **Security
    credentials** 以导航到正确的 AWS IAM 页面。页面顶部应该显示 **My security credentials (root user)**。记下你的
    AWS 账户 ID、访问密钥 ID 和秘密访问密钥。
- en: Navigate to AWS CloudShell by looking at the top menu bar. Launch it by clicking
    on the Command Prompt-looking icon that’s to the left of the bell icon.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看顶部菜单栏，导航到 AWS CloudShell。点击位于铃铛图标左侧的命令提示符图标来启动它。
- en: At the AWS CloudShell CLI, enter **pwd** in order to verify your home directory
    path. You may need to use the **ls** (list files and folders) command and **cd**
    (change directory) command to find your home directory.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS CloudShell CLI 中，输入 **pwd** 来验证你的主目录路径。你可能需要使用 **ls**（列出文件和文件夹）命令和 **cd**（更改目录）命令来找到你的主目录。
- en: 'Enter the following commands to install and configure Prowler inside of a Docker
    container. Make sure that you enter your AWS access keys into the script:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令，在 Docker 容器内安装并配置 Prowler。确保在脚本中输入你的 AWS 访问密钥：
- en: '[PRE4]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Replace **/your/local/dir** with the path of your home directory. Enter your
    access key ID and secret access key after each **\** instance.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 **/your/local/dir** 替换为你的主目录路径。在每个 **\** 实例后输入你的访问密钥 ID 和秘密访问密钥。
- en: 'If you need help generating an **AWS_SESSION_TOKEN** instance, consider using
    this guide:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助生成 **AWS_SESSION_TOKEN** 实例，考虑使用此指南：
- en: '[https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support](https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support](https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support)'
- en: 'Prowler will install in your Docker instance, and you should now be able to
    execute Prowler from the Docker Compose CLI in Docker Desktop. All of the Prowler
    commands from the previous chapter will work here. Also, please familiarize yourself
    with Docker commands with this guide from *Docker* *Docs*: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Prowler 将在您的 Docker 实例中安装，现在您应该能够从 Docker Desktop 的 Docker Compose CLI 执行 Prowler。上一章中的所有
    Prowler 命令在这里都能正常工作。此外，请通过以下 *Docker* *Docs* 指南熟悉 Docker 命令：[https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)。
- en: There is a simple automated pentest script by Vishnu Nair that you can use for
    both real-world pentesting and for trying out for educational purposes. I recommend
    giving it a try! It can be found in Docker Hub ([https://hub.docker.com/r/vishnunair/pentest](https://hub.docker.com/r/vishnunair/pentest)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Vishnu Nair 提供了一个简单的自动化渗透测试脚本，您可以用来进行真实的渗透测试，也可以用于教育用途。我推荐您试试看！它可以在 Docker Hub
    找到 ([https://hub.docker.com/r/vishnunair/pentest](https://hub.docker.com/r/vishnunair/pentest))。
- en: Because I was just trying it out, I decided to run Vishnu Nair’s script in the
    **Play With Docker** (**PWD**) ([https://labs.play-with-docker.com/](https://labs.play-with-docker.com/))
    simulation. PWD offers a “*simple, interactive and fun playground*” to experiment
    with Docker in its own VMs that you can execute from your web browser. But of
    course, Vishnu Nair’s script will work in real Docker instances too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我只是试用一下，所以决定在**Play With Docker** (**PWD**) ([https://labs.play-with-docker.com/](https://labs.play-with-docker.com/))
    模拟环境中运行 Vishnu Nair 的脚本。PWD 提供了一个“*简单、互动且有趣的游乐场*”，您可以在其中的虚拟机上进行 Docker 实验，并且可以直接从浏览器执行。当然，Vishnu
    Nair 的脚本也可以在真实的 Docker 实例中运行。
- en: Vishnu Nair’s automated pentest automatically executes dozens of modules including
    (but not limited to) Nmap, Uniscan, TheHarvester, XSSStrike, Dirb, SSLScan, and
    DNSmap. Then, it prints results both on screen and in the **/src** folder inside
    of the container.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Vishnu Nair 的自动化渗透测试会自动执行包括（但不限于）Nmap、Uniscan、TheHarvester、XSSStrike、Dirb、SSLScan
    和 DNSmap 等多个模块。然后，它会将结果打印到屏幕上，并保存到容器内的 **/src** 文件夹中。
- en: It’s such a simple script—one of the most user-friendly automated vulnerability
    scanners for containers I have ever used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的脚本——我使用过的最用户友好的容器自动化漏洞扫描工具之一。
- en: 'Here are the commands to use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是要使用的命令：
- en: 'First, create a Docker volume:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 Docker 卷：
- en: '[PRE5]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, download the script:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，下载脚本：
- en: '[PRE6]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute it like so:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式执行它：
- en: '[PRE7]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The scan results will print on your screen.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扫描结果将显示在您的屏幕上。
- en: Find your Docker volumes in the **/var/lib/docker/volumes** path. You may need
    to use the **cd** command to navigate to it.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **/var/lib/docker/volumes** 路径中查找您的 Docker 卷。您可能需要使用 **cd** 命令导航到该路径。
- en: 'Then, find your scan report with this command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令查找您的扫描报告：
- en: '[PRE8]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On to Kubernetes!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行 Kubernetes！
- en: Installation in Kubernetes
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中安装
- en: 'Aqua Security’s **kube-bench** is an automated script that runs vulnerability
    scans based on the **Center for Internet Security** (**CIS**) Kubernetes Benchmark
    ([https://www.cisecurity.org/benchmark/kubernetes](https://www.cisecurity.org/benchmark/kubernetes)).
    The Benchmark includes a list of checks in these categories:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Aqua Security 的 **kube-bench** 是一个自动化脚本，根据 **互联网安全中心** (**CIS**) Kubernetes
    基准标准进行漏洞扫描 ([https://www.cisecurity.org/benchmark/kubernetes](https://www.cisecurity.org/benchmark/kubernetes))。该基准标准包括以下类别的检查：
- en: Control-plane components
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面组件
- en: '**etcd**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**'
- en: Control-plane configuration
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面配置
- en: Worker nodes
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作节点
- en: Policies
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: 'There are multiple ways to run **kube-bench** ([https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md](https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md)),
    including as a Kubernetes Job with a YAML file. In this chapter, I created an
    **Azure Kubernetes Service** (**AKS**) cluster for Kubernetes. So, let’s try running
    **kube-bench** there:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以运行 **kube-bench** ([https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md](https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md))，其中包括作为
    Kubernetes 作业使用 YAML 文件。在本章中，我为 Kubernetes 创建了一个 **Azure Kubernetes Service**
    (**AKS**) 集群。所以，让我们在那里尝试运行 **kube-bench**：
- en: 'First, make sure **kubectl-node-shell** is installed in your EKS cluster by
    following the GitHub instructions here: [https://github.com/kvaps/kubectl-node-shell](https://github.com/kvaps/kubectl-node-shell).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保按照 GitHub 上的说明，**kubectl-node-shell** 已经安装在您的 EKS 集群中：[https://github.com/kvaps/kubectl-node-shell](https://github.com/kvaps/kubectl-node-shell)。
- en: 'While at the AWS CLI with Docker installed, run the **kube-bench** script:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装了 Docker 的 AWS CLI 中，运行 **kube-bench** 脚本：
- en: '[PRE9]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your benchmark check results will be printed on screen, and you should also
    find a report in the **/src** folder of your container.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的基准检查结果将在屏幕上打印出来，你还应该能在容器的**/src**文件夹中找到报告。
- en: 'Refer to the **kube-bench** documentation if you need troubleshooting help:
    [https://github.com/aquasecurity/kube-bench/tree/main/docs](https://github.com/aquasecurity/kube-bench/tree/main/docs).'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你需要故障排除帮助，请参考**kube-bench**文档：[https://github.com/aquasecurity/kube-bench/tree/main/docs](https://github.com/aquasecurity/kube-bench/tree/main/docs)。
- en: Tip
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Here’s a tip for trying all of the Docker and Kubernetes pentest tools and scripts
    mentioned in this book. You know how I started this chapter with an analogy about
    the cloud platform (AWS, Azure, GCP) being like a dish and the containerization
    orchestration platform (Docker, Kubernetes) being like a piece of buttered toast?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于尝试本书中提到的所有 Docker 和 Kubernetes 渗透测试工具和脚本的小贴士。你还记得我在本章开头用一个比喻来说明云平台（AWS、Azure、GCP）就像一道菜，而容器化编排平台（Docker、Kubernetes）就像一片抹了黄油的吐司吗？
- en: The AWS ([*Chapter 5*](B18672_05.xhtml#_idTextAnchor080)), Azure ([*Chapter
    8*](B18672_08.xhtml#_idTextAnchor141)), and GCP ([*Chapter 11*](B18672_11.xhtml#_idTextAnchor197))
    pentests are specific to those cloud platforms. But the Docker and Kubernetes
    pentest tools and scripts mentioned in this chapter, [*Chapter 9*](B18672_09.xhtml#_idTextAnchor159),
    and [*Chapter 12*](B18672_12.xhtml#_idTextAnchor215) can be run in any Docker
    or Kubernetes instance regardless of the cloud platform.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: AWS（[*第 5 章*](B18672_05.xhtml#_idTextAnchor080)）、Azure（[*第 8 章*](B18672_08.xhtml#_idTextAnchor141)）、和
    GCP（[*第 11 章*](B18672_11.xhtml#_idTextAnchor197)）的渗透测试是针对这些云平台的特定内容。但本章中提到的 Docker
    和 Kubernetes 渗透测试工具和脚本，以及[*第 9 章*](B18672_09.xhtml#_idTextAnchor159)和[*第 12 章*](B18672_12.xhtml#_idTextAnchor215)中的内容，可以在任何
    Docker 或 Kubernetes 实例中运行，而不管使用的云平台是什么。
- en: So, there are a lot more useful pentest tools and scripts for Docker and Kubernetes
    further on in this book!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，本书后续内容中还有更多有用的 Docker 和 Kubernetes 渗透测试工具和脚本！
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Cloud platforms such as AWS, Azure, and GCP are popular because they offer organizations
    lots of scalability in their massive data centers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AWS、Azure 和 GCP 等云平台之所以流行，是因为它们为组织提供了大量的可扩展性，尤其是在它们的庞大数据中心中。
- en: Containerization orchestrated by Docker or Kubernetes takes full advantage of
    cloud infrastructure by helping organizations manage hardware and software resources
    better for their networked applications. Containers use virtualization but are
    much more lightweight and portable than VMs. You will almost definitely be working
    with containerization as a cloud pentester.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Docker 或 Kubernetes 编排的容器化充分利用了云基础设施，通过帮助组织更好地管理硬件和软件资源，优化了其网络应用。容器使用虚拟化，但比虚拟机更轻量、更便于移植。作为一名云端渗透测试员，你几乎肯定会与容器化打交道。
- en: In AWS, Docker is usually run through Amazon ECS, and Kubernetes with Amazon
    EKS. They’re both interfaces for Amazon EC2.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 中，Docker 通常通过 Amazon ECS 运行，Kubernetes 通过 Amazon EKS 运行。它们都是 Amazon EC2
    的接口。
- en: Docker and Kubernetes pentesting scripts and benchmarks are interchangeable
    between cloud platforms.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Kubernetes 的渗透测试脚本和基准测试在不同云平台之间是可以互换的。
- en: Now that we’ve deployed VMs and containerized applications in AWS and pentested
    them, we will move on to Microsoft Azure in the next chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 AWS 中部署了虚拟机和容器化应用并进行了渗透测试，接下来我们将在下一章转向微软 Azure。
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    links:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涉及的主题，你可以访问以下链接：
- en: 'Docker on AWS: [https://aws.amazon.com/docker/](https://aws.amazon.com/docker/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 上的 Docker：[https://aws.amazon.com/docker/](https://aws.amazon.com/docker/)
- en: 'Kubernetes on AWS: [https://aws.amazon.com/kubernetes/](https://aws.amazon.com/kubernetes/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 上的 Kubernetes：[https://aws.amazon.com/kubernetes/](https://aws.amazon.com/kubernetes/)
- en: 'Docker CLI guide: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker CLI 指南：[https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)
- en: 'PWD test lab: [https://www.docker.com/play-with-docker/](https://www.docker.com/play-with-docker/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWD 测试实验室：[https://www.docker.com/play-with-docker/](https://www.docker.com/play-with-docker/)
- en: Part 3:Pentesting Microsoft Azure
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：渗透测试微软 Azure
- en: Azure is Microsoft’s own cloud platform, and it’s been popular with businesses
    of all kinds for over 15 years. In this part, we will learn about Azure’s various
    software-as-a-service, platform-as-a-service, and infrastructure-as-a-service
    applications. We will deploy our own Azure instance in which to test our pentesting
    skills. We will use Microsoft Defender for Cloud to check the security posture
    of our Azure deployment. We will also try out some pentesting tools in Azure,
    step by step. Then, we’ll deploy Docker and Kubernetes containers and test those
    as well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Azure是微软自家的云平台，已经被各种企业广泛使用超过15年。在这一部分，我们将学习Azure的各种软件即服务（SaaS）、平台即服务（PaaS）和基础设施即服务（IaaS）应用程序。我们将部署自己的Azure实例来测试渗透测试技能。我们将使用Microsoft
    Defender for Cloud来检查我们Azure部署的安全状况。我们还将一步一步尝试Azure中的一些渗透测试工具。然后，我们将部署Docker和Kubernetes容器并进行测试。
- en: 'This section has the following chapters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 7*](B18672_07.xhtml#_idTextAnchor115), *Security Features in Azure*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18672_07.xhtml#_idTextAnchor115)，*Azure中的安全功能*'
- en: '[*Chapter 8*](B18672_08.xhtml#_idTextAnchor141), *Pentesting Azure Features
    through Serverless Applications and Tools*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18672_08.xhtml#_idTextAnchor141)，*通过无服务器应用程序和工具对Azure功能进行渗透测试*'
- en: '[*Chapter 9*](B18672_09.xhtml#_idTextAnchor159), *Pentesting Containerized
    Applications in Azure*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18672_09.xhtml#_idTextAnchor159)，*在Azure中对容器化应用程序进行渗透测试*'
