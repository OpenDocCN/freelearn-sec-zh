- en: '*Chapter 13*: Windows Kernel Security'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：Windows内核安全'
- en: The kernel is the colonel of the operating system. It’s the software that allows
    the **Operating System** (**OS**) to link applications to hardware, translating
    application requests into instructions for the CPU. In fact, it’s hard to distinguish
    an operating system per se from its kernel; it is the heart of the OS. A bug in
    a user’s application may cause crashes, instability, slowness, and so on, but
    a bug in the kernel can crash the entire system. An even more devastating potential
    is arbitrary code execution with the highest privileges available on the OS. Kernel
    attacks are a hacker’s dream.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是操作系统的“军官”。它是允许**操作系统**（**OS**）将应用程序与硬件连接的软件，将应用程序请求转化为CPU指令。实际上，很难将操作系统本身与其内核区分开；它是操作系统的核心。用户应用程序中的错误可能导致崩溃、不稳定、变慢等问题，但内核中的错误可能导致整个系统崩溃。一个更具破坏性的潜在威胁是以操作系统上最高权限执行任意代码。内核攻击是黑客的梦想。
- en: Absolutely everything in an OS works with the kernel in some form. As the core
    of the OS, the kernel requires isolation from the less-privileged processes on
    the system; without isolation, it could be corrupted, and a corrupt kernel renders
    the system unusable. This isolation is accomplished by rendering the kernel’s
    space in memory as off-limits to processes on the user side. Despite this, full
    isolation would make the computer useless for users and their applications – interfaces
    are a necessity. These interfaces create doorways for the attacker into the highest
    privilege level possible on a Windows computer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统中的一切都以某种形式与内核协作。作为操作系统的核心，内核需要与系统中权限较低的进程隔离；如果没有隔离，内核可能会受到破坏，而被破坏的内核将导致系统无法使用。这种隔离通过将内核在内存中的空间设置为用户侧进程无法访问来实现。尽管如此，完全的隔离会使计算机对于用户和应用程序变得无用——接口是必需的。这些接口为攻击者提供了进入Windows计算机最高权限级别的大门。
- en: An in-depth discussion of the Windows NT kernel is out of scope for this chapter,
    but we’ll introduce kernel security concepts and step through a Metasploit exploit
    module against the Windows kernel to better understand how it works. We’ll provide
    a hands-on introduction to exploiting a kernel vulnerability to elevate privileges
    on a Windows target.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对Windows NT内核的深入讨论超出了本章的范围，但我们将介绍内核安全概念，并通过一个Metasploit漏洞利用模块来演示如何攻击Windows内核，以便更好地理解它的工作原理。我们将提供一个实践入门，教你如何利用内核漏洞在Windows目标上提升权限。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: An overview of kernel concepts and attacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核概念和攻击的概述
- en: The concept of pointers to illustrate null pointer flaws
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针概念来说明空指针缺陷
- en: Code from the Metasploit module to exploit the CVE-2014-4113 vulnerability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit模块中的代码，用于利用CVE-2014-4113漏洞
- en: A demonstration of leveraging this module for privilege escalation after gaining
    a foothold on a Windows 7 target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows 7目标机器上获取立足点后，演示如何利用该模块进行权限提升
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Kali Linux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: A Windows 7 target PC or virtual machine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Windows 7目标PC或虚拟机
- en: WinDbg for further debugging study (not necessary to complete the exercise)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于进一步调试学习的WinDbg（完成练习不必要）
- en: The IDA disassembler for analyzing binaries and drivers (not necessary to complete
    the exercise)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分析二进制文件和驱动程序的IDA反汇编器（完成本练习不必要）
- en: Kernel fundamentals – understanding how kernel attacks work
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核基础——理解内核攻击是如何工作的
- en: A crucial philosophical point to remember is that the kernel is a computer program.
    It’s a construct that can be rather intimidating for us lowly noobs, so it helps
    to remember the true nature of the beast. The casual flaws you learn about in
    ordinary programming can all occur in kernel code. The kernel occupies memory,
    just like any ordinary program, so the potential to put something where it doesn’t
    belong and execute it exists. If this is the case, what makes the kernel so special?
    The kernel manages all low-level functions by interfacing the hardware of a computer
    and the software of an OS. There are many, many different programs running on
    a modern instance of Windows, and they all want to use one processor at the same
    time. The programs can’t decide who gets how much time, and the processor dumbly
    completes operations – it can’t decide, either. It’s the kernel that functions
    as the cop, managing all the high-level interactions with the lowest-level structures
    of the system. The next time you’re marveling at the multitasking ability of a
    computer that isn’t actually capable of multitasking, thank the kernel for providing
    that illusion to you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要哲学观点是，内核是一个计算机程序。它是一个构造体，对于我们这些普通的小白来说，可能会感到有些令人生畏，所以有助于记住它的真实面目。在普通编程中你学到的日常缺陷，都可能出现在内核代码中。内核占用内存，就像任何普通程序一样，因此存在将某些东西放到不该放的地方并执行的可能性。如果是这样，那内核到底有什么特别之处呢？内核通过连接计算机的硬件和操作系统的软件来管理所有低级功能。在现代Windows实例中，有许多不同的程序同时运行，它们都想使用同一个处理器。程序无法决定谁能获得多少时间，而处理器则愚蠢地完成操作——它也无法做出决定。是内核充当了警察的角色，管理所有与系统最低级结构的高层次交互。下次你对一台实际上并不具备多任务处理能力的计算机的多任务能力感到惊讶时，记得感谢内核为你提供了这一幻觉。
- en: 'Windows is an example of an OS that uses a dual-mode architecture – user and
    kernel (sometimes called user and supervisor). Thus, the memory space is split
    into two halves, and user mode cannot access kernel space. Kernel mode, on the
    other hand, has the highest authority and can access any part of the system and
    hardware. The kernel is ultimately the mediator between the actual hardware and
    the OS. In Windows, the interface with hardware is provided by the **Hardware
    Abstraction Layer** (**HAL**), which, as the name suggests, creates a layer of
    abstraction to, for instance, normalize differences in hardware. Kernel mode drivers
    provide interfaces for applications requesting access to hardware; even something
    taken for granted such as an application wishing to display data on the screen
    must work with a kernel mode driver. The beauty of these structures is they create
    a layer of abstraction and a single familiar environment for applications to work
    with. A Windows developer doesn’t need to worry about the different monitors that
    may be displaying their program to the user:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Windows是一个使用双模式架构的操作系统示例——用户模式和内核模式（有时称为用户模式和监督模式）。因此，内存空间被分为两部分，用户模式无法访问内核空间。另一方面，内核模式具有最高的权限，可以访问系统和硬件的任何部分。内核最终是实际硬件与操作系统之间的中介。在Windows中，硬件的接口由**硬件抽象层**（**HAL**）提供，顾名思义，它创建了一个抽象层，旨在规范硬件差异。例如，内核模式驱动程序为请求访问硬件的应用程序提供接口；甚至像应用程序希望在屏幕上显示数据这样的事情，也必须与内核模式驱动程序合作。这些结构的美妙之处在于它们为应用程序提供了一个抽象层和一个单一的熟悉环境。Windows开发人员不需要担心可能会显示其程序的不同显示器：
- en: '![Figure 13.1 – How Windows interacts with hardware ](image/Figure_13.1_B17616.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – Windows如何与硬件交互](image/Figure_13.1_B17616.jpg)'
- en: Figure 13.1 – How Windows interacts with hardware
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Windows如何与硬件交互
- en: Kernel attack vectors
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核攻击向量
- en: 'The security implications of the kernel are both profound in the sense of potential
    impact and the extremely low-level activity happening within the kernel, and also
    straightforward in the sense that the kernel is software written by people (say
    no more). Some attack vectors that we consider when examining the kernel concept
    are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的安全性问题既深远（潜在影响巨大）也简单明了（因为内核是由人编写的软件，细节无需多说）。在检查内核概念时，我们考虑的一些攻击向量如下：
- en: '**APIs**: If the kernel doesn’t allow some means for applications to access
    its functionality, there’s no point in a computer and we might as well all go
    home. The potential exists via the APIs for arbitrary code to be executed in kernel
    mode, giving an attacker’s shellcode all the access it needs for total compromise.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：如果内核不允许某些方式让应用程序访问其功能，那么计算机就没有意义，我们还不如回家去。通过API，潜在的恶意代码可能在内核模式下执行，使攻击者的shellcode获得完全访问权限，从而实现完全的攻击。'
- en: '**Paddling upstream from hardware**: If you examine the design of the Windows
    OS, you’ll notice that you can get intimate with the kernel in a more direct way
    from the hardware side of the system hierarchy. Malicious driver design can exploit
    the mechanisms that map the hardware device into virtual memory space.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从硬件向上划水**：如果你检查Windows操作系统的设计，你会注意到，你可以从系统层次结构的硬件侧更直接地接触内核。恶意驱动程序的设计可以利用将硬件设备映射到虚拟内存空间的机制。'
- en: '**Undermining the boot process**: The OS has to be brought up at boot time,
    and this is a vulnerable time for the system. If the boot flow can be arbitrarily
    controlled, it may be possible to attack the kernel before various self-protections
    are initialized.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏引导过程**：操作系统需要在启动时加载，这时是系统的一个脆弱时刻。如果引导流程可以被任意控制，可能在各种自我保护机制初始化之前，就能够攻击内核。'
- en: '**Rootkits**: A kernel-mode rootkit in Windows typically looks like a kernel-mode
    driver. Successful coding of such malware is a very delicate balancing act due
    to the nature of the kernel’s code; couple that with modern protections such as
    driver signing, and this is getting harder and harder to pull off. It isn’t impossible
    though, and regardless, older OSs are still a reality in many environments. It’s
    important for the pen tester to be aware of the attacks that the security industry
    likes to describe as *on their way out the door*.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rootkit**：Windows中的内核模式rootkit通常表现为内核模式驱动程序。成功编写这种恶意软件是一项非常精细的平衡工作，因为内核代码的性质；再加上现代的保护措施，如驱动程序签名，使得这种攻击越来越难以实现。然而，这并非不可能，且无论如何，老旧操作系统在许多环境中仍然存在。渗透测试人员需要意识到那些安全行业喜欢描述为*正在退出历史舞台*的攻击方式。'
- en: The kernel’s role as a time cop
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核作为时间警察的角色
- en: There are various pieces of magic that a modern OS needs to perform, and the
    kernel is the magician. One example is context switching, which is a technique
    that allows numerous processes to share a single CPU. Context switching is the
    actual work of putting a running thread on hold and storing it in memory, getting
    another thread up and running with CPU resources, and then putting the second
    thread on hold and storing it in memory before recalling the first thread. There’s
    no way around the fact that this takes time to do, so some of the latency in a
    processor is found in context switching; one of the innovations in OSs is developing
    ways to cut this time down as much as possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统需要执行各种“魔法”，而内核就是魔术师。一个例子是上下文切换，这是一种允许多个进程共享单个CPU的技术。上下文切换的实际工作是将正在运行的线程挂起并存储到内存中，调度另一个线程使用CPU资源运行，然后将第二个线程挂起并存储到内存中，再调回第一个线程。无法避免的是，这个过程需要时间，因此处理器的一部分延迟就来自上下文切换；操作系统的一个创新是在尽可能减少这一时间。
- en: Of course, we’re rarely fortunate enough to have to worry about just two little
    threads trying to run on the same processor – there are often dozens waiting,
    so the task of prioritizing becomes necessary. Prioritizing threads is a part
    of the work of the scheduler. The scheduler decides who gets what slice of time
    with the processor and when. What if a process doesn’t want to give up its time
    with the processor? In a cooperative multitasking OS, the process needs to be
    finished with resources before they will be released. On the other hand, in a
    preemptive multitasking OS, the scheduler can interrupt a task and resume it later.
    I’m sure you can imagine the security implications of an OS that’s unable to context
    switch with a thread that refuses to relinquish resources. Thankfully, modern
    OSs are typically preemptive. In fact, in the case of Windows, the kernel itself
    is preemptive – this simply means that even tasks running in kernel mode can be
    interrupted.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们很少有幸运的机会需要担心仅有两个小线程试图在同一处理器上运行——通常有几十个线程在等待，所以需要优先级管理。线程优先级是调度器的工作之一。调度器决定谁在什么时间片段内使用处理器。如果一个进程不愿意放弃它与处理器的时间呢？在合作式多任务操作系统中，进程需要完成资源的使用才会释放资源。另一方面，在抢占式多任务操作系统中，调度器可以中断任务，并稍后恢复它。你可以想象一下，一个操作系统如果无法与一个拒绝释放资源的线程进行上下文切换会带来怎样的安全隐患。幸运的是，现代操作系统通常是抢占式的。实际上，在Windows操作系统中，内核本身就是抢占式的——这意味着即使是内核模式下运行的任务也可以被中断。
- en: 'Even young children can grasp one of the fundamental rules of existence – events
    don’t always happen at once, and you often have to wait for something to happen.
    You have to go to school for a whole week before the fun of the weekend starts.
    Even at the extraordinarily small scale of the tiny slices of time used in context
    switching and scheduling, sometimes we have to wait around for something to happen
    before we can proceed. Programmers and reverse engineers alike will see these
    time-dependent constructs in code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是年幼的孩子也能理解存在的基本规则之一——事件并不总是同时发生，你通常需要等待某件事情发生。你必须上整整一周的学，才能迎来周末的乐趣。即使是在上下文切换和调度所用的极其微小的时间片尺度上，我们有时也需要等待某件事情发生才能继续前进。程序员和逆向工程师都会在代码中看到这些时间依赖的构造：
- en: Grab the value of the **VAR** variable; use an **if**/**then** statement to
    establish a condition based on this fetched value.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**VAR**变量的值；使用**if**/**then**语句根据获取的值建立条件。
- en: Grab the value of the **VAR** variable; use it in a function according to the
    condition(s) established in *step 1*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**VAR**变量的值；根据*第1步*中建立的条件在函数中使用该值。
- en: Grab the value of the **VAR** variable; use it in a function according to the
    condition(s) established in *step 1* and *step 2*, and so on.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取**VAR**变量的值；根据*第1步*和*第2步*中建立的条件在函数中使用该值，依此类推。
- en: Imagine if we could create a condition that would cause these dependencies to
    occur out of their prescribed order. For example, what if I could cause *step
    2* to happen first? In this case, the code is expecting a condition to have been
    established already. An attacker may thus trigger an exploit by racing against
    the established order – this is called a **race condition**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们能创建一个条件，使得这些依赖关系按照预定顺序发生。例如，如果我能让*第2步*先发生呢？在这种情况下，代码期望某个条件已经建立。攻击者可能通过与已建立的顺序竞争来触发漏洞——这就是**竞态条件**。
- en: It’s just a program
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它只是一个程序
- en: From a security perspective, one of the most crucial points to understand about
    the kernel is that it’s technically a program made up of code. The real distinction
    between a flaw in the kernel and a flaw in code on the user side is the privilege;
    any piece of code running at the kernel level can own the system because the kernel *is* the
    system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，理解内核最关键的一点是，它本质上是由代码组成的程序。内核中的缺陷与用户端代码中的缺陷的真正区别在于权限；任何在内核级别运行的代码都可以拥有整个系统，因为内核*就是*系统。
- en: Crashing the kernel results in an irrecoverable situation (namely, it requires
    a reboot), whereas crashing a user application just requires restarting the application
    – so, exploring kernel attacks is more precarious and there is far less room for
    mistakes. It’s still just a computer program, though. I emphasize this because
    we can understand the kernel attack in this chapter from a programmer’s perspective.
    The kernel is written in a mix of assembly and C (which is useful due to its low-level
    interface ability), so let’s take a look at a basic programming concept from a
    C and assembly point of view before we dive into exploiting our Windows target.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃内核会导致无法恢复的情况（即需要重新启动），而崩溃用户应用程序只需重启应用程序——因此，探索内核攻击更加危险，容错空间也小得多。不过，它仍然只是一个计算机程序。我强调这一点，因为我们可以从程序员的角度理解本章中的内核攻击。内核是用汇编和
    C 混合编写的（这种低级接口能力非常有用），因此在我们深入利用 Windows 目标之前，让我们先从 C 和汇编的角度看一下基本的编程概念。
- en: Pointing out the problem – pointer issues
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指出问题——指针问题
- en: 'Programming languages make use of different data types: numeric types such
    as integers, Boolean types to convey true and false, sets and arrays as composite
    data types, and so on. Pointers are yet another kind of data type – a reference.
    References are values that refer to data indirectly. For example, suppose I have
    a book with a map of each of the states of the United States on each page. If
    someone asks me where I live, I could say *page 35* – an indirect reference to
    the data (the state map) on that particular page. References as a data type are,
    in themselves, simple, but the datum to which a reference refers can itself be
    a reference. Imagine the complexity that is possible with this cute little object.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言使用不同的数据类型：数值类型，如整数，布尔类型用来表示真和假，集合和数组作为复合数据类型，等等。指针是另一种数据类型——引用。引用是指间接指向数据的值。例如，假设我有一本书，每一页上都有美国各州的地图。如果有人问我住在哪里，我可以说*第35页*——这是对该页面上数据（州地图）的间接引用。作为一种数据类型，引用本身是简单的，但引用所指向的数据本身也可以是一个引用。想象一下，这个小小的对象可能带来的复杂性。
- en: Dereferencing pointers in C and assembly
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C 语言和汇编中的解除引用指针
- en: 'Pointers, as a reference data type, are considered low-level because their
    values are used as memory addresses. A pointer points at a datum, and the actual
    memory address of the datum is therefore the value of the pointer. The action
    of using the pointer to access the datum at the defined memory address is called **dereferencing**.
    Let’s take a look at a sample C program that plays around with pointers and dereferencing,
    and then a quick peek at the assembly of the compiled program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为引用数据类型的指针被认为是低级的，因为它们的值用作内存地址。指针指向一个数据项，因此该数据项的实际内存地址就是指针的值。使用指针访问在定义的内存地址上的数据项的操作叫做**解除引用**。让我们看一个示例
    C 程序，它操作指针和解除引用，然后快速查看编译后的程序的汇编代码：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The compiled program generates this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的程序生成了以下输出：
- en: '![Figure 13.2 – The output of our pointer program ](image/Figure_13.2_B17616.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 我们指针程序的输出](image/Figure_13.2_B17616.jpg)'
- en: Figure 13.2 – The output of our pointer program
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 我们指针程序的输出
- en: Our following assembly examples are 64-bit (hence, for example, **RBP**), but
    the concepts are the same. However, we’re sticking with Intel syntax despite working
    in Linux, which uses AT&T syntax – this is to stay consistent with the previous
    chapter’s introduction to assembly. Remember, source and destination operands
    are reversed in AT&T notation!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的汇编示例是 64 位的（例如，**RBP**），但概念是一样的。然而，尽管我们在使用 Linux，但我们依然采用 Intel 语法，而 Linux
    使用的是 AT&T 语法——这是为了与前一章的汇编介绍保持一致。请记住，在 AT&T 语法中，源操作数和目标操作数是反过来的！
- en: 'Take a look at what happens at key points in the assembled program. Declaring
    the **x** integer causes a spot in memory to be allocated for it. **int x = 10;**
    looks like this in assembly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下在组装程序中的关键点发生了什么。声明**x**整数会在内存中为它分配一个位置。**int x = 10;** 在汇编语言中是这样写的：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Thus, the **10** value is moved into the **4**-byte location at the base pointer,
    minus **20**. Easy enough. (Note that the actual size of the memory allocated
    for our variable is defined here – **DWORD**. A double word is 32 bits, or 4 bytes,
    long.) But now, check out what happens when we get to **int *point = &x;** where
    we declare the int pointer, ***point**, and assign it the actual memory location
    of **x**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**10** 的值被移动到基址指针 **-20** 处的 4 字节位置。这很简单。（请注意，这里定义了我们变量的实际内存大小 —— **DWORD**。一个双字（double
    word）是 32 位或 4 字节长。）但是现在，看看当我们到达 **int *point = &x;** 时会发生什么，在这里我们声明了整数指针 ***point**，并将它赋值为
    **x** 的实际内存位置：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The **lea** instruction means **load effective address**. Here, the **RAX**
    register is the destination, so what’s really being said here is to put the address
    of the minus **20** base pointer into the **RAX** register. Next, the value in
    **RAX** is moved to the quadword of memory (8 bytes) at the minus **8** base pointer.
    So far, we set aside 4 bytes of memory at the minus **20** base pointer and placed
    the **10** integer there. Then, we took the 64-bit address of this integer’s location
    in memory and placed that value into memory at the minus **8** base pointer. In
    short, the **x** integer is now at **RBP - 20**, and the address at **RBP - 20**
    is now stored as a pointer in **RBP - 8**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**lea** 指令表示 **加载有效地址**。这里，**RAX** 寄存器是目标，所以实际上这里的意思是将 **-20** 基址指针的地址放入 **RAX**
    寄存器。接下来，**RAX** 中的值被移动到 **-8** 基址指针处的四字（quadword）内存中。到目前为止，我们已经在 **-20** 基址指针处为
    4 字节的内存腾出了空间，并将 **10** 整数放入其中。然后，我们取出了该整数在内存中的 64 位地址，并将该地址存储到 **-8** 基址指针处的内存中。简而言之，**x**
    整数现在位于 **RBP - 20**，而 **RBP - 20** 的地址现在作为指针存储在 **RBP - 8** 中。'
- en: 'When we dereference the pointer with **int deref = *point;**, we see this in
    assembly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 **int deref = *point;** 解引用指针时，汇编中会看到如下内容：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To understand these instructions, let’s quickly review the registers. Remember
    that **EAX** is a 32-bit register in IA-32 architecture; it’s an extension of
    the 16-bit **AX**. In x64 architecture, **RAX** is a 64-bit register, but remember
    that being backward-compatible, it follows the same principle – **RAX** is an
    extension of **EAX**:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些指令，我们先快速回顾一下寄存器。记住，**EAX** 是 IA-32 架构中的 32 位寄存器，它是 16 位 **AX** 的扩展。在 x64
    架构中，**RAX** 是 64 位寄存器，但记住它是向后兼容的，遵循相同的原则 —— **RAX** 是 **EAX** 的扩展：
- en: '![Figure 13.3 – 64-bit registers ](image/Figure_13.3_B17616.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 64 位寄存器](image/Figure_13.3_B17616.jpg)'
- en: Figure 13.3 – 64-bit registers
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 64 位寄存器
- en: The square brackets, **[ ]**, distinguish the contents of a memory location
    or register. So first, we’re putting the quadword value pointed to by **RBP -
    8** into the **RAX** register, then we’re loading the **DWORD** value that **RAX**
    is pointing to into the **EAX** register, and finally, the **DWORD** in **EAX**
    is placed in a **DWORD**-sized chunk of the memory at the minus **12** base pointer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号 **[ ]** 用于区分内存位置或寄存器的内容。所以，首先，我们将 **RBP - 8** 指向的四字（quadword）值放入 **RAX**
    寄存器中，然后我们将 **RAX** 所指向的 **DWORD** 值加载到 **EAX** 寄存器，最后，将 **EAX** 中的 **DWORD** 值存储到位于
    **-12** 基址指针的内存中。
- en: Remember that **RBP - 8** contained the address of our integer, **x**. So, as
    you can see in the assembly code, we managed to get that integer stored in another
    place in memory by pointing to a pointer that was pointing at our integer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**RBP - 8** 存储的是我们整数 **x** 的地址。所以，正如你在汇编代码中看到的那样，我们通过指向一个指针，成功地将那个整数存储到内存的另一个位置。
- en: Understanding NULL pointer dereferencing
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 NULL 指针解引用
- en: Now that we’ve reviewed pointer basics, we can define NULL pointer dereferencing
    – it’s when a program uses a pointer to access the memory location to which it
    points (dereference), but the pointer’s value is NULL. If you try to recall from
    our introduction to shellcoding, our program tried to access **0x7a7a7a7a** when
    we overwrote the return with the ASCII letter **z**, so in the case of a NULL
    pointer, an invalid location in memory is trying to be accessed. The difference
    is that we aren’t overwriting the pointer value with arbitrary bytes; it’s NULL
    – an address that simply doesn’t exist. The result is always some sort of a fault,
    but the resulting behavior can be unpredictable. With this being the case, why
    are we concerned with NULL pointer dereferencing?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了指针基础知识，我们可以定义NULL指针解引用——当程序使用指针访问它所指向的内存位置（解引用），但指针的值为NULL时，就会发生这种情况。如果你回忆一下我们在介绍shellcoding时的内容，我们的程序试图访问**0x7a7a7a7a**，这是我们在用ASCII字母**z**覆盖返回地址时发生的，所以在NULL指针的情况下，试图访问的是内存中一个无效的位置。区别在于，我们并没有用任意字节覆盖指针值；它是NULL——一个根本不存在的地址。结果总是某种故障，但最终的行为可能是不可预测的。既然如此，为什么我们会关注NULL指针解引用呢？
- en: I know what the hacker in you is saying, *it’s pretty obvious that exploiting
    a NULL pointer dereference vulnerability results in a denial of service*. Perhaps,
    grasshopper, but it’s a little more complicated than that. For one, the memory
    addresses starting at **0x00000000** may or may not be mapped – that is, if a
    NULL pointer’s value is literally zero, it may be possible to end up in a legitimate
    memory location. If it isn’t a valid memory location, we get a crash; but if it
    is valid, and there’s some tasty shellcode waiting there, then we have ourselves
    code execution. Another scenario to consider is that the pointer is not properly validated before
    being dereferenced. The actual value may not be NULL in this case, but the attack
    is effectively the same. For our analysis, we’ll pick on a well-known Windows
    vulnerability from 2014 – CVE-2014-4113.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你心中的黑客正想说，*显然利用NULL指针解引用漏洞会导致拒绝服务攻击（DoS）*。也许吧，小草蜢，但事情比这更复杂。首先，从**0x00000000**开始的内存地址可能是映射的，也可能不是——也就是说，如果NULL指针的值真的为零，可能会进入一个合法的内存位置。如果它不是一个有效的内存位置，我们就会遇到崩溃；但如果是有效的，而且那里有一些诱人的shellcode，那么我们就能实现代码执行。另一个需要考虑的情况是指针在解引用之前没有被正确验证。在这种情况下，实际的值可能不是NULL，但攻击本质上是一样的。为了进行分析，我们将选择一个2014年广为人知的Windows漏洞——CVE-2014-4113。
- en: Probably the most common way of referring to known vulnerabilities is with their
    **Common Vulnerabilities and Exposures** (**CVE**) designation. The CVE is a catalog
    of software-based threats sponsored by the US federal government. Vulnerabilities are
    defined as flaws that can give an attacker direct access to systems or data, whereas
    an exposure is a flaw that allows indirect access to systems or data. The CVE
    convention is **CVE-<year>-<ID number>**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提到已知漏洞最常见的方式可能是通过其**通用漏洞与暴露**（**CVE**）标识。CVE是由美国联邦政府赞助的一个基于软件的威胁目录。漏洞被定义为可能使攻击者直接访问系统或数据的缺陷，而暴露则是允许间接访问系统或数据的缺陷。CVE的命名规范为**CVE-<年份>-<编号>**。
- en: The Win32k kernel-mode driver
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Win32k内核模式驱动程序
- en: CVE-2014-4113 is also known by its Microsoft security bulletin designation,
    MS14-058\. It is an **Elevation of Privilege** (**EoP**) vulnerability in the
    kernel-mode driver **Win32k.sys**. I don’t know if the name **Win32k.sys** makes
    this apparent, but a bug in this particular driver is very bad news for a Windows
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2014-4113也被称为微软安全公告中的MS14-058。它是内核模式驱动程序**Win32k.sys**中的一个**特权提升**（**EoP**）漏洞。我不知道**Win32k.sys**这个名字是否已经表明了这一点，但这个特定驱动程序中的错误对于Windows系统来说是个非常糟糕的消息。
- en: The **Win32k.sys** driver is the kernel side of some core parts of the Windows
    subsystem. Its main functionality is the GUI of Windows; it’s responsible for
    window management. Any program that needs to display something doesn’t talk to
    graphics hardware directly. Instead, it interfaces via the **Graphics Device Interface**
    (**GDI**), which is managed by **Win32k.sys**. User mode window management talks
    to **Win32k.sys** through User32 DLLs from the **Client/Server Runtime Subsystem**
    (**CSRSS**) user-side service. Drivers provide access for entities to their functionality
    via entry points, and **Win32k.sys** has about 600 of them. This highly complex
    interaction and core functionality make security a bit of a nightmare for something
    like **Win32k.sys**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Win32k.sys** 驱动程序是 Windows 子系统某些核心部分的内核端。它的主要功能是 Windows 的图形用户界面（GUI）；负责窗口管理。任何需要显示内容的程序都不会直接与图形硬件交互。相反，它通过
    **图形设备接口**（**GDI**）进行接口，而 **Win32k.sys** 负责管理该接口。用户模式的窗口管理通过 **Client/Server Runtime
    Subsystem**（**CSRSS**）用户端服务中的 User32 DLL 与 **Win32k.sys** 进行通信。驱动程序通过入口点提供对其功能的访问，**Win32k.sys**
    大约有 600 个这样的入口点。这个高度复杂的交互和核心功能使得像 **Win32k.sys** 这样的组件在安全性方面成为一场噩梦。'
- en: 'This is a highly simplified depiction of the place of **Win32k.sys** in the
    Windows kernel and its relationship to userland:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其简化的图示，展示了 **Win32k.sys** 在 Windows 内核中的位置及其与用户空间的关系：
- en: '![Figure 13.4 – Win32k.sys interaction with the kernel ](image/Figure_13.4_B17616.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – Win32k.sys 与内核的交互](image/Figure_13.4_B17616.jpg)'
- en: Figure 13.4 – Win32k.sys interaction with the kernel
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – Win32k.sys 与内核的交互
- en: 'Note that this depiction also physically relates to memory, as userland is
    the lower portion of memory (at the top of the figure), and kernel land occupies
    the upper portion. **0x00000000** to **0x7FFFFFFF** is user space, and application
    virtual memory spaces occupy certain regions within it; the remainder, **0x80000000**
    to **0xFFFFFFFF**, is the almighty kernel. Windows design is not dumb – you can’t
    just arbitrarily execute something in kernel land:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个图示在物理上也与内存相关，因为用户空间位于内存的下半部分（图示的顶部），而内核空间占据上半部分。**0x00000000** 到 **0x7FFFFFFF**
    是用户空间，应用程序的虚拟内存空间占据其中的某些区域；剩余部分 **0x80000000** 到 **0xFFFFFFFF** 是强大的内核空间。Windows
    的设计并不傻——你不能随意在内核空间执行某些操作：
- en: '![Figure 13.5 – Exploiting Win32k.sys ](image/Figure_13.5_B17616.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 利用 Win32k.sys](image/Figure_13.5_B17616.jpg)'
- en: Figure 13.5 – Exploiting Win32k.sys
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 利用 Win32k.sys
- en: What we hope to accomplish is tricking code running in kernel mode to execute
    our payload within user space. We don’t need to trespass in the kernel’s backyard
    to get something running with the kernel’s high privileges.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现的目标是通过在内核模式下运行的代码来执行我们在用户空间中的有效载荷。我们不需要进入内核的“后院”就能让某些操作在内核的高权限下执行。
- en: Passing an error code as a pointer to xxxSendMessage()
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递一个错误代码作为 xxxSendMessage() 的指针
- en: There’s a lot of complexity in **Win32k.sys**, and we don’t have time to even
    scratch the surface, so let’s hone in on the vulnerable structures that we will
    be attacking with our module in the next section. Remember that **Win32k.sys**
    is largely responsible for window management, including handling requests from
    applications to output something to a display. There’s a function inside **Win32k.sys**
    called **xxxMNFindWindowFromPoint()** that is used to identify the window that
    is occupying a particular location on the screen (a point, given in *X* and *Y*
    coordinates). This function will return the memory address of a C++ structure
    called **tagWND** (**WND** means window; this is all window management), but if
    there’s an error, the function returns error codes – **-1** and **-5**. In a classic
    programming oversight, the caller of this function does check for the return of
    **-1**, but there isn’t a check for **-5**. As long as the zero flag isn’t set
    when the following simple comparison is executed – **cmp ebx,0FFFFFFFFh** – the
    program happily continues, knowing that it has a valid memory pointer returned
    from the called function. The invalid pointer vulnerability is born.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Win32k.sys**中有很多复杂内容，我们没有时间深入探讨，因此让我们集中注意力于下一节中，我们将使用模块攻击的脆弱结构。记住，**Win32k.sys**主要负责窗口管理，包括处理来自应用程序的请求，将内容输出到显示器。**Win32k.sys**中有一个名为**xxxMNFindWindowFromPoint()**的函数，用于识别占据屏幕特定位置的窗口（给定的*X*和*Y*坐标点）。该函数会返回一个C++结构体**tagWND**的内存地址（**WND**表示窗口；这属于窗口管理的一部分），但如果发生错误，函数会返回错误代码——**-1**和**-5**。在一个经典的编程疏忽中，调用此函数的代码会检查是否返回了**-1**，但并没有检查**-5**。只要在执行以下简单比较时——**cmp
    ebx,0FFFFFFFFh**——零标志没有被设置，程序就会高兴地继续运行，认为从被调用的函数中返回了有效的内存指针。无效指针漏洞就此产生。'
- en: 'Let’s take a look at the flow of execution through **Win32k.sys** with IDA.
    In my IDA session with the driver, I identify **sub_BF8B959D** as the **xxxSendMessage()**
    function (**sub** stands for subroutine). The critical moment is visible in **loc_BF9392D8** (**loc**
    for location in memory):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下通过IDA分析**Win32k.sys**的执行流程。在我的IDA会话中，我将驱动程序中的**sub_BF8B959D**识别为**xxxSendMessage()**函数（**sub**代表子程序）。关键时刻可以在**loc_BF9392D8**看到（**loc**表示内存位置）：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value in the **EBX** register is checked against the **-1** value (note
    the hexadecimal value is a signed integer; hence **0xFFFFFFFF** is equal to **-1**). **jnz**
    jumps if the zero flag is not set; remember, that’s just assembly talk for a jump
    to the specified location if the two compared values are *not* the same.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**EBX**寄存器中的值将与**-1**进行比较（请注意，十六进制值是有符号整数，因此**0xFFFFFFFF**等于**-1**）。如果零标志没有被设置，**jnz**将跳转；记住，这只是汇编语言的说法：如果两个比较值*不*相等，就跳转到指定的位置。'
- en: Let’s do a quick review of conditional jumps in assembly. The principles of
    *jump if zero* or *jump if not zero* refer to the result of a comparison. Suppose
    you have the **x** and **y** variables. It’s a plain logical statement that **x
    - x = 0**. Therefore, if **x - y = 0**, then we know that **x = y**. **jnz** and
    **jz** will check the zero flag in the flags register to check the result of the
    comparison.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下汇编中的条件跳转。*零跳转*或*非零跳转*的原理是基于比较结果。假设你有**x**和**y**这两个变量。这是一个简单的逻辑语句，**x
    - x = 0**。因此，如果**x - y = 0**，那么我们就知道**x = y**。**jnz**和**jz**会检查标志寄存器中的零标志位，以检查比较结果。
- en: 'So, if the value in **EBX** is not **-1**, then we jump to **loc_BF9392EB**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果**EBX**中的值不是**-1**，那么我们跳转到**loc_BF9392EB**：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s take a look at this in IDA.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在IDA中看一下这个情况。
- en: '![Figure 13.6 – A crucial test in IDA ](image/Figure_13.6_B17616.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – IDA 中的一个关键测试](image/Figure_13.6_B17616.jpg)'
- en: Figure 13.6 – A crucial test in IDA
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – IDA 中的一个关键测试
- en: 'Recall that in my specific IDA session here, **sub_BF8B959D** is the **xxxSendMessage**
    function. The simplest way to put this is that **xxxSendMessage** will be called
    if **EBX** contains anything other than **-1**. The **-5** value is not checked
    against **EBX** before the call. By returning **-5** into the flow at this point,
    we can pass it to the **xxxSendMessage** function as a parameter. **-5** represented
    as a hexadecimal value looks like **0xFFFFFFFB**. In this particular parameter,
    **xxxSendMessage** is expecting a pointer. If the exploit works, execution will
    try to jump to the memory location, **0xFFFFFFFB**. Part of the exploit’s job
    is to land us on the NULL page with an offset. The exploit will have already mapped
    some space in the NULL page before this point, so ultimately, execution jumps
    to shellcode waiting in user space. (As is often the case, Windows allows NULL
    page mapping for backward-compatibility reasons.) Now, I know what the hacker
    in you is saying: *It seems like disabling NULL page mapping would stop this attack
    right in its tracks*. A job well done as you’d be right, and Microsoft thought
    of that – NULL page mapping is disabled by default, starting in Windows 8.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在我的特定IDA会话中，**sub_BF8B959D**是**xxxSendMessage**函数。最简单的说法是，如果**EBX**包含除了**-1**之外的任何值，**xxxSendMessage**将被调用。**-5**的值在调用之前不会与**EBX**进行比较。通过在此时返回**-5**，我们可以将其作为参数传递给**xxxSendMessage**函数。**-5**以十六进制表示的值是**0xFFFFFFFB**。在这个特定参数中，**xxxSendMessage**期望的是一个指针。如果攻击成功，执行将尝试跳转到内存位置**0xFFFFFFFB**。攻击的一部分任务是将我们定位到NULL页面，并带有一个偏移量。在此之前，攻击已经在NULL页面上映射了一些空间，因此最终，执行跳转到用户空间中等待的shellcode。（像往常一样，Windows出于向后兼容的原因，允许NULL页面映射。）现在，我知道你内心的黑客在说：*看起来禁用NULL页面映射就能立刻阻止这个攻击*。你说得对，做得好，微软也考虑到了这一点——从Windows
    8开始，默认禁用NULL页面映射。
- en: There aren’t enough pages to do a deep dive into this particular vulnerability,
    but I hope I’ve given you enough background to try this out – get on your vulnerable
    Windows 7 VM and nab the driver (it’s in **System32**), open it up in IDA, and
    follow the flow of execution. See if you can understand what’s happening in the
    other functions in play here. Try keeping a running map of the registers and their
    values, and use the **push** and **pop** operations to understand the stack in
    real time. IDA is the perfect tool for this analysis. I have a feeling you’ll
    be hooked.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有足够的篇幅深入分析这个特定漏洞，但我希望我已为你提供了足够的背景信息来尝试这个实验——在你的Windows 7虚拟机上操作，获取驱动程序（它位于**System32**文件夹中），在IDA中打开它，跟踪执行流程。看看你是否能理解这里其他函数的运行情况。试着持续记录寄存器及其值，并利用**push**和**pop**操作实时了解堆栈的变化。IDA是进行这种分析的完美工具。我有预感，你会被深深吸引。
- en: Metasploit – exploring a Windows kernel exploit module
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metasploit – 探索Windows内核漏洞模块
- en: Now that we have a little background, we’re going to watch the attack in action
    with Metasploit. The exploit module specific to this vulnerability is called **exploit/windows/local/ms14_058_track_popup_menu**
    (recall that MS14-058 is the Microsoft security bulletin designation for this
    flaw). Note that this exploit falls under the **local** subcategory. The nature
    of this flaw requires that we are able to execute a program as a privileged user
    – this is a local attack, as opposed to a remote attack. Sometimes, you’ll see
    security publications discuss local exploits with phrases such as *the risk is
    limited by the fact that the attacker must be local to the machine*. The pen tester
    in you should be chuckling at this point because you know that the context of
    distinguishing local from remote essentially removes the human factor sitting
    at the keyboard. If we can convince the user to take some action, we’re as good
    as local. These local attacks can become remotely controlled with just a little
    finesse.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些背景知识，接下来我们将通过Metasploit观察攻击的实际操作。与此漏洞相关的利用模块名为**exploit/windows/local/ms14_058_track_popup_menu**（回忆一下，MS14-058是微软针对该漏洞发布的安全公告编号）。请注意，这个漏洞的利用属于**本地**子类别。该漏洞的性质要求我们能够以特权用户身份执行程序——这是一个本地攻击，而非远程攻击。有时，你会看到安全出版物用类似*攻击者必须位于本地机器旁边这一事实限制了风险*的措辞来讨论本地漏洞。此时，你应该会心一笑，因为你知道区分本地与远程攻击的语境，实际上是去除了坐在键盘前的人为因素。如果我们能说服用户采取某些行动，那么我们就可以像本地攻击一样操作。这些本地攻击只需一点小巧思就能变成远程控制。
- en: 'Before we get to the fun stuff, let’s examine the Metasploit module in detail
    so that we understand how it works. As always, we need to take a look at the **include**
    lines so that we can review the functionality that’s being imported into this
    module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入有趣的部分之前，让我们详细检查一下 Metasploit 模块，以便理解它是如何工作的。像往常一样，我们需要查看 **include** 语句，以便回顾导入到该模块中的功能：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, we have several Windows post-exploit modules loaded here: **File**, **Priv**,
    **Process**, **FileInfo**, and **ReflectiveDLLInjection**. I won’t bog you down
    by dumping the code from all five post modules here, but you should always consider
    a proper review of the included modules as a requirement. Recall that the **include**
    statement makes those modules mixins whose parameters are directly referenceable
    within this parent module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里加载了几个 Windows 后期攻击模块：**File**、**Priv**、**Process**、**FileInfo** 和 **ReflectiveDLLInjection**。我不会在这里给你列出所有五个模块的代码，但你应该始终认为，适当审查导入的模块是一个必要步骤。请记住，**include**
    语句将这些模块作为 mixins 导入，使得它们的参数可以直接在父模块中引用。
- en: Back to the parent module – we’re going to skip over the first two defined methods, **initialize(info={})**
    and **check**. You will remember that the **info** initialization provides useful
    information for the user, but this isn’t necessary for the module to function.
    The most practical purpose of this is making keywords available to the search
    function within **msfconsole**. The **check** method is also not strictly necessary,
    but it makes this module available to the compatibility checking functionality
    of Metasploit. When a target is selected, you can load an exploit and check whether
    the target is probably vulnerable. Personally, I find the check functionality
    to be nifty and potentially a timesaver, but in general, I would never recommend
    relying on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回到父模块 – 我们将跳过前两个定义的方法，**initialize(info={})** 和 **check**。你应该记得，**info** 初始化为用户提供有用的信息，但这对模块的功能来说并不是必需的。它的主要作用是使得关键字可以在
    **msfconsole** 中用于搜索功能。**check** 方法也不是严格必须的，但它使得该模块可以与 Metasploit 的兼容性检查功能一起使用。当选择一个目标时，你可以加载一个漏洞利用模块，并检查目标是否可能存在漏洞。就我个人而言，我觉得检查功能非常巧妙且可能节省时间，但通常来说，我不建议完全依赖它。
- en: 'Now, at long last – the **exploit** method. Please note that the method starts
    with some error checking that we’re skipping over; it makes sure we aren’t already
    **SYSTEM** (just in case you’re still racing after crossing the finish line!),
    and it checks that the session host architecture and the options-defined architecture
    match:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终于到了 – **exploit** 方法。请注意，该方法首先进行了一些错误检查，我们跳过了这些部分；它确保我们还不是 **SYSTEM**（以防你在冲过终点线后仍在全速前进！），并且检查会话主机架构与选项定义的架构是否匹配：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method starts with an attempt to launch Notepad. Note that the **{'Hidden'
    => true}** argument is passed to **execute**. This ensures that Notepad will execute
    but the friendly editor window won’t actually appear for the user (which would
    certainly tip off the user that something is wrong). We then handle the successful
    launch of Notepad and nab the process ID for the next stage of the exploit; alternatively,
    **rescue** comes to the rescue to handle the failure to launch Notepad and instead
    nabs the currently open process for the next stage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从尝试启动记事本开始。请注意，**{'Hidden' => true}** 参数被传递给 **execute**。这确保了记事本会执行，但友好的编辑器窗口不会实际出现在用户面前（这肯定会让用户察觉到有什么不对劲）。然后，我们处理记事本启动成功的情况，并获取进程
    ID，进入下一阶段的攻击；如果启动记事本失败，**rescue** 会派上用场，处理启动失败的情况，改为获取当前打开的进程用于下一阶段。
- en: DLLs are the Windows implementation of the shared library model. They are executable
    code that can be shared by programs. For all intents and purposes, they should
    be regarded as executables. The main difference from EXE files is that DLLs require
    an entry point that is provided by a running program. From a security perspective,
    DLLs are very dangerous because they are loaded in the memory space of the calling
    process, which means they have the same permissions as the running process. If
    we can inject a malicious DLL into a privileged process, this is pretty much game
    over.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DLL 是 Windows 中共享库模型的实现。它们是可以被多个程序共享的可执行代码。就实际用途而言，它们应当被视为可执行文件。与 EXE 文件的主要区别在于，DLL
    需要一个由运行中的程序提供的入口点。从安全角度来看，DLL 是非常危险的，因为它们被加载到调用进程的内存空间中，这意味着它们拥有与运行进程相同的权限。如果我们能够将恶意
    DLL 注入到一个特权进程中，这几乎就意味着游戏结束。
- en: 'And now, our big finale – reflective DLL injection. DLLs are meant to be loaded
    into the memory space of a process, so DLL injection is simply forcing this with
    our chosen DLL. However, since a DLL is an independent file in its own right,
    DLL injection typically involves pulling the DLL’s code off of the disk. Reflective DLL
    injection allows us to source code straight out of memory. Let’s take a look at
    what our module does with reflective DLL injection in the context of our **Win32k.sys**
    exploit:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的大高潮——反射 DLL 注入。DLL 旨在加载到进程的内存空间中，因此 DLL 注入实际上就是强制用我们选择的 DLL 来加载它。然而，由于
    DLL 本身就是一个独立的文件，DLL 注入通常涉及从磁盘上提取 DLL 的代码。反射 DLL 注入让我们可以直接从内存中提取源代码。让我们来看看我们的模块在
    **Win32k.sys** 漏洞利用的背景下如何进行反射 DLL 注入：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s examine this step by step and skip over the status printouts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地审查这部分，并跳过状态输出：
- en: First, the **if...else** **target.arch.first == ARCH_X86** statement. This is
    self-explanatory – the module is pulling an exploit DLL from the Metasploit **Data\Exploits**
    folder, and this check allows for the architecture to be targeted correctly.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是 **if...else** **target.arch.first == ARCH_X86** 语句。这不言自明——模块从 Metasploit
    **Data\Exploits** 文件夹中提取利用 DLL，这个检查使得架构能够正确地定位目标。
- en: '**library_path** allows the module to find and load the exploit DLL from the
    attacker’s local disk. I hope your creative side has kicked in and you just realized
    that you could modify this module to point at any DLL you like.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**library_path** 允许模块从攻击者的本地磁盘找到并加载利用 DLL。我希望你的创造性思维已经启动，你应该意识到，你可以修改这个模块，将它指向任何你喜欢的
    DLL。'
- en: '**exploit_mem, offset = inject_dll_into_process()** is the first slap across
    the target’s face. Note that **inject_dll_into_process()** is defined in the included
    **ReflectiveDLLInjection** module. This particular method takes the target process
    and the DLL’s local path as arguments and then returns an array with two values
    – the allocated memory address and the offset. Our module takes these returned
    values and stores them as **exploit_mem** and **offset** respectively.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exploit_mem, offset = inject_dll_into_process()** 是第一次给目标的耳光。注意，**inject_dll_into_process()**
    在包含的 **ReflectiveDLLInjection** 模块中定义。这个方法接受目标进程和 DLL 的本地路径作为参数，然后返回一个包含两个值的数组——分配的内存地址和偏移量。我们的模块将这些返回值分别存储为
    **exploit_mem** 和 **offset**。'
- en: '**payload_mem = inject_into_process()** is the second slap across the target’s
    face. **payload.encoded** is our shellcode (encoded as needed). This method returns
    only one value – the location of the shellcode in the target process’s memory.
    So, as you can see, at this point in our attack, **payload_mem** is now the location
    in our target’s memory where our shellcode begins.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**payload_mem = inject_into_process()** 是第二次给目标的耳光。**payload.encoded** 是我们的
    shellcode（根据需要编码）。此方法仅返回一个值——目标进程内存中 shellcode 的位置。所以，如你所见，在我们的攻击的这一阶段，**payload_mem**
    现在是目标内存中 shellcode 开始的位置。'
- en: 'If those first two instance methods for DLL injection were the slaps in the
    face, then **process.thread.create(exploit_mem + offset, payload_mem)** is our
    coup de grâce. We’re passing two parameters to **process.thread.create()**: first, **exploit_mem**
    with our offset added to it, and then the location of our shellcode in memory,
    **payload_mem**.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前两种 DLL 注入方法是给目标的耳光，那么 **process.thread.create(exploit_mem + offset, payload_mem)**
    就是我们致命的一击。我们向 **process.thread.create()** 传递了两个参数：首先是 **exploit_mem**（加上偏移量），然后是我们在内存中
    shellcode 的位置 **payload_mem**。
- en: So, why are we injecting a DLL into a process? The vulnerable kernel-mode driver,
    **Win32k.sys**, has more than 600 entry points that allow its functionality to
    be accessed; it handles a lot of useful tasks. As previously covered in this chapter,
    **Win32k.sys** is responsible for window management. **Win32k.sys** represents
    a necessary evil of this OS design – the blend of its needed power and accessibility
    to user-mode programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们要将 DLL 注入到一个进程中呢？易受攻击的内核模式驱动程序 **Win32k.sys** 有超过 600 个入口点，允许访问其功能；它处理了许多有用的任务。正如本章之前所讨论的，**Win32k.sys**
    负责窗口管理。**Win32k.sys** 代表了该操作系统设计中一个必要的邪恶——它所需的强大功能与对用户模式程序的可访问性相结合。
- en: Practical kernel attacks with Kali
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kali 进行实际的内核攻击
- en: We have enough background to sit down with Kali and fire off our attack at a
    vulnerable Windows target. At this point, you should fire up your Windows 7 VM.
    However, we’re doing two stages in this demonstration because the attack is local.
    So far, we’ve been examining attacks that get us in. This time, we’re already
    in. To the layperson, this sounds like the game is already won, but don’t forget
    that modern OSs are layered. There was a golden age when remote exploits landed
    you full **SYSTEM** privilege on a target Windows box. These days, this kind of
    remote exploit is a rare thing indeed. The far more likely scenario for today’s
    pen tester is that you’ll get some code executed, a shell pops up, and you feel
    all-powerful – until you realize that you only have the privileges of the lowly
    user of the computer who needs permission from the administrator to install software.
    You have your *foothold* – now, you need to escalate your privileges so that you
    can get some work done.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有足够的背景知识来与Kali坐下来，向一个易受攻击的Windows目标发动攻击。此时，你应该启动你的Windows 7虚拟机。然而，在这个演示中我们进行了两个阶段，因为这次攻击是本地的。到目前为止，我们一直在研究让我们进入的攻击。这一次，我们已经进入了。对于外行来说，这听起来就像游戏已经赢了，但不要忘记现代操作系统是分层的。曾经有一个黄金时代，远程漏洞会让你在目标Windows框上获得完整的**SYSTEM**权限。如今，这种远程漏洞是一件罕见的事情。对于今天的渗透测试人员来说，更有可能的情况是你会执行一些代码，一个shell弹出，你感觉自己无所不能
    - 直到你意识到你只有计算机上卑微用户的权限，需要管理员的许可才能安装软件。你有了你的*立足点* - 现在，你需要提升你的权限以便能够完成一些工作。
- en: An introduction to privilege escalation
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特权升级简介
- en: The kernel attack described in this chapter is an example of privilege escalation
    – we’re attacking a flaw on the kernel side after allocating memory on the user side
    and injecting code into it. Accordingly, did you notice the big difference between
    the module we just reviewed and the remote attacks we examined in previous chapters?
    That’s right – there was no option for specifying a target IP address. This is
    a local attack; the only IP address you’ll define is the return of your reverse
    TCP connection to the handler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的内核攻击是特权升级的一个例子 - 在用户端分配内存并向其中注入代码后，我们攻击内核端的漏洞。因此，你是否注意到我们刚刚审查的模块与我们在之前章节中检查的远程攻击之间的巨大差异？没错
    - 没有选项来指定目标IP地址。这是一次本地攻击；你唯一需要定义的IP地址是你的反向TCP连接返回给处理程序的地址。
- en: To complete this demo, you’ll need to establish the foothold first! As we’re
    challenging you with a little self-study in order to follow along, we’re sticking
    with our old-school Windows 7 target.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个演示，你首先需要建立立足点！由于我们要求你进行一些自学以便跟上，我们将继续使用我们老式的Windows 7目标。
- en: New OS, Old Problems – the Vulnerable OEM Driver
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 新操作系统，旧问题 - 易受攻击的OEM驱动程序
- en: Once you’re comfortable with the theory and practice on the older Windows 7,
    start exploring modern kernel exploits with Metasploit. Check out the amazing
    post module called **dell_memory_protect**. A driver provided by Dell on their
    laptops called **DBUtilDrv2.sys** had a critical kernel-level write-what-where
    vulnerability in versions 2.5 and 2.7\. Metasploit allows us to conduct the *bring
    your own vulnerable driver* attack on any Windows box, Dell or otherwise. The
    driver is easy to find online, so grab it, use the module to install it and disable
    LSA protections, and enjoy your **SYSTEM** access. Extra credit goes to those
    who tear apart the driver in IDA!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对旧版Windows 7的理论和实践感到满意，就开始使用Metasploit探索现代内核漏洞。查看名为**dell_memory_protect**的令人惊叹的后置模块。戴尔笔记本电脑上提供的一个名为**DBUtilDrv2.sys**的驱动程序在2.5和2.7版本中存在关键的内核级写-何处漏洞。Metasploit允许我们对任何Windows框执行*自带易受攻击驱动程序*攻击，无论是戴尔还是其他品牌。这个驱动程序很容易在网上找到，所以抓住它，使用模块安装它并禁用LSA保护，享受你的**SYSTEM**访问。那些在IDA中拆解驱动程序的人将获得额外的赞誉！
- en: Escalating to SYSTEM on Windows 7 with Metasploit
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Metasploit在Windows 7上升级到SYSTEM
- en: At this point, you’ve just received your Meterpreter connection back from the
    target – your foothold payload did the trick. We command **getuid** to see where
    we stand. Hmm – the username **FrontDesk** comes back. It doesn’t concern us that
    this user may or may not be an administrator; what’s important is that it isn’t
    **SYSTEM**, the absolute highest privilege possible. Even an administrator can’t
    get away with certain things – that account is still considered user mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你刚刚从目标那里收到了Meterpreter连接 - 你的立足点有效载荷起了作用。我们使用**getuid**命令来查看我们的身份。嗯 - 用户名**FrontDesk**回来了。这个用户是否是管理员并不关心我们；重要的是它不是**SYSTEM**，这是可能的最高权限。即使管理员也无法逃脱某些事情
    - 该帐户仍被视为用户模式。
- en: 'I type **background** to send my Meterpreter session into the background so
    that I can work at the **msf** prompt. Although the multi/handler exploit is still
    in use, I can simply replace it. This time, we prepare our kernel attack with
    **use exploit/windows/local/ms14_058_track_popup_menu**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入**background**将我的Meterpreter会话发送到后台，以便我可以在**msf**提示符下工作。尽管multi/handler漏洞仍在使用中，但我可以简单地替换它。这次，我们准备好用**use
    exploit/windows/local/ms14_058_track_popup_menu**进行内核攻击：
- en: '![Figure 13.7 – Managing our foothold in Metasploit ](image/Figure_13.7_B17616.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 在Metasploit中管理我们的立足点](image/Figure_13.7_B17616.jpg)'
- en: Figure 13.7 – Managing our foothold in Metasploit
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 在Metasploit中管理我们的立足点
- en: 'In our screenshot examples, we aren’t displaying the options available to us;
    so, try that out with **show options**. When you establish the exploit and run
    this command, you’ll see the **sessions** option. This is specific to the Meterpreter
    sessions you’ve already established. Out in the field, you may have a foothold
    on dozens of machines; use this option to direct this attack at a specific session.
    At the **msf** prompt, use **sessions -l** to identify the session you need. **sessions
    -i <id>** will take you back into a session, so you can issue **getuid** to verify
    your privilege:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的截图示例中，我们没有显示可用的选项；所以，试试**show options**。当你建立漏洞并运行此命令时，你会看到**sessions**选项。这是针对你已经建立的Meterpreter会话的。在实际操作中，你可能在几十台机器上都有立足点；使用这个选项将攻击指向特定的会话。在**msf**提示符下，使用**sessions
    -l**来识别你需要的会话。**sessions -i <id>**将带你回到某个会话中，这样你可以执行**getuid**来验证你的权限：
- en: '![Figure 13.8 – Launching the attack inside our established session ](image/Figure_13.8_B17616.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 在我们建立的会话中发起攻击](image/Figure_13.8_B17616.jpg)'
- en: Figure 13.8 – Launching the attack inside our established session
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 在我们建立的会话中发起攻击
- en: This can be a little confusing to set up, as you’re just coming back from configuring
    your handler with a payload. You need to set the payload to be used by the kernel
    exploit. In my example, I’m issuing **set payload windows/meterpreter/reverse_tcp**
    to create a connect-back Meterpreter shellcode payload.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个可能有点混乱，因为你刚刚配置了带有负载的handler。你需要设置内核漏洞所使用的负载。在我的示例中，我执行**set payload windows/meterpreter/reverse_tcp**来创建一个反向连接的Meterpreter
    shellcode负载。
- en: 'When you’re ready, fire off **run** and cross your fingers. This is an interesting
    attack; by its nature, the escalation could fail without killing your session.
    You’ll see everything on your screen suggesting a successful exploit, complete
    with a new Meterpreter session indicating that the shellcode was indeed executed
    – and yet, **getuid** will show the same user as before. This is why the module
    author put in the fingers-crossed status message, **hopefully privileged**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，执行**run**并祈祷好运。这是一个有趣的攻击；从其性质来看，权限提升可能会失败而不终止你的会话。你会看到屏幕上显示的所有内容都表明攻击成功，且有一个新的Meterpreter会话，表明shellcode确实已执行——然而，**getuid**将显示与之前相同的用户。这就是模块作者在状态消息中加入“祈祷成功”的原因，**hopefully
    privileged**：
- en: '![Figure 13.9 – Exploit complete – we are now SYSTEM ](image/Figure_13.9_B17616.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 漏洞完成 – 我们现在是SYSTEM](image/Figure_13.9_B17616.jpg)'
- en: Figure 13.9 – Exploit complete – we are now SYSTEM
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 漏洞完成 – 我们现在是SYSTEM
- en: In our demo, our Windows 7 Ultimate host was indeed vulnerable. We are now running
    as **SYSTEM**. Game over.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，我们的Windows 7 Ultimate主机确实存在漏洞。我们现在以**SYSTEM**身份运行。游戏结束。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored Windows kernel attacks. First, we reviewed the
    theory behind how the kernel works and what attackers try to leverage to pull
    off these attacks. Included in this theoretical discussion was a review of the
    low-level management role of the kernel and the security implications of these
    tasks, including scheduling interrupts. We picked a vulnerability type, the NULL
    or invalid pointer dereference vulnerability, and studied it in detail to understand
    how exploiting the kernel in this way gives the attacker full control of the system.
    We started with a review of pointers in C code and then examined the compiled
    assembly instructions to understand how the processor deals with the pointer concept.
    This review prepared us to understand what NULL pointers are and how they can
    cause problems in software. We then introduced a specific kernel-mode driver,
    **Win32k.sys**, and did a low-level review of its pointer flaw. We wrapped up
    this discussion with a review of the Metasploit exploit module, designed to attack
    this particular kernel-mode driver. Finally, we wrapped up the chapter with a
    hands-on demonstration of escalating privileges from an initial foothold by leveraging
    this attack against the vulnerable kernel-mode driver.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Windows 内核攻击。首先，我们回顾了内核工作原理及攻击者试图利用的内容。在这个理论讨论中，我们回顾了内核的低级管理角色以及这些任务的安全影响，包括调度中断。我们选择了一种漏洞类型，即
    NULL 或无效指针解引用漏洞，并对其进行了详细研究，以了解以这种方式利用内核如何使攻击者完全控制系统。我们从 C 代码中指针的回顾开始，然后检查编译后的汇编指令，以了解处理器如何处理指针概念。这个回顾使我们能够理解
    NULL 指针是什么，以及它们如何在软件中引起问题。然后，我们介绍了一个特定的内核模式驱动程序 **Win32k.sys**，并对其指针缺陷进行了低级别的审查。我们通过审查
    Metasploit 攻击模块来结束这个讨论，该模块旨在攻击这个特定的内核模式驱动程序。最后，我们通过利用这种攻击对易受攻击的内核模式驱动程序进行特权升级的实际演示来结束本章。
- en: In the next chapter, we’ll wrap up the programming fundamentals with a review
    of fuzzing. In this book, you’ve already played around with fuzzing and may not
    even be aware of it. We’ll review the underlying principles and get hands-on with
    fuzz testing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过对模糊测试的回顾来结束编程基础知识。在本书中，您已经尝试过模糊测试，甚至可能没有意识到。我们将回顾基本原理并进行模糊测试实践。
- en: Questions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的知识掌握情况：
- en: The ______ rests between the NT kernel and hardware.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ______ 位于 NT 内核和硬件之间。
- en: A ______ kernel can interrupt kernel-mode threads; cooperative OSs must wait
    for the thread to finish.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ______ 内核可以中断内核模式线程；协作操作系统必须等待线程完成。
- en: In C, the ampersand operator before a variable references __________.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C 中，变量前的和符号引用 __________。
- en: How many DWORDS fit into three quadwords?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个四字节能容纳多少个双字节？
- en: '**AX** is the lower ________ of the 64-bit **RAX**.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**AX** 是 64 位 **RAX** 的低 ________。'
- en: It is not possible to dereference an invalid pointer – true or false?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法解引用无效指针 - 真或假？
- en: My hexadecimal-to-decimal calculator says that **ffffffff** is equal to 4,294,967,295. Why
    does the **xxxSendMessage()** function think it’s **-1**?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的十六进制转十进制计算器显示 **ffffffff** 等于 4,294,967,295。为什么 **xxxSendMessage()** 函数认为它是
    **-1**？
- en: What’s the difference between DLL injection and reflective DLL injection?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DLL 注入和反射性 DLL 注入有什么区别？
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涵盖的主题的更多信息，请查看以下资源：
- en: Source code for HackSys Extreme Vulnerable Driver ([https://github.com/hacksysteam/HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver))
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HackSys Extreme Vulnerable Driver 的源代码 ([https://github.com/hacksysteam/HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver))
- en: The Windows SDK download for installing the debugger ([https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk))
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows SDK 下载以安装调试器 ([https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk))
