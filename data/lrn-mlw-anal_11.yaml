- en: Detecting Advanced Malware Using Memory Forensics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测使用内存取证技术的高级恶意软件
- en: In the previous chapter, we looked at different Volatility plugins, which help
    in extracting valuable information from the memory image. In this chapter, we
    will continue our journey of memory forensics and we will look at a few more plugins
    that will help you extract forensic artifacts from the memory image infected with
    advanced malware, which uses stealth and concealment techniques. In the next section,
    we will focus on detecting code injection techniques using memory forensics. The
    next section discusses some of the concepts already covered in [Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485),* Code
    Injection and Hooking,* so it is highly recommended to read that chapter before
    reading the next section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们查看了不同的 Volatility 插件，这些插件有助于从内存镜像中提取有价值的信息。在本章中，我们将继续探讨内存取证，并将介绍几个插件，这些插件将帮助您从感染了使用隐蔽和隐藏技术的高级恶意软件的内存镜像中提取取证物证。在接下来的部分中，我们将专注于使用内存取证检测代码注入技术。下一部分讨论了在[第
    8 章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)*代码注入与挂钩*中已经涵盖的一些概念，因此强烈建议在阅读下一部分之前先阅读该章节。
- en: 1\. Detecting Code Injection
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 检测代码注入
- en: 'If you recall from Chapter 8, *Code Injection and Hooking*, code injection
    is a technique used for injecting malicious code (such as EXE, DLL, or shellcode)
    into legitimate process memory and executing the malicious code within the context
    of a legitimate process. To inject code into the remote process, a malware program
    normally allocates a memory with a protection of `Read`, `Write`, and `Execute`
    permission `(PAGE_EXECUTE_READWRITE)`, and then injects the code into the allocated
    memory of the remote process. To detect the code that is injected into the remote
    process, you can look for the suspicious memory ranges based on the memory protection
    and content of the memory. The compelling question is, what is the suspicious
    memory range and how do you get information about the process memory range? If
    you recall from the previous chapter (in the* Detecting Hidden DLL using ldrmodules*
    section), Windows maintains a binary tree structure named *Virtual Address Descriptors
    (VADs)* in the kernel space, and each VAD node describes a virtually contiguous
    memory region in the process memory. If the process memory region contains a memory-mapped
    file (such as an executable, DLL, and so on), then one of VAD nodes stores information
    about its base address, file path, and the memory protection. The following depiction
    is not an exact representation of VAD, but it should help you understand the concept.
    In the following screenshot, one of the VAD nodes in the kernel space is describing
    the information about where the process executable (`explorer.exe`) is loaded,
    its full path, and the memory protection. Similarly, other VAD nodes will describe
    process memory ranges, including the ones that contain mapped executable images
    such as DLL. What this means is that VAD can be used to determine the memory protections
    of each contiguous process memory range, and it can also give information about
    a memory region containing a memory-mapped image file (such as an executable or
    DLL):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得第 8 章中的*代码注入与挂钩*，代码注入是一种用于将恶意代码（如 EXE、DLL 或 shellcode）注入到合法进程内存并在合法进程上下文中执行的技术。为了将代码注入到远程进程中，恶意软件通常会分配一个带有`读`、`写`和`执行`权限的内存（`PAGE_EXECUTE_READWRITE`），然后将代码注入到远程进程的已分配内存中。要检测注入到远程进程中的代码，可以根据内存保护和内存内容查找可疑内存范围。一个引人注目的问题是，什么是可疑的内存范围，如何获取关于进程内存范围的信息？如果你还记得上一章（在*检测隐藏的
    DLL 使用 ldrmodules* 部分），Windows 在内核空间维护了一个名为*虚拟地址描述符（VADs）*的二叉树结构，每个 VAD 节点描述了进程内存中的一个虚拟连续内存区域。如果进程内存区域包含内存映射文件（如可执行文件、DLL
    等），则其中一个 VAD 节点存储有关其基地址、文件路径和内存保护的信息。以下描绘并非 VAD 的精确表示，但应有助于理解该概念。在以下屏幕截图中，内核空间中的一个
    VAD 节点描述了关于进程可执行文件（`explorer.exe`）加载位置、完整路径及内存保护的信息。类似地，其他 VAD 节点将描述进程内存范围，包括包含映射的可执行映像（如
    DLL）的范围。这意味着 VAD 可用于确定每个连续进程内存范围的内存保护，并且还可以提供关于包含内存映像文件（如可执行文件或 DLL）的内存区域的信息：
- en: '![](../images/00345.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00345.jpeg)'
- en: 1.1 Getting VAD Information
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 获取 VAD 信息
- en: 'To get VAD information from the memory image, you can use the `vadinfo` Volatility
    plugin. In the following example, `vadinfo` is used to display the memory regions
    of an `explorer.exe` process using its process ID `(pid 2180)`. In the following
    output, the first VAD node at address `0x8724d718` in the kernel memory describes
    the memory range `0x00db0000-0x0102ffff` in the process memory and its memory
    protection `PAGE_EXECUTE_WRITECOPY.` Since the first node is describing a memory
    range containing a memory-mapped executable image (`explorer.exe`), it also gives
    its full path on the disk. The second node, `0x8723fb50`, describes a memory range
    of `0x004b0000-0x004effff`, which does not contain any memory mapped file. Similarly,
    the third node at address `0x8723fb78` displays the information about the process
    memory range of `0x77690000-0x777cbfff`, which contains `ntdll.dll` and its memory
    protection:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要从内存映像中获取VAD信息，可以使用`vadinfo` Volatility插件。在以下示例中，`vadinfo`用于显示`explorer.exe`进程的内存区域，通过其进程ID`(pid
    2180)`。在以下输出中，位于内核内存中地址`0x8724d718`的第一个VAD节点描述了进程内存中`0x00db0000-0x0102ffff`的内存范围及其内存保护`PAGE_EXECUTE_WRITECOPY`。由于第一个节点描述的是包含内存映射可执行镜像（`explorer.exe`）的内存范围，因此它还给出了其在磁盘上的完整路径。第二个节点`0x8723fb50`描述了`0x004b0000-0x004effff`的内存范围，该范围不包含任何内存映射文件。类似地，位于地址`0x8723fb78`的第三个节点显示了`0x77690000-0x777cbfff`的进程内存范围的信息，其中包含`ntdll.dll`及其内存保护：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To get the VAD information of a process using the Windbg kernel debugger, first,
    you need to switch the context to the desired process using the `.process` command
    followed by the address of the `_EPROCESS` structure. After switching the context,
    use the `!vad` extension command to display the process memory regions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Windbg内核调试器获取进程的VAD信息，首先需要使用`.process`命令切换到所需的进程上下文，并跟随`_EPROCESS`结构的地址。切换上下文后，使用`!vad`扩展命令显示进程的内存区域。
- en: 1.2 Detecting Injected Code Using VAD
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 使用VAD检测注入的代码
- en: 'An important point to note is that when an executable image (such as EXE or
    DLL) is normally loaded into the memory, that memory region is given a memory
    protection of `PAGE_EXECUTE_WRITECOPY(WCX)` by the operating system. An application
    is generally not allowed to allocate a memory with `PAGE_EXECUTE_WRITECOPY` protection
    using an API call such as `VirtualAllocEx.` In other words, if an attacker wants
    to inject a PE file (such as EXE or DLL) or shellcode, then a memory with a `PAGE_EXECUTE_READWRITE(RWX)` protection
    needs be allocated. Normally, you will see that very few memory ranges have a
    memory protection of `PAGE_EXECUTE_READWRITE.` A memory range having a protection
    of `PAGE_EXECUTE_READWRITE` is not always malicious, because a program may allocate
    memory with that protection for a legitimate purpose. To detect code injection,
    we can look for memory ranges containing a memory protection of `PAGE_EXECUTE_READWRITE`
    and examine and verify its contents to confirm the maliciousness. To help you
    understand this, let''s take an example of a memory image infected with *SpyEye.* This
    malware injects code into a legitimate `explorer.exe` process (`pid 1608`)`.`
    The `vadinfo` plugin shows two memory ranges in the `explorer.exe` process having
    a suspicious memory protection of `PAGE_EXECUTE_READWRITE`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的点是，当可执行镜像（如EXE或DLL）正常加载到内存时，操作系统会为该内存区域分配`PAGE_EXECUTE_WRITECOPY(WCX)`的内存保护。应用程序通常不允许使用像`VirtualAllocEx`这样的API调用来分配具有`PAGE_EXECUTE_WRITECOPY`保护的内存。换句话说，如果攻击者想要注入PE文件（如EXE或DLL）或shellcode，那么需要分配具有`PAGE_EXECUTE_READWRITE(RWX)`保护的内存。通常，你会发现很少有内存范围具有`PAGE_EXECUTE_READWRITE`的内存保护。具有`PAGE_EXECUTE_READWRITE`保护的内存范围不一定是恶意的，因为程序可能会出于合法目的分配具有该保护的内存。为了检测代码注入，我们可以查找包含`PAGE_EXECUTE_READWRITE`内存保护的内存范围，并检查和验证其内容以确认是否存在恶意代码。为了帮助你理解这一点，我们来看一个被*SpyEye*感染的内存映像的例子。该恶意软件将代码注入到合法的`explorer.exe`进程（`pid
    1608`）中。`vadinfo`插件显示了在`explorer.exe`进程中两个具有可疑`PAGE_EXECUTE_READWRITE`内存保护的内存范围：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Just from the memory protection, it is hard to conclude if the preceding memory
    regions contain any malicious code. To determine if there is any malicious code,
    we can dump the contents of these memory regions. To display the contents of a
    memory region, you can use the `volshell` plugin. The following command invokes
    `volshell` (an interactive Python shell) in the context of the `explorer.exe`
    process (`pid 1608`). The `db` command dumps the content of the given memory address.
    To get help information and display the supported `volshell` commands, just type
    `hh()` in the `volshell.` Dumping the contents of the memory address `0x03120000`
    (the first entry from the preceding `vadinfo` output) using the `db` command shows
    the presence of the `PE` file. The memory protection of `PAGE_EXECUTE_READWRITE`
    and the presence of the PE file is a clear indication that the executable was
    not normally loaded but was injected into the address space of the `explorer.exe`
    process:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过内存保护，难以得出前述内存区域是否包含恶意代码的结论。为了确定是否有恶意代码，我们可以转储这些内存区域的内容。要显示内存区域的内容，可以使用`volshell`插件。以下命令在`explorer.exe`进程（`pid
    1608`）的上下文中调用`volshell`（交互式 Python shell）。`db`命令将转储给定内存地址的内容。要获取帮助信息并显示支持的`volshell`命令，只需在`volshell`中输入`hh()`。使用`db`命令转储内存地址`0x03120000`（前面`vadinfo`输出中的第一个条目）的内容，显示出`PE`文件的存在。`PAGE_EXECUTE_READWRITE`的内存保护和
    PE 文件的存在明显表明可执行文件并非正常加载，而是被注入到`explorer.exe`进程的地址空间中：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, displaying the contents of a memory region may not be enough to
    identify malicious code. This is especially true when the shellcode is injected,
    and in that case, you need to disassemble the content. For instance, if you dump
    the contents of the address `0x03110000` (the second entry from the preceding
    `vadinfo` output) using the `db` command, you will see the following hex dump.
    From the output, it is not easy to say if this is a malicious code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅显示内存区域的内容不足以识别恶意代码。尤其是当 shellcode 被注入时，这种情况尤为常见。在这种情况下，你需要对内容进行反汇编。例如，如果你使用`db`命令转储地址`0x03110000`的内容（这是前面`vadinfo`输出中的第二个条目），你将看到以下的十六进制转储。从输出来看，很难判断这是否是恶意代码：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you suspect that the memory region contains a shellcode, you can use the  `dis`
    command in `volshell` to disassemble the code at a given address. From the disassembly
    output that''s shown in the following code, you can probably tell that a shellcode
    has been injected into this memory region, because it contains valid CPU instructions.
    To verify if the memory region contains any malicious code, you need to analyze
    it further in order to determine the context. This is because injected code can
    also look similar to the legitimate code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑内存区域包含 shellcode，可以在`volshell`中使用`dis`命令对给定地址的代码进行反汇编。从以下代码显示的反汇编输出来看，你可能会发现
    shellcode 已经被注入到此内存区域，因为它包含有效的 CPU 指令。为了验证内存区域是否包含恶意代码，你需要进一步分析，以确定其上下文。因为注入的代码也可能与合法代码相似：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 1.3 Dumping The Process Memory Region
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 转储进程内存区域
- en: 'After you have identified the injected code (PE file or shellcode) in the process
    memory, you may want to dump it to disk for further analysis (for extracting strings,
    to perform YARA scans, or for disassembly). To dump a region of memory described
    by the VAD node, you can use the `vaddump` plugin. For example, if you want to
    dump the memory region containing the shellcode at address `0x03110000,` you can
    supply the `-b (--base)` option followed by the base address, as follows. If you
    don’t specify the `-b (--base)` option, the plugin dumps all memory regions into
    separate files:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别到进程内存中的注入代码（PE 文件或 shellcode）后，你可能希望将其转储到磁盘以便进一步分析（例如提取字符串、进行 YARA 扫描或反汇编）。要转储由
    VAD 节点描述的内存区域，可以使用`vaddump`插件。例如，如果你想转储位于地址`0x03110000`的包含 shellcode 的内存区域，可以提供`-b
    (--base)`选项，并跟上基地址，如下所示。如果不指定`-b (--base)`选项，插件将把所有内存区域转储到单独的文件中：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some malware programs use stealth techniques to bypass detection. For example,
    a malware program may inject a PE file and wipe out the PE header after it is
    loaded into the memory. In that case, if you are looking at the hex dump, it will
    not give you any indication of the presence of PE file; some level of manual analysis
    may be required to verify the code. An example of such a malware sample is mentioned
    in a blog post titled *"Recovering CoreFlood Binaries with Volatility"* ([http://mnin.blogspot.in/2008/11/recovering-coreflood-binaries-with.html](http://mnin.blogspot.in/2008/11/recovering-coreflood-binaries-with.html)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件程序使用隐蔽技术来绕过检测。例如，某个恶意软件可能会注入一个 PE 文件，并在加载到内存后擦除 PE 头。在这种情况下，如果你查看十六进制转储，它不会显示
    PE 文件的任何迹象；可能需要某些手动分析来验证代码。有关此类恶意软件样本的示例，可以参考一篇名为 *"用 Volatility 恢复 CoreFlood
    二进制文件"* 的博客文章 ([http://mnin.blogspot.in/2008/11/recovering-coreflood-binaries-with.html](http://mnin.blogspot.in/2008/11/recovering-coreflood-binaries-with.html))。
- en: 1.4 Detecting Injected Code Using malfind
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 使用 malfind 检测注入的代码
- en: 'So far, we have looked at identifying suspicious memory regions manually using
    `vadinfo`. You have also understood how to dump a region of memory using `vaddump`.
    There is another Volatility plugin named `malfind`, which automates the process
    of identifying suspicious memory regions based on the memory content and the VAD
    characteristics covered previously. In the following example, when `malfind` was
    run against the memory image infected with *SpyEye,* it automatically identified
    the suspicious memory regions (containing a PE file and shellcode). In addition
    to that, it also displayed the hex dump and the disassembly starting at the base
    address. If you do not specify the `-p (--pid)` option, `malfind` will identify
    suspicious memory ranges of all the processes running on the system:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何使用 `vadinfo` 手动识别可疑的内存区域。你也已经理解了如何使用 `vaddump` 转储内存区域。还有另一个 Volatility
    插件叫做 `malfind`，它基于之前讲解的内存内容和 VAD 特征自动化了识别可疑内存区域的过程。在以下示例中，当 `malfind` 在被 *SpyEye*
    感染的内存镜像上运行时，它会自动识别出可疑的内存区域（包含 PE 文件和 shellcode）。除此之外，它还显示了从基地址开始的十六进制转储和反汇编。如果你没有指定
    `-p (--pid)` 选项，`malfind` 会识别系统上所有正在运行的进程的可疑内存区域：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 2\. Investigating Hollow Process Injection
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 调查空洞进程注入
- en: In the case of code injection techniques covered in the previous sections, the
    malicious code is injected into the process address space of a legitimate process.
    *Hollow Process Injection* (or *Process Hollowing*) is also a code injection technique,
    but the difference is that in this technique, the process executable of a legitimate
    process in the memory is replaced with a malicious executable. Before getting
    into the detection of hollow process injection, let's understand how it works
    in the next section. The detailed information on hollow process injection was
    covered in *[Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485),
    Code Injection and Hooking (section)*. You can also look at the author's presentation
    and video demos on hollow process injection ([https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/](https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/))
    for a better understanding of the subject.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面章节中讲解的代码注入技术中，恶意代码被注入到合法进程的进程地址空间中。*空洞进程注入*（或称 *进程空洞化*）也是一种代码注入技术，但不同之处在于，在这种技术中，合法进程的进程可执行文件会被恶意可执行文件替换。在进入空洞进程注入的检测之前，先让我们了解一下它是如何工作的。在下一节中将详细介绍空洞进程注入的工作原理。空洞进程注入的详细信息已在
    *[第8章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)，代码注入与钩子（章节）* 中讲解。你还可以查看作者关于空洞进程注入的演示和视频演示
    ([https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/](https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/))，以便更好地理解这个主题。
- en: 2.1 Hollow Process Injection Steps
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 空洞进程注入步骤
- en: 'The following steps describe how malware normally performs process hollowing.
    Let’s assume that there are two processes, A and B. In this case, process A is
    the malicious process and process B is the legitimate process (also known as a
    remote process) such as `explorer.exe`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了恶意软件通常如何执行进程空洞化。假设有两个进程，A 和 B。在这种情况下，进程 A 是恶意进程，进程 B 是合法进程（也称为远程进程），例如
    `explorer.exe`：
- en: Process A starts a legitimate process, B, in the suspended mode. As a result
    of that, the executable section of process B is loaded in the memory, and the
    `PEB` (Process Environment Block) identifies the full path to the legitimate process.
    The PEB structure's `ImageBaseAddress` field points to the base address where
    the legitimate process executable is loaded.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 启动合法进程 B，并使其处于挂起模式。结果，进程 B 的可执行区段被加载到内存中，`PEB`（进程环境块）标识了合法进程的完整路径。PEB 结构中的
    `ImageBaseAddress` 字段指向合法进程可执行文件加载的基地址。
- en: Process A gets the malicious executable that will be injected into the remote
    process. This executable can come from the resource section of the malware process
    or from the file on the disk.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 获取将要注入远程进程的恶意可执行文件。这个可执行文件可以来自恶意软件进程的资源区段，也可以来自磁盘上的文件。
- en: Process A determines the base address of the legitimate process B so that it
    can unmap the executable section of the legitimate process. Malware can determine
    the base address by reading the `PEB` (in our case, `PEB.ImageBaseAddress`).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 确定合法进程 B 的基址，以便它可以取消映射合法进程的可执行区段。恶意软件可以通过读取 `PEB`（在我们的例子中是 `PEB.ImageBaseAddress`）来确定基址。
- en: Process A then deallocates the executable section of the legitimate process.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 然后解除分配合法进程的可执行区段。
- en: Process A then allocates the memory in the legitimate process B with `read`,
    `write`, and `execute` permission. This memory allocation is normally done at
    the same address where the executable was previously loaded.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 然后在合法进程 B 中分配内存，并赋予`读`、`写`和`执行`权限。这个内存分配通常是在可执行文件先前加载的相同地址上进行的。
- en: Process A then writes the PE header and PE sections of the malicious executable
    to be injected into the allocated memory.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 然后将恶意可执行文件的 PE 头和 PE 区段写入分配的内存中。
- en: Process A then changes the start address of the suspended thread to the address
    of the entry point of the injected executable and resumes the suspended thread
    of the legitimate process. As a result of that, the legitimate process now starts
    executing malicious code.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程 A 然后将挂起线程的起始地址更改为注入的可执行文件入口点的地址，并恢复合法进程的挂起线程。结果，合法进程现在开始执行恶意代码。
- en: '*Stuxnet* is one such malware that performs hollow process injection using
    the preceding steps. To be specific, Stuxnet creates the legitimate `lsass.exe`
    process in the suspended mode. As a result, `lsass.exe` is loaded into memory
    with `PAGE_EXECUTE_WRITECOPY(WCX)` protection. At this point (before hollowing),
    both `PEB` and `VAD` contain the same metadata information about lsass.exe''s
    memory protection, base address, and the full path. Stuxnet then hollows out the
    legitimate process executable (`lsass.exe`) and allocates a new memory with `PAGE_EXECUTE_READWRITE
    (RWX)` protection in the same region where the `lsass.exe` was previously loaded,
    before injecting the malicious executable in the allocated memory and resuming
    the suspended thread. As a result of hollowing out the process executable, it
    creates a discrepancy in the process path information between the `VAD` and `PEB`,
    that is, the process path in `PEB` still contains the full path to `lsass.exe`,
    whereas `VAD` doesn''t show the full path. Also, there is memory protection discrepancy
    before hollowing `(WCX)` and after hollowing `(RWX).` The following diagram should
    help you visualize what happens before hollowing, and the discrepancy it creates
    in `PEB` and `VAD` after hollowing the process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*Stuxnet* 就是一个执行空洞进程注入的恶意软件，它使用上述步骤。具体来说，Stuxnet 在挂起模式下创建了合法的 `lsass.exe` 进程。结果，`lsass.exe`
    以 `PAGE_EXECUTE_WRITECOPY(WCX)` 保护加载到内存中。此时（空洞前），`PEB` 和 `VAD` 都包含有关 lsass.exe
    内存保护、基址和完整路径的相同元数据。接着，Stuxnet 将合法进程可执行文件（`lsass.exe`）空洞化，并在与 `lsass.exe` 先前加载的相同区域中分配一个具有
    `PAGE_EXECUTE_READWRITE (RWX)` 保护的新内存，随后将恶意可执行文件注入已分配的内存中并恢复挂起的线程。由于空洞化进程可执行文件，它在
    `VAD` 和 `PEB` 之间创建了进程路径信息的不一致，即 `PEB` 中的进程路径仍然包含 `lsass.exe` 的完整路径，而 `VAD` 中则不显示完整路径。此外，空洞前后的内存保护存在不一致：空洞前是
    `(WCX)`，空洞后是 `(RWX)`。下面的图示将帮助你理解空洞前发生的情况，以及空洞化进程后在 `PEB` 和 `VAD` 中创建的不一致。'
- en: '![](../images/00346.jpeg)The complete analysis of Stuxnet, using memory forensics,
    was covered by Michael Hale Ligh in the following blog post: [http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html](http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00346.jpeg)对Stuxnet的完整分析，使用内存取证技术，由Michael Hale Ligh在以下博客文章中介绍：[http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html](http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html)。'
- en: 2.2 Detecting Hollow Process Injection
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 检测空洞进程注入
- en: 'To detect hollow process injection, you can look for the discrepancies created
    between `PEB` and `VAD`, as well as the memory protection discrepancy. You can
    also look for the discrepancy in the parent-child process relationship. In the
    following *Stuxnet* example, you can see that there are two `lsass.exe` processes
    running on the system. The first `lsass.exe` process (`pid 708`) has a parent
    process of `winlogon.exe` (`pid 652`), whereas the second `lsass.exe` process
    (`pid 1732`) has a parent process (`pid 1736`) which is terminated. Based on the
    process information, you can tell that `lsass.exe` with a pid of `1732` is the
    suspicious process because, on a clean system, `winlogon.exe` will be the parent
    process of `lsass.exe` on pre-Vista machines and `wininit.exe` will be the parent
    process of `lsass.exe` on Vista and later systems:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测空洞进程注入，可以查看`PEB`和`VAD`之间的差异，以及内存保护的差异。还可以检查父子进程关系的差异。在下面的*Stuxnet*示例中，您可以看到系统上有两个`lsass.exe`进程正在运行。第一个`lsass.exe`进程（`pid
    708`）的父进程是`winlogon.exe`（`pid 652`），而第二个`lsass.exe`进程（`pid 1732`）的父进程（`pid 1736`）已经终止。根据进程信息，您可以判断`pid
    1732`的`lsass.exe`是可疑进程，因为在干净的系统中，`lsass.exe`的父进程在Vista之前的系统上是`winlogon.exe`，而在Vista及以后的系统上是`wininit.exe`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As mentioned earlier, you can detect hollow process injection by comparing
    the `PEB` and `VAD` structure. The `dlllist` plugin, which gets module information
    from the `PEB`, shows the full path to `lsass.exe` (`pid 1732`) and the base address
    `(0x01000000)` where it is loaded:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过比较`PEB`和`VAD`结构，您可以检测到空洞进程注入。`dlllist`插件从`PEB`中获取模块信息，显示了`lsass.exe`（`pid
    1732`）的完整路径和其加载的基地址`(0x01000000)`：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `ldrmodules` plugin, which relies on VAD in the kernel, does not show the
    full path name to the `lsass.exe.` As a result of malware unmapping the `lsass.exe`
    process executable section, the full path name is no longer associated with the
    address `0x01000000`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrmodules`插件依赖于内核中的VAD，但没有显示`lsass.exe`的完整路径名称。由于恶意软件解除映射了`lsass.exe`进程的可执行部分，完整路径名称不再与地址`0x01000000`关联：'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the malware normally allocates memory with `PAGE_EXECUTE_READWRITE` permission
    after hollowing and before injecting the executable, you can look for that memory
    protection. The `malfind` plugin identified the suspicious memory protection at
    the same address `(0x01000000)` where the executable `lsass.exe` was loaded:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意软件通常会在空洞化并注入可执行文件之前，分配具有`PAGE_EXECUTE_READWRITE`权限的内存，因此可以查找该内存保护。`malfind`插件在同一地址`(0x01000000)`识别到可疑的内存保护，这正是可执行文件`lsass.exe`被加载的地方：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you wish to dump the suspicious memory regions detected by `malfind` to disk,
    you can specify `-D`  followed by the directory name where all the suspicious
    memory regions will be dumped.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将`malfind`检测到的可疑内存区域转储到磁盘，您可以指定`-D`，后跟目录名，将所有可疑的内存区域转储到该目录。
- en: 2.3 Hollow Process Injection Variations
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 空洞进程注入变种
- en: 'In the following example, we will look at a malware named *Skeeyah*, which
    performs hollow process injection in a slightly different way. This is the same
    sample which was covered in [Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485),* Code
    Injection and Hooking (section 3.6 Hollow Process Injection)*. The following are
    the steps performed by *Skeeyah*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将介绍一个名为*Skeeyah*的恶意软件，它以略微不同的方式执行空洞进程注入。这是与[第8章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)中介绍的相同样本，*代码注入和钩子（第3.6节
    空洞进程注入）*。以下是*Skeeyah*执行的步骤：
- en: It starts the `svchost.exe` process in the suspended mode. As a result, `svchost.exe`
    is loaded into the memory (in this case, at address `0x1000000`).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以挂起模式启动`svchost.exe`进程。结果，`svchost.exe`被加载到内存中（在此案例中，加载到地址`0x1000000`）。
- en: It determines the base address of `svchost.exe` by reading `PEB.ImageBaseAddress`
    and then deallocates the executable section of `svchost.exe`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过读取`PEB.ImageBaseAddress`确定`svchost.exe`的基地址，然后释放`svchost.exe`的可执行部分。
- en: Instead of allocating memory in the same region where the `svchost.exe` was
    previously loaded (`0x1000000`), it allocates memory in a different address, `0x00400000`,
    with `read`, `write`, and `execute` permission.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它并没有在`svchost.exe`之前加载的相同区域（`0x1000000`）分配内存，而是分配了一个不同的地址`0x00400000`，并且具有`read`、`write`和`execute`权限。
- en: It then overwrites the `PEB.ImageBaseAdress` of the `svchost.exe` process with
    the newly allocated address, `0x00400000.` This changes the base address of `svchost.exe`
    in the `PEB` from `0x1000000` to `0x00400000` (which contains injected executables).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它随后用新分配的地址`0x00400000`覆盖了`svchost.exe`进程的`PEB.ImageBaseAdress`。这将`svchost.exe`在`PEB`中的基地址从`0x1000000`更改为`0x00400000`（该地址包含注入的可执行文件）。
- en: It then changes the start address of the suspended thread to the address of
    the entry point of the injected executable and resumes the thread.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将挂起线程的起始地址更改为注入的可执行文件入口点的地址，并恢复该线程。
- en: 'The following screenshot shows the discrepancy before and after hollowing.
    To be specific, the PEB after hollowing thinks that `svchost.exe` is loaded at
    `0x00400000`.  The `VAD` node that previously represented `svchost.exe` (loaded
    at `0x1000000`) is no longer present, because when the malware hollowed out the
    `svchost.exe` process executable, the entry for that was removed from the `VAD`
    tree:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了进程空洞化前后的差异。具体来说，空洞化后的PEB认为`svchost.exe`被加载到`0x00400000`。之前表示`svchost.exe`（加载地址为`0x1000000`）的`VAD`节点不再存在，因为当恶意软件将`svchost.exe`进程可执行文件空洞化时，相关的条目已从`VAD`树中移除：
- en: '![](../images/00347.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00347.jpeg)'
- en: 'To detect this variation of hollow process injection, you can follow the same
    methodology. Depending on how the hollow process injection is performed, the results
    will vary. The process listing shows multiple instances of the `svchost.exe` process,
    which is normal. All the `svchost.exe` processes except the last `svchost.exe
    (pid 1824)` have a parent process of `services.exe` `(pid 696)`. On a clean system,
    all the `svchost.exe` process are started by `services.exe`. When you look at
    the parent process of `svchost.exe` `(pid 1824)` you can see that its parent process
    is terminated. Based on the process information, you can tell that the last `svchost.exe
    (pid 1824)` is suspicious:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测这种空洞进程注入变种，可以遵循相同的方法论。根据空洞进程注入的执行方式，结果会有所不同。进程列表显示了多个`svchost.exe`进程实例，这是正常的。除了最后一个`svchost.exe
    (pid 1824)`，所有`svchost.exe`进程的父进程都是`services.exe`（`pid 696`）。在干净的系统上，所有`svchost.exe`进程都是由`services.exe`启动的。当你查看`svchost.exe`（`pid
    1824`）的父进程时，你会发现其父进程已终止。根据进程信息，你可以判断最后一个`svchost.exe (pid 1824)`是可疑的：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `dlllist` plugin (which relies on `PEB`) shows the full path to `svchost.exe`
    (`pid 1824`) and reports the base address as `0x00400000`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于`PEB`的`dlllist`插件显示了`svchost.exe`（`pid 1824`）的完整路径，并报告基地址为`0x00400000`。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, the `ldrmodules` plugin (which relies on VAD in the kernel)
    does not show any entry for `svchost.exe`, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，依赖于内核中的`VAD`的`ldrmodules`插件并未显示`svchost.exe`的任何条目，如下图所示：
- en: '![](../images/00348.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00348.jpeg)'
- en: '`malfind` shows the presence of a PE file at address `0x00400000` with a suspicious
    memory protection of `PAGE_EXECUTE_READWRITE`, indicating that this executable
    was injected and not normally loaded:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`malfind`显示在地址`0x00400000`存在一个PE文件，并且具有可疑的内存保护`PAGE_EXECUTE_READWRITE`，这表明该可执行文件是被注入的，而不是正常加载的：'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Attackers use different variations of hollow process injection to bypass, deflect,
    and divert forensic analysis. For detailed information on how these evasive techniques
    work and how to detect them using a custom Volatility plugin, watch the author''s
    Black Hat presentation titled: *"What Malware Authors Don''t Want You to Know
    - Evasive Hollow Process Injection"* ([https://youtu.be/9L9I1T5QDg4](https://youtu.be/9L9I1T5QDg4)).
    Alternatively, you can read the author''s blog post at the following link: [https://cysinfo.com/detecting-deceptive-hollowing-techniques/](https://cysinfo.com/detecting-deceptive-hollowing-techniques/)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者使用不同变种的空洞进程注入来绕过、偏转和转移取证分析。有关这些规避技术的详细信息，以及如何使用自定义Volatility插件来检测它们，请观看作者在Black
    Hat上的演讲：*“恶意软件作者不希望你知道的——空洞进程注入的规避技巧”*（[https://youtu.be/9L9I1T5QDg4](https://youtu.be/9L9I1T5QDg4)）。另外，你也可以阅读作者的博客文章，链接如下：[https://cysinfo.com/detecting-deceptive-hollowing-techniques/](https://cysinfo.com/detecting-deceptive-hollowing-techniques/)
- en: 3\. Detecting API Hooks
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 检测API钩子
- en: 'After injecting the malicious code into the target process, malware can hook
    API calls made by the target process to control its execution path and reroute
    it to the malicious code. The details of hooking techniques were covered in [Chapter
    8,](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)* Code Injection and
    Hooking (*in the *Hooking Techniques* section). In this section, we will mainly
    focus on detecting such hooking techniques using memory forensics. To identify
    API hooks in both processes and kernel memory, you can use the `apihooks` Volatility
    plugin. In the following example of *Zeus bot*, an executable is injected into
    the `explorer.exe` process''s memory at address `0x2c70000`, as detected by the
    `malfind` plugin:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在将恶意代码注入目标进程后，恶意软件可以挂钩目标进程的 API 调用，以控制其执行路径并将其重定向到恶意代码。挂钩技术的详细内容在[第8章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)中讨论，*代码注入与挂钩*（在*挂钩技术*部分）。在本节中，我们将主要关注如何使用内存取证技术检测此类挂钩技术。为了识别进程和内核内存中的
    API 挂钩，可以使用 `apihooks` Volatility 插件。在以下*Zeus bot*的示例中，一个可执行文件被注入到 `explorer.exe`
    进程的内存中，地址为 `0x2c70000`，这一点通过 `malfind` 插件检测到：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following output, the `apihooks` plugin detects the hook in the user-mode
    API `HttpSendRequestA` (in `wininet.dll`). The hooked API is then redirected to
    address `0x2c7ec48` (hook address). The hook address falls within the address
    range of the injected executable (hooking module). The name of the hooking module
    is unknown, because it is not normally loaded from the disk (but injected). To
    be specific, at the start address (`0x753600fc`) of the API function `HttpSendRequestA`,
    there is a jump instruction which redirects the execution flow of `HttpSendRequestA`
    to address `0x2c7ec48` within the injected executable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，`apihooks` 插件检测到用户模式 API `HttpSendRequestA`（在 `wininet.dll` 中）的挂钩。被挂钩的
    API 随后被重定向到地址 `0x2c7ec48`（挂钩地址）。挂钩地址位于注入的可执行文件（挂钩模块）的地址范围内。挂钩模块的名称未知，因为它通常不是从磁盘加载的（而是被注入的）。具体来说，在
    API 函数 `HttpSendRequestA` 的起始地址（`0x753600fc`）处，有一条跳转指令，将 `HttpSendRequestA` 的执行流重定向到注入可执行文件中的地址
    `0x2c7ec48`：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 4\. Kernel Mode Rootkits
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 内核模式根套件
- en: A malicious program such as rootkit can load a kernel driver to run the code
    in kernel mode. Once it's running in the kernel space, it has access to the internal
    operating system code and it can monitor system events, evade detection by modifying
    the internal data structures, hook functions, and modify the call tables. A kernel
    mode driver typically has an extension of `.sys` and it resides in `%windir%\system32\drivers`.
    A kernel driver is normally loaded by creating a service of type *Kernel Driver
    Service* (as described in [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485)*,
    Malware Functionalities and Persistence, *in the *Service* section).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像根套件这样的恶意程序可以加载一个内核驱动程序，在内核模式下运行代码。一旦它在内核空间中运行，就可以访问操作系统的内部代码，监控系统事件，通过修改内部数据结构、挂钩函数和修改调用表来规避检测。内核模式驱动程序通常具有
    `.sys` 扩展名，并驻留在 `%windir%\system32\drivers` 目录下。内核驱动程序通常通过创建一个*内核驱动程序服务*（如[第7章](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485)中描述的，恶意软件功能与持久性，*在*服务*部分）来加载。
- en: Windows has implemented various security mechanisms that are designed to prevent
    the execution of unauthorized code in the kernel space. This makes it difficult
    for a rootkit to install the kernel drivers. On 64-bit Windows, Microsoft implemented
    *Kernel-Mode Code Signing (KMCS)*, which requires the kernel mode drivers to be
    digitally signed in order to be loaded into memory. Another security mechanism
    is *Kernel Patch Protection (KPP)*, also known as *PatchGuard*, which prevents
    modifications to core system components, data structures, and call tables (such
    as SSDT, IDT, and so on). These security mechanisms are effective against most
    rootkits, but at the same time, this has forced the attackers to come up with
    advanced techniques that allow them to install unsigned drivers and to bypass
    these security mechanisms. One method is to install a *Bootkit*. A Bootkit infects
    the early stages of the system startup process, even before the operating system
    is fully loaded. Another method is to exploit vulnerabilities in the kernel or
    third-party driver to install an unsigned driver. For the rest of this chapter,
    we will assume that an attacker has managed to install the kernel mode driver
    (using *Bootkit* or by exploiting a kernel-level vulnerability), and we will focus
    on kernel memory forensics, which involves identifying the malicious driver.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 实施了各种安全机制，旨在防止内核空间中未经授权的代码执行。这使得 rootkit 难以安装内核驱动程序。在 64 位 Windows 上，微软实施了*内核模式代码签名（KMCS）*，要求内核模式驱动程序在加载到内存中时必须经过数字签名。另一个安全机制是*内核补丁保护（KPP）*，也称为*PatchGuard*，它防止对核心系统组件、数据结构和调用表（如
    SSDT、IDT 等）的修改。这些安全机制对大多数 rootkit 有效，但同时迫使攻击者提出先进技术，使他们能够安装未签名驱动程序并绕过这些安全机制。一种方法是安装*Bootkit*。Bootkit
    感染系统启动过程的早期阶段，甚至在操作系统完全加载之前。另一种方法是利用内核或第三方驱动程序的漏洞来安装未签名驱动程序。在本章的其余部分，我们将假设攻击者已经成功安装了内核模式驱动程序（使用*Bootkit*或利用内核级漏洞），并且我们将专注于内核内存取证，这涉及识别恶意驱动程序。
- en: On a clean windows system, you will find hundreds of kernel modules, so finding
    the malicious kernel module requires some work. In the following sections, we
    will look at some of the common techniques to locate and extract malicious kernel
    modules. We will start by listing the kernel modules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个干净的 Windows 系统上，你会发现数百个内核模块，因此找到恶意内核模块需要一些工作。在接下来的章节中，我们将看一些常见的定位和提取恶意内核模块的技术。我们将从列出内核模块开始。
- en: 5\. Listing Kernel Modules
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 列出内核模块
- en: To list the kernel modules, you can use the `modules` plugin. This plugin relies
    on walking the doubly linked list of metadata structures (`KLDR_DATA_TABLE_ENTRY`)
    pointed to by `PsLoadedModuleList` (this technique is similar to walking the doubly
    linked list of `_EPROCESS` structures, as described in [Chapter 10](part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485)*,
    Hunting Malware Using Memory Forensics,* in the* Understanding ActiveProcessLinks*
    section*)*. Listing kernel modules may not always help you identify the malicious
    kernel driver out of the hundreds of loaded kernel modules, but it can be useful
    for spotting a suspicious indicator such as a kernel driver having a weird name,
    or kernel modules loading from non-standard paths or the temporary paths. The
    `modules` plugin lists the kernel modules in the order in which they were loaded,
    which means that if a rootkit driver was recently installed, you are very likely
    to find that module at the end of the list, provided the module is not hidden
    and the system was not rebooted before the memory image was acquired.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出内核模块，你可以使用`modules`插件。该插件依赖于遍历由`PsLoadedModuleList`指向的元数据结构（`KLDR_DATA_TABLE_ENTRY`）的双向链表（这种技术类似于遍历`_EPROCESS`结构的双向链表，如[第
    10 章](part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485)*，使用内存取证猎杀恶意软件*，在*理解
    ActiveProcessLinks*部分中描述）。列出内核模块可能并不总是帮助你从加载的数百个内核模块中识别出恶意内核驱动程序，但它可以用于发现可疑指标，例如内核驱动程序具有奇怪的名称，或者内核模块从非标准路径或临时路径加载。`modules`插件按照加载顺序列出内核模块，这意味着如果最近安装了
    rootkit 驱动程序，你很可能会在列表的末尾找到该模块，前提是该模块没有被隐藏并且在获取内存镜像之前系统没有重新启动。
- en: 'In the following example of a memory image infected with the *Laqma* rootkit,
    the module listing shows the malicious driver of *Laqma,* `lanmandrv.sys`, at
    the end of the list running from the `C:\Windows\System32` directory, whereas
    most of the other kernel drivers are loaded from `*S*ystemRoot\System32\DRIVERS\`*.*
    From the listing, you can also see that the core operating system components such
    as the NT kernel module (`ntkrnlpa.exe` or `ntoskrnl.exe`) and the hardware abstraction
    layer `(hal.dll)` are loaded first, followed by the boot drivers (such as `kdcom.dll`)
    which start automatically at the boot time and then followed by other drivers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的受*Laqma* rootkit感染的内存映像示例中，模块列表显示了位于列表末尾的恶意驱动程序*Laqma*的`lanmandrv.sys`，该驱动程序来自`C:\Windows\System32`目录，而大多数其他内核驱动程序则加载自`*S*ystemRoot\System32\DRIVERS\`*。从列表中还可以看到，核心操作系统组件，如NT内核模块（`ntkrnlpa.exe`或`ntoskrnl.exe`）和硬件抽象层（`hal.dll`）最先加载，然后是启动驱动程序（如`kdcom.dll`），它们会在启动时自动启动，接着是其他驱动程序：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since walking the doubly linked list is susceptible to DKOM attacks (described
    in [Chapter 10](part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485)*, Hunting
    Malware Using Memory Forensics, section 4.2.1 Direct Kernel Object Manipulation
    (DKOM)*), it is possible to hide a kernel driver from the listing by unlinking
    it. To overcome this problem, you can use another plugin named `modscan.` The
    `modscan` plugin relies on the pool tag scanning approach (covered in [Chapter
    10](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=1250&action=edit#post_1143)*, Hunting
    Malware Using Memory Forensics**, section 4.2.2 Understanding Pool Tag Scanning*).
    In other words, it scans the physical address space looking for the pool tag (`MmLd`)
    associated with the kernel module. As a result of pool tag scanning, it can detect
    unlinked modules and the previously loaded modules. The `modscan` plugin displays
    the kernel modules in the order in which they were found in the physical address
    space, and not based on the order in which they were loaded. In the following
    example of the *Necurs* rootkit, the `modscan` plugin displays the malicious kernel
    driver (`2683608180e436a1.sys`) whose name is composed entirely of hex characters:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遍历双向链表容易受到DKOM攻击（详见[第10章](part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485)*，《使用内存取证狩猎恶意软件》第4.2.1节
    直接内核对象操作（DKOM）*），因此可以通过解除链接来隐藏内核驱动程序。为了解决这个问题，可以使用另一个名为`modscan`的插件。`modscan`插件依赖于池标签扫描方法（详见[第10章](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=1250&action=edit#post_1143)*，《使用内存取证狩猎恶意软件》**第4.2.2节
    理解池标签扫描*）。换句话说，它扫描物理地址空间，寻找与内核模块相关的池标签（`MmLd`）。通过池标签扫描，它可以检测到未链接的模块和先前加载的模块。`modscan`插件按照在物理地址空间中找到的顺序显示内核模块，而不是按加载顺序显示。在下面的*Necurs*
    rootkit示例中，`modscan`插件显示了恶意内核驱动程序（`2683608180e436a1.sys`），其名称完全由十六进制字符组成：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run the `modules` plugin against the memory image infected with the *Necurs*
    rootkit, it does not display that malicious driver (`2683608180e436a1.sys`):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`modules`插件来检查受*Necurs* rootkit感染的内存映像时，它不会显示那个恶意驱动程序（`2683608180e436a1.sys`）：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since `modscan` uses the pool tag scanning approach, which can detect unloaded
    modules (provided that the memory has not been overwritten), it is possible that
    the malicious driver, `2683608180e436a1.sys` was quickly loaded and unloaded,
    or that it is hidden. To confirm whether the driver was unloaded or hidden, you
    can use the `unloadedmodules` plugin, which will display the list of unloaded
    modules and the time when each one was unloaded. In the following output, absence
    of the malicious driver, `2683608180e436a1.sys`, tells you that this driver was
    not unloaded and it is hidden. From the following output, you can see another
    malicious driver called `2b9fb.sys` which was previously loaded and unloaded quickly
    (not present in the `modules` and `modscan` listing which is shown in the following
    code). The `unloadedmodules` plugin can prove to be useful during the investigation
    to detect the rootkit''s attempt to quickly load and unload the driver so that
    it does not show up in the module listing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`modscan`使用池标签扫描方法，可以检测已卸载的模块（前提是内存没有被覆盖），因此恶意驱动程序`2683608180e436a1.sys`可能已经被快速加载和卸载，或者它被隐藏了。为了确认驱动程序是否已卸载或隐藏，你可以使用`unloadedmodules`插件，它会显示已卸载模块的列表以及每个模块被卸载的时间。在以下输出中，恶意驱动程序`2683608180e436a1.sys`的缺失表明该驱动程序未被卸载，它被隐藏了。从以下输出中，你可以看到另一个恶意驱动程序`2b9fb.sys`，它曾被快速加载和卸载（在`modules`和`modscan`列出的模块中没有显示，如以下代码所示）。`unloadedmodules`插件在调查过程中可以证明有用，帮助检测rootkit快速加载和卸载驱动程序的尝试，以使其不出现在模块列表中：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 5.1 Listing Kernel Modules Using driverscan
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 使用driverscan列出内核模块
- en: 'Another method for listing the kernel modules is to use the `driverscan` plugin,
    as shown in the following code. The `driverscan` plugin gets the information related
    to kernel modules from a structure named `DRIVER_OBJECT.` To be specific, the `driverscan`
    plugin uses pool tag scanning to find the driver objects in the physical address
    space. The first column, `Offset(P)`, specifies the physical address where the
    `DRIVER_OBJECT` structure was found, the second column, `Start`, contains the
    base address of the module, and the `Driver Name` column displays the name of
    the Driver. For example, the driver name `\Driver\Beep` is the same as `Beep.sys`,
    and the last entry shows the malicious driver, `\Driver\2683608180e436a1`, associated
    with the *Necurs* rootkit. The `driverscan` plugin is another way of listing the
    kernel modules and can be useful when the rootkit tries to hide from the `modules`
    and the `modscan` plugin:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列出内核模块的另一种方法是使用`driverscan`插件，如以下代码所示。`driverscan`插件从名为`DRIVER_OBJECT`的结构中获取与内核模块相关的信息。具体来说，`driverscan`插件通过池标签扫描来查找物理地址空间中的驱动程序对象。第一列`Offset(P)`指定了找到`DRIVER_OBJECT`结构的物理地址，第二列`Start`包含模块的基地址，`Driver
    Name`列显示驱动程序的名称。例如，驱动程序名称`\Driver\Beep`与`Beep.sys`相同，最后一行显示与*Necurs* rootkit相关的恶意驱动程序`\Driver\2683608180e436a1`。`driverscan`插件是列出内核模块的另一种方法，当rootkit试图隐藏在`modules`和`modscan`插件下时，这种方法非常有用：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To list the kernel modules with the kernel debugger (Windbg), use the `lm k`
    command as follows. For verbose output, you can use the `lm kv` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用内核调试器（Windbg）列出内核模块，使用`lm k`命令，如下所示。要获取详细输出，可以使用`lm kv`命令：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After you identify the malicious kernel module, you can dump it from memory
    to disk using the `moddump` plugin. To dump the module to disk, you need to specify
    the base address of the module, which you can get from the `modules`, `modscan`,
    or `driverscan` plugins. In the following example, the malicious driver of the *Necurs
    rootkit* is dumped to disk using its base address, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你识别出恶意内核模块，你可以使用`moddump`插件将其从内存转储到磁盘。要将模块转储到磁盘，你需要指定模块的基地址，可以通过`modules`、`modscan`或`driverscan`插件获取。以下示例中，*Necurs
    rootkit*的恶意驱动程序通过其基地址转储到磁盘，如下所示：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 6\. I/O Processing
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. I/O处理
- en: While discussing the `driverscan` plugin, I had mentioned that `driverscan`
    gets module information from the `DRIVER_OBJECT` structure. Are you wondering
    what the `DRIVER_OBJECT` structure is? This will become clear soon. In this section,
    you will understand the interaction between the user-mode and kernel-mode components,
    the role of the device driver, and its interaction with the I/O manager. Typically,
    a rootkit consists of a user-mode component (EXE or DLL) and a kernel mode component
    (device driver). The user-mode component of the rootkit communicates with the
    kernel-mode components, using a specific mechanism. From a forensics standpoint,
    it is essential to understand how these communications work and the components
    involved. This section will help you understand the communication mechanism and
    lays the foundation for the upcoming topics.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论`driverscan`插件时，我曾提到`driverscan`从`DRIVER_OBJECT`结构中获取模块信息。你是不是在想`DRIVER_OBJECT`结构是什么？这个问题很快就会清楚。在本节中，你将理解用户模式与内核模式组件之间的交互、设备驱动程序的作用以及它与I/O管理器的交互。通常，rootkit包括一个用户模式组件（EXE或DLL）和一个内核模式组件（设备驱动程序）。rootkit的用户模式组件通过特定机制与内核模式组件进行通信。从取证角度来看，理解这些通信是如何工作的以及涉及的组件非常重要。本节将帮助你理解这种通信机制，并为接下来的主题打下基础。
- en: 'Let''s try to understand what happens when a user-mode application performs
    input/output (I/O) operations, and how it is processed at a high level. While
    discussing the API call flow in [Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485), *Code
    Injection and Hooking* (in the *Windows API call flow* section), I used the example
    of a user-mode application performing a write operation using the `WriteFile()`
    API, which ends up calling the `NtWriteFile()` system service routine in the kernel
    executive `(ntoskrnl.exe)`, which then directs the request to the I/O manager,
    whereupon the I/O manager requests the device driver to perform the I/O operation.
    Here, I will revisit that topic again with a little more detail and with an emphasis
    on the kernel-space components (mainly the device driver and the I/O manager).
    The following diagram illustrates the flow of the write request (other types of
    I/O requests, such as read, are similar; they just use different APIs):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解当用户模式应用程序执行输入/输出（I/O）操作时发生了什么，以及它在高层次上是如何处理的。在讨论[第8章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)中的API调用流程时，*代码注入与钩取*（在*Windows
    API调用流程*部分），我用一个用户模式应用程序通过`WriteFile()` API执行写操作的例子，这最终会调用内核执行中的`NtWriteFile()`系统服务例程`(ntoskrnl.exe)`，然后将请求指引给I/O管理器，接着I/O管理器请求设备驱动程序执行I/O操作。在这里，我将再次回顾这个话题，提供更多细节，并重点强调内核空间组件（主要是设备驱动程序和I/O管理器）。以下图示说明了写请求的流程（其他类型的I/O请求，如读取，也类似；它们只使用不同的API）：
- en: '![](../images/00349.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00349.jpeg)'
- en: 'The following points discuss the role of the device driver and the I/O manager
    at a high level:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点讨论了设备驱动程序和I/O管理器在高层次的作用：
- en: The device driver typically creates a device or multiple devices and specifies
    what type of operations (open, read, and write) it can handle for the device.
    It also specifies the address of routines that handle these operations. These
    routines are called dispatch routines or IRP handlers.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备驱动程序通常会创建一个或多个设备，并指定它可以处理的操作类型（打开、读取和写入）。它还指定了处理这些操作的例程地址。这些例程被称为分发例程或IRP处理程序。
- en: After creating the device, the driver advertises that device so that it is accessible
    to user-mode applications.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建设备后，驱动程序会发布该设备，以便用户模式应用程序可以访问。
- en: The user mode application can use API calls, such as `CreateFile`, to open handle
    the advertised device and perform I/O operations such as read, and write on the
    device using the `ReadFile` and `WriteFile` APIs. APIs, such as `CreateFile`,
    `ReadWrite`, and `WriteFile`, that are used to perform I/O operations on the file
    also work on a device. This is because the device is treated as a virtual file.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户模式的应用程序可以使用API调用，如`CreateFile`，打开已公开的设备句柄，并使用`ReadFile`和`WriteFile` API在设备上执行I/O操作，如读取和写入。用于执行文件I/O操作的API，如`CreateFile`、`ReadWrite`和`WriteFile`，也适用于设备。这是因为设备被视为虚拟文件。
- en: When the I/O operation is performed on the advertised device by the user mode
    application, the request is routed to the I/O manager. The I/O manager determines
    the driver that handles the device and requests the driver to complete the operation
    by passing an IRP (I/O request packet). An IRP is a data structure that contains
    information on what operation to perform and the buffer required for the I/O operation.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户模式应用程序在广告设备上执行I/O操作时，请求将被路由到I/O管理器。 I/O管理器确定处理设备的驱动程序，并请求驱动程序通过传递IRP（I/O请求数据包）来完成操作。
    IRP是一个包含执行操作和I/O操作所需缓冲区信息的数据结构。
- en: The driver reads the IRP, verifies it, and completes the requested operation
    before notifying the I/O manager about the status of the operation. The I/O manager
    then returns the status and the data back to the user application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序读取IRP，验证它，并在通知I/O管理器有关操作状态之前完成请求的操作。 然后，I/O管理器将状态和数据返回给用户应用程序。
- en: 'At this stage, the preceding points might seem foreign to you, but don''t let
    it discourage you: it will be clear by the time you complete this section. Next,
    we will look at the role of the device driver, followed by the role of the I/O
    manager.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，前面的内容可能对您来说很陌生，但不要让它让您灰心：当您完成本节时，一切将变得清晰。 接下来，我们将看一下设备驱动程序的作用，然后是I/O管理器的作用。
- en: 6.1 The Role Of The Device Driver
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 设备驱动程序的作用
- en: 'When the driver is loaded into the system, the I/O manager creates a driver
    object (`DRIVER_OBJECT` structure). The I/O manager then calls the driver''s initialization
    routine, `DriverEntry` (which is analogous to the `main()` or `WinMain()` functions),
    by passing a pointer to the `DRIVER_OBJECT` structure as an argument. A driver
    object (`DRIVER_OBJECT` structure) represents an individual driver on the system.
    The `DriverEntry` routine will use the `DRIVER_OBJECT` to populate it with various
    entry points of the driver for handling specific I/O requests. Typically, in the
    `DriverEntry` routine, the driver creates a device object (`DEVICE_OBJECT` structure)
    that represent logical or physical devices. The device is created using an API
    called `IoCreateDevice` or `IoCreateDevice-Secure.` When the driver creates a
    device object, it can optionally assign the name to the device and it can also
    create multiple devices. After the device is created, the pointer to the first
    created device is updated in the driver object. To help you understand this better,
    let''s list the loaded kernel modules and look at a driver object of a simple
    kernel module. For this example, we will examine the `null.sys` kernel driver.
    As per Microsoft documentation, the Null device driver provides the functional
    equivalent of `\dev\null` in the Unix environment. When the system starts during
    the kernel initialization phase, `null.sys` gets loaded into the system. In the
    kernel module listing, you can see that `null.sys` is loaded at base address `8bcde000`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序加载到系统中时，I/O管理器会创建一个驱动程序对象（`DRIVER_OBJECT`结构）。 然后，I/O管理器通过将指向`DRIVER_OBJECT`结构的指针作为参数调用驱动程序的初始化例程`DriverEntry`（类似于`main()`或`WinMain()`函数）。
    驱动程序对象（`DRIVER_OBJECT`结构）代表系统上的一个驱动程序。 `DriverEntry`例程将使用`DRIVER_OBJECT`来填充具有处理特定I/O请求的驱动程序各种入口点的结构。
    通常，在`DriverEntry`例程中，驱动程序会使用一个名为`IoCreateDevice`或`IoCreateDevice-Secure`的API创建代表逻辑或物理设备的设备对象（`DEVICE_OBJECT`结构）。
    当驱动程序创建设备对象时，可以选择为设备分配名称，也可以创建多个设备。 创建设备后，将更新指向第一个创建的设备的指针在驱动程序对象中。 为了帮助您更好地理解这一点，让我们列出加载的内核模块，并查看一个简单内核模块的驱动程序对象。
    作为示例，我们将检查`null.sys`内核驱动程序。 根据微软文档，Null设备驱动程序提供了Unix环境中`\dev\null`的功能等效物。 当系统在内核初始化阶段启动时，`null.sys`被加载到系统中。
    在内核模块列表中，您可以看到`null.sys`加载在基地址`8bcde000`处：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `null.sys` is already loaded, its driver object (`DRIVER_OBJECT` structure)
    will be populated with metadata information during the driver initialization.
    Let''s look at its driver object to understand what kind of information it contains.
    You can display the driver object information using the `!drvobj` extension command.
    From the following output, the driver object representing `null.sys` is at address
    `86a33180.` The value `86aa2750` below `Device Object list` is the pointer to
    the device object created by `null.sys`. If the driver creates multiple devices,
    you will see multiple entries under the `Device Object list`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`null.sys`已经加载，在驱动程序初始化过程中，它的驱动对象（`DRIVER_OBJECT`结构）将会填充元数据。在驱动程序对象中查看它包含什么信息。你可以使用`!drvobj`扩展命令显示驱动程序对象信息。从以下输出可以看到，表示`null.sys`的驱动对象位于地址`86a33180`。`Device
    Object list`下的`86aa2750`是指向由`null.sys`创建的设备对象的指针。如果驱动程序创建了多个设备，你将会在`Device Object
    list`下看到多个条目：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can use the driver object address `86a33180` to examine the `_DRIVER_OBJECT`
    structure of `null.sys` using the `dt (display type)` command. From the following
    output, you can see that the `DriverStart` field holds the base address (`0x8bcde000`)
    of the driver, the `DriverSize` field contains the size of the `driver(0x7000)`,
    and the `Drivername` is the name of the driver object (`\Driver\Null`)`.` The
    `DriverInit` field holds the pointer to the *Driver initialization routine* (`DriverEntry`).
    The `DriverUnload` field contains the pointer to the driver''s unload routine,
    which normally frees up resources created by the driver during unload process.
    The `MajorFunction` field is one of the most important fields, that points to
    a table of 28 major function pointers. This table will be populated with the addresses
    of the dispatch routines, and we will look at the `MajorFunction` table later
    in this section. The `driverscan` plugin covered earlier performs pool tag scanning
    for the driver objects and gets the information related to the kernel module such
    as base address, size, and the driver name by reading some of these fields:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用驱动程序对象地址`86a33180`来通过`dt (display type)`命令检查`null.sys`的`_DRIVER_OBJECT`结构。从以下输出可以看到，`DriverStart`字段包含驱动程序的基地址（`0x8bcde000`），`DriverSize`字段包含`driver(0x7000)`的大小，`Drivername`是驱动对象的名称（`\Driver\Null`）。`DriverInit`字段保存指向*驱动初始化例程*（`DriverEntry`）的指针。`DriverUnload`字段包含指向驱动程序卸载例程的指针，该例程通常会在卸载过程中释放驱动程序创建的资源。`MajorFunction`字段是最重要的字段之一，它指向一个包含28个主要功能指针的表。这个表将会填充调度例程的地址，我们将在本节稍后查看`MajorFunction`表。前面讲到的`driverscan`插件会对驱动程序对象执行池标签扫描，并通过读取这些字段中的某些信息获取与内核模块相关的信息，如基地址、大小和驱动程序名称：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `DeviceObject` field in the `DRIVER_OBJECT` structure contains the pointer
    to the device object created by the driver (`null.sys`). You can use the device
    object address `0x86aa2750` to determine the name of the device created by the
    driver. In this case, `Null` is the name of the device created by the driver `null.sys`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`DRIVER_OBJECT`结构中的`DeviceObject`字段包含指向驱动程序（`null.sys`）创建的设备对象的指针。你可以使用设备对象地址`0x86aa2750`来确定驱动程序创建的设备的名称。在本例中，`Null`是由驱动程序`null.sys`创建的设备名称：'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also look at the actual `DEVICE_OBJECT` structure by specifying the
    device object address next to the `display type (dt)` command, as shown in the
    following code. If the driver creates more than one device, then the `NextDevice`
    field in the `DEVICE_OBJECT` structure will point to the next device object. Since
    the `null.sys` driver creates only one device, the `NextDevice` field is set to
    `null`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在`display type (dt)`命令后面指定设备对象地址来查看实际的`DEVICE_OBJECT`结构，如下所示的代码。如果驱动程序创建了多个设备，那么`DEVICE_OBJECT`结构中的`NextDevice`字段将指向下一个设备对象。由于`null.sys`驱动程序只创建了一个设备，`NextDevice`字段被设置为`null`：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the preceding output, you can see that the `DEVICE_OBJECT` contains a `DriverObject` field
    that points back to the driver object. In other words, the associated driver can
    be determined from the device object. This is how the I/O manager can determine
    the associated driver when it receives the I/O request for a specific device.
    This concept can be visualized using the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出可以看到，`DEVICE_OBJECT`包含一个`DriverObject`字段，它指向回驱动程序对象。换句话说，可以通过设备对象确定相关联的驱动程序。这就是I/O管理器如何在收到特定设备的I/O请求时，确定关联的驱动程序的方式。这个概念可以通过以下图示来可视化：
- en: '![](../images/00350.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00350.jpeg)'
- en: 'You can use a GUI tool such as *DeviceTree* ([http://www.osronline.com/article.cfm?article=97](http://www.osronline.com/article.cfm?article=97))
    to look at the devices created by the driver. The following is a screenshot of
    the tool showing the `Null` device created by the `null.sys` driver:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用像 *DeviceTree* ([http://www.osronline.com/article.cfm?article=97](http://www.osronline.com/article.cfm?article=97))
    这样的图形界面工具来查看驱动程序创建的设备。以下是该工具显示 `null.sys` 驱动程序创建的 `Null` 设备的截图：
- en: '![](../images/00351.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00351.jpeg)'
- en: 'When a driver creates a device, the device objects are placed in the `\Device`
    directory in the Windows object manager''s namespace. To view the object manager''s
    namespace information, you can use the  *WinObj* tool ([https://docs.microsoft.com/en-us/sysinternals/downloads/winobj](https://docs.microsoft.com/en-us/sysinternals/downloads/winobj)).
    The following screenshot shows the device (`Null`) created by `null.sys` in the
    `\Device` directory. You can also see the devices that have been created by other
    drivers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序创建一个设备时，设备对象会被放置在 Windows 对象管理器的命名空间中的 `\Device` 目录下。要查看对象管理器的命名空间信息，可以使用
    *WinObj* 工具 ([https://docs.microsoft.com/en-us/sysinternals/downloads/winobj](https://docs.microsoft.com/en-us/sysinternals/downloads/winobj))。以下截图显示了由
    `null.sys` 在 `\Device` 目录下创建的设备（`Null`）。你还可以看到其他驱动程序创建的设备：
- en: '![](../images/00352.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00352.jpeg)'
- en: 'The device created under the `\Device` directory is not accessible to the applications
    running in the user mode. In other words, if a user mode application wants to
    perform I/O operations on the device, it cannot directly open a handle to the
    device by passing the name of the device (such as `\Device\Null`) as the argument
    to the `CreateFile` function. The `CreateFile` function is not just used for creating
    or opening a file, it can also be used to open a handle to the device. If a user
    mode application cannot access the device, then how can it perform I/O operations?
    To make the device accessible to the user mode applications, the driver needs
    to advertise the device. This is done by creating a symbolic link to the device.
    A driver can create a symbolic link using the kernel API `IoCreateSymbolicLink.`
    When a symbolic link is created for a device (such as `\Device\Null`), you can
    find it in the `\GLOBAL??` directory in the object manager namespace, which can
    also be viewed using the *WinObj* tool. In the following screenshot, you can see
    that `NUL` is the name of the symbolic link created for the `\Device\Null` device
    by the `null.sys` driver:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建在 `\Device` 目录下的设备对于用户模式下运行的应用程序是不可访问的。换句话说，如果一个用户模式应用程序想要对设备执行 I/O 操作，它不能通过将设备名称（如
    `\Device\Null`）作为参数传递给 `CreateFile` 函数来直接打开设备句柄。`CreateFile` 函数不仅用于创建或打开文件，还可以用于打开设备句柄。如果用户模式应用程序无法访问设备，那它如何执行
    I/O 操作呢？为了使设备对用户模式应用程序可访问，驱动程序需要宣传该设备。这可以通过为设备创建一个符号链接来实现。驱动程序可以使用内核 API `IoCreateSymbolicLink`
    来创建符号链接。当为设备（如 `\Device\Null`）创建符号链接时，你可以在对象管理器命名空间中的 `\GLOBAL??` 目录下找到它，也可以使用
    *WinObj* 工具查看。以下截图中，你可以看到 `NUL` 是由 `null.sys` 驱动程序为 `\Device\Null` 设备创建的符号链接名称：
- en: '![](../images/00353.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00353.jpeg)'
- en: 'The symbolic link is also referred to as an MS-DOS device name. A user mode
    application can simply use the name of the symbolic link (MS-DOS device name)
    to open the handle to the device using the convention `\\.\<symboliclink name>`.
    For example, to open a handle to `\Device\Null`, a user mode application has to
    just pass `\\.\NUL` as the first argument (`lpFilename`) to the `CreateFile` function,
    which returns the file handle to the device. To be specific, anything that is
    a symbolic link within the object manager''s directory `GLOBAL??` can be opened
    using the `CreateFile` function. As shown in the following screenshot, the `C:` volume
    is just a symbolic link to `\Device\HarddiskVolume1`*.* In Windows, I/O operations
    are performed on virtual files. In other words, devices, directories, pipes, and
    files are all treated as virtual files (that can be opened using the `CreateFile`
    function):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接也被称为 MS-DOS 设备名称。用户模式应用程序可以直接使用符号链接的名称（MS-DOS 设备名称）来通过约定 `\\.\<symboliclink
    name>` 打开设备的句柄。例如，要打开 `\Device\Null` 的句柄，用户模式应用程序只需将 `\\.\NUL` 作为第一个参数（`lpFilename`）传递给
    `CreateFile` 函数，该函数会返回设备的文件句柄。具体来说，在对象管理器的 `GLOBAL??` 目录下的任何符号链接都可以通过 `CreateFile`
    函数打开。如下面的截图所示，`C:` 盘符仅仅是 `\Device\HarddiskVolume1` 的符号链接。在 Windows 中，I/O 操作是在虚拟文件上执行的。换句话说，设备、目录、管道和文件都被视为虚拟文件（可以通过
    `CreateFile` 函数打开）：
- en: '![](../images/00354.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00354.jpeg)'
- en: At this point, you know that the driver, during its initialization, creates
    the device and advertises it to be used by the user application using symbolic
    links. Now, the question is, how does the driver tell the I/O manager what type
    of operation (open, read, write, and so on) it supports for the device? During
    initialization, another thing the driver normally does is update the `Major function
    table (dispatch routine array)` with the addresses of the dispatch routines in
    the `DRIVER_OBJECT` structure. Examining the major function table will give you
    an idea of the type of operations (open, read, write, and so on) supported by
    the driver, and the addresses of dispatch routines associated with the specific
    operation. The major function table is an array of `28` function pointers; the
    index values `0` to `27` represents a particular operation. For example, the index
    value `0` corresponds to the major function code `IRP_MJ_CREATE`, the index value
    `3` corresponds to the major function code `IRP_MJ_READ`, and so on. In other
    words, if an application wants to open a handle to a file or device object, the
    request will be sent to the I/O manager, which will then use the `IRP_MJ_CREATE`
    major function code as the index into the major function table to find the address
    of the dispatch routine that will handle this request. In the same manner for
    the read operation, `IRP_MJ_READ` is used as the index to determine the address
    of the dispatch routine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经知道驱动程序在初始化过程中会创建设备，并通过符号链接向用户应用程序宣传它。现在，问题是，驱动程序如何告诉I/O管理器它支持哪些类型的操作（如打开、读取、写入等）？在初始化过程中，驱动程序通常会做的另一件事是更新`Major
    function table（分派例程数组）`，并将分派例程的地址填充到`DRIVER_OBJECT`结构中。检查主要功能表将帮助你了解驱动程序支持哪些操作（如打开、读取、写入等）以及与特定操作相关的分派例程地址。主要功能表是一个包含`28`个函数指针的数组；索引值`0`到`27`表示特定操作。例如，索引值`0`对应于主要功能代码`IRP_MJ_CREATE`，索引值`3`对应于主要功能代码`IRP_MJ_READ`，依此类推。换句话说，如果应用程序想要打开文件或设备对象的句柄，请求将被发送给I/O管理器，然后I/O管理器使用`IRP_MJ_CREATE`主要功能代码作为索引查找主要功能表中的分派例程地址，来处理该请求。对于读取操作，也是同样的方式，使用`IRP_MJ_READ`作为索引来确定分派例程的地址。
- en: 'The following `!drvobj` commands displays the dispatch routine array populated
    by the `null.sys` driver. The operations that are not supported by the driver
    point to `IopInvalidDeviceRequest` in the `ntoskrnl.exe` (`nt`). Based on this
    information, you can tell that `null.sys` only supports `IRP_MJ_CREATE` (open),
    `IRP_MJ_CLOSE` (close), `IRP_MJ_READ` (read), `IRP_MJ_WRITE` (write), `IRP_MJ_QUERY_INFORMATION`
    (query information), and `IRP_MJ_LOCK_CONTROL` (lock control) operations. Any
    request to perform any of the supported operations will be dispatched to the appropriate
    dispatch routine. For example, when the user application performs a `write` operation,
    the `write` request to the device will be dispatched to the `MajorFunction[IRP_MJ_WRITE]` function,
    which happens to be at address `8bce107c` within the `null.sys` driver''s unload
    routine. In the case of `null.sys`, all the supported operations are dispatched
    to the same address, `8bce107c`. Normally, that is not the case; you will see
    different routine addresses for handling different operations:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`!drvobj`命令显示由`null.sys`驱动程序填充的分派例程数组。对于驱动程序不支持的操作，会指向`ntoskrnl.exe`（`nt`）中的`IopInvalidDeviceRequest`。根据这些信息，你可以知道`null.sys`仅支持`IRP_MJ_CREATE`（打开）、`IRP_MJ_CLOSE`（关闭）、`IRP_MJ_READ`（读取）、`IRP_MJ_WRITE`（写入）、`IRP_MJ_QUERY_INFORMATION`（查询信息）和`IRP_MJ_LOCK_CONTROL`（锁控制）操作。任何请求执行这些支持的操作将会被分派到适当的分派例程。例如，当用户应用程序执行`write`操作时，写入设备的请求会被分派到`null.sys`驱动程序卸载例程中的`MajorFunction[IRP_MJ_WRITE]`函数，该函数位于地址`8bce107c`。在`null.sys`的情况下，所有支持的操作都被分派到相同的地址`8bce107c`。通常情况下，情况并非如此；你会看到处理不同操作的不同例程地址：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also look at the supported operations in the *DeviceTree* tool, as
    shown the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在*DeviceTree*工具中查看支持的操作，如以下截图所示：
- en: '![](../images/00355.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00355.jpeg)'
- en: At this point, you know that the driver creates the device, advertises it to
    be used by the user applications, and it also updates the dispatch routine array
    (major function table) to tell the I/O manager what operation it supports. Now,
    let's look at what the role of the I/O manager is and understand how the I/O request
    received from the user application is dispatched to the driver.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经知道驱动程序创建设备，将其广告宣传以供用户应用程序使用，并且还更新了调度例程数组（主要功能表），告知 I/O 管理器它支持的操作。现在，让我们来看一下
    I/O 管理器的作用，并了解从用户应用程序接收到的 I/O 请求是如何调度到驱动程序的。
- en: 6.2 The Role Of The I/O Manager
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 I/O 管理器的作用
- en: When the I/O request reaches the I/O manager, the I/O manager locates the driver
    and creates an `IRP (I/O request packet)`, that is a data structure which contains
    information describing an I/O request. For an operation such as read, write, and
    so on, the IRP created by the I/O manager also contains a buffer in the kernel
    memory to be used by the driver to store the data read from the device or the
    data to be written to the device. The IRP created by the I/O manager is then passed
    to the correct driver's dispatch routine. The driver receives the IRP, and the
    IRP contains the major function code (`IRP_MJ_XXX`) that describes the operation
    (open, read, or write) to be performed. Before initiating an I/O operation, the
    driver performs a check to make sure everything is OK (for example, the buffer
    provided for read or write operations is large enough) after which it initiates
    the I/O operation. The driver normally goes through the HAL routines if it is
    required to perform I/O operations on the hardware device. Upon completion of
    its work, the driver then returns the IRP to the I/O manager, either to let it
    know that the requested I/O operation has been completed or because it must be
    passed to another driver for further processing in the driver stack. The I/O manager
    frees the IRP if the job is complete or passes the IRP to the next driver in the
    device stack to complete the IRP. Upon completion of the job, the I/O manager
    returns the status and the data to the user mode application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当 I/O 请求到达 I/O 管理器时，I/O 管理器定位驱动程序并创建一个 `IRP（I/O 请求包）`，它是一个包含描述 I/O 请求信息的数据结构。对于读取、写入等操作，I/O
    管理器创建的 IRP 还包含一个内核内存中的缓冲区，用于驱动程序存储从设备读取的数据或写入设备的数据。I/O 管理器创建的 IRP 随后传递给正确的驱动程序调度例程。驱动程序接收
    IRP，IRP 中包含描述要执行的操作（如打开、读取或写入）的主要功能代码（`IRP_MJ_XXX`）。在启动 I/O 操作之前，驱动程序会进行检查，以确保一切正常（例如，提供的读取或写入操作的缓冲区足够大），然后启动
    I/O 操作。如果需要对硬件设备执行 I/O 操作，驱动程序通常会经过 HAL 例程。工作完成后，驱动程序将 IRP 返回给 I/O 管理器，告诉它请求的
    I/O 操作已完成，或者因为 IRP 必须传递给驱动程序堆栈中的另一个驱动程序进行进一步处理。I/O 管理器在任务完成时释放 IRP，或者将 IRP 传递给设备堆栈中的下一个驱动程序以完成
    IRP。任务完成后，I/O 管理器将状态和数据返回给用户模式应用程序。
- en: 'At this point, you should have an understanding of the role of the I/O manager.
    For detailed information on the I/O system and device drivers, refer to the book
    *"Windows Internals, Part 1: 7th Edition"* by Pavel Yosifovich, Alex Ionescu,
    Mark E. Russinovich, and David A. Solomon.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '到此为止，你应该已经理解了 I/O 管理器的作用。有关 I/O 系统和设备驱动程序的详细信息，请参考 Pavel Yosifovich、Alex Ionescu、Mark
    E. Russinovich 和 David A. Solomon 所著的《*Windows Internals, Part 1: 第七版*》一书。'
- en: 6.3 Communicating With The Device Driver
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 与设备驱动程序的通信
- en: 'Now, let''s revisit the interaction between the user-mode component and the
    kernel-mode component. We will get back to our example of the `null.sys` driver
    and trigger a write operation to it''s device (`\Device\Null`) from the user-mode
    and monitor the IRP sent to the `null.sys` driver. To monitor the IRP packets
    sent to the driver, we can use the `IrpTracker` tool ([https://www.osronline.com/article.cfm?article=199](https://www.osronline.com/article.cfm?article=199)).
    To monitor launch the `IrpTracker` as an Administrator, click on File | Select
    Driver and enter the name of the driver (in this case, `null`), as shown in the
    following screenshot, and select the OK button:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视用户模式组件和内核模式组件之间的交互。我们将回到 `null.sys` 驱动程序的例子，并从用户模式触发一个写入操作到它的设备（`\Device\Null`），并监控发送到
    `null.sys` 驱动程序的 IRP。为了监控发送到驱动程序的 IRP 包，我们可以使用 `IrpTracker` 工具（[https://www.osronline.com/article.cfm?article=199](https://www.osronline.com/article.cfm?article=199)）。要启动
    `IrpTracker`，请以管理员身份启动，点击文件 | 选择驱动程序，输入驱动程序的名称（在此例中为 `null`），如以下截图所示，然后点击确认按钮：
- en: '![](../images/00356.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00356.jpeg)'
- en: 'Now, to trigger the I/O operation, you can open the Command Prompt and type
    the following command. This will write the string `"hello"` to the null device.
    As mentioned earlier, the symbolic link name is what a user-mode application (such
    as `cmd.exe`) can use; that is the reason I''m specifying the symbolic link name
    of the device (NUL) to write the content:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要触发 I/O 操作，你可以打开命令提示符并输入以下命令。这将把字符串 `"hello"` 写入空设备。正如之前提到的，符号链接名称是用户模式应用程序（如
    `cmd.exe`）可以使用的；这就是我指定设备符号链接名称（NUL）来写入内容的原因：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A device is treated as a virtual file and before writing to the device, handles
    to the device will be opened using `CreateFile()` (an API that''s used to create/open
    a file or device). The `CreateFile()` API will eventually call `NtCreateFile()`
    in `ntoskrnl.exe`, which sends the request to the I/O manager. The I/O manager
    finds the driver associated with the device based on the symbolic link name, and
    calls its dispatch routine corresponding to the `IRP_MJ_CREATE` major function
    code. After the handle is opened to the device, the write operation is performed
    using `WriteFile()`, which will call `NtWriteFile`. This request will be dispatched
    by the I/O manager to the driver''s routine that''s corresponding to the `IRP_MJ_WRITE`
    major function code. The following screenshot shows calls to the driver''s dispatch
    routines that are corresponding to `IRP_MJ_CREATE` and `IRP_MJ_WRITE` and their
    completion status:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设备被视为虚拟文件，在写入设备之前，会通过 `CreateFile()` 打开设备的句柄（`CreateFile()` 是一个用于创建/打开文件或设备的
    API）。`CreateFile()` API 最终会调用 `ntoskrnl.exe` 中的 `NtCreateFile()`，该函数将请求发送给 I/O
    管理器。I/O 管理器根据符号链接名称查找与设备关联的驱动程序，并调用其与 `IRP_MJ_CREATE` 主功能代码对应的分派例程。在设备的句柄被打开后，写入操作将使用
    `WriteFile()` 执行，该操作将调用 `NtWriteFile`。该请求将被 I/O 管理器分派到与 `IRP_MJ_WRITE` 主功能代码对应的驱动程序例程。以下截图显示了与
    `IRP_MJ_CREATE` 和 `IRP_MJ_WRITE` 对应的驱动程序分派例程调用及其完成状态：
- en: '![](../images/00357.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00357.jpeg)'
- en: 'At this point, you should have an understanding of how the user-mode code that
    performs I/O operations communicates with the kernel mode driver. Windows supports
    another mechanism, which allows the user-mode code to communicate directly with
    the kernel-mode device driver. This is done using the generic API called `DeviceIoControl`
    (exported by `kernel32.dll`). This API accepts the handle to the device as one
    of the parameters. Another parameter it accepts is the control code, known as
    the `IOCTL` (I/O control) code, which is a 32-bit integer value. Each control
    code identifies a specific operation to be performed and the type of device on
    which to perform the operation. A user-mode application can open the handle to
    the device (using `CreateFile`), call `DeviceIoControl`, and pass the standard
    control codes provided by the Windows operating system to perform direct input
    and output operations on the device, such as hard disk drive, tape drive, or CD-ROM
    drive. In addition, a device driver (a rootkit driver) can define its own device-specific
    control codes, which can be used by the user-mode component of the rootkit to
    communicate with the driver via the `DeviceIoControl` API. When a user-mode component
    calls `DeviceIoControl` by passing `IOCTL` code, it calls `NtDeviceIoControlFile`
    in `ntdll.dll`, which transitions the thread to the kernel-mode and calls the
    system service routine `NtDeviceIoControlFile` in the Windows executive `ntoskrnl.exe.`
    The Windows executive invokes the I/O manager, the I/O manager builds an IRP packet
    containing the IOCTL code, and then it routes it to the kernel dispatch routine
    identified by `IRP_MJ_DEVICE_CONTROL.` The following diagram illustrates this
    concept of communication between user-mode code and the kernel-mode driver:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该已经理解了执行I/O操作的用户模式代码如何与内核模式驱动程序进行通信。Windows还支持另一种机制，允许用户模式代码直接与内核模式设备驱动程序通信。这是通过使用通用API
    `DeviceIoControl`（由`kernel32.dll`导出）来完成的。该API接受设备的句柄作为其中一个参数。它接受的另一个参数是控制代码，称为`IOCTL`（I/O控制）代码，它是一个32位的整数值。每个控制代码标识一个要执行的特定操作以及在哪个设备上执行该操作。用户模式应用程序可以打开设备句柄（使用`CreateFile`），调用`DeviceIoControl`，并传递Windows操作系统提供的标准控制代码来直接对设备执行输入输出操作，例如硬盘驱动器、磁带驱动器或CD-ROM驱动器。此外，设备驱动程序（例如rootkit驱动程序）可以定义自己的设备特定控制代码，用户模式的rootkit组件可以通过`DeviceIoControl`
    API与驱动程序进行通信。当用户模式组件通过传递`IOCTL`代码调用`DeviceIoControl`时，它会调用`ntdll.dll`中的`NtDeviceIoControlFile`，该函数将线程切换到内核模式，并调用Windows执行系统`ntoskrnl.exe`中的系统服务例程`NtDeviceIoControlFile`。Windows执行系统调用I/O管理器，I/O管理器构建包含IOCTL代码的IRP数据包，然后将其路由到由`IRP_MJ_DEVICE_CONTROL`标识的内核调度例程。以下图示展示了用户模式代码与内核模式驱动程序之间的通信概念：
- en: '![](../images/00358.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00358.jpeg)'
- en: 6.4 I/O Requests To Layered Drivers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 I/O 请求到分层驱动程序
- en: 'So far, you have understood how an I/O request is handled by a simple device
    controlled by a single driver. The I/O request can go through multiple layers
    of drivers; I/O processing for the layered drivers happens in much the same way.
    The following screenshot illustrates an example of how an I/O request might travel
    through layered drivers before reaching the hardware-based devices:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经理解了如何通过一个由单一驱动程序控制的简单设备来处理I/O请求；I/O请求可以经过多个驱动程序层次；这些层次的I/O处理方式基本相同。以下截图展示了I/O请求如何在达到硬件设备之前通过多个驱动程序层的一个例子：
- en: '![](../images/00359.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00359.jpeg)'
- en: 'This concept is better understood with an example, so let''s trigger a write
    operation to `c:\abc.txt` using the following command. When this command is executed,
    `netstat` will open the handle to `abc.txt` and write to it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念通过一个例子来更好地理解，因此我们通过以下命令触发对`c:\abc.txt`的写操作。当该命令执行时，`netstat`将打开`abc.txt`的句柄并写入其中：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A point to note here is that the filename *(*`C:\abc.txt`*)* also includes
    the name of the device where the file resides, that is, volume `C:` is the symbolic
    link name for the device, `\Device\HarddiskVolume1` (you can verify it using the `WinObj`
    tool, as mentioned earlier). This means the write operation will be routed to
    the driver associated with the device `\Device\HarddiskVolume1`*.* When `netstat.exe`
    opens `abc.txt`, the I/O manager creates a file object (`FILE_OBJECT` structure)
    and stores the pointer to the device object inside the file object before returning
    the handle to `netstat.exe.` The following screenshot from the `ProcessHacker`
    tool displays the handle to `C:\abc.txt` that has been opened by `netstat.exe.`
    The object address `0x85f78ce8` represents the file object:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，文件名*（*`C:\abc.txt`*）*也包含了文件所在设备的名称，即，`C:`驱动器是设备`\Device\HarddiskVolume1`的符号链接名称（你可以使用之前提到的`WinObj`工具进行验证）。这意味着写操作将被路由到与设备`\Device\HarddiskVolume1`相关联的驱动程序。当`netstat.exe`打开`abc.txt`时，I/O管理器创建一个文件对象（`FILE_OBJECT`结构）并在文件对象中存储指向设备对象的指针，然后将句柄返回给`netstat.exe.`。以下是来自`ProcessHacker`工具的截图，显示了已由`netstat.exe.`打开的`C:\abc.txt`句柄。对象地址`0x85f78ce8`代表文件对象：
- en: '![](../images/00360.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00360.jpeg)'
- en: 'You can examine the file object (`FILE_OBJECT`) using the object address as
    follows. From the output, you can see that the `FileName` field contains the name
    of the file, and the `DeviceObject` field contains the pointer to the device object
    `(DEVICE_OBJECT)`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式使用对象地址检查文件对象（`FILE_OBJECT`）。从输出中，你可以看到`FileName`字段包含了文件的名称，而`DeviceObject`字段包含了指向设备对象（`DEVICE_OBJECT`）的指针：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As mentioned earlier, from the device object, one can determine the name of
    the device and the associated driver. This is how the I/O manager determines which
    driver to pass the I/O request to. The following output displays the name of the
    device, `HarddiskVolume1`, and its associated driver, `volmgr.sys.` The `AttachedDevice`
    field tells you that there is an unnamed device object (`868e7b28`) associated
    with the `fvevol.sys` driver sitting on top of the device object `HarddiskVolume1`
    in the device stack:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过设备对象，可以确定设备的名称和相关的驱动程序。这是I/O管理器决定将I/O请求传递给哪个驱动程序的方式。以下输出显示了设备的名称`HarddiskVolume1`及其相关的驱动程序`volmgr.sys.`。`AttachedDevice`字段告诉你，`fvevol.sys`驱动程序下有一个没有命名的设备对象（`868e7b28`），它位于设备对象`HarddiskVolume1`之上，在设备栈中：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To determine the layers of drivers through which the I/O request goes through,
    you can use the `!devstack` kernel debugger command and pass the device object
    address to display the device stack (of layered device objects) associated with
    a particular device object. The following output shows the device stack associated
    with `\Device\HarddiskVolume1`, which is owned by `volmgr.sys.` The `>` character
    in the fourth column tells you that the entry is associated with the device `HarddiskVolume1`
    and the entries above that line are the list of drivers layered above `volmgr.sys.`
    What this means is that the I/O request will be first passed to `volsnap.sys`
    by the I/O manager. Depending on the type of request, `volsnap.sys` can handle
    the IRP request and send the request down to other drivers in the stack, which
    finally reaches `volmgr.sys`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定I/O请求经过的驱动程序层级，你可以使用`!devstack`内核调试命令并传递设备对象地址，以显示与特定设备对象相关的设备栈（分层设备对象）。以下输出显示了与`\Device\HarddiskVolume1`相关的设备栈，该设备由`volmgr.sys.`拥有。第四列中的`>`字符表示该条目与设备`HarddiskVolume1`相关，且该行之上的条目是位于`volmgr.sys.`之上的驱动程序列表。这意味着I/O请求将首先传递给`volsnap.sys`，根据请求的类型，`volsnap.sys`可以处理IRP请求并将请求传递给栈中的其他驱动程序，最终到达`volmgr.sys`：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To view the device tree, you can use the GUI tool *DeviceTree* (which we mentioned
    earlier). The tool displays the driver on the outer edge of the tree, and their
    devices are indented one level. The attached devices are further intended, as
    shown in the following screenshot. You can compare the following screenshot with
    the preceding `!devstack` output to get an idea of how to interpret the information:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看设备树，你可以使用我们之前提到的GUI工具*DeviceTree*。该工具将驱动程序显示在树的外侧，而它们的设备则缩进一级。附加设备会进一步缩进，如下图所示。你可以将以下截图与之前的`!devstack`输出进行对比，从而了解如何解读这些信息：
- en: '![](../images/00361.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00361.jpeg)'
- en: It is important to understand this layered approach, because sometimes, a rookit
    driver can insert or attach below or above the target device's stack to receive
    `IRP`. Using this technique, a rootkit driver can log or modify the `IRP` before
    passing it on to the legitimate driver. For example, a keylogger can log strokes
    by inserting a malicious driver that sits above the keyboard function driver.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种分层方法很重要，因为有时，rootkit 驱动程序可以插入或附加到目标设备的堆栈上方或下方以接收`IRP`。通过这种技术，rootkit 驱动程序可以在将`IRP`传递给合法驱动程序之前，记录或修改`IRP`。例如，键盘记录器可以通过插入一个恶意驱动程序（该驱动程序位于键盘功能驱动程序上方）来记录按键。
- en: 7\. Displaying Device Trees
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 显示设备树
- en: 'You can use the `devicetree` plugin in Volatility to display the device tree
    in the same format as the *DeviceTree* tool. The following highlighted entries
    show the device stack of `HarddiskVolume1` that is associated with `volmgr.sys`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Volatility中的`devicetree`插件，以与*DeviceTree*工具相同的格式显示设备树。以下高亮的条目显示了与`volmgr.sys`相关联的`HarddiskVolume1`设备堆栈：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To help you understand the use of the `devicetree` plugin in forensic investigation,
    let''s take a look at a malware which creates its own device to store its malicious
    binary. In the following example of the Z*eroAccess* *rootkit*, I have used the
    `cmdline` plugin, which displays process command-line arguments. This can be useful
    in determining the full path of a process (you can also use the `dlllist` plugin).
    From the output, you can see that the last `svchost.exe` process is running from
    a suspicious namespace:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解`devicetree`插件在取证调查中的使用，下面我们来看一个创建自己设备来存储恶意二进制文件的恶意软件。在接下来的 Z*eroAccess*
    *rootkit* 示例中，我使用了`cmdline`插件，它显示进程的命令行参数。这对于确定进程的完整路径非常有用（你也可以使用`dlllist`插件）。从输出中，你可以看到最后一个`svchost.exe`进程是从一个可疑的命名空间中运行的：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From the earlier discussion, if you remember, `\\.\<symbolic link name>` is
    the convention used to access a device from the user-mode using the name of the
    symbolic link. When a driver creates a symbolic link for the device, it is added
    to the `\GLOBAL??` directory in the object manager namespace (which can be viewed
    using the *WinObj* tool, as we discussed earlier). In this case, `globalroot`
    is the name of the symbolic link. Then, the question is, what is `\\.\globalroot`?
    It turns out that `\\.\globalroot` refers to the `\GLOBAL??` namespace. In other
    words, the `\\.\globalroot\Device\svchost.exe\svchost.exe` path is the same as
    `\Device\svchost.exe\svchost.exe`*.* At this stage, you know that the Z*eroAccess*
    rootkit creates its own device (`svchost.exe`) to hide its malicious binary, `svchost.exe.`
    To identify the driver which created this device, you can use the `devicetree`
    plugin. From the following output, you can tell that the `svchost.exe` device
    was created by the `00015300.sys` driver:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的讨论中，如果你还记得，`\\.\<symbolic link name>` 是从用户模式使用符号链接名称访问设备的约定。当驱动程序为设备创建符号链接时，它会被添加到`\GLOBAL??`目录中，该目录位于对象管理器命名空间中（可以使用*WinObj*工具查看，正如我们之前讨论的）。在这种情况下，`globalroot`是符号链接的名称。那么，问题是，`\\.\globalroot`是什么？事实证明，`\\.\globalroot`指的是`\GLOBAL??`命名空间。换句话说，`\\.\globalroot\Device\svchost.exe\svchost.exe`路径与`\Device\svchost.exe\svchost.exe`路径是相同的。此时，你知道
    Z*eroAccess* rootkit 创建了自己的设备（`svchost.exe`）来隐藏其恶意二进制文件`svchost.exe`。要识别创建此设备的驱动程序，你可以使用`devicetree`插件。从以下输出中，你可以看出`svchost.exe`设备是由`00015300.sys`驱动程序创建的：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the following example of *BlackEnergy* malware, it replaces the legitimate
    `aliide.sys` driver on the disk with the malicious driver to hijack the existing
    service (as covered in [Chapter 10](part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485),* Hunting
    Malware Using Memory Forensics,* in the* Investigating Service* section). When
    the service starts, the malicious driver creates a device to communicate with
    the malicious user-mode component (DLL injected into the legitimate `svchost.exe`)
    process. The following `devicetree` output shows the device created by the malicious
    driver:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的*BlackEnergy*恶意软件示例中，它将磁盘上的合法`aliide.sys`驱动程序替换为恶意驱动程序，以劫持现有服务（如在[第10章](part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485)，*使用内存取证猎杀恶意软件*部分中所述）。当服务启动时，恶意驱动程序创建一个设备与恶意用户模式组件（注入到合法`svchost.exe`中的
    DLL）进程进行通信。以下`devicetree`输出显示了恶意驱动程序创建的设备：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To get an idea of the type of operations supported by the malicious driver.
    You can use Volatility''s `driverirp` plugin, since it displays the major IRP
    functions associated with a particular driver or all the drivers. From the following
    output, you can tell that the malicious `aliide` driver supports `IRP_MJ_CREATE
    (open)`, `IRP_MJ_CLOSE (close)`, and the `IRP_MJ_DEVICE_CONTROL (DeviceIoControl)`
    operations. The operations that are not supported by the driver typically point
    to `IopInvalidDeviceRequest` in the `ntoskrnl.exe`, which is the reason you are
    seeing all other non-supported operations pointing to `0xfffff80002a5865c` in
    `ntoskrnl.exe`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解恶意驱动程序支持的操作类型，您可以使用 Volatility 的 `driverirp` 插件，因为它可以显示与特定驱动程序或所有驱动程序相关的主要
    IRP 函数。从以下输出中，您可以看出恶意 `aliide` 驱动程序支持 `IRP_MJ_CREATE (打开)`、`IRP_MJ_CLOSE (关闭)`
    和 `IRP_MJ_DEVICE_CONTROL (DeviceIoControl)` 操作。驱动程序不支持的操作通常指向 `ntoskrnl.exe` 中的
    `IopInvalidDeviceRequest`，这也是您看到所有其他不受支持的操作指向 `0xfffff80002a5865c` 在 `ntoskrnl.exe`
    中的原因：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 8\. Detecting Kernel Space Hooking
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 检测内核空间劫持
- en: When discussing hooking techniques (In case [Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485), *Code
    Injection and Hooking,* in the* Hooking Techniques* section), we saw how some
    malware programs modify the call table (*IAT Hooking*) and some modify the API
    function (*inline hooking*) to control the execution path of the program and re-route
    it to the malicious code. The objective is to block calls to the API, monitor
    input parameters passed to the API, or to filter the output parameters returned
    from the API. The techniques covered in [Chapter 8](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=1250&action=edit#post_985), *Code
    Injection and Hooking, *mainly focused on hooking techniques in the user space.
    Similar capabilities are possible in the kernel space if an attacker manages to
    install a kernel driver. Hooking in a kernel space is more powerful approach an
    than hooking in a user space, because kernel components play a very important
    role in the operation of the system as a whole. It allows an attacker to execute
    code with high privileges, giving them the capability to conceal the presence
    of the malicious component, bypass security software, or  intercept the execution
    path. In this section, we will understand different hooking techniques in the
    kernel space and how to detect such techniques using memory forensics.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论劫持技术时（参见[第8章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)，*代码注入与劫持*部分），我们看到一些恶意软件通过修改调用表（*IAT
    劫持*）以及一些修改 API 函数（*内联劫持*）来控制程序的执行路径，并将其重定向到恶意代码。其目标是阻止对 API 的调用，监控传递给 API 的输入参数，或过滤从
    API 返回的输出参数。[第8章](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=1250&action=edit#post_985)中涉及的*代码注入与劫持*技术主要集中在用户空间的劫持技术。如果攻击者能够安装一个内核驱动程序，类似的功能也可以在内核空间实现。内核空间中的劫持是一种比用户空间更强大的方法，因为内核组件在整个系统的运作中扮演着非常重要的角色。这使得攻击者能够以高权限执行代码，从而具备隐藏恶意组件、绕过安全软件或拦截执行路径的能力。在本节中，我们将了解内核空间中的不同劫持技术，以及如何使用内存取证来检测这些技术。
- en: 8.1 Detecting SSDT Hooking
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 检测 SSDT 劫持
- en: 'The **System Service Descriptor Table** (**SSDT**) in kernel space contains
    the pointers to the system service routines (kernel functions) exported by the
    kernel executive (`ntoskrnl.exe, ntkrnlpa.exe` and so on). When an application
    calls an API such as `WriteFile()`, `ReadFile()`, or `CreateProcess()`, it calls
    the stub in the `ntdll.dll` which switches the thread to the kernel mode. The
    thread running in the kernel mode consults the *SSDT* to determine the address
    of the kernel function to invoke. The following screenshot illustrates this concept
    with an example of `WriteFile()` (the concept is similar for other APIs):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内核空间中的**系统服务描述符表**（**SSDT**）包含指向由内核执行文件（`ntoskrnl.exe`、`ntkrnlpa.exe`等）导出的系统服务例程（内核函数）的指针。当应用程序调用像
    `WriteFile()`、`ReadFile()` 或 `CreateProcess()` 等 API 时，它会调用 `ntdll.dll` 中的存根，从而将线程切换到内核模式。运行在内核模式中的线程会查询*SSDT*以确定要调用的内核函数的地址。下图通过
    `WriteFile()` 示例展示了这一概念（对于其他 API，概念类似）：
- en: '![](../images/00362.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00362.jpeg)'
- en: 'In general, `ntoskrnl.exe` exports core kernel API functions such as `NtReadFile()`, `NtWrite()File`,
    and so on. In the x86 platform, the pointers to these kernel functions are stored
    directly in the SSDT, whereas on the x64 platforms,  SSDT does not contain the
    pointers. Instead, it stores an encoded integer that is decoded to determine the
    address of the kernel function. Irrespective of the implementation, the concept
    remains the same and the SSDT is consulted to determine the address of a specific
    kernel function. The following *WinDbg* command on the `Windows7 x86` platform
    displays the contents of the SSDT. The entries in the table contain the pointers
    to the functions implemented by `ntoskrnl.exe` (`nt`). The order and the number
    of entries vary across operating system versions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`ntoskrnl.exe`导出核心内核API函数，如`NtReadFile()`、`NtWriteFile()`等。在x86平台中，这些内核函数的指针直接存储在SSDT中，而在x64平台中，SSDT不包含指针。相反，它存储一个编码的整数，通过解码该整数来确定内核函数的地址。无论实现方式如何，概念都是相同的，SSDT被查询以确定特定内核函数的地址。以下是`Windows7
    x86`平台上的*WinDbg*命令，用于显示SSDT的内容。表格中的条目包含指向`ntoskrnl.exe`（`nt`）实现的函数的指针。条目的顺序和数量会因操作系统版本而异：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is a second table, similar to the SSDT, known as *SSDT shadow*. This
    table stores the pointers to the GUI-related functions exported by `win32k.sys.`
    To display the entries of both the tables, you can use the `ssdt` volatility plugin,
    as shown here. `SSDT[0]` refers to the native *SSDT table* and `SSDT[1]` refers
    to *SSDT shadow*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第二个表格，类似于SSDT，称为*SSDT shadow*。此表格存储由`win32k.sys`导出的与GUI相关的函数指针。要显示这两个表格的条目，可以使用`ssdt`
    volatility插件，如下所示。`SSDT[0]`表示原生的*SSDT表格*，而`SSDT[1]`表示*SSDT shadow*：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the case of SSDT hooking, an attacker replaces the pointer of a specific
    function with the address of the malicious function. For instance, if an attacker
    wishes to intercept the data that is written to a file, the pointer to `NtWriteFile()`
    can be changed to point to the address of the malicious function of an attacker''s
    choice. This is illustrated in the following diagram:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSDT hooking的情况下，攻击者将特定函数的指针替换为恶意函数的地址。例如，如果攻击者希望拦截写入文件的数据，可以将`NtWriteFile()`的指针更改为指向攻击者选择的恶意函数的地址。如下图所示：
- en: '![](../images/00363.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00363.jpeg)'
- en: 'To detect SSDT hooking, you can look for the entries in the SSDT table that
    do not point to addresses in `ntoskrnl.exe` or `win32k.sys.` The following code
    is an example of the *Mader* rootkit, which hooks various-registry related functions
    and points them to the malicious driver `core.sys.` At this stage, you can determine
    the base address of `core.sys` using `modules`, `modscan`, or `driverscan` and
    then dump it to disk for further analysis using the `moddump` plugin:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测SSDT hooking，可以查看SSDT表格中不指向`ntoskrnl.exe`或`win32k.sys`地址的条目。以下代码是*Mader*
    rootkit的示例，它hook了多个与注册表相关的函数，并将它们指向恶意驱动程序`core.sys`。在此阶段，您可以使用`modules`、`modscan`或`driverscan`确定`core.sys`的基址，然后使用`moddump`插件将其转储到磁盘以供进一步分析：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The disadvantage of using SSDT hooking for an attacker is that it is easy to
    detect, and the 64-bit release of Windows prevents SSDT hooking due to the **Kernel
    Patch Protection** (**KPP**) mechanism, also known as *PatchGuard* ([https://en.wikipedia.org/wiki/Kernel_Patch_Protection](https://en.wikipedia.org/wiki/Kernel_Patch_Protection)).
    Since the entries in the SSDT vary across different versions of Windows and are
    subject to change in newer versions, it becomes difficult for a malware author
    to write a rootkit that is reliable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSDT hooking对攻击者的缺点在于它很容易被检测到，而且Windows的64位版本由于**内核补丁保护**（**KPP**）机制，也被称为*PatchGuard*，会阻止SSDT
    hooking（[https://en.wikipedia.org/wiki/Kernel_Patch_Protection](https://en.wikipedia.org/wiki/Kernel_Patch_Protection)）。由于SSDT中的条目在不同版本的Windows中有所不同，并且在新版本中可能会发生变化，因此恶意软件作者很难编写一个可靠的rootkit。
- en: 8.2 Detecting IDT Hooking
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 检测IDT Hooking
- en: 'The **Interrupt Descriptor Table** (**IDT**) stores the addresses of functions
    known as *ISR (Interrupt Service Routines or Interrupt handlers).* These functions
    handle interrupts and processor exceptions. Like hooking an SSDT, an attacker
    may hook the entries in the IDT to redirect control to the malicious code. To
    display the IDT entries, you can use the `idt` Volatility plugin. An example of
    a malware which hooked an IDT is the *Uroburos (Turla) rootkit.* This rootkit
    hooked the interrupt handler located at the `0xc3 (INT C3)` index. On a clean
    system, the interrupt handler at `0xC3` points to an address that resides in the
    memory of `ntoskrnl.exe`. The following output shows the entry from the clean
    system:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断描述符表**（**IDT**）存储着被称为*ISR（中断服务例程或中断处理程序）*的函数地址。这些函数处理中断和处理器异常。就像挂钩 SSDT
    一样，攻击者可能会挂钩 IDT 中的条目，以将控制权重定向到恶意代码。要显示 IDT 条目，可以使用 `idt` Volatility 插件。一个挂钩 IDT
    的恶意软件示例是*Uroburos (Turla) rootkit*。该 rootkit 挂钩了位于 `0xc3 (INT C3)` 索引的中断处理程序。在干净的系统中，`0xC3`
    处的中断处理程序指向的地址位于 `ntoskrnl.exe` 的内存中。以下输出显示了来自干净系统的条目：'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following output displays the hooked entry. You can see that the `0xC3`
    entry in the IDT is pointing to an address in the `UNKNOWN` module. In other words,
    the hooked entry resides outside the range of the `ntoskrnl.exe` module:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了挂钩条目。您可以看到 IDT 中的 `0xC3` 条目指向一个 `UNKNOWN` 模块中的地址。换句话说，挂钩条目位于 `ntoskrnl.exe`
    模块的范围之外：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For detailed analysis of Uroburos rootkit and to understand the technique used
    by the rootkit to trigger the hooked interrupt handler, refer to the following
    blog post: [https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg](https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细分析 Uroburos rootkit，并了解 rootkit 用于触发挂钩中断处理程序的技术，请参阅以下博客文章：[https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg](https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg)。
- en: 8.3 Identifying Inline Kernel Hooks
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 识别内核空间内联钩取
- en: 'Instead of replacing the pointers in the SSDT, which makes it easy to recognize,
    an attacker can modify the kernel function or function in an existing kernel driver
    with a `jmp` instruction to reroute the execution flow to the malicious code.
    As mentioned earlier in this chapter, you can use the `apihooks` plugin to detect
    inline hooking in the kernel space. By specifying the `-P` argument, you can tell
    the `apihooks` plugin to only scan for the hooks in the kernel space. In the following
    example of a *TDL3 rootkit*, the `apihooks` detect the hooks in the kernel functions
    `IofCallDriver` and `IofCompleteRequest.` The hooked API functions are redirected
    to the `0xb878dfb2` and `0xb878e6bb` addresses within a malicious module whose
    name is unknown (possibly because it is hiding by unlinking the `KLDR_DATA_TABLE_ENTRY`
    structure):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过修改内核函数或现有内核驱动程序中的函数，使用 `jmp` 指令将执行流重新路由到恶意代码，而不是替换 SSDT 中的指针，这样更容易被识别。如本章前面所述，您可以使用
    `apihooks` 插件来检测内核空间中的内联钩取。通过指定 `-P` 参数，您可以告诉 `apihooks` 插件仅扫描内核空间中的钩取。在以下 *TDL3
    rootkit* 的示例中，`apihooks` 检测到了内核函数 `IofCallDriver` 和 `IofCompleteRequest` 中的钩取。被挂钩的
    API 函数被重定向到 `0xb878dfb2` 和 `0xb878e6bb` 这些地址，位于一个名称未知的恶意模块中（可能是因为它通过解除链接 `KLDR_DATA_TABLE_ENTRY`
    结构来隐藏自己）：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Even though the name of the hooking module is unknown, it is still possible
    to detect the malicious kernel module. In this case, we know the API functions
    are redirected to addresses starting with `0xb87` within the malicious module,
    which means the malicious module must be residing at some address starting with
    `0xb87`.  Running the `modules` plugin does not detect any module at that address
    range (because it is hidden), whereas the modscan plugin detected a kernel module
    called `TDSSserv.sys` loaded at base address `0xb878c000` with a size of `0x11000.`
    In other words, the start address of the kernel module `TDSSserv.sys` is `0xb878c000`
    and the end address is `0xb879d000 (0xb878c000+0x11000)`. You can clearly see
    that the hook addresses `0xb878dfb2` and `0xb878e6bb` fall within the address
    range of `TDSSserv.sys`. At this point, we have successfully identified the malicious
    driver. You can now dump the driver to disk for further analysis:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使钩子模块的名称未知，仍然可以检测到恶意的内核模块。在这种情况下，我们知道API函数被重定向到恶意模块中以`0xb87`开头的地址，这意味着恶意模块一定驻留在以`0xb87`开头的某个地址处。运行`modules`插件并未检测到该地址范围内的任何模块（因为它被隐藏），而`modscan`插件则检测到一个名为`TDSSserv.sys`的内核模块，该模块加载在基地址`0xb878c000`，大小为`0x11000`。换句话说，内核模块`TDSSserv.sys`的起始地址是`0xb878c000`，结束地址是`0xb879d000（0xb878c000+0x11000）`。你可以清楚地看到钩子地址`0xb878dfb2`和`0xb878e6bb`落在`TDSSserv.sys`的地址范围内。此时，我们已经成功识别出恶意驱动程序。你现在可以将驱动程序转储到磁盘以便进一步分析：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 8.4 Detecting IRP Function Hooks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 检测IRP函数钩子
- en: 'Instead of hooking the kernel API functions, a rootkit can modify the entries
    in the major function table (dispatch routine array) to point to a routine in
    the malicious module. For example, a rookit can inspect the data buffer that is
    written to a disk or network by overwriting the address corresponding to `IRP_MJ_WRITE`
    in a driver''s major function table. The following diagram illustrates this concept:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: rootkit可以通过修改主功能表（调度例程数组）中的条目，而不是钩住内核API函数，将它们指向恶意模块中的某个例程。例如，rootkit可以通过覆盖驱动程序主功能表中与`IRP_MJ_WRITE`相关的地址，来检查写入磁盘或网络的数据缓冲区。以下图示说明了这一概念：
- en: '![](../images/00364.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00364.jpeg)'
- en: 'Normally, the IRP handler functions of a driver point within their own module.
    For instance, the routine associated with `IRP_MJ_WRITE` of `null.sys` points
    to an address in `null.sys`, however, sometimes a driver will forward the handler
    function to another driver. The following is an example of the disk driver forwarding
    handler functions to `CLASSPNP.SYS` (the storage class device driver):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，驱动程序的IRP处理程序函数会指向它们自己模块中的某个位置。例如，`null.sys`的`IRP_MJ_WRITE`相关例程指向`null.sys`中的一个地址，但有时驱动程序会将处理程序函数转发到另一个驱动程序。以下是磁盘驱动程序将处理程序函数转发到`CLASSPNP.SYS`（存储类设备驱动程序）的示例：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To detect IRP hooks, you can focus on IRP handler functions that point to another
    driver, and since the driver can forward an IRP handler to another driver, you
    need to further investigate it to confirm the hook. If you are analyzing the rootkit
    in a lab setup, then you can list the IRP functions of all the drivers from a
    clean memory image and compare them with the IRP functions from the infected memory
    image for any modifications. In the following example, the *ZeroAccess rootkit*
    hooks the IRP functions of the disk driver and redirects them to the functions
    within a malicious module whose address is unknown (because the module is hidden):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测IRP钩子，可以关注指向另一个驱动程序的IRP处理程序函数，并且由于驱动程序可以将IRP处理程序转发到另一个驱动程序，你需要进一步调查以确认钩子。如果你在实验室环境中分析rootkit，则可以从干净的内存映像中列出所有驱动程序的IRP函数，并将其与受感染的内存映像中的IRP函数进行比较，以查找任何修改。在以下示例中，*ZeroAccess
    rootkit*钩住了磁盘驱动程序的IRP函数，并将它们重定向到一个恶意模块中的函数，而该模块的地址未知（因为该模块被隐藏）：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following output from the `modscan` displays the malicious driver (with
    a suspicious name) associated with *ZeroAccess* and the base address where it
    is loaded in the memory (which can be used to dump the driver to disk):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`modscan`的输出，显示与*ZeroAccess*相关的恶意驱动程序（具有可疑名称）及其在内存中加载的基地址（该地址可用于将驱动程序转储到磁盘）：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Some rootkits use indirect IRP hooking to avoid suspicion. In the following
    example, the *Gapz* Bootkit hooks the `IRP_MJ_DEVICE_CONTROL` of `null.sys`. At
    first glance, it may look like everything is normal because the IRP handler address
    corresponding to `IRP_MJ_DEVICE_CONTROL` points to within `null.sys.` Upon close
    inspection, you will notice the discrepancy; on a clean system, `IRP_MJ_DEVICE_CONTROL`
    points to the address in `ntoskrnl.exe` (`nt!IopInvalidDeviceRequest`). In this
    case, it is pointing to `0x880ee040` in `null.sys`. After disassembling the address `0x880ee040`
    (using the `volshell` plugin), you can see the jump to an address of `0x8518cad9`,
    which is outside the range of `null.sys`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 rootkit 使用间接 IRP 钩子来避免引起怀疑。在以下示例中，*Gapz* Bootkit 钩住了 `null.sys` 的 `IRP_MJ_DEVICE_CONTROL`。乍一看，一切似乎正常，因为对应于
    `IRP_MJ_DEVICE_CONTROL` 的 IRP 处理程序地址指向 `null.sys` 内部。然而，仔细观察会发现差异；在一个干净的系统上，`IRP_MJ_DEVICE_CONTROL`
    会指向 `ntoskrnl.exe` 中的地址（`nt!IopInvalidDeviceRequest`）。在这种情况下，它指向了 `null.sys` 中的
    `0x880ee040`。通过反汇编地址 `0x880ee040`（使用 `volshell` 插件），您可以看到它跳转到 `0x8518cad9`，这个地址位于
    `null.sys` 的范围之外：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For detailed information on the stealth techniques used by the Gapz Bootkit,
    read the whitepaper ([https://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf](https://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf))
    titled "*Mind the Gapz: The Most Complex Bootkit Ever Analyzed"* by Eugene Rodionov
    and Aleksandr Matrosov.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Gapz Bootkit 使用的隐身技术的详细信息，请阅读 Eugene Rodionov 和 Aleksandr Matrosov 所写的白皮书（[https://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf](https://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf)），标题为“*留意
    Gapz：有史以来最复杂的 Bootkit 分析*”。
- en: As discussed so far, detecting standard hooking techniques is fairly straightforward.
    For instance, you can look for signs such as SSDT entries not pointing to `ntoskrnl.exe`/`win32k.sys`
    or IRP functions pointing to somewhere else, or jump instructions at the start
    of the function. To avoid such detections, an attacker can implement hooks while
    keeping call table entries within the range, or place the jump instructions deep
    inside the code. To do this, they need to rely on patching the system modules
    or third-party drivers. The problem with patching system modules is that *Windows
    Kernel Patch Protection (PatchGuard)* prevents patching call tables (such as SSDT
    or IDT) and the core system modules on 64-bit systems. For these reasons, attackers
    either use techniques that rely on bypassing these protection mechanisms (such
    as installing a *Bootkit/*exploiting kernel-mode vulnerabilities) or they use
    supported ways (which also work on 64-bit systems) to execute their malicious
    code to blend in with other legitimate drivers and reduce the risk of detection.
    In the next section, we will look at some of the supported techniques used by
    the rootkits.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，检测标准的钩子技术相对简单。例如，您可以查看一些迹象，如 SSDT 条目未指向`ntoskrnl.exe`/`win32k.sys`，或者 IRP
    函数指向其他地方，或者函数开始处存在跳转指令。为了避免这种检测，攻击者可以在保持调用表条目在范围内的同时实现钩子，或者将跳转指令放置在代码深处。为此，他们需要依赖于修补系统模块或第三方驱动程序。修补系统模块的问题在于，*Windows
    内核补丁保护（PatchGuard）* 会阻止修补调用表（如 SSDT 或 IDT）以及 64 位系统上的核心系统模块。由于这些原因，攻击者要么使用依赖绕过这些保护机制的技术（如安装*Bootkit*/*利用内核模式漏洞*），要么使用受支持的方式（这些方式同样适用于
    64 位系统）执行恶意代码，以便与其他合法驱动程序融合并减少被检测的风险。在接下来的章节中，我们将探讨 rootkit 使用的一些受支持的技术。
- en: 9\. Kernel Callbacks And Timers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 内核回调和定时器
- en: The Windows operating system allows a driver to register a callback routine,
    which will be called when a particular event occurs. For instance, if a rootkit
    driver wants to monitor the execution and termination of all processes running
    on the system, it can register a callback routine for the process event by calling
    the kernel function `PsSetCreateProcessNotifyRoutine`, `PsSetCreateProcessNotifyRoutineEx`,
    or `PsSetCreateProcessNotifyRoutineEx2`. When the process event occurs (starts
    or exits) the rootkit's callback routine will be invoked, which can then take
    necessary action such as preventing a process from launching. In the same manner,
    a rootkit driver can register a callback routine to receive notifications when
    an image (EXE or DLL) gets loaded into memory, when file and registry operations
    are performed, or when the system is about to be shut down. In other words, the
    callback functionality gives the rootkit driver the ability to monitor system
    activities and take necessary action depending on the activity. You can get a
    list of some of the documented and undocumented kernel functions that the rootkit
    may use to register callback routines at the following link: [https://www.codemachine.com/article_kernel_callback_functions.html](https://www.codemachine.com/article_kernel_callback_functions.html).
    The kernel functions are defined in different header files (`ntddk.h`, `Wdm.h`,
    and so on) in the *Windows Driver Kit (WDK)*. The quickest method to get details
    on the documented kernel functions is to do a quick Google search, which should
    take you to the appropriate link in the WDK online documentation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统允许驱动程序注册回调例程，当特定事件发生时，该例程会被调用。例如，如果一个 rootkit 驱动程序希望监控系统上所有进程的执行和终止，它可以通过调用内核函数`PsSetCreateProcessNotifyRoutine`、`PsSetCreateProcessNotifyRoutineEx`或`PsSetCreateProcessNotifyRoutineEx2`来为进程事件注册回调例程。当进程事件发生（启动或退出）时，rootkit
    的回调例程将被调用，从而采取必要的措施，例如防止进程启动。以同样的方式，rootkit 驱动程序可以注册回调例程，在映像（EXE 或 DLL）被加载到内存中、文件和注册表操作执行时，或系统即将关闭时接收通知。换句话说，回调功能使
    rootkit 驱动程序能够监控系统活动，并根据活动采取必要的行动。你可以通过以下链接获取一些 rootkit 可能用来注册回调例程的已记录和未记录的内核函数列表：[https://www.codemachine.com/article_kernel_callback_functions.html](https://www.codemachine.com/article_kernel_callback_functions.html)。这些内核函数在不同的头文件（`ntddk.h`、`Wdm.h`
    等）中定义，位于*Windows 驱动程序工具包 (WDK)* 中。获取已记录内核函数详细信息的最快方法是进行快速的 Google 搜索，这将引导你到 WDK
    在线文档中的相应链接。
- en: The way callbacks work is that a particular driver creates a callback object,
    which is a structure that contains the list of function pointers. The created
    callback object is advertised so that it can be used by other drivers. The other
    drivers can then register their callback routines with the driver that created
    the callback object ([https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects)).
    The driver that created the callback can be the same as or different from the
    kernel driver that is registering for the callback. To look at the system-wide
    callback routines, you can use `callbacks` Volatility plugin. On a clean Windows
    system, you will typically see many callbacks installed by various drivers, which
    means not all entries in the `callbacks` output are malicious; further analysis
    is required to identify the malicious driver from a suspect memory image.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的工作方式是，特定的驱动程序创建一个回调对象，该对象是一个包含函数指针列表的结构。创建的回调对象会被发布，以便其他驱动程序可以使用。其他驱动程序随后可以将它们的回调例程注册到创建回调对象的驱动程序中
    ([https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects))。创建回调的驱动程序可以与注册回调的内核驱动程序相同，也可以不同。要查看系统范围的回调例程，可以使用`callbacks`
    Volatility 插件。在一个干净的 Windows 系统中，通常可以看到由各种驱动程序安装的许多回调，这意味着并非所有`callbacks`输出中的条目都是恶意的；需要进一步分析以从可疑的内存镜像中识别恶意驱动程序。
- en: 'In the following example, the *Mader rootkit* as which performed *SSDT hooking*
    (discussed in the* Detecting SSDT Hooking* section of this chapter), also installed
    a process creation callback routine to monitor the execution or termination of
    all the processes running on the system. In particular, when a process event occurs,
    the callback routine at address `0xf66eb050` within the malicious module `core.sys`
    is invoked. The `Module` column specifies the name of the kernel module within
    which the callback function is implemented. The `Details` column gives the name
    or description of the kernel object that installed the callback. After you have
    identified the malicious driver, you can further investigate it or you can dump
    it to disk for further analysis (disassembly, AV scanning, string extraction,
    and so on), as shown in the `moddump` command here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，*Mader rootkit* 执行了*SSDT hooking*（在本章的*检测 SSDT hooking* 部分讨论），并安装了一个进程创建回调例程，以监控系统上所有进程的执行或终止。特别地，当进程事件发生时，位于恶意模块
    `core.sys` 中地址 `0xf66eb050` 的回调例程将被调用。`Module` 列指定实现回调函数的内核模块的名称。`Details` 列提供安装回调的内核对象的名称或描述。在识别出恶意驱动程序后，您可以进一步调查它，或将其转储到磁盘以进行进一步分析（反汇编、AV
    扫描、字符串提取等），如下所示的 `moddump` 命令：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the following example, the *TDL3 rootkit* installs process callback and
    image load callback notifications. This allows the rootkit to monitor process
    events and to get notifications when an executable image (EXE, DLL, or kernel
    module) is mapped into memory. The module names in the entries are set to `UNKNOWN`;
    this tells you that callback routine exists in an unknown module, which happens
    if the rootkit driver tries to hide by unlinking the `KLDR_DATA_TABLE_ENTRY` structure
    or if a rootkit is running an orphan thread (a thread that is hidden or detached
    from the kernel module). In such cases, the `UNKNOWN` entry makes it easy for
    you to spot the suspicious entry:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，*TDL3 rootkit* 安装了进程回调和映像加载回调通知。这使得 rootkit 能够监控进程事件，并在可执行映像（EXE、DLL
    或内核模块）映射到内存时收到通知。条目中的模块名称设置为 `UNKNOWN`；这告诉您回调例程存在于一个未知模块中，这种情况发生在 rootkit 驱动程序通过取消链接
    `KLDR_DATA_TABLE_ENTRY` 结构或运行一个孤立线程（隐藏或与内核模块分离的线程）来尝试隐藏自己时。在这种情况下，`UNKNOWN` 条目使您更容易发现可疑条目：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Even though the module name is `UNKNOWN`, based on the callback routine address,
    we can deduce that the malicious module should be residing somewhere in the memory
    region starting with address `0xb878`. From the output of the `modules` plugin,
    you can see that the module has unlinked itself, but the `modscan` plugin was
    able to detect the kernel module which is loaded at `0xb878c000` and with a size
    of `0x11000`. Clearly, all the callback routine addresses fall within the range
    of this module. Now that the base address of the kernel module is known, you can
    dump it using the `moddump` plugin for further analysis:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 即使模块名称为 `UNKNOWN`，通过回调例程地址，我们也可以推断出恶意模块应该位于从地址 `0xb878` 开始的内存区域中。从 `modules`
    插件的输出中，您可以看到该模块已经取消链接，但 `modscan` 插件仍然能够检测到加载在 `0xb878c000` 并大小为 `0x11000` 的内核模块。显然，所有回调例程地址都位于该模块的范围内。现在，已知内核模块的基地址，您可以使用
    `moddump` 插件将其转储以进行进一步分析：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Like callbacks, a rootkit driver may create a timer and get notified when the
    specified time elapses. A rootkit driver may use this functionality to schedule
    operations to be performed periodically. The way it works is that the rootkit
    creates a timer and provides a callback routine known as *DPC (Deferred Procedure
    Call),* which will be called when the timer expires. When the callback routine
    is invoked, the rootkit can perform malicious actions. In other words, the timer
    is another way by which a rootkit can get to execute its malicious code. For detailed
    information on how the kernel timer works, refer to the following Microsoft documentation: [https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 像回调函数一样，rootkit 驱动程序可能会创建一个定时器，并在指定时间到期时获得通知。rootkit 驱动程序可以利用此功能来调度定期执行的操作。其工作原理是，rootkit
    创建一个定时器并提供一个称为*DPC（延迟过程调用）*的回调例程，当定时器过期时，该回调例程会被调用。当回调例程被调用时，rootkit 可以执行恶意操作。换句话说，定时器是
    rootkit 执行其恶意代码的另一种方式。有关内核定时器如何工作的详细信息，请参阅以下 Microsoft 文档：[https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs)。
- en: 'To list the kernel timers, you can use the `timers` Volatility plugin. A point
    to note out is that timers are not malicious, as such; it is a Windows functionality,
    so on a clean system you will see some of the legitimate drivers installing timers.
    Like callbacks, further analysis may be required to identify the malicious module.
    Since most rootkits try to hide their driver, as a result, obvious artifacts are
    created that can help you quickly identify the malicious module. In the following
    example, the *ZeroAccess rootkit* installs a timer for `6000` milliseconds. When
    this time elapses, the routine at address `0x814f9db0` in an `UNKNOWN` module
    is invoked. The `UNKNOWN` in the `Module` column tells us that the module is probably
    hidden, but the routine address points you to the memory range where the malicious
    code is present:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出内核定时器，你可以使用`timers` Volatility插件。需要注意的是，定时器本身并不具有恶意性质，它只是Windows的一项功能，因此在干净的系统上，你会看到一些合法的驱动程序安装了定时器。像回调一样，可能需要进一步分析才能识别恶意模块。由于大多数根工具尝试隐藏它们的驱动程序，结果就会生成一些明显的痕迹，帮助你快速识别恶意模块。在以下示例中，*ZeroAccess根工具*安装了一个6000毫秒的定时器。当时间到期时，`UNKNOWN`模块中的`0x814f9db0`地址的例程被调用。`Module`列中的`UNKNOWN`表明该模块可能被隐藏，但例程地址指向了恶意代码所在的内存范围：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In addition to timers, *ZeroAccess* also installs callbacks to monitor registry
    operations. Again, the callback routine address points to the same memory range
    (starting with `0x814f`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定时器，*ZeroAccess*还安装了回调以监控注册表操作。同样，回调例程的地址指向相同的内存范围（以`0x814f`开头）：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Trying to find the `UNKNOWN` module using the `modules`, `modscan`, and `driverscan`
    plugins does not return any results:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`modules`、`modscan`和`driverscan`插件查找`UNKNOWN`模块并没有返回任何结果：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inspecting the driverscan listing revealed suspicious entries where the base
    address and the size are zeroed out (which is not normal and could be a bypass
    trick). Zeroing out the base address explains why `modules`, `modscan`, and `driverscan`
    did not return any results. The output also reveals that the name of the malicious
    driver is composed only of numbers, which adds to the suspicion:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`driverscan`列出的内容时，发现了可疑的条目，其中基址和大小被清零（这不正常，可能是一种绕过技巧）。基址清零解释了为什么`modules`、`modscan`和`driverscan`没有返回任何结果。输出还显示，恶意驱动程序的名称仅由数字组成，这进一步引发了怀疑：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'By zeroing out the base address, the rootkit is making it hard for the forensic
    analyst to determine the start address of the kernel module, which also prevents
    us from dumping the malicious module. We still know where the malicious code is
    residing (the address starting with `0x814f`). The compelling question is, how
    do we determine the base address using that information? One method is to take
    one of the addresses and subtract a certain number of bytes (such as by going
    backwards) till you find the `MZ` signature, but the problem with that approach
    is that it''s not easy to determine how many bytes to subtract. The fastest method
    is to use the `yarascan` plugin, since this plugin allows you to scan for a pattern
    (string, hex bytes, or regex) in the memory. Since we are trying to find the module
    that resides in the kernel memory starting with address `0x814f`, we can use `yarascan`
    with `-K` ( which only scans kernel memory) to look for the `MZ` signature. From
    the output, you can see the presence of an executable at address `0x814f1b80`.
    You can specify this as the base address to dump the malicious module to disk
    using the `moddump` plugin. The dumped module is around 53.2 KB in size, which
    turns out to be `0xd000` bytes in hex. In other words, the module starts at address
    `0x814f1b80` and ends at `0x814feb80`. All the callback addresses fall within
    the address range of this module:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将基址清零，根工具使得取证分析师很难确定内核模块的起始地址，这也阻止了我们导出恶意模块。我们仍然知道恶意代码的驻留位置（地址以`0x814f`开头）。一个引人注目的问题是，我们如何利用这些信息来确定基址？一种方法是取一个地址，减去一定字节数（比如倒着减），直到找到`MZ`签名，但这种方法的问题在于很难确定需要减去多少字节。最快的方法是使用`yarascan`插件，因为这个插件允许你在内存中扫描模式（字符串、十六进制字节或正则表达式）。由于我们正在寻找驻留在内核内存中并以`0x814f`开头的模块，可以使用带有`-K`选项的`yarascan`（该选项只扫描内核内存）来查找`MZ`签名。通过输出结果，你可以看到在地址`0x814f1b80`处有一个可执行文件。你可以将这个地址指定为基址，通过`moddump`插件将恶意模块导出到磁盘。导出的模块大小约为53.2
    KB，对应的十六进制为`0xd000`字节。换句话说，模块从地址`0x814f1b80`开始，到`0x814feb80`结束。所有的回调地址都在这个模块的地址范围内：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To confirm that the dumped module is malicious, it was submitted to *VirusTotal*.
    The results from AV vendors confirm it to be the *ZeroAccess Rootkit* (also known
    as *Sirefef*):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认该转储模块是否为恶意模块，它被提交到*VirusTotal*。来自AV厂商的结果确认它是*ZeroAccess Rootkit*（也被称为*Sirefef*）：
- en: '![](../images/00365.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00365.jpeg)'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Malware authors use various advanced techniques to install their kernel driver
    and to bypass Windows security mechanisms. Once the kernel driver is installed,
    it can modify the system components or third-party drivers to bypass, deflect,
    and divert your forensic analysis. In this chapter, you looked at some of the
    most common rootkit techniques and we saw how to detect such techniques using
    memory forensics. Memory forensics is a powerful technique, and using it as part
    of your malware analysis efforts will greatly help you understand adversary tactics.
    Malware authors frequently come up with new ways to hide their malicious component,
    so it is not enough just to know how to use the tools; it becomes important to
    understand the underlying concepts to recognize the efforts by the attackers to
    bypass the forensic tools.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用各种先进技术来安装其内核驱动程序，并绕过Windows安全机制。一旦内核驱动程序安装完成，它可以修改系统组件或第三方驱动程序，从而绕过、偏转并转移你的取证分析。在本章中，你了解了一些最常见的rootkit技术，并且我们看到了如何通过内存取证来检测这些技术。内存取证是一项强大的技术，将其作为恶意软件分析的一部分，能极大地帮助你理解对手的战术。恶意软件作者经常想出新的方法来隐藏其恶意组件，因此，仅仅知道如何使用工具是不够的；理解其背后的概念也变得至关重要，以识别攻击者绕过取证工具的努力。
