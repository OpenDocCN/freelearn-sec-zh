- en: '*Chapter 2*: Manipulating SQL – Exploiting SQL Injection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：操作 SQL – 利用 SQL 注入'
- en: 'After dealing more generally with **Structured Query Language** (**SQL**) and
    its characteristics and peculiarities, we are now focusing more on the main crux
    of this book: the injection vulnerability. We''ve already seen, in a broader sense,
    what SQL injection is, and gave a glimpse of what could be done with it, and why.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在更一般地讨论**结构化查询语言**（**SQL**）及其特点和特性之后，我们现在将更多地聚焦于本书的核心内容：注入漏洞。我们已经在更广泛的意义上了解了
    SQL 注入是什么，并且简要介绍了它可能带来的影响，以及为什么它是一个严重的安全问题。
- en: In this chapter, as a follow-up to the previous one, we are continuing with
    the theoretical approach to the matter, getting more in touch with the practical
    aspects of SQL injection attacks. This chapter includes, in fact, examples of
    input strings that could be used for triggering SQL injection for many different
    purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，作为上一章的延续，我们继续采用理论方法，进一步接触 SQL 注入攻击的实际应用方面。本章实际上包括了触发 SQL 注入的输入字符串示例，这些示例可以用于多种不同的目的。
- en: This chapter will lay the foundation for the practical part, which will instead
    focus on the execution of SQL injection attacks in a controlled setup, putting
    into practice what we will see in this part.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为实践部分奠定基础，实践部分将专注于在受控环境中执行 SQL 注入攻击，将我们在本部分所学应用到实际操作中。
- en: After discussing SQL injection with SQL syntax, this chapter will also describe
    the injection vulnerability in some non-relational settings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了 SQL 语法的 SQL 注入后，本章还将描述非关系型数据库中的注入漏洞。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: '**Exploitable SQL commands and syntax**: We''ll highlight the SQL commands
    and syntactic structures most open to abuse that could be exploited for carrying
    out SQL injection attacks.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可利用的 SQL 命令与语法**：我们将重点介绍最容易被滥用的 SQL 命令和语法结构，这些可能被用来实施 SQL 注入攻击。'
- en: '**Common SQL injection commands and manipulation**: An overview of the main
    SQL attack techniques, showing actual commands used by attackers and their possible
    effects on an application or a system.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见的 SQL 注入命令与操作**：概述主要的 SQL 攻击技术，展示攻击者使用的实际命令及其对应用程序或系统可能产生的影响。'
- en: '**Not only SQL injection: non-relational repositories**: A brief introduction
    to the non-relational context.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不仅仅是 SQL 注入：非关系型数据库**：简要介绍非关系型数据库的背景。'
- en: '**The injection vulnerability in non-relational repositories**: An explanation
    of the impact of SQL injection in the non-relational environment, showing some
    possible techniques.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非关系型数据库中的注入漏洞**：解释 SQL 注入在非关系型环境中的影响，展示一些可能的攻击技术。'
- en: '**Wrapping up: (No-)SQL injection in theory**: A final recap of the theoretical
    part of this book, to fix the main topics and approach the practical section with
    more confidence.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总结：（非）SQL 注入理论**：对本书理论部分的最终回顾，以巩固主要主题，并以更大的信心进入实践部分。'
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we recommend that you are familiar with SQL and its main
    commands. If you have not already done so, we suggest reading the SQL technical
    documentation from the previous chapter, available at the following links:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们建议你熟悉 SQL 及其主要命令。如果你还没有这样做，建议先阅读上一章的 SQL 技术文档，文档可以通过以下链接获取：
- en: '[https://dev.mysql.com/doc/refman/8.0/en/](https://dev.mysql.com/doc/refman/8.0/en/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.mysql.com/doc/refman/8.0/en/](https://dev.mysql.com/doc/refman/8.0/en/)'
- en: '[https://docs.oracle.com/en/database/oracle/oracle-database/index.html](https://docs.oracle.com/en/database/oracle/oracle-database/index.html)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.oracle.com/en/database/oracle/oracle-database/index.html](https://docs.oracle.com/en/database/oracle/oracle-database/index.html)'
- en: '[https://docs.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver15)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver15)'
- en: Exploitable SQL commands and syntax
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可利用的 SQL 命令和语法
- en: 'We have already seen that the main problem that makes applications and systems
    vulnerable to SQL injection is the lack of controls on user-provided input. By
    default, input sources need to be considered as untrusted so that everything sent
    to our application or system is verified prior to processing. You may now ask:
    *how exactly could a malicious user insert an instruction within our code?* SQL,
    being a very powerful language, permits many different operations on a database;
    tricking an application into executing arbitrary commands could lead to someone
    who wants to damage or obtain access to a system being given a serious advantage.
    In this section, we will see the main enablers for SQL injection, underlining
    how important correctly preprocessing input is, thus saving our systems and applications
    from being compromised through a simple input string.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，使应用程序和系统容易受到 SQL 注入攻击的主要问题是缺乏对用户输入的控制。默认情况下，输入源需要被视为不可信，因此必须在处理之前验证所有发送到应用程序或系统的内容。你现在可能会问：*恶意用户到底是如何在我们的代码中插入指令的？*
    SQL 是一种非常强大的语言，允许对数据库执行多种操作；如果应用程序被欺骗执行任意命令，可能会使想要破坏或访问系统的人获得严重的优势。在本节中，我们将看到
    SQL 注入的主要促成因素，并强调正确预处理输入的重要性，从而避免通过一个简单的输入字符串让我们的系统和应用程序遭受攻击。
- en: SQL injection-enabling characters
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 SQL 注入的字符
- en: Before dealing with SQL statements and constructions, we should first examine
    what, given the lack of controls on the input, makes inserting arbitrary instructions
    possible in the first place.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 SQL 语句和构造之前，我们应首先检查在缺乏输入控制的情况下，为什么能够插入任意指令。
- en: In a similar fashion to what happens in most machine-interpreted languages,
    SQL maps some specific characters to corresponding purposes within code text.
    The most trivial character a person would try to exploit is the single quote (**'**)
    or the double quote (**"**), as it is used as a delimiter for text values within
    queries.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数机器解释语言中的情况类似，SQL 将一些特定字符映射到代码文本中的相应用途。一个人最容易尝试利用的字符是单引号（**'**）或双引号（**"**），因为它们在查询中作为文本值的定界符。
- en: One example is the semicolon character (**;**) that is used to separate different
    commands (the same as in most programming languages).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是分号字符（**;**），它用于分隔不同的命令（与大多数编程语言相同）。
- en: Another quite abused character in SQL injection is the comment separator, which
    in most syntaxes corresponds to the **–** sequence, because it can render the
    next part of a SQL query useless, as the system will consider it a comment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 SQL 注入中被广泛滥用的字符是注释分隔符，在大多数语法中，它对应于**–**序列，因为它可以使 SQL 查询的下一部分变得无效，系统会将其视为注释。
- en: 'Think, just as a general example, of a text input used in a naïve **SELECT**
    query for the color of an object, for which a regular user would have inserted
    **red**, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个普遍的例子，考虑一个用于查询物体颜色的简单**SELECT**语句，普通用户会输入**red**，如以下所示：
- en: SELECT color, shape FROM objects WHERE color='red'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT color, shape FROM objects WHERE color='red'
- en: 'Things could go quite differently if, instead of **red**, the following were
    inserted as text input:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入的文本输入不是**red**，而是以下内容，情况可能会大不相同：
- en: red'; DROP TABLE objects --
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: red'; DROP TABLE objects --
- en: 'This would result in the query looking like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致查询看起来像这样：
- en: SELECT color, shape FROM objects WHERE color='red'; DROP TABLE objects –-'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT color, shape FROM objects WHERE color='red'; DROP TABLE objects –-'
- en: User-provided input, not having been sanitized, would trick the system into
    processing, alongside the command that uses an expected syntax, another SQL command
    that removes the **objects** table entirely from the database. The addition of
    the comment separator removes the second single-quote character automatically
    inserted by the application, thus making it possible for a malicious user to insert
    any SQL command they like while keeping the syntax correct.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的输入未经过清理，可能会导致系统在处理使用预期语法的命令时，错误地执行另一个 SQL 命令，完全删除数据库中的**objects**表。添加注释分隔符会自动移除应用程序插入的第二个单引号字符，从而使恶意用户能够在保持语法正确的情况下插入他们想要的任何
    SQL 命令。
- en: To better understand the level of manipulation that would be possible in the
    case of unchecked input, we will see how SQL statements are usually constructed
    within an application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解在输入未被检查的情况下可能发生的操控程度，我们将看到 SQL 语句通常是如何在应用程序中构造的。
- en: SQL statement construction
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 语句构造
- en: As we mentioned earlier, the most common SQL statements used in applications
    are **SELECT** statements. Many times, when you encounter a web form used for
    searching an item, it is linked to a database running within the application so
    that data can be accessed in a structured and reliable way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序中最常用的 SQL 语句是 **SELECT** 语句。很多时候，当你遇到一个用于搜索项的 Web 表单时，它会与应用程序中的数据库连接，从而以结构化和可靠的方式访问数据。
- en: Think of a regular login form, made of the text inputs of a given username and
    password. What the application does is match the information inserted to see if
    the provided username and password pair exists within the same record of a database
    (linked to a single user). Thus, if the result exists, the application knows that
    the user has access to it and grants the necessary permission.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个常规的登录表单，由给定的用户名和密码文本输入框组成。应用程序的作用是匹配插入的信息，查看提供的用户名和密码对是否存在于数据库中的同一条记录中（与单个用户关联）。因此，如果结果存在，应用程序就知道该用户有权限访问，并授予必要的权限。
- en: 'If we inserted **Overlord** as the username and **pass** as the password, the
    resulting **SELECT** statement would look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 **Overlord** 作为用户名，**pass** 作为密码，那么生成的 **SELECT** 语句将如下所示：
- en: SELECT * FROM users WHERE username='Overlord' AND password='pass'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM users WHERE username='Overlord' AND password='pass'
- en: 'The application inserts the strings collected, stored as variables, as text
    within another text string that constitutes the general body of the query. Of
    course, those variables could be acquired as input in various ways in a web context
    (as parameters in **HyperText Transfer Protocol** (**HTTP**) **GET** requests—which
    we would not recommend: it''s not the 90s anymore—or in **POST** requests). For
    simplicity, in this example, we will consider variables acquired through a **GET**
    request to the (made-up) address [sqlexample.com/login.php?username=Overlord&password=pass](http://sqlexample.com/login.php?username=Overlord&password=pass).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将收集到的字符串，存储为变量，作为文本插入到构成查询主体的另一个文本字符串中。当然，这些变量可以通过各种方式在 Web 环境中获取（作为 **超文本传输协议**（**HTTP**）**GET**
    请求的参数——我们不推荐这样做：现在已经不是90年代了——或作为 **POST** 请求）。为了简便起见，在本例中，我们将考虑通过 **GET** 请求从（虚构的）地址
    [sqlexample.com/login.php?username=Overlord&password=pass](http://sqlexample.com/login.php?username=Overlord&password=pass)
    获取变量。
- en: 'Therefore, the application code would look something like the following **PHP:
    Hypertext Preprocessor** (**PHP)** example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，应用程序的代码可能如下所示 **PHP: 超文本预处理器**（**PHP**）示例：'
- en: $user=$_GET[username]; //$_GET extracts data from parameters $pass=$_GET[password];
    //in the address (after the "?") $query="SELECT * FROM users WHERE username='"
    + $user +"' AND password='" + $pass + "'";
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: $user=$_GET[username]; //$_GET 从参数中提取数据 $pass=$_GET[password]; //从地址中提取数据（在“？”之后）
    $query="SELECT * FROM users WHERE username='" + $user +"' AND password='" + $pass
    + "'";
- en: By constructing the query in this way, it becomes apparent how a statement could
    be altered using user-provided input, as described earlier. This is why being
    careful when handling user-provided input is important not only when using SQL
    but in general, as we can't assume anybody to have benign intentions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构造查询，可以清楚地看到如何利用用户提供的输入来修改语句，如前所述。这也是为什么在处理用户提供的输入时要小心的重要原因，不仅是在使用 SQL
    时，而是一般来说，因为我们不能假设任何人都有良好的意图。
- en: We will now examine some examples of SQL injection commands and their purpose
    for attackers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将分析一些 SQL 注入命令的示例及其攻击者的目的。
- en: Common SQL injection commands and manipulation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 SQL 注入命令和操作
- en: 'SQL injection can be used in many different ways for many different purposes,
    due to the wide range of possible actions that can be performed through SQL. The
    most trivial use is trying to obtain otherwise inaccessible information, querying
    the database in ways that are not usually envisioned by the regular flow of the
    application logic. Other uses involve the bypass of *authentication gates* within
    applications, thus effectively escalating privileges, or alternatively gaining
    more control on the affected system in the case of stored credentials. Other common
    attacks include blind SQL injection: in most cases, the database console or output
    is not shown to an attacker, as the operations happen behind the so-called *frontend*;
    however, it is possible for an attacker to identify and exploit SQL injection
    by observing the application behavior. We will now see some examples of notorious
    attack techniques.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入可以以多种不同的方式用于许多不同的目的，因为SQL可以执行许多不同的操作。最简单的使用方法是试图获取通常无法访问的信息，通过数据库查询以应用程序逻辑中通常未考虑到的方式。其他用途包括绕过应用程序中的*身份验证门*，从而有效地提升权限，或者在存储凭证的情况下，获得更多对受影响系统的控制。其他常见的攻击包括盲注SQL注入：在大多数情况下，数据库控制台或输出不会显示给攻击者，因为操作发生在所谓的*前端*背后；然而，攻击者可以通过观察应用程序的行为来识别并利用SQL注入。我们将看到一些著名的攻击技术示例。
- en: Information gathering and schema extraction – UNION queries
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息收集与模式提取 – UNION查询
- en: Step 0 of any attack is collecting useful information, in order to gather enough
    data to identify the target, such as system configuration, possible intrinsic
    vulnerabilities, and attack points. While not strictly SQL injection, the act
    itself of gathering information using SQL is a form of attack, which is of course
    useful for attackers who would need to exploit SQL injection on a system, especially
    considering the subtle differences in the main SQL **database management systems**
    (**DBMSs**).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何攻击的第0步都是收集有用的信息，以便收集足够的数据来识别目标，例如系统配置、可能的内在漏洞和攻击点。虽然严格来说这不是SQL注入，但使用SQL收集信息本身就是一种攻击形式，这对于需要在系统上利用SQL注入的攻击者来说，尤其是考虑到主要SQL
    **数据库管理系统**（**DBMSs**）之间的细微差异，显然是非常有用的。
- en: 'The simplest way to get to know the target system better is by triggering an
    error message, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 了解目标系统的最简单方法是通过触发错误信息，如下所示：
- en: '![Figure 2.1 – An error message from a test application caused by erroneous
    SQL syntax'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 测试应用程序因SQL语法错误而产生的错误信息'
- en: '](image/B15632_02_001.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_001.jpg)'
- en: Figure 2.1 – An error message from a test application caused by erroneous SQL
    syntax
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 测试应用程序因SQL语法错误而产生的错误信息
- en: In this case, by entering a purposely wrong syntax (namely, we inserted a **'wrong**
    string within the username field of a form), we got a useful error message stating
    that we're dealing with a MySQL database. Nowadays, only badly coded applications
    display error information in case of a syntax error, but it's definitely worth
    a try.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过输入故意错误的语法（即，我们在表单的用户名字段中插入了一个**错误的**字符串），我们得到了一个有用的错误信息，指出我们正在处理的是一个MySQL数据库。如今，只有编码不良的应用程序才会在语法错误时显示错误信息，但尝试一下绝对是值得的。
- en: 'Continuing our exploration of the tools at our disposal, we will now focus
    on an advanced SQL command that is used a lot in SQL injection: **UNION**.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们对可用工具的探索，我们现在将重点讨论SQL注入中经常使用的一个高级SQL命令：**UNION**。
- en: 'The **UNION** command is one of the most powerful tools available for database
    discovery and dumping through SQL injection. Logically, it is used to concatenate
    the results of two or more queries within the same result table. Let''s refer
    to the following examples from [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)*,
    Structured Query Language for SQL Injection*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**UNION**命令是通过SQL注入进行数据库发现和转储的最强大工具之一。从逻辑上讲，它用于将两个或更多查询的结果合并到同一个结果表中。我们可以参考以下来自[*第1章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)*的示例，《SQL注入的结构化查询语言》：'
- en: SELECT color, shape FROM objects WHERE color='blue' UNION SELECT color, shape
    FROM objects WHERE color='red'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT color, shape FROM objects WHERE color='blue' UNION SELECT color, shape
    FROM objects WHERE color='red'
- en: 'The previous query shows the **color** and **shape** attributes of records
    from the **objects** table that have a **blue** value for attribute color, and
    also puts in the same results table records with **red** as the color. Keep in
    mind that **UNION** only works if the attributes of the two queries are of the
    same dimension. Arbitrary values could also be inserted in a **UNION** section,
    like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个查询显示了**color**和**shape**属性的记录，这些记录来自**objects**表，并且它们在color属性上有**blue**的值，同时也把颜色为**red**的记录放入了相同的结果表中。请记住，**UNION**仅在两个查询的属性维度相同时才有效。还可以在**UNION**部分插入任意值，像这样：
- en: SELECT color, shape FROM objects WHERE color='blue' UNION SELECT 1,2
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT color, shape FROM objects WHERE color='blue' UNION SELECT 1,2
- en: In this example, we are showing the arbitrary values **1** and **2** in the
    same output table as for the first query. This trick can in addition be used to
    display arbitrary values as output, and also to fit **UNION** sections in the
    same format as a previous query, possibly displaying hidden information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在与第一个查询相同的输出表中显示了任意值**1**和**2**。此外，这个技巧还可以用来显示任意值作为输出，并且使**UNION**部分与前一个查询的格式一致，可能会显示隐藏的信息。
- en: 'Do you remember the **@@VERSION** command from the previous chapter? This useful
    command can be used by an attacker to see the version of the database running.
    The **SELECT @@VERSION** query shows, in fact, the system version of the target.
    Let''s see it in an example, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得上一章的**@@VERSION**命令吗？这个有用的命令可以被攻击者用来查看正在运行的数据库版本。**SELECT @@VERSION**查询实际上显示的是目标系统的版本。让我们通过一个例子来看一下，内容如下：
- en: '![Figure 2.2 – The result of a UNION query displaying the database system'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 一个 UNION 查询的结果，显示了数据库系统'
- en: version to be inserted after a query
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果会在查询之后插入版本
- en: '](image/B15632_02_002.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_002.jpg)'
- en: Figure 2.2 – The result of a UNION query displaying the database system version
    to be inserted after a query
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 一个 UNION 查询的结果，显示了查询之后要插入的数据库系统版本
- en: 'Although this command is mostly useful in the case of MS SQL, due to the fact
    that it may also show relevant information about the Windows operating system
    for the existence of important vulnerabilities, it can also report some information
    about other systems (note: **@@VERSION** is not supported in Oracle Database).
    The example is taken from another purposely vulnerable web app from the **Open
    Web Application Security Project** (**OWASP**) (Vicnum). The reported version
    is **5.1.41-3ubuntu12.6-log**, indicating a MySQL installation on Ubuntu 12\.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个命令在 MS SQL 的情况下最为有用，因为它还可能显示有关 Windows 操作系统的重要漏洞的相关信息，但它也能报告关于其他系统的一些信息（注意：**@@VERSION**在
    Oracle 数据库中不受支持）。这个例子来自**开放 Web 应用程序安全项目**（**OWASP**）的另一个故意易受攻击的 Web 应用程序（Vicnum）。报告的版本是**5.1.41-3ubuntu12.6-log**，表明这是一个安装在
    Ubuntu 12 上的 MySQL。
- en: Another important component of information gathering through SQL injection is
    the enumeration of tables and databases included within the schema. Once again,
    the **UNION** command will prove to be very useful, as it provides enough flexibility.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SQL 注入进行信息收集的另一个重要组成部分是枚举模式中包含的表和数据库。再次强调，**UNION**命令将非常有用，因为它提供了足够的灵活性。
- en: 'Let''s take advantage of the default tables available, shown in the previous
    chapter. Let''s try showing all the schemas available within a database. We will
    once again target **OWASP Vicnum** for example purposes. Have a look at the following
    screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用上一章中显示的默认表来进行实验。让我们尝试显示数据库中所有可用的模式。为了示范，我们再次以**OWASP Vicnum**为例。请看以下截图：
- en: '![Figure 2.3 – The result of a UNION query displaying the schema names on the
    database'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 一个 UNION 查询的结果，显示了数据库中的模式名称'
- en: '](image/B15632_02_003.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_003.jpg)'
- en: Figure 2.3 – The result of a UNION query displaying the schema names on the
    database
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 一个 UNION 查询的结果，显示了数据库中的模式名称
- en: 'Notice how we can see many schemas from the same system? This is because our
    target resides on an emulated system that has multiple applications present on
    it. You can imagine how targeting an application on a shared database could reveal
    much information, not only on the target application but on the system in general.
    Just to make you more enticed: this emulated environment will be the one you will
    be able to set up after [*Chapter 3*](B15632_03_Final_JC_ePub.xhtml#_idTextAnchor050),
    *Setting Up the Environment*, and it will be one of our main targets during the
    practical part.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们可以看到同一系统中的多个模式吗？这是因为我们的目标位于一个模拟系统上，该系统上有多个应用程序。你可以想象，针对一个共享数据库中的应用程序进行攻击，可能会揭示大量信息，不仅是目标应用的，还包括整个系统的。为了让你更有兴趣：这个模拟环境将是你在[*第3章*](B15632_03_Final_JC_ePub.xhtml#_idTextAnchor050)中能够设置的环境，*设置环境*，它将成为我们实际操作部分的主要目标之一。
- en: 'Let''s insist on using the **information_schema** default table, as it contains
    all the information about how the schema is organized within a MySQL system. One
    of the preceding results is the schema related to a WordPress application, so
    we will try to inject this query using another **UNION** keyword to show all tables
    in a target schema, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坚持使用**information_schema**默认表，因为它包含关于 MySQL 系统中模式组织的所有信息。前面的一个结果是与 WordPress
    应用相关的模式，因此我们将尝试通过另一个**UNION**关键字注入此查询，以显示目标模式中的所有表，如下所示：
- en: SELECT table_schema,table_name FROM information_schema.tables WHERE  table_schema
    = 'wordpress'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema
    = 'wordpress'
- en: 'The result of such a query, inserted after the **UNION** keyword, would have
    the following result in a vulnerable application that openly displays query results:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样查询的结果，如果插入到**UNION**关键字之后，将在一个脆弱的应用程序中显示以下结果，该应用程序公开显示查询结果：
- en: '![Figure 2.4 – The result of a UNION query displaying schema and table names
    on target schema'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 显示目标模式中的模式和表名的 UNION 查询结果](image/B15632_02_004.jpg)'
- en: '](image/B15632_02_004.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_004.jpg)'
- en: Figure 2.4 – The result of a UNION query displaying schema and table names on
    target schema
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 显示目标模式中的模式和表名的 UNION 查询结果
- en: This can be done for all schemas found within the database. We have seen these
    information-gathering techniques using MySQL default tables, but let's now also
    consider the other two main DBMS systems with a client-server architecture. Each
    has some peculiarities that introduce some differences with respect to MySQL.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以对数据库中找到的所有模式进行处理。我们已经看到过使用 MySQL 默认表的这些信息收集技术，但现在让我们也考虑一下另外两个具有客户端-服务器架构的主要数据库管理系统。它们各自有一些独特之处，相对于
    MySQL 引入了一些不同。
- en: Microsoft SQL Server
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Microsoft SQL Server
- en: 'Microsoft SQL Server, as we said in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)*,
    Structured Query Language for SQL Injection,* also has some default tables and
    databases. One that is very helpful for attackers is the database named **master**,
    which contains information about the whole database system. In the same fashion
    as we did for MySQL, by querying the **sysdatabases** table, it is possible to
    obtain the list of all databases, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)*，SQL注入的结构化查询语言*中所提到的，Microsoft
    SQL Server 也有一些默认的表和数据库。其中一个对攻击者非常有帮助的数据库是名为**master**的数据库，它包含有关整个数据库系统的信息。与我们对
    MySQL 所做的类似，通过查询**sysdatabases**表，可以获取所有数据库的列表，具体如下：
- en: SELECT name FROM master..sysdatabases
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM master..sysdatabases
- en: 'This query mirrors exactly our **SELECT schema_name FROM information_schema.schemata**
    statement we first made in MySQL. From there, **UNION** queries can be used to
    extend information gathering to tables contained in databases with the help of
    the **sysobjects** table, showing elements contained within, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询与我们最初在 MySQL 中执行的**SELECT schema_name FROM information_schema.schemata**语句完全相同。通过**UNION**查询，可以扩展信息收集，查询数据库中的表，借助**sysobjects**表显示其中的元素，具体如下：
- en: SELECT name FROM databasename..sysobjects
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM databasename..sysobjects
- en: 'This query would show a lot of information, including noise. Luckily, the search
    can be refined by focusing on specific types of data. Selecting the f**xtype**
    field with the **U** value, for example, will filter only user-defined tables.
    Here is a list of possible values for the **xtype** field in **sysobjects**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询会显示很多信息，包括噪声。幸运的是，可以通过关注特定类型的数据来精炼搜索。例如，选择**xtype**字段并设为**U**值，将只过滤出用户定义的表。以下是**sysobjects**中**xtype**字段可能的值列表：
- en: '**C**: CHECK constraint'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**：CHECK 约束'
- en: '**D**: Default or DEFAULT constraint'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：默认或DEFAULT约束'
- en: '**F**: FOREIGN KEY constraint'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F**：外键约束'
- en: '**L**: Log'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：日志'
- en: '**P**: Stored procedure'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P**：存储过程'
- en: '**PK**: PRIMARY KEY constraint (type is K)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PK**：主键约束（类型是K）'
- en: '**RF**: Replication filter stored procedure'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RF**：复制过滤存储过程'
- en: '**S**: System table'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：系统表'
- en: '**TR**: Trigger'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TR**：触发器'
- en: '**U**: User table'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**U**：用户表'
- en: '**UQ**: UNIQUE constraint (type is K)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UQ**：唯一约束（类型是K）'
- en: '**V**: View'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**V**：视图'
- en: '**X**: Extended stored procedure'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X**：扩展存储过程'
- en: Oracle Database
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle数据库
- en: 'As for Oracle Database, despite it having default tables and databases too,
    results could be a bit more limited with respect to MySQL and Microsoft SQL Server,
    as enumeration (as we have seen before) is not completely possible due to its
    structure. However, fear not: much information could still be obtained from an
    Oracle Database, despite having access.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 至于Oracle数据库，尽管它也有默认的表和数据库，但与MySQL和Microsoft SQL Server相比，结果可能会有所限制，因为枚举（如我们之前所见）由于其结构不完全可能。然而，不必担心：即使有访问权限，Oracle数据库仍能提取许多信息。
- en: 'Database names, due to the compartmentalized nature of Oracle Database, can
    only be obtained within a specific context. To return the current database, there
    are some options available in terms of queries an attacker could try, such as
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Oracle数据库的分区特性，数据库名称只能在特定上下文中获取。为了返回当前数据库，攻击者可以尝试以下几种查询：
- en: SELECT name FROM v$database;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM v$database;
- en: 'This query would return the name stored in **v$database**, which stores information
    about—you guessed it—the database, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询将返回存储在**v$database**中的名称，**v$database**存储关于——你猜对了——数据库的信息，如下所示：
- en: SELECT global_name FROM global_name
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT global_name FROM global_name
- en: '**global_name** is a one-row table that stores the name of the current database,
    like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**global_name**是一个单行表，存储当前数据库的名称，类似于：'
- en: SELECT SYS.DATABASE_NAME FROM DUAL
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT SYS.DATABASE_NAME FROM DUAL
- en: 'The **DUAL** table is a default table that serves as a dummy: it only contains
    a single value, set at **x**. It is mostly used when computing constant expressions,
    due to the fact that it is visible to any user. In this case, **SYS.DATABASE_NAME**
    is not linked to the **DUAL** table, but it is a constant.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**DUAL**表是一个默认表，用作虚拟表：它只包含一个值，设置为**x**。由于它对任何用户都可见，因此通常在计算常量表达式时使用。在这种情况下，**SYS.DATABASE_NAME**并未与**DUAL**表连接，但它是一个常量。'
- en: 'In Oracle, a user''s access to information depends on how privileges are set.
    The following query returns all the tables the current user has access to:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oracle中，用户访问信息的权限取决于权限设置。以下查询返回当前用户可访问的所有表：
- en: SELECT table_name,owner FROM all_tables;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT table_name,owner FROM all_tables;
- en: 'To retrieve all available columns, the following query can be used:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索所有可用列，可以使用以下查询：
- en: SELECT column_name FROM all_tab_columns
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT column_name FROM all_tab_columns
- en: Of course, since it would return a very high number of results, it is best to
    refine the search (for example, using **WHERE** or **LIKE**, which acts as a less
    strict **WHERE**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于它返回的结果数量可能非常庞大，最好精细化查询（例如，使用**WHERE**或**LIKE**，后者是**WHERE**的一种宽松方式）。
- en: An attacker could identify interesting tables containing private information.
    Speaking of which… let's move to the next subsection! This will focus more on
    MySQL due to the presence of some interesting examples, but the reasoning could
    also apply to other DBMSs, with the exception of the notes we mentioned earlier.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以识别出包含私密信息的有趣表格。说到这个…让我们进入下一小节！这一小节将更多地关注MySQL，因其有一些有趣的示例，但这种推理也适用于其他数据库管理系统，除了我们之前提到的注意事项。
- en: Dumping the database
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出数据库
- en: Using the information that we can extract from the database schema, we have
    the power to view all the information we want from an injectable database. Once
    again, **UNION** comes to our aid, this time allowing us to go deeper so that
    we can extract the complete contents of any tables we need.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们从数据库架构中提取的信息，我们可以查看从可注入数据库中提取的所有信息。再一次，**UNION**帮助了我们，这次使我们能够深入提取我们需要的任何表的完整内容。
- en: The idea is to perform enumeration of fields within a table, then, with the
    same approach, to extract all the content we need once we have discovered the
    full schema of the database. The entire database, if vulnerable to SQL injection,
    can be fully visible to an attacker, who can also extract sensitive information
    contained therein.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路是对表中的字段进行枚举，然后采用相同的方法，在发现数据库完整架构后提取我们所需的所有内容。如果数据库存在SQL注入漏洞，攻击者可以完全访问整个数据库，并提取其中包含的敏感信息。
- en: 'For explanatory reasons, we are now targeting the **wp_users** table from the
    previous example. We are now interested in retrieving the full structure of the
    table, enumerating its fields. An attacker could use this to explore the database
    and detect the presence of potentially useful information. The query we now need
    to insert after **UNION** is something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释的目的，我们现在针对前一个例子中的**wp_users**表。我们现在感兴趣的是获取该表的完整结构，列出其字段。攻击者可以利用这个方法探索数据库并检测潜在有用的信息。我们现在需要在**UNION**后插入的查询语句类似于以下内容：
- en: SELECT table_schema,table_name,column_name FROM information_schema.columns WHERE  table_name
    = 'wp_users'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT table_schema,table_name,column_name FROM information_schema.columns WHERE  table_name
    = 'wp_users'
- en: 'By performing the **UNION** query as in the previous example, by inserting
    the missing value to make our columns the same as the original query, we now have
    access to the field names of the selected table, as illustrated in the following
    screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行如前一个例子中的**UNION**查询，插入缺失的值，使得我们的列与原始查询相同，我们现在可以访问所选表的字段名，如下图所示：
- en: '![Figure 2.5 – The result of a UNION query displaying field names of target'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 显示目标字段名称的UNION查询结果'
- en: '](image/B15632_02_005.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_005.jpg)'
- en: Figure 2.5 – The result of a UNION query displaying field names of target
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 显示目标字段名称的UNION查询结果
- en: 'Well, that''s awkward: we found the **user_login** and **user_pass** fields,
    which definitely contain login information. Let''s try to query those in a simple
    query, using the information we collected before, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，这有点尴尬：我们找到了**user_login**和**user_pass**字段，显然这些字段包含了登录信息。让我们尝试使用之前收集到的信息，进行一个简单的查询，如下所示：
- en: SELECT ID,display_name,user_login,user_pass FROM wordpress.wp_users
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT ID,display_name,user_login,user_pass FROM wordpress.wp_users
- en: 'This results in the following response, giving us information about user profiles
    within the WordPress instance that relies on the database:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下响应，向我们提供关于依赖于数据库的WordPress实例中用户配置文件的信息：
- en: '![Figure 2.6 – The result of a UNION query displaying the wp_users table'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 显示wp_users表的UNION查询结果'
- en: '](image/B15632_02_006.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_006.jpg)'
- en: Figure 2.6 – The result of a UNION query displaying the wp_users table
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 显示wp_users表的UNION查询结果
- en: As a common practice, passwords are hashed. This means that such passwords are
    unusable unless they are cracked. In this case, we have MD5 hashes that could
    be easily broken by specialized software. This means that an attacker could easily
    obtain login information for such accounts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种常见做法，密码会进行哈希处理。这意味着这些密码无法使用，除非被破解。在这种情况下，我们有MD5哈希值，这些哈希值可以被专门的软件轻松破解。这意味着攻击者可以轻松地获取这些账户的登录信息。
- en: This drill-down approach can be used in principle to obtain all the information
    an attacker could wish for on a database. Default databases, such as MySQL's **information_schema**
    database, could lead to a full map of the information contained in a database
    system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种深入查询的方法原则上可以用来获取攻击者希望从数据库中获得的所有信息。默认数据库，如MySQL的**information_schema**数据库，可能导致获取数据库系统中所有信息的完整映射。
- en: Escalating privileges and gaining access
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升权限并获得访问权限
- en: Let's now move on to another purpose of SQL injection attacks. We already mentioned
    in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020), *Structured
    Query Language for SQL Injection,* how SQL can be used for privilege escalation
    or to gain access to applications and/or systems. We will now go deeper into this
    aspect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续探讨SQL注入攻击的另一个目的。我们已经在[*第一章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)中提到过，*SQL注入的结构化查询语言*，SQL如何用于提升权限或访问应用程序和/或系统。接下来我们将深入讨论这一方面。
- en: 'Databases are often used for authentication purposes: whenever you insert your
    login information into a web form, in most cases this data is compared to information
    stored within a specific database. This way, the system knows whether you have
    the right to go through the authentication gate of an application. I know what
    you''re thinking: if it''s a database we are interacting with, someone can definitely
    try performing injection; right? Absolutely true. An application vulnerable to
    SQL injection can, in fact, allow an attacker to obtain more privileges than intended.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常用于身份验证目的：每当你将登录信息输入到网页表单时，在大多数情况下，这些数据会与存储在特定数据库中的信息进行比较。通过这种方式，系统可以知道你是否有权限通过应用程序的身份验证门禁。我知道你在想什么：既然我们正在与数据库交互，那么有人肯定会尝试进行注入攻击，对吧？完全正确。一个容易受到SQL注入攻击的应用程序，实际上可能允许攻击者获得比预期更多的权限。
- en: 'Remember the example in the previous subsection, where we obtained the information
    stored in the **wp_login** table of the WordPress instance in the database schema?
    This is shown here again for your reference:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记得前一小节中的示例吗？我们在数据库架构中获得了存储在 WordPress 实例的**wp_login**表中的信息？这里再次为您参考：
- en: '![Figure 2.7 –Record from the WordPress wp_login table corresponding to the
    admin user'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – 来自 WordPress wp_login 表的记录，对应于管理员用户'
- en: '](image/B15632_02_006.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_006.jpg)'
- en: Figure 2.7 –Record from the WordPress wp_login table corresponding to the admin
    user
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 来自 WordPress wp_login 表的记录，对应于管理员用户
- en: 'For security purposes, in an attempt to prevent password attacks facilitated
    by database dumping, the password is not stored in the database as is. The database
    contains instead the MD5 hashing of it, still useable for comparing with the application.
    MD5 is a hashing function that produces a specific *message digest* of 128 bits,
    expressed as 32 hexadecimal digits (0-9, a-f) for a given input. This hashing
    function has been replaced with more complex and secure ones (such as SHA-256)
    because it is now deemed too weak. In this case, the password itself was quite
    predictable, and it was obtainable in relatively little time. The hash corresponds
    to the **admin** password. Let''s try it in the WordPress application of our local
    emulated environment. This is illustrated in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全目的，为了防止通过数据库转储进行密码攻击，密码不会以明文形式存储在数据库中。数据库中存储的是密码的 MD5 哈希值，仍然可以用于与应用程序进行比对。MD5
    是一种哈希函数，它会生成一个特定的*消息摘要*，由 128 位表示，并以 32 个十六进制数字（0-9，a-f）表示给定输入。由于 MD5 现在被认为过于脆弱，这种哈希函数已经被更复杂且安全的哈希函数（如
    SHA-256）所取代。在这种情况下，密码本身非常容易预测，而且可以在相对较短的时间内获取。该哈希值对应于**管理员**密码。让我们在本地模拟环境中的 WordPress
    应用程序中尝试一下。如下图所示：
- en: '![Figure 2.8 – Successful attempt at authenticating the WordPress admin account'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 成功尝试验证 WordPress 管理员账户'
- en: '](image/B15632_02_008.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_008.jpg)'
- en: Figure 2.8 – Successful attempt at authenticating the WordPress admin account
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 成功尝试验证 WordPress 管理员账户
- en: Another less complicated way to obtain access using SQL injection is by totally
    bypassing authentication forms that are vulnerable to SQL injection. The most
    infamous example of SQL injection for authentication bypass exploits the fact
    that usually, SQL queries used for authenticating rely simply on the presence
    of a record satisfying the condition stating that such a record exists in the
    database. Thus, our final result needs to be "true". For this reason, we are talking
    about **tautologies**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通过 SQL 注入获得访问权限的方式是完全绕过易受 SQL 注入攻击的身份验证表单。最臭名昭著的 SQL 注入身份验证绕过示例利用了这样一个事实：通常，用于身份验证的
    SQL 查询仅仅依赖于满足条件的记录是否存在于数据库中。因此，我们的最终结果需要为“真”。因此，我们谈论的是**重言式**。
- en: In Boolean logic, a tautology is a logical expression that is always true, no
    matter the conditions. Putting any logical statement with a true statement in
    the binary **OR** operation, which returns true if either of the two operands
    is true, means always having **TRUE** as a result.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔逻辑中，重言式是一个总为真的逻辑表达式，无论条件如何。在二进制**OR**运算中，若两个操作数中的任意一个为真，结果将为真，这意味着结果始终为**TRUE**。
- en: 'This also applies to SQL injection: SQL also supports Boolean operands for
    conditions, which we always find in the **WHERE** part of a **SELECT** statement.
    If we were to write this SQL query, for example, we will always satisfy the **WHERE**
    condition:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于 SQL 注入：SQL 也支持用于条件的布尔运算符，我们总是在**WHERE**部分的**SELECT**语句中看到它们。例如，如果我们编写这个
    SQL 查询，我们将总是满足**WHERE**条件：
- en: SELECT * FROM table1 WHERE field='x' OR '1=1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM table1 WHERE field='x' OR '1=1'
- en: 'This is one of the most basic queries an attacker could, in principle, use
    to bypass authentication. Thus, an attacker could insert the following string
    in a vulnerable login form—for example, in the **user** text input:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是攻击者原则上可以用来绕过身份验证的最基本查询之一。因此，攻击者可以在易受 SQL 注入攻击的登录表单中插入以下字符串——例如，在**用户**文本输入框中：
- en: x' OR '1=1'--
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: x' OR '1=1'--
- en: By making the statement always true, an attacker could bypass the authentication
    of an application vulnerable to SQL injection. As we saw in the previous examples,
    commenting out the following part of the query helps in letting the system evaluate
    only what we want.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使语句始终为真，攻击者可以绕过易受 SQL 注入攻击的应用程序的身份验证。如我们在之前的示例中看到的，注释掉查询中的以下部分有助于让系统仅评估我们想要的内容。
- en: Depending on the underlying query, some additional considerations should be
    made. For example, the attacker should know which DBMS the database is running
    on in order to select the correct characters to be used as injection enablers.
    Other login forms could check that both text inputs, for username and password,
    are not empty, thus the attacker should insert information in both.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据底层查询的不同，应该考虑一些额外的因素。例如，攻击者应当知道数据库运行的是哪种数据库管理系统（DBMS），以便选择正确的字符作为注入启用符号。其他登录表单可能会检查用户名和密码两个文本输入框是否为空，因此攻击者应在两个输入框中插入信息。
- en: In the end, excluding the trial-and-error aspect, SQL injection can, in principle,
    allow an attacker to bypass authentication screens and obtain much higher privileges
    than intended.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，排除试错过程，SQL 注入原则上可以允许攻击者绕过认证屏幕，并获得比预期更高的权限。
- en: We will now analyze other common attack techniques—this time, probably the most
    widely used one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将分析其他常见的攻击技术——这次，可能是最广泛使用的一种。
- en: Blind SQL injection
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盲 SQL 注入
- en: Most of the time, interaction with databases does not provide record output—unlike
    we have seen in the Vicnum example. Thus, attackers do not have a direct feedback
    of the actions that they perform on the database in terms of records or tables.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，与数据库的交互不会提供记录输出——与我们在 Vicnum 示例中看到的不同。因此，攻击者无法直接通过记录或表格反馈他们在数据库上执行的操作。
- en: In this scenario, we are talking about **blind SQL injection** because attackers
    are interacting with databases without seeing, at least directly, the results
    of their actions. The authentication bypass is of course an example of blind SQL
    injection, but it's not the only one.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们谈论的是**盲 SQL 注入**，因为攻击者与数据库交互时，至少从直接上来说，看不到他们的操作结果。当然，认证绕过就是盲 SQL 注入的一个例子，但这并不是唯一的。
- en: Blind SQL injection is used to uncover information with the so-called **inference**
    attack. Basically, it consists, through various attempts, of disclosing information
    about the database through logical assumptions based on the web response. While
    in tautologies and contradictions, we chose our statements to have a predictable
    result—always true or always false—this time, we will be using conditions that
    *could* be true, and, if they are, they can disclose some information.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**盲注 SQL 注入**是通过所谓的**推断**攻击来揭示信息。基本上，它通过各种尝试，基于网站响应的逻辑假设，揭示关于数据库的信息。在重言式和矛盾中，我们选择使我们的语句有可预测的结果——始终为真或始终为假——而这次，我们将使用*可能*为真的条件，如果它们为真，它们可以揭示一些信息。'
- en: Without seeing the output from the database, an attacker this way still has
    some ways to tell whether an application is vulnerable to SQL injection. One of
    the most common ways to test for SQL injection in a blind setting is the introduction
    of an arbitrary time delay in the query submission.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 即使看不到数据库的输出，攻击者仍然有一些方法来判断应用程序是否易受 SQL 注入攻击。在盲注场景中，最常见的测试 SQL 注入的方法之一是通过在查询提交中引入一个任意的时间延迟。
- en: A common way to see the *injectability* of an application working with databases
    is by using logical expressions, in a similar way to what we saw with tautologies.
    In some cases, depending on the response that the application might return, it
    is possible to tell if it is injectable by making assumptions about how it treats
    logical expressions, or even leak some information. Here, we are dealing with
    **Boolean-based blind injection**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 查看与数据库交互的应用程序是否具备*可注入性*的一种常见方式是使用逻辑表达式，类似于我们在重言式中看到的方式。在某些情况下，根据应用程序可能返回的响应，可以通过对其如何处理逻辑表达式的假设来判断它是否可注入，甚至泄漏一些信息。在这里，我们处理的是**基于布尔值的盲注**。
- en: 'If we try a tautology (adding, for example, **'' OR ''1=1''--** to our query),
    then try an always false expression—a contradiction—by using the **AND** operation
    (**'' AND ''1=2''--**), we might see different results in the appearance of the
    response. In this case, we might have the cue we need to spot SQL injection: the
    SQL snippet we injected is successfully evaluated, changing the result of our
    query. In terms of database results, the first attempt ensures that, if successfully
    evaluated, all results are returned because the condition is always satisfied;
    vice versa, the second one would return an empty result.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试一个恒真式（例如，**' OR '1=1'--**），然后再尝试一个恒假表达式——即矛盾——通过使用**AND**操作符（**' AND '1=2'--**），我们可能会看到响应外观上的不同结果。在这种情况下，我们可能就会得到发现SQL注入的线索：我们注入的SQL片段成功执行，改变了查询结果。在数据库结果方面，第一个尝试确保如果成功评估，所有结果都会返回，因为条件始终满足；反之，第二个则会返回空结果。
- en: 'The trick is, by knowing the difference in output between true and false results,
    we can see whether a logical statement is true or false by putting it in an **AND**
    operation. This way, we could investigate about database information using this
    comparison, since we can''t directly query the database as we did in the case
    of non-blind SQL injection. A useful trick, besides comparing entire strings to
    a field value, is the use of **SUBSTRING()** to check for a specific character
    in a specific position, thus reconstructing the information we need. If we were
    to extract the first letter of the value of a string field, we would insert the
    following condition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是，通过了解真和假结果之间的输出差异，我们可以通过将逻辑语句放入**AND**操作中来判断其真假。这样，我们就可以通过这种比较来调查数据库信息，因为我们不能像非盲SQL注入那样直接查询数据库。一个有用的技巧，除了将整个字符串与字段值进行比较外，就是使用**SUBSTRING()**函数检查特定位置的特定字符，从而重构我们需要的信息。如果我们要提取字符串字段值的第一个字母，我们可以插入如下条件：
- en: SUBSTRING(fieldname,1,1)= 'x'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SUBSTRING(fieldname,1,1)= 'x'
- en: This, of course, could be iterated to obtain the entire information we seek,
    but performing it manually would definitely be a chore. An attacker would probably
    use some script to automate the process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个过程可以反复进行，以获得我们所需的所有信息，但手动执行时肯定会很麻烦。攻击者可能会使用一些脚本来自动化这个过程。
- en: Another way to perform a blind SQL injection is through the use of **time-based
    SQL injection**. Sometimes, the output for true or false results does not differ
    enough, so an attacker needs to introduce some artificial difference in the output.
    This is done through some nifty functions supported by the main SQL database systems.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行盲SQL注入的另一种方式是通过使用**基于时间的SQL注入**。有时，真或假的结果输出差异不大，因此攻击者需要引入一些人为的差异。这是通过一些主流SQL数据库系统支持的巧妙函数实现的。
- en: 'MySQL supports the **SLEEP()** and the **BENCHMARK(count, expression)** functions,
    which could be integrated in any statement. For example, the following snippet
    inserts a time delay in the query of **15** seconds:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持**SLEEP()**和**BENCHMARK(count, expression)**函数，它们可以集成到任何语句中。例如，以下代码片段在查询中插入了**15**秒的时间延迟：
- en: SLEEP(15)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SLEEP(15)
- en: 'This one, instead, performs the **SELECT @@VERSION** query **10000** times,
    introducing an indirect time delay depending on the execution time, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法则是执行**SELECT @@VERSION**查询**10000**次，根据执行时间引入间接的时间延迟，代码如下：
- en: BENCHMARK(10000, SELECT @@VERSION)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: BENCHMARK(10000, SELECT @@VERSION)
- en: 'Microsoft SQL Server instead supports the **WAITFOR DELAY()** and **WAITFOR
    TIME()** functions. The same result as the preceding **SLEEP()** function can
    be obtained with the following snippets. **DELAY** introduces a time delay (relative),
    while **TIME** specifies the actual clock time in which the wait ends. For the
    following example, let''s imagine that the actual time is 9:00:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft SQL Server则支持**WAITFOR DELAY()**和**WAITFOR TIME()**函数。与之前的**SLEEP()**函数相同的结果可以通过以下代码片段获得。**DELAY**引入时间延迟（相对的），而**TIME**指定等待结束的实际时间。以下例子中，我们假设当前时间是9:00：
- en: WAITFOR DELAY(0:0:15)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: WAITFOR DELAY(0:0:15)
- en: WAITFOR TIME(9:0:15)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: WAITFOR TIME(9:0:15)
- en: 'Oracle SQL has a slightly trickier way to perform time-based queries. There
    actually is a **SLEEP()** function, but it can only inserted within the Oracle
    SQL programming code, as it''s not supported by regular dynamic queries. The code
    snippet should be like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle SQL执行基于时间的查询的方式稍微复杂一些。实际上是有**SLEEP()**函数的，但它只能在Oracle SQL编程代码中插入，因为常规动态查询不支持。代码片段应如下所示：
- en: BEGIN DBMS_LOCK.SLEEP(15); END;
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: BEGIN DBMS_LOCK.SLEEP(15); END;
- en: 'There are, however, some tricks for introducing time delays. This is made possible
    through time-consuming queries, including network-dependent tasks (such as reverse
    **Domain Name Systems** (**DNS**) queries) or querying data using multiple (or
    replicated) tables. The following code snippets are two examples of such queries
    that could be injected. However, the effectiveness of these may change depending
    on the target:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确实有一些技巧可以引入时间延迟。这是通过消耗时间的查询实现的，包括依赖网络的任务（例如反向**域名系统**（**DNS**）查询）或使用多个（或复制的）表进行数据查询。以下代码片段是这类查询的两个示例，可以被注入。然而，它们的有效性可能会根据目标的不同而变化：
- en: SELECT UTL_INADDR.get_host_name('10.10.10.10') FROM dual
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT UTL_INADDR.get_host_name('10.10.10.10') FROM dual
- en: 'SELECT count(*) FROM all_users A, all_users B, all_users C, all_users D # and
    so on…'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'SELECT count(*) FROM all_users A, all_users B, all_users C, all_users D # 依此类推…'
- en: By verifying the time delay after a request has been made, an attacker can see
    whether the functions are evaluated by the backend system, thus confirming that
    SQL instruction can be successfully injected.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在发出请求后验证时间延迟，攻击者可以看到后台系统是否在评估函数，从而确认 SQL 指令可以成功注入。
- en: 'Time delays and Boolean queries could also be combined: nobody said that we
    cannot use time delays to see if a condition is true or not. The following query,
    in fact, is also legal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 时间延迟和布尔查询也可以结合使用：没有人说我们不能利用时间延迟来判断条件是否为真。事实上，以下查询也是合法的：
- en: SELECT IF SUBSTRING(fieldname,1,1)='x' SLEEP(15)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT IF SUBSTRING(fieldname,1,1)='x' SLEEP(15)
- en: This way, our signal is given by the passing of time before the response, instead
    of using logical conditions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的信号就是通过响应前的时间延迟来传递，而不是通过使用逻辑条件。
- en: 'Another important technique in the spectrum of blind SQL injection is called
    **splitting and balancing**. The main intuition is trying queries that, according
    to SQL, are functionally the same, and ensuring that the opening and closing of
    parentheses and quotes are perfectly balanced within the query, thus generating
    legal SQL. Let''s consider two very basic **SELECT** queries, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在盲注 SQL 注入的范畴内，另一个重要的技巧叫做 **拆分和平衡**。其主要思路是尝试那些根据 SQL 功能上相同的查询，并确保查询中括号和引号的开闭是完全平衡的，从而生成合法的
    SQL。我们可以考虑以下两个非常基本的 **SELECT** 查询：
- en: SELECT name FROM customers WHERE id=3
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM customers WHERE id=3
- en: SELECT name FROM customers WHERE id=2+1
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM customers WHERE id=2+1
- en: 'The two queries are functionally identical, due to the obvious arithmetic involved.
    This can also be used with string data with operations possible on strings, such
    as concatenating (**||**), if the DBMS allows for it, as illustrated in the following
    code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个查询在功能上是完全相同的，因为涉及到的算术是显而易见的。这个方法也可以用在字符串数据上，执行可能的字符串操作，如连接（**||**），如果数据库管理系统允许的话，如下代码片段所示：
- en: SELECT name FROM customers WHERE name='Jonathan'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM customers WHERE name='Jonathan'
- en: SELECT name FROM customers WHERE name='Jo'||'nathan'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM customers WHERE name='Jo'||'nathan'
- en: 'Here''s the catch: by using equivalent queries, other queries could also be
    injected, like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是：通过使用等效查询，其他查询也可能被注入，如下所示：
- en: SELECT name FROM customers WHERE id=3
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM customers WHERE id=3
- en: SELECT name FROM customers WHERE id=3+(SELECT 2-2)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT name FROM customers WHERE id=3+(SELECT 2-2)
- en: By exploiting this possibility provided by SQL, more complex sub-queries could
    also be inserted between parentheses, possibly inserting harmful attack payloads.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 SQL 提供的这一可能性，更多复杂的子查询也可以插入括号之间，可能插入有害的攻击负载。
- en: 'We have now seen an overview—without examples—of the main examples of SQL injection
    attacks against SQL systems. Let''s now move on to an aspect that is not always
    considered: does SQL injection also apply to NoSQL? By the name, you might be
    able to tell that it doesn''t, but the reality is a bit more complex than just
    a misleading name.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了 SQL 注入攻击针对 SQL 系统的主要示例概述——没有示例。接下来让我们讨论一个通常未被考虑的方面：SQL 注入是否也适用于 NoSQL？从名字上看，你可能会认为它不适用，但现实比这个误导性的名字要复杂得多。
- en: Not only SQL injection – non-relational repositories
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不仅仅是 SQL 注入——非关系型数据存储
- en: The term *NoSQL* has been debated over the years. Someone, probably not careful
    enough, would tell you it means *No SQL*, as in there is *positively nothing SQL-related
    about this matter*. While it is true that such databases use different approaches
    from the relational model (as we saw in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020),
    *Structured Query Language for SQL Injection*), some underlying logic is shared.
    The term NoSQL stems from the need to underline the differences with respect to
    the dominant database model. Going on, the term NoSQL, due to the fact that it
    generates some misunderstandings, is less preferred to the more general term **non-relational**,
    or **no-rel** for short.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*NoSQL*这个术语多年来一直备受争议。有些人，可能是没有足够注意的人，会告诉你它意味着*没有SQL*，也就是这件事*完全与SQL无关*。虽然确实这些数据库使用的方式不同于关系模型（正如我们在[*第一章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)中所见，*SQL注入的结构化查询语言*），但是一些底层逻辑是共享的。NoSQL这个术语的产生是为了强调它与主流数据库模型的差异。进一步说，由于NoSQL这个术语会引发一些误解，它已经不那么受欢迎，取而代之的是更通用的术语**非关系型**，简称**no-rel**。'
- en: As we already mentioned in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020),
    *Structured Query Language for SQL Injection*, the principles of SQL injection
    also impact, in some form or another, databases that do not incorporate SQL or
    the relational model. A trivial explanation is that the principle of injection,
    as it happens with code injection, can apply to every piece of software in charge
    of interpreting some piece of code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第一章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)中提到的，*SQL注入的结构化查询语言*，SQL注入的原理在某种形式上也会影响那些不包含SQL或关系模型的数据库。一个简单的解释是，注入的原理，正如代码注入一样，适用于任何负责解释某段代码的软件。
- en: One of the claims of non-relational database developers is that, by not using
    standard strings to build actual queries, non-SQL databases are not vulnerable
    to injection. Alas, there have been examples of this vulnerability, mostly in
    the case of document-based databases such as MongoDB.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库开发者的一项主张是，通过不使用标准字符串来构建实际的查询，非SQL数据库不容易受到注入攻击。可惜，实际上也有出现这种漏洞的例子，主要是在MongoDB等基于文档的数据库中。
- en: 'In short: just because your database is not SQL-based, it doesn''t mean that
    it is invulnerable to injection attacks. It''s true that it''s called **SQL injection**,
    but that''s just because it was discovered in a SQL setting. And, more importantly,
    it doesn''t mean at all that the only database systems vulnerable to injection
    are SQL ones.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：仅仅因为你的数据库不是基于SQL的，并不意味着它免疫于注入攻击。虽然这被称为**SQL注入**，但这只是因为它是在SQL环境中发现的。更重要的是，这一点也并不意味着只有SQL数据库系统容易受到注入攻击。
- en: The injection vulnerability in non-relational repositories
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非关系型存储库中的注入漏洞
- en: The problem of injectability is strictly dependent on trusting input, which
    could include interpretable code. This is also true in some cases of NoSQL database
    systems.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注入性问题严格依赖于对输入的信任，这些输入可能包含可解释的代码。对于某些NoSQL数据库系统，这一点也同样适用。
- en: Document-based databases still use formatted text to be inserted in a structured
    format. Most applications that use such databases rely mostly on text, be it in
    **JavaScript Object Notation** (**JSON**) format, or in any case from user-provided
    input. Thus, if not adequately sanitized, specific input could trigger some issues,
    in a similar fashion to how these happen in SQL.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文档的数据库仍然使用格式化文本以结构化的方式插入数据。大多数使用这种数据库的应用程序主要依赖文本，无论是**JavaScript对象表示法**（**JSON**）格式，还是来自用户提供的输入。因此，如果没有适当的清理，特定的输入可能会触发一些问题，类似于SQL中的情况。
- en: 'Let''s for now consider a fictitious website that relies on a document-based
    database, MongoDB, for authentication purposes. An attacker could send an HTTP
    **GET** request, **https://targetsite.org/login?user=admin&password[%24ne]=**.
    The target website, coded using a framework of **Node.js**, unfortunately has
    a very naïve way to check for credentials. Have a look at the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在考虑一个虚构的网站，该网站依赖基于文档的数据库MongoDB进行身份验证。攻击者可能会发送一个HTTP **GET**请求，**https://targetsite.org/login?user=admin&password[%24ne]=**。该目标网站使用**Node.js**框架编写，遗憾的是，它检查凭证的方法非常简单。请看以下代码片段：
- en: db.collection('users').find({
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('users').find({
- en: '"user": req.query.user,'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '"user": req.query.user,'
- en: '"password": req.query.password'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '"password": req.query.password'
- en: '});'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: 'In this format, the website still accepts the malevolent content, and thus
    will grant access to the malicious user. Why? Because no matter the technology,
    an unsanitized input could still be inserted. The request will be interpreted
    in this way:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种格式下，网站仍然接受恶意内容，因此会授予恶意用户访问权限。为什么？因为无论采用什么技术，未经清理的输入仍然可能被插入。请求将会按如下方式被解释：
- en: db.collection('users').find({
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('users').find({
- en: '"user": "admin",'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '"user": "admin",'
- en: '"password": {"$ne": ""}'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '"password": {"$ne": ""}'
- en: '});'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '**$ne** in MongoDB is a specific operator that defines the *not equal* relation.
    Put into practice, it is read as such in MongoDB and makes the **find()** function
    successful, thus granting access in a similar way as in SQL injection. This is
    because MongoDB expects input in a specific string format—namely, JSON.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ne** 在 MongoDB 中是一个特定的操作符，用于定义 *不等于* 关系。在实践中，它在 MongoDB 中是这样读取的，并使得 **find()**
    函数成功执行，从而以类似于 SQL 注入的方式授予访问权限。这是因为 MongoDB 期望输入采用特定的字符串格式——即 JSON。'
- en: 'The **GET** example was made just for explanatory purposes, but this attack
    could also work in a **POST** request, as illustrated in the following code snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET** 示例仅用于说明目的，但此攻击也可以在 **POST** 请求中工作，如下方代码片段所示：'
- en: POST /login HTTP/1.1
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: POST /login HTTP/1.1
- en: 'Host: [targetsite.org](http://targetsite.org)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: [targetsite.org](http://targetsite.org)'
- en: 'Content-Type: application/x-www-form-urlencoded'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/x-www-form-urlencoded'
- en: 'Content-Length: 27'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 27'
- en: user=admin&password[%24ne]=
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: user=admin&password[%24ne]=
- en: 'Being just text, the content could also be written in a JSON format request,
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为纯文本，内容也可以按如下 JSON 格式请求编写：
- en: POST /login HTTP/1.1
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: POST /login HTTP/1.1
- en: 'Host: [targetsite.org](http://targetsite.org)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: [targetsite.org](http://targetsite.org)'
- en: 'Content-Type: application/json'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json'
- en: 'Content-Length: 36'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Length: 36'
- en: '{''user'': ''admin'', ''password'': {''$ne'': ''''}}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '{''user'': ''admin'', ''password'': {''$ne'': ''''}}'
- en: With this example, it's apparent how the principles of SQL injection can apply
    to a non-relational database model. Of course, not having queries written in a
    powerful querying language limits the scope of possible attacks so that information
    gathering and database dumping are rendered impossible. However, by knowing the
    semantic of the server-side code, an attacker could exploit it to their advantage.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，明显可以看到 SQL 注入的原理如何应用于非关系型数据库模型。当然，由于没有使用强大的查询语言编写查询，攻击的范围受到限制，信息收集和数据库导出变得不可能。然而，通过了解服务器端代码的语义，攻击者仍然可以利用这一点来获得自己的利益。
- en: 'In general, an attacker could insert within an input objects that alter the
    semantics of queries, thus resulting in unexpected behavior. The solution for
    this is always the same: sanitizing input properly, and expecting possible compromise
    attempts from users.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，攻击者可以在输入中插入改变查询语义的对象，从而导致意外的行为。解决方案始终是相同的：正确清理输入，并预期用户可能的攻击尝试。
- en: After this brief example, we hope that, at least in theory, SQL injection, and
    its possible use outside of the realm of SQL, are clear and that you have the
    necessary tools to put your knowledge into practice.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的示例之后，我们希望至少在理论上，SQL 注入及其在 SQL 范畴之外的应用已经清晰，并且你已经掌握了将知识付诸实践所需的工具。
- en: Wrapping up – (No-)SQL injection in theory
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结——（非）SQL 注入的理论
- en: OK; that was quite a lot of information. Let's have a recap of what we were
    dealing in this theoretical section so far.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这信息量蛮大的。让我们回顾一下到目前为止在这个理论部分讨论的内容。
- en: 'SQL injection can be used by attackers in a variety of scenarios. In this chapter,
    we have seen examples regarding two common purposes, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以在各种场景下使用 SQL 注入。在本章中，我们已看到关于两种常见用途的示例，具体如下：
- en: Obtaining undisclosed information about the database or its content, through
    database exploration or inference techniques
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数据库探索或推理技术获取关于数据库或其内容的未公开信息
- en: Gaining privileged access to applications that use a shared database system
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取使用共享数据库系统的应用的特权访问权限
- en: Limiting application functionality could also be possible using SQL statements
    such as **DROP**, or through modification of vital information in a database,
    such as login information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 限制应用功能也可能通过 SQL 语句，如 **DROP**，或通过修改数据库中的重要信息，如登录信息来实现。
- en: 'In this chapter, we added another very important tool to be used within SQL
    statements, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们加入了另一个非常重要的工具，可以在 SQL 语句中使用，具体如下：
- en: '**UNION** can be added to existing statements to return results pertaining
    to another query within the same result table. To function properly, it''s necessary
    that the second query has the same number of fields as the first one, but this
    is easily obtainable by adding arbitrary static values, such as fixed numbers.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UNION** 可以添加到现有语句中，以返回与同一结果表中另一个查询相关的结果。为了正常工作，第二个查询必须与第一个查询具有相同数量的字段，但这可以通过添加任意静态值（如固定数字）来轻松获得。'
- en: 'SQL injection, especially using **UNION**, can be used for information gathering.
    Much information can be extracted from a vulnerable database:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入，特别是使用**UNION**，可以用于信息收集。可以从一个脆弱的数据库中提取大量信息：
- en: The database schema can be queried to get information about databases within
    the system, tables, and table fields.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以查询数据库架构以获取有关系统内的数据库、表和表字段的信息。
- en: The resulting information can be used to directly query the database, knowing
    exactly which tables and fields to extract.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得到的信息可以直接用于查询数据库，精确知道需要提取哪些表和字段。
- en: '**UNION** queries can retrieve a great deal of information, especially in MySQL
    and MSSQL, as many databases can be queried, especially if the system runs many
    database-relying applications on them.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UNION** 查询可以检索大量信息，特别是在 MySQL 和 MSSQL 中，许多数据库可以被查询，尤其是当系统运行着依赖于多个数据库的应用时。'
- en: 'SQL-based systems, due to some variations in implementation, can have some
    slight differences, as seen in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020),
    *Structured Query Language for SQL Injection*. Here are some of them:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 SQL 的系统由于实现的差异，可能会有一些细微的差别，如在[*第一章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)中所见，*SQL
    注入的结构化查询语言*。以下是其中一些：
- en: Among default databases, some are more interesting than others in terms of contained
    information.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在默认数据库中，一些数据库在所包含的信息方面比其他的更有趣。
- en: Tables can be accessed in different ways—for example, MSSQL uses **..** to access
    tables within our default databases.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表可以通过不同方式访问——例如，MSSQL 使用**..**来访问我们默认数据库中的表。
- en: Oracle Database accesses a single database in a single connection, so an attacker
    can retrieve information about one database at a time.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle 数据库在单个连接中访问单个数据库，因此攻击者每次只能检索一个数据库的信息。
- en: 'We prepared the following quick reference table, highlighting some basic differences
    between the main database systems, which can turn out to be useful during information
    gathering in terms of databases and tables to query for information:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了以下快速参考表，突出显示了主要数据库系统之间的一些基本差异，这在信息收集过程中，查询数据库和表以获取信息时，可能会非常有用：
- en: '![Figure 2.9 – Reference table for information gathering in the three main
    DBMS we’ve seen'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 信息收集的参考表格，适用于我们所见的三种主要数据库管理系统'
- en: '](image/B15632_02_Table_08.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_02_Table_08.jpg)'
- en: 'SQL injection can also help an attacker in gaining privileges and accessing
    otherwise inaccessible application functionalities, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入还可以帮助攻击者获取权限并访问通常无法访问的应用功能，具体如下：
- en: Extracting information from a database can sometimes lead to password disclosure,
    as password hashes are stored in databases, and those might be decrypted by offline
    password attacks if a weak hashing algorithm is used.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中提取信息有时可能导致密码泄露，因为密码哈希值存储在数据库中，如果使用了弱哈希算法，可能会通过离线密码攻击进行解密。
- en: Using tautologies, also known as always true expressions (such as **1=1**),
    you could make the login query always true, thus gaining access within a vulnerable
    authentication form in an application.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用恒等式，也称为总为真的表达式（如**1=1**），可以使登录查询始终为真，从而在应用程序中的脆弱认证表单内获得访问权限。
- en: 'One of the most common SQL attack techniques is called blind SQL injection,
    as most of the time, attackers do not have access to direct database output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一种最常见的 SQL 攻击技术叫做盲目 SQL 注入，因为大多数时候，攻击者无法直接访问数据库输出：
- en: All the previous examples that do not involve viewing database output, including
    authentication bypassing, are de facto blind SQL injections.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有不涉及查看数据库输出的先前示例，包括认证绕过，实际上都是盲目 SQL 注入。
- en: 'Time-based SQL injection can be used to determine whether or not a database
    can be vulnerable to SQL injection: the attacker inserts a time delay within the
    query and checks whether this is correctly interpreted by the database system.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的 SQL 注入可以用来判断数据库是否可能受到 SQL 注入的攻击：攻击者在查询中插入时间延迟，并检查数据库系统是否正确解释了这一点。
- en: Boolean-based SQL injection uses logical statements in order to reconstruct
    hidden database information, as an attacker cannot see the actual database content
    through queries. This is done by observing the behavior of the application in
    the context of true and false statements. If different, an attacker might try
    to inject conditions and see whether they are true or not based on the response.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于布尔值的 SQL 注入利用逻辑语句重建隐藏的数据库信息，因为攻击者无法通过查询看到实际的数据库内容。攻击者通过观察应用程序在真假语句上下文中的行为来实现这一点。如果行为不同，攻击者可能会尝试注入条件并根据响应判断它们是否为真。
- en: 'Time-based queries and Boolean-based queries can be combined: an attacker might
    insert, with a **UNION** statement, an **IF** condition that, depending on the
    result, might cause a set time delay. This way, an attacker can perform inference
    by studying the application behavior in terms of response time instead of content.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的查询和基于布尔值的查询可以结合使用：攻击者可能会通过**UNION**语句插入**IF**条件，根据结果，可能会引起一定的时间延迟。这样，攻击者可以通过研究应用程序在响应时间方面的行为进行推理，而不是内容。
- en: Splitting and balancing is another blind SQL injection technique that abuses
    the equivalence of some queries, which can also, if the application is vulnerable,
    include in some cases arbitrary sub-queries using parentheses and ensure the syntax
    is correct.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分和平衡是另一种盲目 SQL 注入技术，它滥用了某些查询的等价性，如果应用程序存在漏洞，甚至可能在某些情况下通过使用括号插入任意子查询并确保语法正确。
- en: 'Despite being called SQL injection, this vulnerability is also relevant to
    non-relational databases:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管被称为 SQL 注入，但这种漏洞对非关系型数据库也有影响：
- en: While databases do not always rely on query languages as powerful as SQL, that
    does not mean that commands or alterations can't be injected at all.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然数据库并不总是依赖像 SQL 这样的强大查询语言，但这并不意味着不能注入任何命令或修改。
- en: In case of NoSQL databases, we can talk about NoSQL injection. While the huge
    array of attacks we have seen so far cannot usually be performed, such as database
    dumping and arbitrary queries, some of the semantics can be altered at will by
    attackers who can access a way to insert an input within an application.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 NoSQL 数据库的情况下，我们可以讨论 NoSQL 注入。虽然到目前为止我们见过的大量攻击通常无法执行，比如数据库倾倒和任意查询，但攻击者只要能访问一种在应用程序中插入输入的方式，就可以随意改变某些语义。
- en: As in the login bypass example we have seen, NoSQL databases can be altered
    in a simple way by inserting elements that can alter the syntax and trick the
    underlying database in to evaluating specific conditions that could result in
    harmful behavior.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在登录绕过示例中看到的那样，NoSQL 数据库可以通过插入元素的简单方式进行修改，这些元素可以改变语法并欺骗底层数据库评估特定条件，从而可能导致有害行为。
- en: 'While SQL injection can be more harmful, it''s better not to underestimate
    the injection vulnerability in other database contexts: if an application that
    relies on a database does not sanitize user input, it may still be subject to
    injection.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 SQL 注入可能更具危害性，但最好不要低估其他数据库环境中的注入漏洞：如果依赖数据库的应用程序没有对用户输入进行清理，它仍然可能受到注入攻击。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: To recap, in this chapter, we saw that SQL can be exploited to insert malicious
    code, using specific constructs and symbols. Some of these can be particularly
    useful for gathering information, but also for gaining privileged access to applications
    and databases themselves.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中，我们看到 SQL 可以通过特定的构造和符号被利用来插入恶意代码。某些构造特别有助于收集信息，但也有助于获取应用程序和数据库本身的特权访问权限。
- en: We also saw that the concept of injection in database systems not only involves
    SQL databases but also some non-relational ones, for which we've seen some examples.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，数据库系统中的注入概念不仅涉及 SQL 数据库，还包括一些非关系型数据库，我们也看到了一些例子。
- en: The next chapter will be the first one of the practical section, and will focus
    on the setup of the same virtual environment we have seen in the examples involving
    Mutillidae II and Vicnum (by querying the **information_schema** database, you
    probably noticed the presence of various applications, including the vulnerable
    WordPress version we saw earlier). While the practical examples shown in this
    chapter served only an explanatory role, the second part of this book is instead
    intended to have a more practical approach and is presented in a step-by-step
    manner.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是实践部分的第一章，重点介绍我们在涉及Mutillidae II和Vicnum的示例中所见的相同虚拟环境的设置（通过查询**information_schema**数据库，你可能注意到了包括我们之前看到的易受攻击的WordPress版本在内的多个应用程序）。虽然本章中的实践示例仅起到说明作用，但本书的第二部分则旨在采用更为实际的方法，并以逐步指导的方式呈现。
- en: 'This first part was intended to be a full introduction to the topic of SQL
    injection. Theory, however, is not always enough: mastering a topic requires practice,
    and this is why the following practical part is the core of this book.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分旨在为SQL注入主题提供全面的介绍。然而，理论知识并不足够：掌握一个主题需要实践，这也是本书后续实际部分的核心所在。
- en: We hope you will enjoy what we have in store for you!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你喜欢我们为你准备的内容！
- en: Questions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How is it usually possible to trigger SQL injection?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常如何触发SQL注入？
- en: Describe, without going too much into detail, how it could be possible to extract
    information from a database using an application vulnerable to SQL injection.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简要描述如何在一个易受SQL注入攻击的应用程序中提取数据库信息。
- en: Describe how a malicious user could use SQL injection to defeat user authentication
    and gain access to an application.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一个恶意用户如何利用SQL注入绕过用户认证并访问应用程序。
- en: What is blind SQL injection? Describe two ways to perform blind SQL injection.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是盲SQL注入？描述执行盲SQL注入的两种方式。
- en: You are facing an application that relies on a database. You suspect that a
    web form relies on a SQL database, but the application does not return meaningful
    output after a query. Which SQL injection technique would you use to determine
    whether the application form is vulnerable to SQL injection?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在处理一个依赖数据库的应用程序。你怀疑一个网页表单依赖SQL数据库，但该应用程序在查询后未返回有意义的输出。你会使用哪种SQL注入技术来判断该应用程序表单是否易受SQL注入攻击？
- en: Is it true that only SQL databases are vulnerable to injection?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否只有SQL数据库容易受到注入攻击？
