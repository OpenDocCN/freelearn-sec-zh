- en: Reverse Engineering and Stress Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程和压力测试
- en: If you want to know how malware will behave, the easiest way to achieve that
    goal is to let it run rampant in your network and track its behavior in the wild.
    This is not how you want to get to understand malware behavior. You might easily
    miss something that your network environment doesn't enact, and then you'll have
    to remove the malware from all of the machines in your network. Kali has some
    selected tools to help you do that. This chapter also covers stress testing your
    Windows server or application. This is a great idea, if you want to discover how
    much DDoS will turn your server belly-up. This chapter is the beginning of how
    to develop an anti-fragile, self-healing Windows network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道恶意软件的行为，最简单的方法是让它在您的网络中肆虐，并跟踪其在野外的行为。这不是您想要了解恶意软件行为的方式。您可能会轻易错过您的网络环境没有执行的某些内容，然后您将不得不从网络中的所有计算机中删除恶意软件。Kali有一些精选的工具可以帮助您做到这一点。本章还涵盖了压力测试您的Windows服务器或应用程序。如果您想发现DDoS会让您的服务器崩溃多少，这是一个很好的主意。本章是如何开发一个抗脆弱、自我修复的Windows网络的开端。
- en: 'We will learn about the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Setting up a test environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立测试环境
- en: Reverse Engineering theory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆向工程理论
- en: Working with Boolean logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔逻辑
- en: Practicing Reverse Engineering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆向工程实践
- en: Stress testing your Windows machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试您的Windows机器
- en: There are some changes in the Reverse Engineering tools that are available in
    Kali Linux 2.0 compared to the tools in Kali Linux 1.x. Some tools have disappeared
    from the menu structure, and you can use the last section of [Chapter 6](7b8a5720-a83e-426c-8d7e-76fb427fc041.xhtml), *NetBIOS
    Name Service and LLMNR – Obsolete but Still Deadly*, to put them back if you wish.
    Some tools have not been included in Kali Linux 2 at all, though there are traces
    of them here and there. The following table shows these changes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kali Linux 1.x相比，Kali Linux 2.0中提供的逆向工程工具有一些变化。一些工具已经从菜单结构中消失，如果您希望，可以使用[第6章](7b8a5720-a83e-426c-8d7e-76fb427fc041.xhtml)的最后一节，*NetBIOS名称服务和LLMNR
    - 已过时但仍然致命*，将它们放回。一些工具根本没有包含在Kali Linux 2中，尽管在各处都有它们的痕迹。以下表格显示了这些变化。
- en: Tools showing full paths are not in the default Kali 2.0 menu at all, and the
    NASM Shell, a part of the Metasploit Framework suite of tools, was not in the
    Kali 1.x menu.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 显示完整路径的工具在默认的Kali 2.0菜单中根本不存在，NASM Shell，Metasploit Framework套件的一部分，在Kali 1.x菜单中也不存在。
- en: 'The following table shows you the difference between the tools in Kali 1.x
    and 2.0:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Kali 1.x和2.0中工具的区别：
- en: '![](img/ffda7889-19ed-40d0-8120-33d91c492340.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffda7889-19ed-40d0-8120-33d91c492340.png)'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: A running Kali Linux machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的Kali Linux机器
- en: A running copy of a Windows operating system (this can be a VM)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的Windows操作系统副本（可以是虚拟机）
- en: Setting up a test environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立测试环境
- en: Developing your test environment requires virtual machine examples of all of
    the Windows operating systems that you are testing against. For instance, an application
    developer might be running very old browser/OS test machines to see what breaks
    for customers running antique hardware. In this example, we are running Windows
    XP, Windows 7, and Windows 10\. We are using Oracle VirtualBox for desktop virtualization,
    but if you are more comfortable using VMWare, then use that instead. It is important
    to use machines that you can isolate from the main network, just in case the malware
    acts as it should, and attempts to infect the surrounding machines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发您的测试环境需要对您正在测试的所有Windows操作系统进行虚拟机示例。例如，应用程序开发人员可能正在运行非常旧的浏览器/操作系统测试机器，以查看对于运行古董硬件的客户来说会出现什么问题。在这个例子中，我们正在运行Windows
    XP、Windows 7和Windows 10。我们正在使用Oracle VirtualBox进行桌面虚拟化，但如果您更喜欢使用VMWare，那就使用它。重要的是要使用您可以与主网络隔离的机器，以防恶意软件表现如其应该，并试图感染周围的机器。
- en: Creating your victim machine(s)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的受害机器
- en: If you already have Windows VMs set up for some other purpose, you can either
    clone them (probably the safest option) or run them from a snapshot (this is the
    fastest way to set up). These machines should not be able to access the main network
    after you have built them, and you should probably set them up to communicate
    only with an internal network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经为其他目的设置了Windows虚拟机，您可以克隆它们（可能是最安全的选项）或者从快照中运行它们（这是设置的最快方式）。在构建完它们后，这些机器不应该能够访问主网络，并且您可能应该将它们设置为仅与内部网络通信。
- en: Testing your testing environment
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的测试环境
- en: Bring up your Kali VM
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的Kali虚拟机
- en: Make sure your Kali instance can talk to the internet, for ease of getting updates
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Kali实例可以与互联网通信，以便轻松获取更新
- en: Make sure your Kali instance can talk to your host machine
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Kali实例可以与您的主机机器通信
- en: Bring up your target Windows instances
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的目标Windows实例
- en: Make sure your Windows victims are not able to contact the internet, or your
    private Ethernet LAN, to avoid unexpected propagation of malware
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Windows受害者无法访问互联网，或者您的私人以太网局域网，以避免恶意软件的意外传播
- en: 'The three virtual machines on our test network are on a host-only network inside
    Oracle VirtualBox. The DHCP is provided by the host (`192.168.56.100`), and the
    three testing network machines are `101`, `102`, and `103`, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试网络上的三台虚拟机都在Oracle VirtualBox内部的仅主机网络上。DHCP由主机提供（`192.168.56.100`），三台测试网络机器分别是`101`、`102`和`103`，如下所示：
- en: '![](img/bf29f285-779a-40a1-b74a-0e24abb9d844.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf29f285-779a-40a1-b74a-0e24abb9d844.png)'
- en: Reverse Engineering theory
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程理论
- en: 'Theory scares IT professionals for some reason. This is not truly warranted,
    as theory is the underlying bedrock of all of your troubleshooting. It may be
    the axioms you have learned through your X years of hard-knocks trial and error.
    In the land of qualitative research, this is literally called the **Grounded Theory
    Research Method**. The base theory for Reverse Engineering is that the outputs
    infer the interior behavior of the application. When you are faced with a piece
    of malware, you are going to start making working hypotheses from a mixture of
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理论因某种原因使IT专业人员感到恐慌。这并不真正有根据，因为理论是您所有故障排除的基础。这可能是您通过X年的艰难试错学到的公理。在定性研究领域，这实际上被称为**基础理论研究方法**。逆向工程的基本理论是输出推断应用程序的内部行为。当您面对一种恶意软件时，您将开始从以下混合物中提出工作假设：
- en: Prior knowledge, from recalled interactions with malware perceived as similar
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从与被视为相似的恶意软件的交互中回忆的先验知识
- en: Generalizing perceived outcomes of interactions with the malware under test
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与测试中的恶意软件的交互的感知结果的概括
- en: '**Hacker tip**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客提示**：'
- en: It is probably not useful to label an application in an *a priori* manner. It
    may mask data to apply the *if it walks like a duck and quacks like a duck, it
    is probably a duck* axiom to the application. Especially with malware, it is likely
    that the design includes some deceptive features that are expected to set you
    off on the wrong track. Consider the trojans and rootkits that remove other trojans
    and rootkits as their first task. They are cleaning up your environment, but,
    are they really your friend?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在*a priori*的情况下给应用程序贴标签可能没有用。这可能掩盖了应用“如果它走起来像鸭子，叫起来像鸭子，那它可能就是鸭子”的公理。特别是对于恶意软件，设计可能包括一些欺骗性特征，预期会让你走上错误的道路。考虑一下作为其第一个任务删除其他特洛伊木马和rootkit的特洛伊木马和rootkit。它们正在清理你的环境，但是，它们真的是你的朋友吗？
- en: Malware applications are designed to provide outputs from inputs, but knowing
    the outputs and inputs does not truly give you a good idea of how the outputs
    are achieved. The outputs can be produced in several different ways, and you may
    find that it matters how the developer chose to create the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件应用程序旨在从输入中提供输出，但是知道输出和输入并不能真正让你了解输出是如何实现的。输出可以通过几种不同的方式产生，您可能会发现开发人员选择创建应用程序的方式很重要。
- en: One general theory of Reverse Engineering
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程的一个一般理论
- en: 'This theory was published by Lee and Johnson-Laird in 2013 in the Journal of
    Cognitive Psychology, and is useful for Information Security practitioners because
    it is shown in a Boolean system. A Boolean system is a logic gate. Either a condition
    is true or it is false. A very common definition of the problem might be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论是由李和约翰逊-莱尔德在2013年发表在《认知心理学杂志》上的，对信息安全从业者有用，因为它在布尔系统中显示。布尔系统是逻辑门。条件要么为真，要么为假。问题的一个非常常见的定义可能如下：
- en: '"Any system to be reverse-engineered contains a finite number of components
    that work together in giving rise to the system''s behavior. Some of these components
    are variable, that is, they can be in more than one distinct state that affects
    the performance of the system, for example, the setting on a digital camera that
    allows for the playback or erasing of photographs. Other components of the system
    do not vary, for example, a wire leading from a switch to a bulb. The system has
    a number of distinct inputs from the user and a number of consequent outputs,
    and they are mediated by a finite number of interconnected components. In some
    systems, a component may have a potentially infinite number of particular states,
    for example, different voltages. But, for the purposes of reverse engineering,
    we assume that all variable components can be treated as having a finite number
    of distinct states, that is, the system as a whole is equivalent to a finite-state
    automaton. In other words, analogue systems can be digitized, as in digital cameras,
    CDs, and other formerly analogue devices. We also assume that the device is intended
    to be deterministic, though a nondeterministic finite-state device can always
    be emulated by one that is deterministic."'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “任何要进行逆向工程的系统都包含一定数量的组件，这些组件共同作用产生了系统的行为。其中一些组件是可变的，也就是说，它们可以处于影响系统性能的多个不同状态，例如，数码相机上允许播放或删除照片的设置。系统的其他组件不变，例如，从开关到灯泡的导线。系统具有用户的一些不同输入和一些随之而来的输出，并且它们由有限数量的相互连接的组件中介。在某些系统中，一个组件可能具有潜在的无限数量的特定状态，例如，不同的电压。但是，为了进行逆向工程，我们假设所有可变组件都可以被视为具有有限数量的不同状态，也就是说，整个系统等同于有限状态自动机。换句话说，模拟系统可以被数字化，例如数码相机、CD和其他以前的模拟设备。我们还假设设备旨在是确定性的，尽管非确定性有限状态设备总是可以被确定性设备模拟。”
- en: –(Lee & Johnson-Laird, 2013)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: –（李和约翰逊-莱尔德，2013）
- en: A theory of Reverse Engineering and its application to Boolean systems. *Journal
    of Cognitive Psychology, 25(4)*, 365-389\. [http://doi.org/10.1080/20445911.2013.782033](http://doi.org/10.1080/20445911.2013.782033).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程理论及其在布尔系统中的应用。*认知心理学杂志，25(4)*，365-389。[http://doi.org/10.1080/20445911.2013.782033](http://doi.org/10.1080/20445911.2013.782033)。
- en: 'The Lee and Johnson-Laird model uses only Boolean internal models for the possible
    internal conditions that reveal the behaviors that were noted. Since it is not
    possible to test an infinite number of inputs, it is more useful to test only
    a subset of the possible inputs and outputs. We can start with a simple example,
    for instance, this one here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 李和约翰逊-莱尔德模型仅使用布尔内部模型来表示可能的内部条件，以揭示已注意到的行为。由于不可能测试无限数量的输入，因此测试仅可能的输入和输出的子集更有用。我们可以从一个简单的例子开始，例如这里：
- en: If the malware lands on an Apple platform, and is designed to exploit a Windows
    vulnerability, it is likely not to run at all (switch 1)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果恶意软件降落在苹果平台上，并且旨在利用Windows漏洞，那么它很可能根本无法运行（开关1）。
- en: If it lands on a Windows machine, but is aimed at a vulnerability of the XP
    version, it may test for that OS version and do nothing if it finds itself on
    Windows Server 2012 (switch 2)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它落在Windows机器上，但是针对XP版本的漏洞，它可能会测试该操作系统版本，并且如果发现自己在Windows Server 2012上则不执行任何操作（开关2）
- en: If it happens to be Windows XP, but is patched for the sought vulnerability,
    it might also do nothing (switch 3)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果碰巧是Windows XP，但已修补所寻找的漏洞，它也可能不执行任何操作（开关3）
- en: If it lands on a Windows XP machine that contains the sought-after unpatched
    vulnerability, it drops its payload
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它落在一个包含所寻找的未修补漏洞的Windows XP机器上，它会释放其有效负载
- en: '![](img/13e08369-520c-4bb4-b21b-d474c3bc2225.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13e08369-520c-4bb4-b21b-d474c3bc2225.png)'
- en: Working with Boolean logic
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布尔逻辑
- en: Computer programs are made up **data structures** that use conditions and decisions
    to bring the desired outputs. We will use Python notation here, as it is simple,
    and you may have seen it before. The basic data structures are as follows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序由使用条件和决策的**数据结构**组成，以获得所需的输出。我们将在这里使用Python符号，因为它很简单，而且您可能以前见过它。基本的数据结构如下。
- en: Iterators such as while loops and for loops. An iterator loops as many times
    as it is told to, running other commands each time it goes around.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器，如while循环和for循环。迭代器循环的次数与其被告知的次数一样多，每次循环时运行其他命令。
- en: Decision points such as if structures and case structures. The previous diagram
    is of a set of nested if structures.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策点，如if结构和case结构。前面的图是一组嵌套的if结构。
- en: '| **Boolean operators** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **布尔运算符** |'
- en: '| --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Notation** | **Description** | **Examples** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| X == Y | X is equivalent to Y.This is not always a numeric value set. | "shirts"
    == "hats" evaluates to FALSE."shirts" == "shirts" evaluates to TRUE.1 == 11 evaluates
    to FALSE.11 == 11 evaluates to TRUE. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| X == Y | X等于Y。这不总是一个数字值集。 | "shirts" == "hats" 评估为FALSE。"shirts" == "shirts"
    评估为TRUE。1 == 11 评估为FALSE。11 == 11 评估为TRUE。 |'
- en: '| X != Y | X is not equivalent to Y. | "shirts" != "hats" evaluates to TRUE."shirts"
    != "shirts" evaluates to FALSE.1 != 11 evaluates to TRUE.11 != 11 evaluates to
    FALSE. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| X != Y | X不等于Y。 | "shirts" != "hats" 评估为TRUE。"shirts" != "shirts" 评估为FALSE。1
    != 11 评估为TRUE。11 != 11 评估为FALSE。 |'
- en: '| X <= Y | X is smaller than OR equal to Y. | "shirts" <= "hats" evaluates
    to FALSE."shirts" <= "shirts" evaluates to TRUE.(It is counting the characters.)1
    <= 11 evaluates to TRUE.11 <= 11 evaluates to TRUE. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| X <= Y | X小于或等于Y。 | "shirts" <= "hats" 评估为FALSE。"shirts" <= "shirts" 评估为TRUE。（它在计算字符。）1
    <= 11 评估为TRUE。11 <= 11 评估为TRUE。 |'
- en: '| X >= Y | X is greater than or equal to Y. | "shirts" >= "hats" evaluates
    to TRUE."shirts" >= "shirts" evaluates to TRUE.(It is counting the characters.)1
    <= 11 evaluates to TRUE.11 <= 11 evaluates to TRUE. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| X >= Y | X大于或等于Y。 | "shirts" >= "hats" 评估为TRUE。"shirts" >= "shirts" 评估为TRUE。（它在计算字符。）1
    <= 11 评估为TRUE。11 <= 11 评估为TRUE。 |'
- en: '| X < Y | X is less than Y. | "shirts" < "hats" evaluates to FALSE."shirts"
    < "shirts" evaluates to FALSE.(It is counting the characters.)1 < 11 evaluates
    to TRUE.11 < 11 evaluates to FALSE. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| X < Y | X小于Y。 | "shirts" < "hats" 评估为FALSE。"shirts" < "shirts" 评估为FALSE。（它在计算字符。）1
    < 11 评估为TRUE。11 < 11 评估为FALSE。 |'
- en: '| X > Y | X is greater than Y. | "shirts" > "hats" evaluates to TRUE."shirts"
    > "shirts" evaluates to FALSE.(It is counting the characters.)1 > 11 evaluates
    to FALSE.11 > 11 evaluates to FALSE. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| X > Y | X大于Y。 | "shirts" > "hats" 评估为TRUE。"shirts" > "shirts" 评估为FALSE。（它在计算字符。）1
    > 11 评估为FALSE。11 > 11 评估为FALSE。 |'
- en: 'The following table shows the Boolean variables that are used in logical operations
    to join elements for more complex conditions. You might want to have limit conditions
    such as the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了用于逻辑操作的布尔变量，以连接元素以获得更复杂条件。您可能希望有以下限制条件：
- en: X and Y are both true
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X和Y都为真
- en: X and Y are both false
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X和Y都为假
- en: Either X or Y is true
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X或Y为真
- en: Anything but X
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了X之外的任何东西
- en: Anything but Y
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了Y之外的任何东西
- en: '| **Boolean variables** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **布尔变量** |'
- en: '| --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Variable** | **Description** | **Examples** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| AND | Produces a Boolean comparison that is only true if all of the elements
    are true. | `if ((1 == 1) and (2 == 2))` evaluates to TRUE, because all elements
    are true.`if ((1 == 1) and (2 > 2))` evaluates to FALSE, because only one of the
    elements is true.`if ((1 < 1) and (2 > 2))` evaluates to FALSE because no element
    evaluates to true. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| AND | 产生一个布尔比较，只有当所有元素都为真时才为真。 | `if ((1 == 1) and (2 == 2))` 评估为TRUE，因为所有元素都为真。`if
    ((1 == 1) and (2 > 2))` 评估为FALSE，因为只有一个元素为真。`if ((1 < 1) and (2 > 2))` 评估为FALSE，因为没有一个元素为真。
    |'
- en: '| OR | Produces a Boolean comparison that is true if any of the elements are
    true. | `if ((1 == 1) or (2 == 2))` evaluates to TRUE, because all elements are
    true.`if ((1 == 1) or (2 > 2))` evaluates to FALSE, because only one of the elements
    is true.`if ((1 < 1) or (2 > 2))` evaluates to FALSE because no element evaluates
    to true. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| OR | 产生一个布尔比较，如果任何一个元素为真则为真。 | `if ((1 == 1) or (2 == 2))` 评估为TRUE，因为所有元素都为真。`if
    ((1 == 1) or (2 > 2))` 评估为FALSE，因为只有一个元素为真。`if ((1 < 1) or (2 > 2))` 评估为FALSE，因为没有一个元素为真。
    |'
- en: '| NOT | Produces a Boolean comparison that is only true if all of the elements
    are not true. | `X = 2``if not (X == 3)` evaluates to TRUE because X isn''t 3.`X
    = 3``if not (X == 3)` evaluates to FALSE because X is 3. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| NOT | 产生一个布尔比较，只有当所有元素都不为真时才为真。 | `X = 2``if not (X == 3)` 评估为TRUE，因为X不是3。`X
    = 3``if not (X == 3)` 评估为FALSE，因为X是3。 |'
- en: 'The following code is testing the two conditions of `X` against a Boolean variable
    of NOT. You are probably starting to see how outputs can be drawn from many different
    internal coding choices. The attacker or original could be testing a condition
    by any of a number of conditions, so you have to think of all the ways that the
    output might be obtained:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码正在测试`X`的两个条件与NOT的布尔变量。您可能已经开始看到输出可以从许多不同的内部编码选择中绘制出来。攻击者或原始人可能会通过多种条件来测试条件，因此您必须考虑获得输出的所有方式：
- en: '![](img/e5ea8c3b-dc4f-4c92-90fe-7d2ae0238c3b.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5ea8c3b-dc4f-4c92-90fe-7d2ae0238c3b.png)'
- en: Reviewing a while loop structure
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查while循环结构
- en: 'A `while` loop is explicitly started and stopped by true/false choice points.
    These can look very complicated, but they resolve to a limited set of tests for
    a single condition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环是由真/假选择点明确启动和停止的。这些看起来可能非常复杂，但它们最终会解决为一组有限的测试，针对一个条件：'
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This Python 3 loop will print the value of `X` over and over until it reaches
    10, then stop. It would work exactly the same if we said `while X < Y`, because
    the loop structure is testing `X` as it is incremented. A more complicated loop,
    using a random number for the incrementor element, might go on for much longer
    (or not) before it randomly hits on a value of `X` that was the equivalent of
    `Y`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python 3循环将重复打印`X`的值，直到它达到10，然后停止。如果我们说`while X < Y`，它将完全相同工作，因为循环结构正在测试`X`的增量。使用一个随机数作为增量器元素的更复杂的循环，可能会在随机命中等于`Y`的`X`值之前进行更长时间的运行（或者不运行）：
- en: '![](img/38da95fe-217a-4e8b-befd-5c08d737b285.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38da95fe-217a-4e8b-befd-5c08d737b285.png)'
- en: 'It is obvious that the program is testing the looping condition each time.
    Here is an example of using that random `X` value. First, the `X` value is chosen,
    and then the `print (X)` command is run twice. Since `X` was only set once in
    the first line, it didn''t change in the two print commands. When the value of
    `X` was reset, it printed a different value. The condition was that `X` would
    not equal `Y`. We set the value of `Y` a few lines up, so it does not need to
    be reset to run this example. The reason why `X` returned only once was that the
    second time through, `X` was randomly set to `11`. The odds of it being set to
    `11` from the random draw was 1 out of eleven, a far better chance than your probability
    of winning the Powerball lottery:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，程序每次都在测试循环条件。这是使用随机`X`值的一个例子。首先，选择`X`值，然后运行两次`print(X)`命令。由于`X`只在第一行设置了一次，所以在两次打印命令中它没有改变。当`X`的值被重置时，它打印了一个不同的值。条件是`X`不等于`Y`。我们在几行上设置了`Y`的值，所以不需要重新设置它来运行这个例子。`X`只返回一次的原因是第二次，`X`被随机设置为`11`。从随机抽取中设置为`11`的几率是11分之1，远远超过你赢得Powerball彩票的概率：
- en: '![](img/ce8da739-431f-4bc7-a4b7-5e593a227eed.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce8da739-431f-4bc7-a4b7-5e593a227eed.png)'
- en: 'If we run the loop again, it might run more times, as it randomly avoids a
    value of `X` that''s equivalent to `Y`. Again, it does not print the value of
    `X = 11`, because that is precluded by the `while` loop condition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行循环，它可能会运行更多次，因为它随机避开了等于`Y`的`X`值。同样，它不会打印`X = 11`的值，因为这是被`while`循环条件排除的：
- en: '![](img/9f6d296a-3de0-446d-964f-4ff56f7a5caa.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f6d296a-3de0-446d-964f-4ff56f7a5caa.png)'
- en: Reviewing the for loop structure
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查for循环结构
- en: 'A `for` loop doesn''t need an incrementor because it builds the range into
    the condition, as contrasted with a `while` loop, which only includes a limit
    beyond which the loop will not run. Using Python notation, the following code
    shows what happens if you start with an `X` value of `0` and a range from one
    to eleven. The preset value of `X` is not important to the `for` loop iteration.
    It applies all values to `X` that it tests:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环不需要增量器，因为它将范围构建到条件中，与`while`循环相反，后者只包括一个超出该循环不会运行的限制。使用Python符号，以下代码显示了如果您从`0`值的`X`和从一到十一的范围开始会发生什么。`X`的预设值对`for`循环迭代并不重要。它将所有测试的值应用于`X`：'
- en: '![](img/1b3c08e1-a9a5-4561-a493-08ed2e3e8596.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b3c08e1-a9a5-4561-a493-08ed2e3e8596.png)'
- en: 'We are starting with `X` set to `100`, but the `for` loop takes the `X` value
    from its own condition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`X`设置为`100`开始，但`for`循环从它自己的条件中获取`X`的值：
- en: '![](img/33b6b841-da20-4bf7-b6c7-a569fcb293b7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33b6b841-da20-4bf7-b6c7-a569fcb293b7.png)'
- en: 'If you really want `X` to remain a constant, you can use it as the base of
    a different range, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的希望`X`保持不变，你可以将它用作不同范围的基础，如下所示：
- en: '![](img/2cdd090c-6062-468f-9498-a0ebf506060a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cdd090c-6062-468f-9498-a0ebf506060a.png)'
- en: Understanding the decision points
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解决策点
- en: 'An `if` structure is a binary decision: either yes or no. A light switch on
    the wall is a physical example of an if structure. If the switch is in one position,
    the lights are on, and if it is in the other position, the lights are off:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`结构是一个二进制决定：要么是，要么不是。墙上的开关灯是一个if结构的物理例子。如果开关处于一种位置，灯是亮的，如果它处于另一种位置，灯是灭的：'
- en: '![](img/b04ab4ba-4a4a-4740-9377-35a245614bb0.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b04ab4ba-4a4a-4740-9377-35a245614bb0.png)'
- en: 'A case structure is a decision structure with more than one right answer, more
    than one YES, and not a single NO. An example of this might be an ice cream dispenser
    with three flavors—chocolate, strawberry, and vanilla. If you do not want ice
    cream, you do not even approach the machine. You have three choices, and they
    are all correct:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`结构是一个具有多个正确答案的决策结构，不只有一个YES，而没有一个NO。一个例子可能是一个有三种口味的冰淇淋分配器——巧克力、草莓和香草。如果你不想要冰淇淋，你甚至不会接近这台机器。你有三种选择，它们都是正确的：'
- en: '![](img/6b7e5a48-6bd6-4430-8d71-5b5c83905c12.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b7e5a48-6bd6-4430-8d71-5b5c83905c12.png)'
- en: Practicing Reverse Engineering
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习逆向工程
- en: Since knowing that the inputs and outputs cannot, with any surety, provide you
    with a true picture of the internal construction of the application you want to
    reverse-engineer, let's look at some helpful utilities from Kali Linux that might
    make it easier. We will look at three debuggers, one disassembly tool, and one
    miscellaneous Reverse Engineering tool.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于知道输入和输出不能确保为您提供要逆向工程的应用程序的内部构造的真实图像，让我们看一些来自Kali Linux的有用工具，这些工具可能会使事情变得更容易。我们将看看三个调试器，一个反汇编工具和一个杂项逆向工程工具。
- en: We will show the usage and output from two Linux-based debuggers, **Valgrind**
    and **EDB-Debugger**, and then a similar output from a Windows-only debugger,
    **OllyDbg**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示两个基于Linux的调试器**Valgrind**和**EDB-Debugger**的用法和输出，然后展示一个仅适用于Windows的调试器**OllyDbg**的类似输出。
- en: 'The disassembler is **JAD**, which is a Java decompiler:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编器是**JAD**，它是一个Java反编译器：
- en: '![](img/0b954cd7-29ad-45a7-8a63-2e6848e62f1e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b954cd7-29ad-45a7-8a63-2e6848e62f1e.png)'
- en: Using debuggers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器
- en: What is debugging? The honor of coining the term is often erroneously attributed
    to Admiral Grace Hopper, on the occasion of her team members finding a physical
    (but dead) moth stuck in a relay inside a Mark II computer at Harvard University.
    The term may actually come from Thomas Edison as he mentioned and defined the
    term as *little faults and difficulties*. In software development, a bug is usually
    a logic error, and not a typographical error in the code. Typos usually stop the
    code from compiling at all, so they do not get out of the developers' lab. Logic
    errors do not stop the program from compiling, but they may cause a failure in
    the output or an unexpected behavior when the program is initiated. Another word
    often used synonymously with **bug** is **defect**. **Technical debt** in a project
    is the number of defects that are unfixed in a project. Different project managers
    have different levels of tolerance for unfixed bugs. Many malware packages have
    several show-stopping bugs in their released versions, but some of the more sophisticated
    recent malware packages appear to be very low in technical debt.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是什么？通常错误地将这个术语的创造归功于格雷斯·霍珀上将军，她的团队成员在哈佛大学的马克II计算机内发现了一只（但已死）蛾卡在继电器内。这个术语实际上可能来自托马斯·爱迪生，因为他提到并定义了术语为*小错误和困难*。在软件开发中，错误通常是逻辑错误，而不是代码中的拼写错误。拼写错误通常会导致代码根本无法编译，因此它们不会离开开发人员的实验室。逻辑错误不会阻止程序编译，但可能会导致输出失败或在启动程序时出现意外行为。与**bug**同义的另一个词是**defect**。项目中的**技术债务**是项目中未修复的缺陷数量。不同的项目经理对未修复的错误有不同的容忍度。许多恶意软件包在发布版本中有几个严重的错误，但一些更复杂的最近的恶意软件包似乎在技术债务方面非常低。
- en: Debuggers allow you to watch the behavior of an application in a step-wise manner.
    You can see what gets put into memory, what system calls are made, and how the
    application pulls and releases memory. The main reason we use debuggers is to
    check the behavior of programs for which we have access to the source code. The
    reason for this is that the programs we are most likely to debug are code that
    was made in our own workshops. This does not quite constitute a code security
    audit, but it can help a lot to find where a program is leaking memory, and how
    well it cleans up its used memory. Many programs display status reports on the
    command line if you start them that way, and these are internal debugging information.
    This could be cleaned up after release of the application, but in most use cases,
    the end user never sees any of it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器允许您以逐步方式观察应用程序的行为。您可以看到什么被放入内存，进行了什么系统调用，以及应用程序如何获取和释放内存。我们使用调试器的主要原因是检查我们可以访问源代码的程序的行为。这是因为我们最有可能调试的程序是在我们自己的研讨会中制作的代码。这并不完全构成代码安全审计，但可以帮助找出程序泄漏内存的位置，以及它如何清理已使用的内存。许多程序在命令行上显示状态报告，如果您以这种方式启动它们，这些都是内部调试信息。这些信息可能在应用程序发布后进行清理，但在大多数情况下，最终用户从未看到其中任何内容。
- en: Using the Valgrind debugger
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind调试器
- en: 'Programs generally reserve memory from the total RAM available. One program
    we have found useful for debugging on the command line is `valgrind`, which is
    not in the default Kali install. We add it when we find we need to do preliminary
    debugging. For instance, at one time, a version of [http://www.openoffice.org/](http://www.openoffice.org/),
    the free, open source office suite, had a bug in Linux that was allowing the install,
    but failed to run the program. It just seized up at the display of the initial
    splash screen. Running the following command showed that it was looking for a
    file that did not exist. Rather than just sending a bug report, and hoping for
    a solution to be added as a patch to the source code, we just added the missing
    file as a blank text file. This allowed OpenOffice to start. The OpenOffice developers
    added a patch later that removed the bug, but we didn''t have to wait for it.
    As an example of `valgrind`, here is the command-line code to run a test on `gedit`,
    a text editor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常从总内存中保留内存。我们发现在命令行上进行调试的一个有用程序是`valgrind`，它不在默认的Kali安装中。当我们发现需要进行初步调试时，我们会添加它。例如，有一次，[http://www.openoffice.org/](http://www.openoffice.org/)的一个版本，在Linux上有一个错误，允许安装，但无法运行程序。它在显示初始启动画面时就卡住了。运行以下命令显示它正在寻找一个不存在的文件。我们没有只是发送一个错误报告，并希望解决方案作为补丁添加到源代码中，而是只是添加了缺失的文件作为空白文本文件。这使得OpenOffice能够启动。OpenOffice开发人员后来添加了一个补丁，去除了错误，但我们不必等待。作为`valgrind`的一个例子，以下是在`gedit`上运行测试的命令行代码：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It takes much longer to start a program when it is encased in a debugger, and
    the entire output will go to the log file that's been designated. Once the program
    is open, you can close the program by pressing *Ctrl* + *C* on the command line,
    or if the application under test has a GUI interface, you can close the window,
    and `valgrind` will shut down after watching the application you are testing go
    down.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在将程序包装在调试器中启动时需要更长的时间，并且整个输出将进入指定的日志文件。一旦程序打开，您可以通过在命令行上按下*Ctrl* + *C*来关闭程序，或者如果被测试的应用程序具有GUI界面，您可以关闭窗口，`valgrind`将在观察您正在测试的应用程序关闭后关闭。
- en: 'In this example, there are over 600 lines of output from the debugger, and
    you are going to need to use a more user-friendly debugger to find more useful
    information. Keeping in mind that gedit is a very mature program and that it works
    flawlessly every time we use it to edit text files, it still has 24 memory errors
    noted by `valgrind` in the undemanding use case of opening gedit, typing a few
    characters, and closing without saving the new document:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，调试器输出了600多行，您需要使用一个更用户友好的调试器来找到更有用的信息。请记住，gedit是一个非常成熟的程序，每次我们使用它来编辑文本文件时都能完美运行，但在打开gedit，输入几个字符并在不保存新文档的情况下关闭时，`valgrind`在这种简单的用例中记录了24个内存错误：
- en: '![](img/e8051f1c-ef02-4c49-abf4-92f140f6ab51.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8051f1c-ef02-4c49-abf4-92f140f6ab51.png)'
- en: Using the EDB-Debugger
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EDB-调试器
- en: 'The EDB-Debugger is a version of a Windows application called the Olly debugger.
    The EDB-Debugger has the following features:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: EDB-Debugger是一个名为Olly debugger的Windows应用程序的版本。EDB-Debugger具有以下功能：
- en: A GUI interface, which the developers call intuitive
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员称之为直观的GUI界面
- en: Standard debugging operations (step-into/step-over/run/break)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准调试操作（步入/步过/运行/中断）
- en: More unusual conditional breakpoints
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多不寻常的条件断点
- en: A debugging core that is implemented as a plugin (you can drop in replacement
    core plugins)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为插件实现的调试核心（您可以插入替换核心插件）
- en: Some platforms may have several debugging APIs available, in which case you
    may have a plugin that implements any of them
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些平台可能有多个可用的调试API，如果是这种情况，您可能有一个实现其中任何一个的插件
- en: Basic instruction analysis
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本指令分析
- en: View/Dump memory regions
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看/转储内存区域
- en: Effective address inspection
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地址检查
- en: The data dump view is tabbed, allowing you to have several views of memory open
    at the same time that you can quickly switch between
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转储视图是分页的，允许您同时打开多个内存视图，并可以快速在它们之间切换
- en: It allows the importing and generation of symbol maps
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许导入和生成符号映射
- en: Has plugins to extend usability
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有扩展可用性的插件
- en: 'EDB-Debugger is designed to debug Linux applications, and we will look at the
    same application, gedit, with EDB-Debugger. The GUI interface shows the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: EDB-Debugger旨在调试Linux应用程序，我们将使用EDB-Debugger查看相同的应用程序gedit。GUI界面显示如下：
- en: The application being tested and the process ID in the title bar
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题栏中正在测试的应用程序和进程ID
- en: Memory location
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存位置
- en: Commands
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: General purpose binary command map
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用二进制命令映射
- en: 'Bookmarks: Places of interest in the code'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书签：代码中感兴趣的地方
- en: Registers set aside for data (specifically for the marked line in 2/3)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据保留的寄存器（特别是在2/3中标记的行）
- en: 'Data dump: Memory locations and content'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转储：内存位置和内容
- en: Memory Stack data
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存堆栈数据
- en: 'The GUI can be seen in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GUI的截图：
- en: '![](img/684a2a3c-6157-4e31-ae84-f7798c699f06.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/684a2a3c-6157-4e31-ae84-f7798c699f06.png)'
- en: EDB-Debugger symbol mapper
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDB-Debugger符号映射器
- en: 'EDB-Debugger can give you a symbol map via the following command-line entry:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: EDB-Debugger可以通过以下命令行输入给您一个符号映射：
- en: '[PRE2]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The symbol table maps functions, lines, or variables in a program. In the case
    of gedit, the symbol table looks as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表映射程序中的函数、行或变量。对于gedit，符号表如下所示：
- en: '![](img/c681ada7-4a79-4293-a374-32e87c12de7b.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c681ada7-4a79-4293-a374-32e87c12de7b.png)'
- en: Running OllyDbg
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行OllyDbg
- en: 'If you are running the 64-bit version of Kali Linux 2.0, you will first need
    to update Kali. It is missing the 32-bit wine infrastructure, and wine doesn''t
    even want to start without that. Luckily, Kali Linux gives you a useful error
    message. You just have to copy the quoted part of the error message and run it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Kali Linux 2.0的64位版本，您首先需要更新Kali。它缺少32位wine基础设施，而没有这个基础设施，wine甚至不想启动。幸运的是，Kali
    Linux给了您一个有用的错误消息。您只需复制错误消息中的引号部分并运行它：
- en: '![](img/dce4dcba-bf1e-494a-ae00-d1dea21d9a93.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dce4dcba-bf1e-494a-ae00-d1dea21d9a93.png)'
- en: 'The OllyDbg GUI window does look a lot like EDB-Debugger, though it is graphically
    a little uglier. We are looking at `notepad.exe`, which is a Windows-only editor,
    similar to a cut-down version of gedit. The window is broken up into the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDbg的GUI窗口看起来很像EDB-Debugger，尽管在图形上有点丑陋。我们正在查看`notepad.exe`，这是一个仅适用于Windows的编辑器，类似于gedit的简化版本。窗口分为以下部分：
- en: The application being tested in the title bar
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题栏中正在测试的应用程序
- en: Memory location
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存位置
- en: Symbol mapping
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号映射
- en: Commands
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Registers
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器
- en: 'Data dump: Memory locations and content'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转储：内存位置和内容
- en: Memory Stack data
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存堆栈数据
- en: 'When you open an executable file (EXE, PIF, or COM), it shows you the entire
    running program:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开一个可执行文件（EXE、PIF或COM）时，它会显示整个运行程序：
- en: '![](img/8f1acd3b-5b8e-456f-bdee-b5ee6df4fa63.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f1acd3b-5b8e-456f-bdee-b5ee6df4fa63.png)'
- en: You could choose to run OllyDbg on your target Windows machine, to look at an
    ongoing infection by copying its folder to a flash drive and carrying the flash
    drive over to the infected machine. You could also install Kali Linux to a bootable
    flash drive as we mentioned in [Chapter 1](b18fe074-058f-410f-86de-77499a727708.xhtml),
    *Choosing Your Distro*, and run Kali directly on the infected machine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择在目标Windows机器上运行OllyDbg，通过将其文件夹复制到闪存驱动器并将闪存驱动器携带到受感染的机器上来查看正在进行的感染。您还可以按照[第1章](b18fe074-058f-410f-86de-77499a727708.xhtml)中提到的内容，将Kali
    Linux安装到可引导的闪存驱动器上，并直接在受感染的机器上运行Kali。
- en: Introduction to disassemblers
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反汇编器简介
- en: A disassembler takes compiled binary code and displays the assembly code. This
    is similar to what the debuggers can show you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编器将编译的二进制代码显示为汇编代码。这与调试器可以显示的内容类似。
- en: Running JAD
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行JAD
- en: JAD is a Java Decompiler that's included with Kali Linux, and it seems like
    a useful tool for analyzing potentially dangerous Java applets that come from
    web pages. The biggest problem with it is that it has not had a maintainer since
    2011, and so is difficult to find, except in the Kali repository and at Tomas
    Varaneckas's blog page, *Jad Decompiler Download Mirror* ([http://varaneckas.com/jad/](http://varaneckas.com/jad/)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JAD是Kali Linux附带的Java反编译器，似乎是分析潜在危险的来自网页的Java小程序的有用工具。它最大的问题是自2011年以来就没有维护者了，因此很难找到，除非在Kali存储库和Tomas
    Varaneckas的博客页面*Jad Decompiler Download Mirror* ([http://varaneckas.com/jad/](http://varaneckas.com/jad/))中。
- en: 'The following is a page from the JAD help file, which you can access from the
    main menu or by typing `jad` in the command line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是JAD帮助文件中的一页，您可以从主菜单访问，或者通过在命令行中输入`jad`来访问：
- en: '![](img/567fb42e-0b7f-4c8b-809c-e5590f6e153d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/567fb42e-0b7f-4c8b-809c-e5590f6e153d.png)'
- en: For a short example of what it looks like to use `jad`, we created a Java class
    for you. The following three illustrations are of the following
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单地演示使用`jad`，我们为您创建了一个Java类。以下三个插图是以下内容的插图
- en: Original source code (not always available)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始源代码（不一定总是可用）
- en: Running `jad`
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`jad`
- en: Decompiled source
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反编译源代码
- en: 'So, here is the source code for a little Java class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里是一个小的Java类的源代码：
- en: '![](img/dfc15700-4027-497a-9286-25dc0c2f0949.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfc15700-4027-497a-9286-25dc0c2f0949.png)'
- en: 'The application is running. We showed the result of using the inline help (type
    a question mark instead of one of the letter choices) just to show the level of
    detail that''s available. We then chose `a`, and `jad` overwrote the source. This
    will not be a problem when you have only the compiled class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在运行。我们展示了使用内联帮助的结果（在字母选择中键入问号），只是为了展示可用的详细级别。然后我们选择了`a`，`jad`覆盖了源代码。当您只有编译后的类时，这不会是一个问题：
- en: '![](img/c44bb035-7c44-4db7-8979-3f9e37c34738.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c44bb035-7c44-4db7-8979-3f9e37c34738.png)'
- en: 'Finally, here is the decompiled source code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是反编译的源代码：
- en: '![](img/0dc44f26-9e68-4174-8de9-eb155d7f2ce9.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dc44f26-9e68-4174-8de9-eb155d7f2ce9.png)'
- en: Creating your own disassembling code with Capstone
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Capstone创建自己的反汇编代码
- en: 'The Capstone decompiling engine is well maintained, and has a simple API. The
    basic Capstone libraries come as default on Kali Linux, and you can build your
    own frontend using any language with which you are familiar. We are using Python,
    as it is our go-to scripting language. Using the `aptitude search <keyword>` command
    structure, you can make sure that you have the available packages and can see
    the status of the packages. In this case, you can see that `p` in the first column
    means that there is a package available, and `i` means that it is installed. The
    `A` in the second column shows that the package was installed automatically, and
    is probably a dependency for some other package. We have chosen to `install libcapstone-dev`
    for the 64-bit architecture we have on the Kali instance, in case we want to attempt
    to customize the behavior of Capstone. You don''t need to do this to use Capstone:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Capstone反编译引擎得到很好的维护，并且有一个简单的API。基本的Capstone库默认安装在Kali Linux上，您可以使用任何您熟悉的语言构建自己的前端。我们使用Python，因为它是我们首选的脚本语言。使用`aptitude
    search <keyword>`命令结构，您可以确保您有可用的软件包，并查看软件包的状态。在这种情况下，您可以看到第一列中的`p`表示有一个可用的软件包，`i`表示已安装。第二列中的`A`表示该软件包是自动安装的，可能是某个其他软件包的依赖。我们选择`install
    libcapstone-dev`，用于Kali实例上的64位架构，以防我们想尝试自定义Capstone的行为。您不需要这样做来使用Capstone：
- en: '![](img/18a2332d-611a-4d8a-b514-151fa6d53b49.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18a2332d-611a-4d8a-b514-151fa6d53b49.png)'
- en: 'Here is a simple disassembler script based on examples from [http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html).
    This could be far more automated, but for the sake of this example, the hexcode
    is hardcoded into the script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的反汇编脚本，基于[http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html)上的示例。这可以更加自动化，但为了这个例子，十六进制代码是硬编码到脚本中的：
- en: '![](img/0ea09aad-578b-452a-bb66-ca1bfe93bf07.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ea09aad-578b-452a-bb66-ca1bfe93bf07.png)'
- en: Some miscellaneous Reverse Engineering tools
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些其他的逆向工程工具
- en: There is a large category of miscellaneous Reverse Engineering tools, listed
    as such in the Kali Linux 1.x menu, but not categorized in the Kali Linux 2.0
    menu. Rather than randomly picking a couple of these, we are showing you an integrated
    suite of tools led by Radare2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有一大类其他的逆向工程工具，在Kali Linux 1.x菜单中列为此类，但在Kali Linux 2.0菜单中没有分类。我们不是随机选择其中的一些，而是向您展示了由Radare2领导的一套集成工具。
- en: Running Radare2
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Radare2
- en: 'You can start Radare2 by clicking the menu link under Reverse Engineering.
    You are probably more comfortable with the command line now, so you will probably
    want to open it directly in the command line. Open the command-line launcher by
    typing the keyboard shortcut, *Alt* + *F2*. Then, the following command opens
    the program''s help file in a new Terminal window:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击逆向工程下的菜单链接来启动Radare2。您现在可能更习惯于使用命令行，所以您可能想直接在命令行中打开它。通过键入键盘快捷键*Alt* +
    *F2*来打开命令行启动器。然后，以下命令在新的终端窗口中打开程序的帮助文件：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break this command down for you:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为您解释一下这个命令：
- en: '`bash` opens a Bash shell.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`打开一个Bash shell。'
- en: '`-c` directs dash to read from a command string, which follows in double quotes,
    instead of waiting for standard input from the keyboard.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`指示破折号从一个命令字符串中读取，该命令字符串在双引号中跟随，而不是等待键盘的标准输入。'
- en: '`radare2` is the application we are opening.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radare2`是我们正在打开的应用程序。'
- en: '`-h` is the option that opens a help file in the Terminal window, if one exists.
    `--help` is the long form of that option (these options are available on almost
    every Linux command-line tool).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`是打开终端窗口中的帮助文件的选项，如果存在的话。`--help`是该选项的长格式（这些选项几乎在每个Linux命令行工具上都可用）。'
- en: 'Radare2 is an advanced command-line hexadecimal editor, disassembler, and debugger.
    Radare2 ([http://radare.org](http://radare.org)) states that Radare2 is a portable
    reversing framework with the following features:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Radare2是一个高级的命令行十六进制编辑器、反汇编器和调试器。Radare2 ([http://radare.org](http://radare.org))表示Radare2是一个具有以下特点的可移植逆向框架：
- en: Disassembles (and assemble for) many different architectures
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对许多不同的架构进行反汇编（和汇编）
- en: Debugs with local native and remote debuggers (gdb, rap, webui, r2pipe, winedbg,
    and windbg)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地本机和远程调试器进行调试（gdb、rap、webui、r2pipe、winedbg和windbg）
- en: Runs on Linux, *BSD, Windows, OSX, Android, iOS, Solaris, and Haiku
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux、*BSD、Windows、OSX、Android、iOS、Solaris和Haiku上运行
- en: Performs forensics on filesystems and data carving
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件系统和数据进行取证和数据刻录
- en: Is scripted in Python, JavaScript, Go, and more
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python、JavaScript、Go等脚本编写
- en: Supports collaborative analysis using the embedded web server
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用嵌入式Web服务器进行协作分析
- en: Visualizes data structures of several file types
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化多种文件类型的数据结构
- en: Patches programs to uncover new features or fix vulnerabilities
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补程序以发现新功能或修复漏洞
- en: Uses powerful analysis capabilities to speed up reversing
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强大的分析能力加快逆向
- en: Aids in software exploitation
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助软件开发
- en: '![](img/63b6c01b-49ad-48cf-a871-5ecb87bcc76d.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63b6c01b-49ad-48cf-a871-5ecb87bcc76d.png)'
- en: 'Radare2 is the tip of a framework that is integrated with ten plugins and several
    other applications. To keep the PG rating, we fuzzed out the last plugin name:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Radare2是一个集成了十个插件和其他几个应用程序的框架的顶端。为了保持PG评级，我们模糊了最后一个插件的名称：
- en: '![](img/610b1ed6-59c0-4d28-8ca1-bcf5c48b2212.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/610b1ed6-59c0-4d28-8ca1-bcf5c48b2212.png)'
- en: The additional members of the Radare2 tool suite
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Radare2工具套件的其他成员
- en: We will discuss additional members of the Radare2 tool suite in the following
    sections.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分讨论Radare2工具套件的其他成员。
- en: Running rasm2
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rasm2
- en: 'rasm2 `/usr/bin/rasm2` is a command-line assembler/disassembler for several
    architectures, for example, Intel x86 and x86-64, MIPS, ARM, PowerPC, Java, and
    MSIL. This may be your go-to for disassembly when JAD is no longer available:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: rasm2 `/usr/bin/rasm2`是一个用于多种架构的命令行汇编器/反汇编器，例如Intel x86和x86-64、MIPS、ARM、PowerPC、Java和MSIL。当JAD不再可用时，这可能是你的反汇编工具：
- en: '![](img/1e81f6b2-70d4-496a-8af9-71e919d37614.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e81f6b2-70d4-496a-8af9-71e919d37614.png)'
- en: Running rahash2
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rahash2
- en: 'rahash2 `/usr/bin/rahash` is a block-based hash tool, which supports many algorithms,
    for example, MD4, MD5, CRC16, CRC32, SHA1, SHA256, SHA384, SHA512, par, xor, xorpair,
    mod255, hamdist, and entropy. You can use `rahash2` to check the integrity of,
    and track changes to, files, memory dumps, and disks:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: rahash2 `/usr/bin/rahash`是一个基于块的哈希工具，支持许多算法，例如MD4、MD5、CRC16、CRC32、SHA1、SHA256、SHA384、SHA512、par、xor、xorpair、mod255、hamdist和entropy。你可以使用`rahash2`来检查文件、内存转储和磁盘的完整性，并跟踪变化：
- en: '![](img/36e0dc00-57dc-44b5-a869-e3fda48c622e.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36e0dc00-57dc-44b5-a869-e3fda48c622e.png)'
- en: 'The following is an example of testing the sha256 hash for a small file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对小文件进行sha256哈希测试的示例：
- en: '![](img/68ab55b7-b278-4ab6-bab6-728074a41cd5.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68ab55b7-b278-4ab6-bab6-728074a41cd5.png)'
- en: Running radiff2
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行radiff2
- en: 'radiff2 is a binary utility that uses various algorithms to compare files.
    It supports byte-level or delta comparisons for binary files, and code analysis
    comparisons to find changes in code blocks produced by a `radare` code analysis.
    The following is a test that''s comparing two states of the `/var/log/message`
    log over the course of a couple of seconds. This is a comparison at the bit level,
    for random changes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: radiff2是一个使用各种算法比较文件的二进制实用程序。它支持二进制文件的字节级或增量比较，以及代码分析比较，以找到`radare`代码分析产生的代码块中的变化。以下是一个比较`/var/log/message`日志在几秒钟内的两个状态的测试。这是一个在位级别进行比较的测试，用于随机更改：
- en: '![](img/8c64b9c4-412b-4e9b-8d44-4ff73b16ebc2.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c64b9c4-412b-4e9b-8d44-4ff73b16ebc2.png)'
- en: Running rafind2
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rafind2
- en: 'rafind2 is designed to search for patterns in files. In the following example,
    `rafind2 -s "string searched" <file>` shows you what we can see when we search
    for a string that we know to exist, and one we know to be absent:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: rafind2旨在在文件中搜索模式。在下面的示例中，`rafind2 -s "string searched" <file>`向我们展示了当我们搜索一个我们知道存在的字符串和一个我们知道不存在的字符串时，我们能看到什么：
- en: '![](img/48233c42-8587-4854-81d2-93ba7cb3c44e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48233c42-8587-4854-81d2-93ba7cb3c44e.png)'
- en: Running rax2
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rax2
- en: 'rax2 is a mathematical expression evaluator for the command line. You can do
    many conversion operations, including one that is useful for making base conversions
    between floating point values, hexadecimal representations, hex-pair strings to
    ASCII, octal to integer, and so on. It also supports endianness settings and can
    be used as an interactive shell if no arguments are given:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: rax2是一个命令行的数学表达式求值器。你可以进行许多转换操作，包括对浮点值、十六进制表示、十六进制对字符串到ASCII的基数转换等等。它还支持字节序设置，如果没有给出参数，可以用作交互式shell：
- en: '![](img/c7cd4858-5ad6-43cc-b5ca-d02cb126cab7.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7cd4858-5ad6-43cc-b5ca-d02cb126cab7.png)'
- en: 'Here are some example conversions with rax2:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是rax2的一些示例转换：
- en: Decimal to hexadecimal
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制转十六进制
- en: Hexadecimal to decimal
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制转十进制
- en: Octal to hexadecimal
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制转十六进制
- en: Hashing two strings
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对两个字符串进行哈希
- en: Hashing a single string
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对单个字符串进行哈希
- en: '![](img/c6307c77-db85-484f-a975-a99077185542.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6307c77-db85-484f-a975-a99077185542.png)'
- en: Stress testing Windows
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试Windows
- en: Next, let's look at some tools that will make your Windows machine cry. Stress
    testing a system can show you just how much of a load your machine and network
    will carry. Here's a little experiment you can also run. Set up a service on a
    Windows machine and the same type of service on a Linux machine and see which
    can handle the loads better. You will be surprised with the outcome. The outcome
    may make you ask *why would I ever use Windows in the first place?*
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一些会让你的Windows机器哭泣的工具。对系统进行压力测试可以显示出你的机器和网络能承受多大负荷。你也可以进行一个小实验。在Windows机器上设置一个服务，在Linux机器上设置相同类型的服务，看看哪个能更好地处理负载。结果可能会让你感到惊讶。结果可能会让你问*为什么我要使用Windows？*
- en: '**Hacker''s tip**:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客提示**：'
- en: Use Linux as your daily driver OS—I do!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将Linux作为你的日常驱动操作系统——我就是！
- en: Dealing with Denial
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理拒绝
- en: '**ATK6-Denial6** is an IPv6 network stress tester that sends packets to a target
    host and beats them into submission. This is the help file for ATK6-Denial6:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**ATK6-Denial6**是一个IPv6网络压力测试工具，它向目标主机发送数据包并将其击败。这是ATK6-Denial6的帮助文件：'
- en: '![](img/6ec7068c-d795-4824-9180-9f6b7bb96736.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ec7068c-d795-4824-9180-9f6b7bb96736.png)'
- en: 'The following screenshot is the `nmap -A` reading for the vulnerable Windows
    7 target machine. We want to find out if it has ports open, and which ports they
    are. We can see that ports `139`, `445`, `2869`, `5357`, and `10243` are open.
    The big problem with this tool is that the test network is IPv4:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是对易受攻击的Windows 7目标机器进行的`nmap -A`读取。我们想要找出它是否有开放的端口，以及它们是哪些端口。我们可以看到端口`139`、`445`、`2869`、`5357`和`10243`是开放的。这个工具的一个大问题是测试网络是IPv4：
- en: '![](img/290e14d3-7991-42ad-b379-31dbb5d56cdf.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/290e14d3-7991-42ad-b379-31dbb5d56cdf.png)'
- en: Let's find a tool with which we can attack our IPv4 network.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找一个可以攻击我们的IPv4网络的工具。
- en: Putting the network under Siege
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让网络陷入围攻
- en: Siege is a web stress tester. Siege is a multi-threaded HTTP load testing and
    benchmarking utility. It was designed to let web developers measure the performance
    of their code under pressure. It allows you to hit a web server with a configurable
    number of concurrent simulated users.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Siege是一个Web压力测试工具。Siege是一个多线程的HTTP负载测试和基准测试实用程序。它旨在让Web开发人员在压力下测量其代码的性能。它允许您使用可配置数量的并发模拟用户访问Web服务器。
- en: 'It is those users who place the web server *under siege*. Performance measures
    include the following, which are quantified and reported at the end of each run:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这些用户将Web服务器置于*围攻*之下。性能指标包括以下内容，每次运行结束时都会进行量化和报告：
- en: Elapsed time
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过的时间
- en: Total data transferred
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总传输数据
- en: Server response time
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器响应时间
- en: Transaction rate
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务率
- en: Throughput
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量
- en: Concurrency
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: OK return count
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OK返回计数
- en: 'Their meaning and significance are discussed later. Siege essentially has three
    modes of operation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的含义和重要性稍后会讨论。围攻基本上有三种操作模式：
- en: Regression (when invoked by bombardment)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归（在被轰炸时调用）
- en: Internet simulation
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟互联网
- en: Brute force
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛮力
- en: 'The formats for using siege are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用siege的格式如下：
- en: '`siege [options]`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`siege [options]`'
- en: '`siege [options] [url]`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`siege [options] [url]`'
- en: '`siege -g [url]`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`siege -g [url]`'
- en: '![](img/c7a27efd-88fe-4af4-8294-524938eca229.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7a27efd-88fe-4af4-8294-524938eca229.png)'
- en: Siege imitated 15 users going to the website on the Windows 7 target machine.
    The performance was not all that bad, all in all. There were 8,072 hits on the
    site in four and a half minutes. The Windows 7 target maintained 100% availability
    with better than 1/100th of a second response time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 围攻模拟了15个用户访问Windows 7目标机器上的网站。总体性能并不算太差。在四分半钟内，网站有8072次点击。Windows 7目标机器保持100%的可用性，响应时间低于1/100秒。
- en: Configuring your Siege engine
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的围攻引擎
- en: 'What do you think would happen if we increase the number of besiegers to 10,000?
    The configuration is `at /usr/bin/siege.config`. When we run that on the command
    line, it tells us we already have a local configuration file at `/root/siegerc`,
    so let''s go look at that:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将围攻者的数量增加到10,000，你认为会发生什么？配置文件在`/usr/bin/siege.config`。当我们在命令行上运行时，它告诉我们我们已经有一个本地配置文件在`/root/siegerc`，所以让我们去看看：
- en: '![](img/9ec4021f-e519-44c5-bd87-bc4b7ab93227.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ec4021f-e519-44c5-bd87-bc4b7ab93227.png)'
- en: To edit `/root/.siegerc`, we can use the command line or the Run Launcher (*Alt*
    + *F2*) to enter the name of our favorite text editor. Here, we are going to use
    gedit, so enter gedit `/root/.siegerc` . Alternatively, we could find gedit in
    the `Usual Applications`/`Accessories` folder, and open the file open dialog and
    turn on hidden files, then find `.siegerc` in the `/root` directory. You are probably
    starting to see the reason Linux administrators like the command line so much.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑`/root/.siegerc`，我们可以使用命令行或运行启动器（*Alt* + *F2*）输入我们喜欢的文本编辑器的名称。在这里，我们将使用gedit，所以输入gedit
    `/root/.siegerc`。或者，我们可以在`Usual Applications`/`Accessories`文件夹中找到gedit，打开文件对话框并打开隐藏文件，然后在`/root`目录中找到`.siegerc`。你可能已经开始明白为什么Linux管理员如此喜欢命令行了。
- en: 'On line `162` of the configuration file, you will find the number of concurrent
    users. The current default is `15`, but let''s change that to 10,000\. Let''s
    see if we can crack this baby:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件的第162行，您会找到并发用户的数量。当前默认值为`15`，但让我们将其更改为10,000。让我们看看我们能否破解这个：
- en: '![](img/df072eea-fec9-4844-b93f-619d19719d7e.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df072eea-fec9-4844-b93f-619d19719d7e.png)'
- en: 'After forcing the Kali instance to close, let''s try it with fewer besiegers.
    The larger the number of concurrent users, the more RAM it uses on your Kali machine,
    too:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在强制关闭Kali实例后，让我们尝试使用更少的围攻者。并发用户数量越多，它在您的Kali机器上使用的RAM也就越多：
- en: '![](img/f8b800dd-f2d4-40c8-b47f-f1c4c8560daa.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8b800dd-f2d4-40c8-b47f-f1c4c8560daa.png)'
- en: Using 625 besiegers, we got a solid result without crashing the testing machine.
    In-between, we tested 5,000, 2,500, and 1,250, but they all crashed the machine.
    If you have a sense of fun, you could test higher numbers, such as 940, 1,090,
    and so on. The resources available on your testing machine will rule the number
    of besiegers you can employ.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用625个围攻者，我们得到了一个稳定的结果，而没有使测试机器崩溃。期间，我们测试了5,000、2,500和1,250，但它们都使机器崩溃了。如果您有一点乐趣，您可以测试更高的数字，比如940、1,090等。您可以使用测试机器上的资源来决定您可以使用的围攻者数量。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Reverse Engineering to get a definitive answer as to the actual code for a complicated
    application is unlikely, since there are many ways to achieve the same output
    via loops or choice structures. It is easier to get a statistical list of possible
    treatments of the inputs by testing several of them. You are likely to get more
    detail from looking at the assembly code outputs from **EDB-Debugger** or **OllyDbg**.
    As you have probably noticed, the assembly code for Linux and for Windows applications
    is basically identical. High-level languages such as C and C++ are just ways to
    get at the assembly code that can be easily converted to machine code to tell
    the machine what to do.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程以获得复杂应用的实际代码的明确答案是不太可能的，因为有许多通过循环或选择结构实现相同输出的方法。通过测试其中几种可能的输入处理方法，更容易获得统计列表。您可能会从查看**EDB-Debugger**或**OllyDbg**的汇编代码输出中获得更多细节。您可能已经注意到，Linux和Windows应用程序的汇编代码基本上是相同的。高级语言如C和C++只是访问汇编代码的方式，可以轻松转换为机器代码，告诉机器该做什么。
- en: Stress testing your Windows hosts comes down to checking their ability to take
    in many inputs over a short period of time, on any open ports whatsoever. Remember,
    when stress testing, you will make a lot of noise on the network, and any intrusion
    detection tool, configured properly, will notice your attack. You may also knock
    the target machine off the network, so you had better alert the management before
    you start your test.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对Windows主机进行压力测试归结为检查它们在任何开放端口上在短时间内接收许多输入的能力。请记住，在进行压力测试时，您将在网络上制造很多噪音，任何正确配置的入侵检测工具都会注意到您的攻击。您还可能使目标机器脱离网络，因此在开始测试之前最好通知管理层。
- en: As this is the last chapter, we hope that you have enjoyed this book and we
    hope that you have learned something to better your understanding of penetration
    testing and exploitation of the Windows operating system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最后一章，我们希望您喜欢这本书，也希望您学到了一些东西，以便更好地理解渗透测试和对Windows操作系统的利用。
- en: Thank you for reading this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读本书。
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**More reading on the Radare2 Tool Suite**: [https://rada.re/r/](https://rada.re/r/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关Radare2工具套件的更多阅读**：[https://rada.re/r/](https://rada.re/r/)'
- en: '**Radare2 Cheatsheets**: [https://github.com/pwntester/cheatsheets/blob/master/radare2.md](https://github.com/pwntester/cheatsheets/blob/master/radare2.md)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Radare2备忘单**：[https://github.com/pwntester/cheatsheets/blob/master/radare2.md](https://github.com/pwntester/cheatsheets/blob/master/radare2.md)'
- en: '**More on EDB-Debugger**: [https://github.com/eteran/edb-debugger](https://github.com/eteran/edb-debugger)
    and [http://codef00.com/projects](http://codef00.com/projects)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关EDB-Debugger的更多信息**：[https://github.com/eteran/edb-debugger](https://github.com/eteran/edb-debugger)
    和 [http://codef00.com/projects](http://codef00.com/projects)'
- en: '**More on OllyDbg**: [http://www.ollydbg.de/](http://www.ollydbg.de/)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关OllyDbg的更多信息**：[http://www.ollydbg.de/](http://www.ollydbg.de/)'
- en: '**More on Capstone**: [http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关Capstone的更多信息**：[http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html)'
