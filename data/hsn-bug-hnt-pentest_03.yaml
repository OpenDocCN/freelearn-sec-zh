- en: Preparing for an Engagement
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备进行渗透测试
- en: When you've narrowed down your search to the application you'd like to test,
    it's time to start collecting information. Getting a full sitemap, unmasking hidden
    content, and discovering artifacts left over from development (commented-out code,
    inline documentation, and so on) can help your narrow your focus to fertile areas.
    And by understanding what information you'll need for your vulnerability report,
    you can ensure you're collecting everything you need for when it's time to submit,
    right from the start.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将搜索范围缩小到想要测试的应用程序时，就可以开始收集信息了。获取完整的站点地图、揭示隐藏内容并发现开发过程中遗留的工件（注释掉的代码、内联文档等）可以帮助你将焦点集中到有价值的领域。通过了解报告漏洞所需的信息，你可以确保从一开始就收集到所有需要的内容，方便最终提交。
- en: This chapter discusses techniques to map your target application's attack surface,
    search the site for hidden directories and leftover (but accessible) services,
    make informed decisions about what tools to use in a pentesting session, and document
    your sessions for your eventual report.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了映射目标应用程序的攻击面、在站点上搜索隐藏目录和剩余（但可访问）服务、根据渗透测试会话中的工具选择做出明智决策，以及为最终报告记录会话的技巧。
- en: 'We''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding your target application's points of interest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解目标应用程序的关注点
- en: Setting up and using Burp Suite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用 Burp Suite
- en: Where to find open source lists of XSS snippets, SQLi payloads, and other code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找 XSS 代码片段、SQLi Payload 和其他代码的开源列表
- en: Gathering DNS and other network information about your target
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集目标的 DNS 和其他网络信息
- en: Creating a stable of small, versatile scripts for information-gathering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一系列小巧、灵活的信息收集脚本
- en: Checking for known component vulnerabilities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查已知组件的漏洞
- en: Technical Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter, like many, will rely on a `unix` command shell (`zsh`) to bootstrap
    and interact with programs installed via their graphical installer, a package
    manager (`homebrew`), or a tarball. It will also include several desktop apps,
    all of which we'll install, via similar methods, into a macOS High Sierra (`10.13.2`)
    environment. When a web browser is required, we will use Chrome (`66.0.3359.139`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与许多其他章节一样，将依赖于 `unix` 命令行 shell（`zsh`）来引导并与通过图形安装程序、包管理器（`homebrew`）或 tarball
    安装的程序进行交互。它还将包括几个桌面应用程序，我们将通过类似的方法安装它们到 macOS High Sierra（`10.13.2`）环境中。当需要使用网页浏览器时，我们将使用
    Chrome（`66.0.3359.139`）。
- en: For some of these, there will be an explicit Windows option. In that case, the
    menus may look different but the available actions will be the same. When no Windows
    option is available, you might have to dual-boot with one of the more user-friendly
    Linux distros.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中一些，会有明确的 Windows 选项。在这种情况下，菜单可能看起来不同，但可用的操作是相同的。如果没有 Windows 选项，可能需要通过双系统启动更易用的
    Linux 发行版之一。
- en: Tools
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: 'We''ll be using a variety of tools this chapter, some of which we''ll be coming
    back to throughout the book:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用多种工具，其中一些将在本书中多次使用：
- en: '`wfuzz`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wfuzz`'
- en: '`scrapy`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrapy`'
- en: '`striker`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`striker`'
- en: Burp Suite
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burp Suite
- en: Homebrew (package manager)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homebrew（包管理器）
- en: SecLists
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SecLists
- en: '`virtualenv`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualenv`'
- en: '`jenv`(Java version manager)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jenv`（Java 版本管理器）'
- en: '**Java Development Kit** (**JDK**)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包**（**JDK**）'
- en: '**Java Runtime Environment** (**JRE**) 1.6 or greater'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 运行环境**（**JRE**）1.6 或更高版本'
- en: '`wfuzz` is a fuzzer and discovery tool built by pentesters for pentesters.
    To install it, simply use `pip`: `pip install wfuzz`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`wfuzz` 是一款由渗透测试员为渗透测试员开发的模糊测试和发现工具。要安装它，只需使用 `pip`：`pip install wfuzz`。'
- en: Homebrew is an excellent package manager for macOS that allows you to install
    dependencies from the command line, much like you would with `apt-get` in Debian
    or `yum` in Redhat-flavored Linux distributions. Homebrew is easily installed
    via its website ([https://brew.sh/](https://brew.sh/)), then packages can be installed
    simply via `brew install <PACKAGE_NAME>`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 是一个出色的 macOS 包管理器，它允许你通过命令行安装依赖项，就像在 Debian 中使用 `apt-get` 或在 Redhat
    风味的 Linux 发行版中使用 `yum` 一样。Homebrew 可以通过其官网轻松安装（[https://brew.sh/](https://brew.sh/)），然后可以通过
    `brew install <PACKAGE_NAME>` 安装软件包。
- en: Burp Suite requires a JRE (version 1.6 or greater), but we'll also need the
    JDK to use the `java` command line tool to bootstrap Burp Suite from the command
    line. Running Burp from the command line lets us pass in settings via arguments
    that give us more control over the execution environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite需要一个JRE（1.6或更高版本），但我们还需要JDK来使用`java`命令行工具从命令行引导Burp Suite。从命令行运行Burp允许我们通过参数传递设置，从而更好地控制执行环境。
- en: 'Please install Burp Suite by following the directions on Portswigger''s website:
    [https://portswigger.net/burp/help/suite_gettingstarted](https://portswigger.net/burp/help/suite_gettingstarted).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照Portswigger网站上的说明安装Burp Suite：[https://portswigger.net/burp/help/suite_gettingstarted](https://portswigger.net/burp/help/suite_gettingstarted)。
- en: To use Burp Suite, you need to run a legacy version of Java. If you try to start
    Burp from its CLI with Java 10.0.0 or later, you'll receive a message to the effect
    that Burp has not been tested on this version and is susceptible to errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Burp Suite，你需要运行一个旧版本的Java。如果你尝试使用Java 10.0.0或更高版本从CLI启动Burp，你将收到一条消息，说明Burp尚未在此版本上进行测试，可能会出现错误。
- en: If you just need Java for Burp, you can install an older version—we'll be using
    Java `1.8.0` (Java 8)—and use that system-wide. But if you need a more up-to-date
    Java installation for other programs, you can still run legacy Java by using the
    `jenv` command-line utility that allows you to switch between versions. `jenv`
    is similar to the Ruby version manager `rvm` or the Node version manager `nvm`,
    they all allow you add, list, and switch between versions of the language with
    just a few commands.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要为Burp安装Java，你可以安装一个旧版本——我们将使用Java `1.8.0`（Java 8）——并在整个系统中使用。但是，如果你需要一个更新版本的Java安装来运行其他程序，你仍然可以通过使用`jenv`命令行实用程序来运行旧版本的Java。`jenv`类似于Ruby版本管理器`rvm`或Node版本管理器`nvm`，它们都允许你通过几个命令添加、列出和在不同版本之间切换语言版本。
- en: 'Please install `jenv` from its website: [http://www.jenv.be/](http://www.jenv.be/).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请从其网站安装`jenv`：[http://www.jenv.be/](http://www.jenv.be/)。
- en: 'After you''ve installed `jenv`, you can add a new Java version to it simply
    by using the path to its `/Home` directory. Then we''ll set our system to use
    it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`jenv`之后，你可以通过使用其`/Home`目录的路径简单地向其添加一个新的Java版本。然后我们将设置我们的系统使用它：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You might have to restart your Terminal. But you should have Java 8 installed!
    Check it''s Java 8 with `java -version`. You should see this output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要重新启动你的终端。但是你应该已经安装了Java 8！用`java -version`检查一下是否是Java 8。你应该看到这个输出：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using Burp
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp
- en: 'Now let''s start Burp – the `4G` part of the command is where we''re specifying
    Burp Suite should run on 4 GB memory:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动Burp - 命令中的`4G`部分是我们指定Burp Suite应该在4 GB内存上运行的地方：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since this is a mouthful, we can create a small wrapper script that will use
    the `$@` variable to add any options we may want to pass, without making us rewrite
    our path to the `.jar` executable. Here''s `bootstrap_burp.sh`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个命令太长了，我们可以创建一个小的包装脚本，使用`$@`变量来添加我们想要传递的任何选项，而不用重写我们的路径到`.jar`可执行文件。这里是`bootstrap_burp.sh`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you can make the file executable and symlink it to `/usr/local/bin` or
    the appropriate utility so it''s available in your `$PATH`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将文件设置为可执行，并将其符号链接到`/usr/local/bin`或适当的实用程序，这样它就可以在你的`$PATH`中使用：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This allows us to start the program with just `bootstrap_burp`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以只用`bootstrap_burp`来启动程序。
- en: Attack Surface Reconnaisance – Strategies and the Value of Standardization
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击面侦察 - 策略和标准化的价值
- en: The Attack Surface of an application is, put succinctly, wherever data can enter
    or exit the app. Attack-surface analysis describes the methods used to describe
    the vulnerable parts of an application. There are formal processes, such as the  **Relative
    Attack Surface Quotient** (**RASQ**) developed by Michael Howard and other researchers
    at Microsoft that counts a system's attack opportunities and indicates an app's
    general attackability. There are programmatic means available through scanners
    and manual methods, involving navigating a site directly, documenting weak points
    via screenshots and other notes. We'll talk about low- and high-tech methods you
    can use to focus your attention on profitable lines of attack, in addition to
    methods you can use to find hidden or leftover content not listed on the sitemap.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的攻击面，简言之，就是数据可以进入或退出应用程序的地方。攻击面分析描述了用于描述应用程序易受攻击部分的方法。有正式的过程，比如由微软的Michael
    Howard和其他研究人员开发的**相对攻击面指数**（**RASQ**），它计算系统的攻击机会并指示应用程序的一般易受攻击性。还有通过扫描仪和手动方法可用的程序化手段，直接浏览网站，通过截图和其他笔记记录弱点。我们将讨论您可以使用的低技术和高技术方法，以便将注意力集中在有利可图的攻击线上，以及您可以使用的方法来查找网站地图上未列出的隐藏或剩余内容。
- en: Sitemaps
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网站地图
- en: Sitemaps are an absurdly simple way of doing basic research with zero effort.
    Doing a little URL hacking with the `sitemap.xml` slug will often return either
    an actual XML file detailing the site's structure, or a Yoast-or-other-seo-plugin-supplied
    HTML page documenting different areas of the site, with separate sitemaps for
    posts, pages, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 网站地图是一种极其简单的方式进行基础研究，零努力。通过使用`sitemap.xml`标识进行一些URL黑客攻击，通常会返回一个详细描述网站结构的实际XML文件，或者是一个Yoast或其他SEO插件提供的HTML页面，记录了网站的不同区域，包括文章、页面等的单独网站地图。
- en: 'The following is an example of a Yoast-generated sitemap page:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由Yoast生成的网站地图页面示例：
- en: '![](assets/5fe190f8-d9b7-4db7-b2f4-083af5cd0c23.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5fe190f8-d9b7-4db7-b2f4-083af5cd0c23.png)'
- en: 'It helpfully exposes the high-level structure of the site while allowing you
    to focus on important points. Some areas can be skipped: the `post-sitemap1.xml`
    and `post-sitemap2.xml` sections, listing the links to every blog post on the
    site, aren''t useful because every blog post will more or less have the same points
    of attack (comments, like/dislike buttons, and social sharing).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于揭示网站的高层结构，同时让您专注于重要点。有些区域可以跳过：列出网站上每篇博客文章的链接的`post-sitemap1.xml`和`post-sitemap2.xml`部分并不有用，因为每篇博客文章或多或少都会有相同的攻击点（评论、喜欢/不喜欢按钮和社交分享）。
- en: 'While `wp_quiz-sitemap.xml` hints at a tantalizing set of form fields, along
    with telling us the site is a WordPress application if we didn''t already know,
    the `page-sitemap.xml` will give us a broader swath of site functionality:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`wp_quiz-sitemap.xml`暗示了一组诱人的表单字段，同时告诉我们网站是一个WordPress应用程序（如果我们之前不知道的话），`page-sitemap.xml`将为我们提供更广泛的网站功能：
- en: '![](assets/ba9a32c4-62dc-4933-9963-b864c49d4a74.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba9a32c4-62dc-4933-9963-b864c49d4a74.png)'
- en: Here, too, there are candidates for immediate follow-up and dismissal. Purely
    informational pages such as `/privacy-policy`, `/method/rule-two`, and `/pricing-guarantee`,
    are simple markup, with no opportunity to interact with the server or an external
    service. Pages such as `/contact-us`, `/book-preorder-entry-form` (the form's
    in the title!), and `/referral` (which might have a form for submitting them)
    are all worth a follow-up. `/jobs`, which could have a resume-submission field
    or could be just job listings, is a gray area. Some pages will simply need to
    be perused.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，也有可以立即跟进和放弃的候选项。纯粹信息性的页面，如`/privacy-policy`、`/method/rule-two`和`/pricing-guarantee`，是简单的标记，没有与服务器或外部服务交互的机会。像`/contact-us`、`/book-preorder-entry-form`（表单在标题中！）和`/referral`（可能有一个提交表单的表单）这样的页面都值得跟进。`/jobs`可能有一个简历提交字段，也可能只是工作列表，是一个灰色区域。有些页面只需浏览一下。
- en: Sitemaps aren't always available – and they're always limited to what the site
    wants to show you – but they can be useful starting points for further investigation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网站地图并非总是可用的 - 它们总是受限于网站想要向您展示的内容 - 但它们可以作为进一步调查的有用起点。
- en: Scanning and Target Reconaissance
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描和目标侦察
- en: Automated information-gathering is a great way to get consistent, easy-to-understand
    information about site layout, attack surface, and security posture.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自动信息收集是获得关于网站布局、攻击面和安全状况的一种一致、易于理解的信息的好方法。
- en: Brute-forcing Web Content
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制获取网页内容
- en: Fuzzing tools such as `wfuzz` can be used to discover web content by trying
    different paths, with URIs taken from giant wordlists, then analyzing the HTTP
    status codes of the responses to discover hidden directories and files. `wfuzz`
    is versatile and can do both content-discovery and form-manipulation. It's easy
    to get started with, and because `wfuzz` supports plugins, recipes, and other
    advanced features, it can be extended and customized into other workflows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 像`wfuzz`这样的模糊工具可以通过尝试不同的路径，使用来自巨大的词汇表的URI，然后分析响应的HTTP状态码，发现隐藏的目录和文件。`wfuzz`功能强大，可以进行内容发现和表单操作。它易于上手，并且由于`wfuzz`支持插件、配方和其他高级功能，可以扩展并自定义为其他工作流程。
- en: 'The quality of the wordlists you''re using to brute-force-discover hidden content
    is important. After installing `wfuzz`, clone the SecLists GitHub repository (a
    curated collection of fuzz lists, SQLi injection scripts, XSS snippets, and other
    generally malicious input) at [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists).
    We can start a scan of the target site simply be replacing the part of the URL
    we''d like to replace with the wordlist with the `FUZZ` string:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你用来暴力破解发现隐藏内容的词汇表质量非常重要。安装`wfuzz`后，克隆SecLists GitHub仓库（一个整理过的模糊列表集合，包括SQLi注入脚本、XSS片段和其他通常是恶意的输入）到[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)。我们只需将想要替换为词汇表部分的URL用`FUZZ`字符串替换，就能启动目标站点的扫描：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can tell from the command, we passed in the web-content discovery list
    from SVNDigger with the `-w` flag, `-hc` tells the scan to ignore 404 status codes
    (hide code), and then the final argument is the URL we want to target:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从命令中看到的，我们传入了来自SVNDigger的Web内容发现列表，使用`-w`标志，`-hc`指示扫描忽略404状态码（隐藏代码），最后一个参数是我们想要扫描的目标URL：
- en: '![](assets/b3390347-3cd8-480d-94d7-4cb1082f1e42.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b3390347-3cd8-480d-94d7-4cb1082f1e42.png)'
- en: You can see some interesting points to explore. While the effectiveness of brute-force
    tools is dictated by their wordlists, you can find effective jumping-off points
    as long as you do your research.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一些有趣的探索点。虽然暴力破解工具的有效性取决于它们的词汇表，但只要你做足了研究，还是能找到有效的切入点。
- en: Keep in mind that brute-forcers are very noisy. Only use them against isolated
    staging/QA environments, and only with permission. If your brute-forcer overwhelms
    a production server, it's really no different from a DoS attack.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，暴力破解工具非常嘈杂。只应在隔离的预发布/QA环境中使用，且必须获得许可。如果你的暴力破解工具压垮了生产服务器，这实际上与DoS攻击没有什么不同。
- en: Spidering and Other Data-Collection Techniques
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬虫与其他数据收集技术
- en: Parallel to brute-forcing for sensitive assets, spidering can help you get a
    picture of a site that, without a sitemap, just brute-forcing itself can't provide.
    That link base can also be shared with other tools, pruned of any out-of-scope
    or irrelevant entries, and subjected to more in-depth analysis. There are a couple
    of useful spiders, each with its own advantages. The first one we'll cover, Burp's
    native spider functionality, is obviously a contender because it's part of (and
    integrates with) a tool that's probably already part of your toolset.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与暴力破解敏感资源并行，爬虫可以帮助你获取没有网站地图的站点的整体信息，而单靠暴力破解无法提供。这些链接基础也可以与其他工具共享，剔除任何超出范围或无关的条目，并进行更深入的分析。有几个有用的爬虫工具，每个工具都有其自身的优点。我们将介绍的第一个是Burp自带的爬虫功能，显然它是一个有力的竞争者，因为它是（并与）你工具集中的一个工具集成在一起。
- en: Burp Spider
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Burp Spider
- en: 'To kick-off a spidering session, make sure you have the appropriate domains
    in scope:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开始爬虫会话时，确保你已经确定了适当的目标域名：
- en: '![](assets/6bdea000-cc41-4ad8-8e62-c88df3a23401.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bdea000-cc41-4ad8-8e62-c88df3a23401.png)'
- en: 'You can then right-click the target domain and select Spider this host:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以右键点击目标域名并选择“蜘蛛抓取此主机”：
- en: '![](assets/00ba4914-e8cf-4037-93d7-5a90a3b664de.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00ba4914-e8cf-4037-93d7-5a90a3b664de.png)'
- en: Striker
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Striker
- en: Striker ([https://github.com/s0md3v/Striker](https://github.com/s0md3v/Striker))
    is a Python-offensive information and vulnerability scanner that does a number
    of checks using different sources, but has a particular focus on DNS and network
    information. You can install it by following the instructions on its Github page.
    Like many Python projects, it simply requires cloning the code and downloading
    the dependencies listed in `requirements.txt`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Striker ([https://github.com/s0md3v/Striker](https://github.com/s0md3v/Striker))
    是一个 Python 攻击性信息和漏洞扫描器，使用不同的资源进行多项检查，特别关注 DNS 和网络信息。你可以通过访问其 Github 页面上的说明进行安装。像许多
    Python 项目一样，它只需要克隆代码并下载 `requirements.txt` 中列出的依赖项。
- en: 'Striker provides useful, bedrock network identification and scanning capabilities:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Striker 提供了有用的基础网络识别和扫描功能：
- en: Fingerprinting the target web server
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指纹识别目标 web 服务器
- en: Detecting CMS (197+ supported)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测 CMS（支持 197 种以上）
- en: Scanning target ports
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描目标端口
- en: Looking up `whois` information
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找 `whois` 信息
- en: 'It also provides a grab-bag of other functionality, such as launching WPScan
    for WordPress instances or bypassing Cloudflare:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一些其他功能，比如为 WordPress 实例启动 WPScan 或绕过 Cloudflare：
- en: '![](assets/3ee7f15d-7702-46da-8803-c5c6a7258804.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ee7f15d-7702-46da-8803-c5c6a7258804.png)'
- en: Scrapy and Custom Pipelines
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scrapy 和自定义管道
- en: '`scrapy` is a popular web-crawling framework for Python that allows you to
    create web crawlers out of the box. It''s a powerful general-purpose tool that,
    since it allows a lot of customization, has naturally found its way into professional
    security workflows. Projects such as XSScrapy, an XSS and SQLi scanning tool built
    on Scrapy, show the underlying base code''s adaptability. Unlike the Burp Suite
    Spider, whose virtue is that it integrates easily with other Burp tools, and Striker,
    whose value comes in collecting DNS and networking info from its default configuration,
    Scrapy''s appeal is that it can be set up easily and then customized to create
    any kind of data pipeline.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrapy` 是一个流行的 Python 网络爬虫框架，可以让你轻松创建爬虫。它是一个功能强大的通用工具，由于其高度可定制性，已经自然地融入了专业安全工作流。像
    XSScrapy 这样的项目，基于 Scrapy 构建的 XSS 和 SQLi 扫描工具，展示了底层代码的适应性。与 Burp Suite Spider（它的优点在于可以轻松与其他
    Burp 工具集成）以及 Striker（其价值在于通过默认配置收集 DNS 和网络信息）不同，Scrapy 的吸引力在于它可以轻松设置并进行定制，创建任何类型的数据管道。'
- en: Manual Walkthroughs
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动操作演练
- en: If the app doesn't have a sitemap, and you don't want to use a scanner, you
    can still create a layout of the site's structure by navigating through it, without
    having to take notes or screenshots. Burp allows you to link your browser to the
    application's proxy, where it will then keep a record of all the pages you visit
    as you step through the site. As you map the site's attack surface, you can add
    or remove pages from the scope to ensure you control what gets investigated with
    automated workflows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用没有网站地图，而你又不想使用扫描器，你仍然可以通过浏览网站的方式创建网站结构的布局，无需做笔记或截图。Burp 允许你将浏览器与应用的代理链接，然后它会记录你访问的所有页面，帮助你在浏览网站时进行记录。当你绘制网站的攻击面时，你可以通过自动化工作流添加或删除页面，确保你控制哪些内容被调查。
- en: Doing this manual-with-an-assist method can actually be preferable to using
    an automated scanner. Besides being less noisy and less damaging to target servers,
    the manual method lets you tightly control what gets considered in-scope and investigated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种手动辅助的方法实际上可能比使用自动扫描器更为优选。除了噪音更少、对目标服务器的影响更小外，手动方法还允许你精确控制哪些内容被视为范围内并进行调查。
- en: First, connect your browser to the Burp proxy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将你的浏览器连接到 Burp 代理。
- en: 'Portswigger provides support articles to help you. If you''re using Chrome,
    you can follow along with me here. Even though we''re using Chrome, we''re going
    to use the Burp support article for Safari because the setting in question is
    in your Mac settings: [https://support.portswigger.net/customer/portal/articles/1783070-Installing_Configuring%20your%20Browser%20-%20Safari.html](https://support.portswigger.net/customer/portal/articles/1783070-Installing_Configuring%20your%20Browser%20-%20Safari.html).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Portswigger 提供支持文章帮助你。如果你使用的是 Chrome，可以跟着我一起操作。尽管我们使用的是 Chrome，但我们将使用 Burp 针对
    Safari 的支持文章，因为相关设置在你的 Mac 设置中：[https://support.portswigger.net/customer/portal/articles/1783070-Installing_Configuring%20your%20Browser%20-%20Safari.html](https://support.portswigger.net/customer/portal/articles/1783070-Installing_Configuring%20your%20Browser%20-%20Safari.html)。
- en: Once your browser is connected and on (and you've turned the Intercept function
    off), go to `http://burp/`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的浏览器连接并开启（并且你已经关闭了拦截功能），请访问 `http://burp/`。
- en: 'If you do this through your Burp proxy, you''ll be redirected to a page where
    you can download the Burp certificate. We''ll need the certificate to remove any
    security warnings and allow our browser to install static assets:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过 Burp 代理进行此操作，您将被重定向到一个页面，您可以在该页面上下载 Burp 证书。我们需要该证书来移除任何安全警告，并允许我们的浏览器安装静态资源：
- en: '![](assets/fc25ed5a-8120-4266-b260-bf06e6c5f281.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc25ed5a-8120-4266-b260-bf06e6c5f281.png)'
- en: 'After you download the certificate, you just need to go to your Keychains settings,
    File | Import Items, and upload your Burp certificate(a `.der` file). Then you
    can double-click it to open another window where you can select Always Trust This
    Certificate:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下载证书后，您只需进入您的钥匙串设置，选择文件 | 导入项目，然后上传您的 Burp 证书（`.der` 文件）。然后您可以双击它打开另一个窗口，在其中选择始终信任此证书：
- en: '![](assets/444b695c-ad20-4709-b140-77b89d26cb93.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/444b695c-ad20-4709-b140-77b89d26cb93.png)'
- en: 'After browsing around a site, you''ll start to see it populating information
    in Burp. Under the Target | Site map tabs, you can see URLs you''ve hit as you
    browse through Burp:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览一个网站后，您将开始看到它在 Burp 中填充信息。在目标 | 网站地图选项卡下，您可以看到浏览时点击的 URL：
- en: 020![](assets/5f77b98a-44e8-4819-9352-0e730456c77e.png)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 020![](assets/5f77b98a-44e8-4819-9352-0e730456c77e.png)
- en: Logging into every form, clicking on every tab, following every button – eventually
    you'll build up a good enough picture of the application to inform the rest of
    your research. And because you're building this picture within Burp, you can add
    or remove URLs from scope, and send the information you're gathering for follow-up
    investigations in other Burp tools.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 登录每个表单，点击每个选项卡，跟随每个按钮——最终您将建立一个足够清晰的应用程序图片，以指导接下来的研究。因为您是在 Burp 中建立这个图片，您可以添加或移除范围中的
    URL，并将收集到的信息发送到 Burp 中的其他工具进行后续调查。
- en: Source Code
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码
- en: Source-code analysis is typically thought of as something that only takes place
    in a white box, an internal testing scenario, either as part of an automated build
    chain or as a manual review. But analyzing client-side code available to the browser
    is also an effective way of looking for vulnerabilities as an outside researcher.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码分析通常被认为仅发生在白盒测试中，即内部测试场景，作为自动化构建链的一部分或手动审查。但分析浏览器可用的客户端代码也是作为外部研究人员寻找漏洞的有效方式。
- en: 'We''re specifically going to look at `retire` (Retire.js), a node module that
    has both Node and CLI components, and analyzes client-side JavaScript and Node
    modules for previously-reported vulnerabilities. You can install it easily using
    `npm` and then using the global flag (`-g`) to make it accessible in your `$PATH`:
    `npm install -g retire`. Reporting a bug that may have been discovered in a vendor''s
    software, but still requires addressing/patching in a company''s web application,
    will often merit a reward. The easy-to-use CLI of `retire` makes it simple to
    write short, purpose-driven scripts in the Unix style. We''ll be using it to elaborate
    on a general philosophy of pentesting automation.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别查看 `retire`（Retire.js），一个具有 Node 和 CLI 组件的 Node 模块，用于分析客户端 JavaScript 和
    Node 模块中的已报告漏洞。您可以通过 `npm` 轻松安装它，然后使用全局标志（`-g`）将其添加到您的 `$PATH` 中：`npm install
    -g retire`。报告可能已经在供应商的软件中发现的错误，但仍需在公司网站应用程序中解决/修补，通常会获得奖励。`retire` 易于使用的 CLI 使得在
    Unix 风格中编写简短、有目的的脚本变得简单。我们将利用它来阐述渗透测试自动化的一般理念。
- en: '`retire --help` shows you the general contour of functionality:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`retire --help` 显示了功能的大致轮廓：'
- en: '![](assets/8ac7181a-92ef-4a6b-86b0-4988dbbb00d6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ac7181a-92ef-4a6b-86b0-4988dbbb00d6.png)'
- en: 'Let''s test it against an old project of mine written in Angular and node:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我以前写的一个 Angular 和 Node 项目进行测试：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s a little hard to read. And the attempt to show the vulnerable modules
    within their nested dependencies makes it even harder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以阅读。尝试显示其嵌套依赖项中的脆弱模块使其变得更加困难：
- en: '![](assets/9cae1a88-0452-4554-bb5e-75a5243f2e36.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9cae1a88-0452-4554-bb5e-75a5243f2e36.png)'
- en: 'But we can use some of its available flags to rectify this. As we pass in options
    to output the data in the `json` format and specify the name of the file we want
    to save, we can also wrap it in a script to make it a handier reference from the
    command line. Let''s make a script called `scanjs.sh`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以使用一些可用的标志来纠正这个问题。通过传递选项以将数据输出为 `json` 格式，并指定我们想要保存的文件名称，我们还可以将其包装在脚本中，从命令行中更方便地引用它。让我们创建一个名为
    `scanjs.sh` 的脚本：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This script requires two arguments, the path to the files being analyzed and
    a name for the file it will output. Basically the script analyzes the target code
    repository, creates a `json` file of the vulnerabilities it discovers, then prints
    out a pretty version of the `json` file to `STDOUT`. The script has two outputs
    so that it can use the `json` file as a local flat file log, and the `STDOUT`
    output to pass on to the next step, a formatting script.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本需要两个参数，一个是被分析文件的路径，另一个是它将输出的文件名。基本上，脚本分析目标代码库，创建一个发现的漏洞的 `json` 文件，然后将格式化后的
    `json` 文件输出到 `STDOUT`。这个脚本有两个输出，这样它就可以将 `json` 文件作为本地平面日志文件使用，并将 `STDOUT` 输出传递到下一个步骤，一个格式化脚本。
- en: Building a Process
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个流程
- en: If we think about how to build processes the Unix way, with small scripts responsible
    for single concerns, chained together into more complex workflows (all built on
    the common foundation of plain text) it makes sense to boil down our automated
    reconnaissance tools into the smallest reusable parts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑按照 Unix 的方式构建流程，每个小脚本负责一个单一的任务，通过链式连接组成更复杂的工作流（所有流程都建立在纯文本的共同基础上），那么将我们的自动化侦察工具拆解为最小的可重用部分是很有意义的。
- en: One part is that wrapper script we just wrote, `scanjs.sh`. This script scans
    the client-side code of a website (currently from a repo) and compiles a report
    in `json`, which it both saves and displays.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一部分是我们刚才编写的包装脚本 `scanjs.sh`。该脚本扫描网站的客户端代码（目前来自一个代码库），并生成一个 `json` 格式的报告，同时保存和显示该报告。
- en: Formatting the JS Report
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化 JS 报告
- en: 'But to make better sense of that `json`, we need to format it in a way that
    pulls out the critical info (for example, severity, description, and location)
    while leaving out noise (for example, dependency graphs). Let''s use Python, which
    is great for string manipulation and general data munging, to write a script that
    formats that `json` into a plain text report. We''ll call the script `formatjs.py`
    to associate it with our other tool. The first thing we need to do is pull in
    `json` from `STDIN` and encode it as a Python data structure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为了更好地理解这个 `json`，我们需要以一种方式格式化它，从中提取关键信息（例如严重性、描述和位置），同时去除噪声（例如，依赖关系图）。我们将使用
    Python，这对于字符串操作和一般的数据处理非常适合，编写一个脚本将该 `json` 格式化为纯文本报告。我们将把脚本命名为 `formatjs.py`，以便与我们的其他工具关联。首先，我们需要从
    `STDIN` 获取 `json` 并将其编码为 Python 数据结构：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our goal is to create a table to display the data from the report, covering
    the `severity`, `summary`, `info`, and `file` attributes for each vulnerability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个表格来显示报告中的数据，涵盖每个漏洞的 `severity`、`summary`、`info` 和 `file` 属性。
- en: 'We''ll be using a simple Python table library, `tabulate` (which you can install
    via `pip install tabulate`). As per the `tabulate` docs, you can create a table
    using a nested list, where the inner list contains the values of an individual
    table row. We''re going to iterate over the different files analyzed, iterate
    over each vulnerability, and process their attributes into `row` lists that we''ll
    collect in our `rows` nested list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的 Python 表格库 `tabulate`（可以通过 `pip install tabulate` 安装）。根据 `tabulate`
    的文档，您可以使用嵌套列表创建一个表格，其中内层列表包含单个表格行的值。我们将遍历分析过的不同文件，遍历每个漏洞，并将它们的属性处理成 `row` 列表，然后将这些
    `row` 列表收集到我们的 `rows` 嵌套列表中：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That `format_bug()` function will just pull out the information we care about
    from the `vulnerability` dictionary and order the info properly in a list the
    function will return:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_bug()` 函数将从 `vulnerability` 字典中提取我们关心的信息，并将信息按正确的顺序排列在一个列表中，函数将返回该列表：'
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we''ll sort the vulnerabilities by severity so that all the different
    types (high, medium, low, and so on) are grouped together:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将根据严重性对漏洞进行排序，这样不同类型（高、中、低等）将被分组在一起：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s what it looks like all together, for reference:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将所有内容整合在一起后的样子，供参考：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the following is what it looks like when it''s run on the Terminal. I''m
    running the `scanjs.sh` script wrapper and then piping the data to `formatjs.py`.
    Here''s the command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在终端运行时的样子。我正在运行 `scanjs.sh` 脚本包装器，然后将数据传输到 `formatjs.py`。这是命令：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And here''s the output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![](assets/4bd98ea7-6084-43ce-b026-ff4fea44c439.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4bd98ea7-6084-43ce-b026-ff4fea44c439.png)'
- en: Downloading the JavaScript
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载 JavaScript
- en: 'There''s one more step before we can point this at a site – we need to download
    the actual JavaScript! Before analyzing the source code using our `scanjs` wrapper,
    we need to pull it from the target page. Pulling the code once in a single, discrete
    process (and from a single URL) means that, even as we develop more tooling around
    attack-surface reconnaissance, we can hook this script up to other services: it
    could pull the JavaScript from a URL supplied by a crawler, it could feed JavaScript
    or other assets into other analysis tools, or it could analyze other page metrics.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将它指向一个网站之前，还有一步——我们需要下载实际的JavaScript！在使用我们的`scanjs`封装分析源代码之前，我们需要从目标页面提取它。一次性从单一的URL拉取代码意味着，即使我们围绕攻击面侦察开发更多工具，我们也可以将这个脚本与其他服务连接起来：它可以从爬虫提供的URL拉取JavaScript，也可以将JavaScript或其他资源输入到其他分析工具中，或者分析其他页面指标。
- en: 'So the simplest version of this script should be: the script takes a URL, looks
    at the source code for that page to find all JavaScript libraries, and then downloads
    those files to the specified location.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个脚本的最简单版本应该是：脚本接受一个URL，查看该页面的源代码以查找所有JavaScript库，然后将这些文件下载到指定的位置。
- en: 'The first thing we need to do is grab the HTML from the URL of the page we''re
    inspecting. Let''s add some code that accepts the `url` and `directory` CLI arguments,
    and defines our target and where to store the downloaded JavaScript. Then, let''s
    use the `requests` library to pull the data and Beautiful Soup to make the HTML
    string a searchable object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是抓取我们正在检查的页面的HTML内容。让我们添加一些代码，接受`url`和`directory`命令行参数，定义我们的目标和存储下载的JavaScript的位置。然后，我们使用`requests`库来拉取数据，并使用Beautiful
    Soup将HTML字符串转化为可搜索的对象：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we need to iterate over each script tag and use the `src` attribute data
    to download the file to a directory within our current root:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要遍历每个`script`标签，并使用`src`属性的数据将文件下载到我们当前根目录内的一个目录：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That `download_script()` function might not ring a bell because we haven''t
    written it yet. But that''s what we want – a function that takes the `src` attribute
    path, builds the link to the resource, and downloads it into the directory we''ve
    specified:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你对`download_script()`函数不太熟悉，因为我们还没有编写它。但这正是我们所需要的——一个函数，它接受`src`属性路径，构建资源链接，并将其下载到我们指定的目录：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each line is pretty direct. After the function definition, the HTTP address
    of the script is created using a Python ternary. If the `src` attribute starts
    with `/`, it's a relative path and can just be appended onto the hostname; if
    it doesn't, it must be a full/absolute link. Ternaries can be funky but also powerfully
    expressive once you get the hang of them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每行代码都很直接。函数定义之后，脚本的HTTP地址是通过Python的三元表达式创建的。如果`src`属性以`/`开头，它是相对路径，可以直接附加到主机名；如果不是，它必须是完整的绝对链接。三元表达式可能看起来有点复杂，但一旦你掌握了它，它的表达能力非常强大。
- en: The second line of the function creates the filename of the JavaScript library
    link by finding the character index of the last forward slash (`address.rfind("/")`)
    and the index of the `js` file extension, plus 2 to avoid slicing off the `js`
    part (`address.rfind("js")+2)`), and then uses the `[begin:end]` list-slicing
    syntax to create a new string from just the specified indices.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二行通过查找最后一个斜杠（`address.rfind("/")`）的字符索引和`js`文件扩展名的索引，再加上2以避免切掉`js`部分（`address.rfind("js")+2)`），然后使用`[begin:end]`列表切片语法从指定的索引创建一个新的字符串，从而生成JavaScript库链接的文件名。
- en: Then, in the third line, the script pulls data from the assembled address using
    `requests`, creates a new file using a context manager, and writes the page source
    code to `/directory/filename.js`. Now you have a location, the path passed in
    as an argument, and all of the JavaScript from a particular page saved inside
    of it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第三行中，脚本使用`requests`从组装好的地址拉取数据，通过上下文管理器创建一个新文件，并将页面源代码写入`/directory/filename.js`。现在你有了一个位置，路径作为参数传递，所有来自特定页面的JavaScript都会保存在其中。
- en: Putting It All Together
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: 'So what does it look like when we put it all together? It''s simple – we can
    construct a one-liner to scan the JavaScript of a target site just by passing
    the right directory references:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们把这一切整合在一起时会是什么样子呢？其实很简单——我们只需传递正确的目录引用，就能构造一个一行代码来扫描目标网站的JavaScript：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Keep in mind we've already symlinked these scripts to our `/usr/local/bin` and
    changed their permissions using `chmod u+x` to make them executable and accessible
    from our path. With this command, we're telling our CL to download the JavaScript
    from `http://target.site` to the `sourcejs` directory, then scan that directory,
    create an `output.json` representation of the data, and finally format everything
    as a plain-text report.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们已经将这些脚本创建了符号链接并将其权限更改为`chmod u+x`，使它们可执行并可从我们的路径中访问。通过此命令，我们告诉我们的CL从`http://target.site`下载JavaScript到`sourcejs`目录，然后扫描该目录，创建一个`output.json`格式的数据表示，最后将所有内容格式化为纯文本报告。
- en: 'As a means of testing the command, I recently read a blog decrying the fact
    that jQuery, responsible for a large chunk of the web''s client-side code, was
    running an out-of-date WordPress version on [http://jquery.com/](http://jquery.com/),
    so I decided to see whether their JavaScript had any issues:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试命令的一种手段，我最近读到一篇博客，批评jQuery（负责Web上大部分客户端代码）在[http://jquery.com/](http://jquery.com/)上运行过时的WordPress版本，于是我决定查看它们的JavaScript是否存在问题：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](assets/b5b352c7-9a2d-4917-b3cf-6d27dc6f2207.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5b352c7-9a2d-4917-b3cf-6d27dc6f2207.png)'
- en: The fact that [http://jquery.com/](http://jquery.com/) has a few issues is nothing
    huge, but still surprising! Known component vulnerabilities in JavaScript are
    a widespread issue, affecting a sizable portion of sites (different methodologies
    put the number of affected sites at between one-third and three-quarters of the
    entire web).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jquery.com/](http://jquery.com/)存在一些问题，这并不算什么大事，但仍然令人吃惊！JavaScript中的已知组件漏洞是一个普遍存在的问题，影响了大量网站（不同的方法论估计受影响的网站数量在整个网络中占据三分之一到四分之三之间）。'
- en: The Value Behind the Structure
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构背后的价值
- en: 'We''ve developed several scripts to achieve a single goal. The exercise begs
    this question: why didn''t we write one program instead? We could''ve included
    all our steps (download the JSON, analyze it, print a report) in a Python or Shell
    script; wouldn''t that have been easier?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了多个脚本来实现一个目标。这个过程提出了一个问题：为什么我们不写一个程序呢？我们本可以将所有步骤（下载JSON、分析、打印报告）都包含在一个Python或Shell脚本中；这样不是更方便吗？
- en: 'But the advantage of our current setup is the modularity of the different pieces
    in the face of different workflows. For example, we might want to do all the steps
    at once, or we might just want a subset. If I''ve already downloaded all the JSON
    for a page and put it into a folder, scanned it, and created a report at `some-site-1-18-18.json`,
    then, when I visit the info, all I need is the ability to format the report from
    the raw `json`. I can achieve that with simple Unix:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们当前设置的优势在于不同工作流下各个部分的模块化。例如，我们可能希望一次性完成所有步骤，或者我们只需要其中的一部分。如果我已经下载了页面的所有JSON并将其放入一个文件夹，扫描了它并创建了`some-site-1-18-18.json`报告，那么，当我访问该信息时，我所需要的只是将原始`json`格式的报告转换为格式化输出。我可以通过简单的Unix命令实现这一点：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or we might want to extend the workflow. Because the foundation is built on
    plain text, it''s easy to add new pieces. If our `mail` utility is set up, we
    can email ourselves the results of the test:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可能想要扩展工作流。因为基础是建立在纯文本上的，所以添加新内容非常简单。如果我们的`mail`工具已经设置好，我们可以将测试结果通过邮件发送给自己：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or we could decide we only want to email ourselves the critical vulnerabilities.
    We could pull out the text we care about by using `ag`, a `grep`-like natural-language
    search utility known for its blazing speed:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以决定只向自己发送关键漏洞的邮件。我们可以使用`ag`，一个类似`grep`的自然语言搜索工具，以其惊人的速度提取我们关心的文本：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We could substitute using email as a notification with using a script invoking
    the Slack API or another messaging service – the possibilities are endless. The
    benefit from using these short, stitched-together programs, built around common
    input and output, is that they can be rearranged and added to at will. They are
    the building blocks for a wider range of combinations and services. They are also,
    individually, very simple scripts, and because they're invoked through and pass
    information back to the command line, can be written in a variety of languages.
    I've used Python and Shell in this work, but could employ Ruby, Perl, Node, or
    another scripting language, with similar success.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用调用Slack API或其他消息服务的脚本来替代通过电子邮件作为通知的方式——这种可能性是无穷无尽的。使用这些短小的、拼接在一起的程序的好处在于，它们围绕着通用的输入和输出构建，可以随意重组和添加。它们是更广泛组合和服务的构建模块。它们本身也是非常简单的脚本，因为它们是通过命令行调用并传回信息的，可以用多种语言编写。我在这项工作中使用了Python和Shell，但也可以使用Ruby、Perl、Node或其他脚本语言，成功的效果相似。
- en: There are obviously a lot of ways these short scripts could be improved. They
    currently have no input-verification, error-handling, logging, default arguments,
    or other features meant to make them cleaner and more reliable. But as we progress
    through the book, we'll be building on top of the utilities we're developing until
    they become more reliable, professional tools. And by adding new options, we'll
    show the value of a small, interlocking toolset.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些短小的脚本有很多可以改进的地方。目前它们没有输入验证、错误处理、日志记录、默认参数或其他旨在使它们更干净、更可靠的功能。但随着我们逐步深入本书，我们将基于正在开发的工具进行扩展，直到它们变得更加可靠和专业。通过添加新选项，我们将展示一个小型互锁工具集的价值。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered how to discover information about a site's attack surface
    using automated scanners, passive proxy interception, and command-line utilities
    wired into our own homebrew setup, and a couple of things in between. You learned
    some handy third-party tools, and also how to use them and others within the context
    of custom automation. Hopefully you've come away not only with a sense of the
    tactics (the code we've written), but of the strategy as well (the design behind
    it).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用自动扫描器、被动代理拦截和命令行工具（这些工具通过我们的自制设置进行连接）来发现网站攻击面的一些信息，并介绍了其中的一些内容。你学习了一些实用的第三方工具，也了解了如何在自定义自动化的背景下使用它们和其他工具。希望你不仅掌握了战术（我们编写的代码），还了解了背后的策略（设计理念）。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's a good tool for finding hidden directories and secret files on a site?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找网站上隐藏的目录和秘密文件，有什么好的工具？
- en: How and where can you find a map of the site's architecture? How can you create
    one if it's not already there?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在哪里找到网站架构的地图？如果没有，如何自己创建一张？
- en: How can you safely create a map of an application's attack surface without using
    scanners or automated scripts?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不使用扫描器或自动化脚本的情况下安全地创建应用程序的攻击面地图？
- en: What's a common resource in Python for scraping websites?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中，什么是常见的网页抓取资源？
- en: What are some advantages to writing scripts according to the Unix philosophy
    (single-purpose, connectable, built around text)?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Unix哲学（单一功能、可连接、基于文本）编写脚本有什么优势？
- en: What's a good resource for finding XSS submissions, SQLi snippets, and other
    fuzzing inputs?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找XSS提交、SQLi代码片段和其他模糊输入的好资源是什么？
- en: What's a good resource for discovering DNS info associated with a target?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找与目标相关的DNS信息，有什么好的资源？
- en: Further Reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解我们在本章中讨论的部分主题：
- en: '**SecLists**: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SecLists**: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
- en: '**Measuring Relative Attack Surfaces**: [http://www.cs.cmu.edu/~wing/publications/Howard-Wing03.pdf](http://www.cs.cmu.edu/~wing/publications/Howard-Wing03.pdf)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量相对攻击面**: [http://www.cs.cmu.edu/~wing/publications/Howard-Wing03.pdf](http://www.cs.cmu.edu/~wing/publications/Howard-Wing03.pdf)'
- en: '**XSScrapy**: [http://pentestools.com/xsscrapy-xsssqli-finder/](http://pentestools.com/xsscrapy-xsssqli-finder/)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSScrapy**: [http://pentestools.com/xsscrapy-xsssqli-finder/](http://pentestools.com/xsscrapy-xsssqli-finder/)'
