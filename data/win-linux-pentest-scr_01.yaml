- en: '*Chapter 4*: Windows Passwords on the Network'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：网络上的Windows密码'
- en: Few technologies have molded modern **information security** quite like the
    **Windows** **password**. The sheer popularity of the **Windows** **operating
    system** (**OS**) has resulted in intense scrutiny of its methods and their security.
    When more eyes are examining the security of an authentication system, there are
    more lessons to inform growth and improvement. On the other hand, a major goal
    of Windows implementations is **backward compatibility**. What this means in practice
    is that older and weaker methods are often found in today’s IT environments, even
    when a more secure version is available, and even when that more secure version
    is enabled in the same environment. In this chapter, we’ll be discussing some
    technology that’s literally more than two decades old, and you might wonder, do
    we really need to be looking at this anymore? The answer is, sadly, yes. Your
    clients will have their reasons for configuring their systems to support security
    methods that can literally be broken in seconds, but it’s not likely that they’ve
    truly grasped the impact of these decisions. That’s why you are there, and it’s
    why I’ve included this chapter in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有技术像**Windows** **密码**一样深刻地塑造了现代**信息安全**。**Windows**操作系统（**OS**）的极大普及使得其方法和安全性受到了严格审查。随着更多的目光聚焦于身份验证系统的安全性，便有更多的教训能够推动技术的成长和进步。另一方面，Windows实现的一个主要目标是**向后兼容性**。这在实践中的含义是，即使有更安全的版本可用，甚至该更安全的版本已在同一环境中启用，老旧且脆弱的技术仍然出现在当今的IT环境中。本章将讨论一些超过二十年的技术，或许你会想，真的有必要继续关注这些内容吗？答案是，遗憾的是，必须的。你的客户可能会有自己的理由去配置系统以支持那些可以在几秒钟内破解的安全方法，但他们很可能并未真正意识到这些决策的影响。这就是你存在的意义，也是我在本书中加入这一章节的原因。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: A quick overview of Windows password hashes and design flaws
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows密码哈希及设计缺陷的简要概述
- en: An introduction to **Metasploit** by using an authentication capture auxiliary
    module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用认证捕获辅助模块介绍**Metasploit**
- en: A demonstration of **Link-Local Multicast Name Resolution** (**LLMNR**)/**NetBIOS
    Name Service** (**NetBIOS NS**) spoofing to capture Windows credentials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示如何使用**Link-Local Multicast Name Resolution**（**LLMNR**）/**NetBIOS Name Service**（**NetBIOS
    NS**）欺骗技术来捕获Windows凭据
- en: An introduction to **John the Ripper** and **Hashcat**, two popular password
    crackers, and modifying parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍两款流行的密码破解工具**John the Ripper**和**Hashcat**，以及修改参数的方法
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following technical requirements are needed in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的技术要求如下：
- en: A laptop running **Kali** **Linux**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行**Kali** **Linux**的笔记本电脑
- en: A laptop or desktop running Windows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行Windows的笔记本或台式电脑
- en: Understanding Windows passwords
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Windows密码
- en: Imagine you sit down at your Windows computer. You punch in your password and
    the computer logs you in. Windows has to have some means of knowing that your
    entry is correct. Naturally, we’d assume the password is stored on the computer,
    but, interestingly enough, the password is stored nowhere on the computer. A unique
    representation of your password is used instead, and the same type of representation
    of your entry during the logon process is simply compared to it. If they match,
    Windows assumes your entry is the same as the password. This representation of
    Windows passwords is called a **hash**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你坐在Windows电脑前。你输入密码，电脑登录了。Windows必须有某种方式来验证你的输入是否正确。通常我们会认为密码保存在电脑上，但有趣的是，密码并没有保存在电脑上。而是使用了密码的唯一表示形式，登录过程中你输入的内容与这种表示进行比较。如果它们匹配，Windows就会认为你的输入与密码相同。这种表示Windows密码的方式被称为**哈希**。
- en: A crash course on hash algorithms
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希算法速成课程
- en: A hash is a one-way function; you can’t take a hash value and work backward
    to an input. The hash value is a fixed length defined by the algorithm, whereas
    the input is a variable length. You can create a **SHA-256** hash value (256 bits
    long) for a single letter or for the entire works of Shakespeare.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种单向函数；你无法通过哈希值反向推导出输入。哈希值是由算法定义的固定长度，而输入是可变长度的。你可以为一个字母或莎士比亚的全集创建**SHA-256**哈希值（256位长）。
- en: 'Some hash examples using SHA-256 include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用SHA-256的哈希示例包括以下内容：
- en: 'The **ASCII** letter *a* (lowercase):'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASCII**字母*a*（小写）：'
- en: ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807
- en: 785afee48bb
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 785afee48bb
- en: 'The ASCII letter *A* (uppercase):'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASCII 字母 *A*（大写字母）：
- en: 559aead08264d5795d3909718cdd05abd49572e84fe55590eef
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 559aead08264d5795d3909718cdd05abd49572e84fe55590eef
- en: 31a88a08fdffd
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 31a88a08fdffd
- en: 'Shakespeare’s *The Tragedy of Titus Andronicus* (the entire play):'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 莎士比亚的 *《提图斯·安德罗尼克斯》*（完整剧本）：
- en: 02b8d381c9e39d6189efbc9a42511bbcb2d423803bb86c28ae
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 02b8d381c9e39d6189efbc9a42511bbcb2d423803bb86c28ae
- en: 248e31918c3b9a
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 248e31918c3b9a
- en: 'Shakespeare’s *The Tragedy of Titus Andronicus* (but with a single word misspelled):'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 莎士比亚的 *《提图斯·安德罗尼克斯》*（但有一个单词拼写错误）：
- en: 4487eba46b2327cfb59622a6b8984a74f1e1734285e4f8093fe
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4487eba46b2327cfb59622a6b8984a74f1e1734285e4f8093fe
- en: 242c885b4aadb
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 242c885b4aadb
- en: With these examples, you can see the fundamental nature of a hash algorithm
    at work. The output is fixed length. In these examples, the output is 64 hexadecimal
    characters long (a single hexadecimal character is 4 bits long; 256 divided by
    4 yields 64 characters). An SHA-256 hash is always 64 characters, no matter the
    length of the input – even if the length is zero! Yes, there’s even a hash value
    for literally nothing. It’s 64 characters even for massive inputs, like Shakespeare’s
    *Titus Andronicus* – that’s 1.19 million characters. When it comes to the security
    application of hashing, one critical feature is the fact that changing a single
    character in a Shakespeare play radically changed the hash value. This is due
    to a principle in cryptography called **the avalanche effect**, and it’s a core
    feature of secure algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，你可以看到哈希算法的基本特性。输出是固定长度的。在这些示例中，输出是 64 个十六进制字符（一个十六进制字符长 4 位；256 除以 4
    等于 64 个字符）。SHA-256 哈希总是 64 个字符，无论输入的长度是多少——即使长度为零！是的，甚至对于“什么也没有”的哈希值也是有的。即使对于像莎士比亚的
    *《提图斯·安德罗尼克斯》* 这样的大量输入——共有 119 万个字符，哈希值仍然是 64 个字符。谈到哈希的安全应用，其中一个关键特性是：在莎士比亚的戏剧中，改变一个字符就能彻底改变哈希值。这是由于密码学中的一个原理，叫做
    **雪崩效应**，它是安全算法的核心特性。
- en: 'Let’s suppose that a bad guy has captured a hash representing my password.
    Thanks to the avalanche effect, he has no way of knowing by merely hashing his
    guesses that he was getting close to the actual value. He could be a single character
    off and the hash would look radically different. I know what the hacker in you
    is thinking: “*Mathematically speaking, as long as the fixed-length, one-way function
    will accept inputs of arbitrarily longer lengths, there will always be some pair
    of values that will hash to the same output.*” Brilliant point, and you’re right.
    This is called a **collision**. The primary goal of any secure hashing algorithm
    design is to reduce the risk of collisions. Mathematically speaking, you can’t
    eliminate them – you can just make them extremely hard to find so that you may
    as well just try to find the target input.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个坏人捕获了代表我密码的哈希值。感谢雪崩效应，他仅凭哈希化他的猜测，是无法知道自己是否接近真实值的。他可能只错了一个字符，而哈希值就会完全不同。我知道你心中的黑客在想：“*从数学角度讲，只要固定长度的单向函数能够接受任意长度的输入，肯定总会有一对值会哈希成相同的输出。*”这是个非常聪明的观点，你说得对。这被称为
    **碰撞**。任何安全哈希算法设计的主要目标都是减少碰撞的风险。从数学角度讲，你无法完全消除碰撞——你只能让它们极难找到，这样你不如直接去尝试找到目标输入。
- en: Now, it’s best to not go too deep down the rabbit hole of hashing when discussing
    Windows security because, in classic **Microsoft** form, they just had to do things
    their way. A *Windows hash*, from any point in the history of the operating system,
    is no ordinary hash.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在讨论 Windows 安全时，最好不要深入探讨哈希的细节，因为，按照经典的 **Microsoft** 风格，他们总是要走自己的路。从操作系统历史上的任何一个时期来看，*Windows
    哈希* 都不是普通的哈希。
- en: Password hashing methods in Windows
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 中的密码哈希方法
- en: We start our journey way back in the distant past. It was a time after the dinosaurs,
    though not by much. I’m talking about, of course, the age of the **LAN Manager**
    (**LM**) hash.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程开始于遥远的过去。那是一个恐龙时代之后的时期，虽然距离恐龙时代并不远。我说的当然是 **LAN 管理器**（**LM**）哈希时代。
- en: There’s an ancient concept in operating systems called **the network operating
    system** (**NOS**). When you say these words today, you’ll probably be understood
    as referencing the operating systems on networking devices such as routers (think
    **Cisco** **IOS**). But back in the day, it was an operating system optimized
    for networking tasks such as client-server communications. The concept was born
    when personal computing went from being a single user and computer in isolation
    to one of many users sharing information on a network. One such NOS is Microsoft’s
    LM. LM was successful, but quickly found to be suffering from significant security
    issues. Microsoft then took the authentication mechanism and beefed it up in a
    new suite of protocols called **NT LAN Manager** (**NTLM**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统中有一个古老的概念叫做**网络操作系统**（**NOS**）。当你今天说到这些词时，你可能会被理解为指代网络设备（如路由器）上的操作系统（比如**思科**
    **IOS**）。但在过去，这是一种为网络任务（如客户端-服务器通信）优化的操作系统。这个概念诞生于个人计算从单一用户和计算机的孤立状态转变为多个用户共享网络上信息的时代。一个这样的
    NOS 是微软的 LM。LM 曾经成功，但很快发现它存在严重的安全问题。于是微软将认证机制进行了增强，推出了一套新的协议称为**NT LAN Manager**（**NTLM**）。
- en: As we explore these authentication mechanisms, you need to know that there are
    two ways you’ll get your hands on credentials – over the network, or by stealing
    the hashes straight from the **Security Account Manager** (**SAM**). Hashes stored
    in the SAM are just plain representations of passwords, but authentication over
    the network is more complicated by virtue of using a **challenge-response mechanism**,
    which we’ll discuss next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索这些认证机制时，你需要知道有两种方式可以获得凭据 —— 通过网络，或者通过直接从**安全账户管理器**（**SAM**）中窃取哈希值。存储在
    SAM 中的哈希只是密码的简单表示，而通过网络进行的认证则因为使用了**挑战-响应机制**变得更加复杂，接下来我们会讨论这个问题。
- en: If it ends with 1404EE, then it’s easy for me – understanding LM hash flaws
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果它以 1404EE 结尾，那么对我来说很容易 —— 理解 LM 哈希的缺陷
- en: 'Let’s take a look at the LM hashes for a few passwords and see whether there
    are any immediately noticeable patterns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下几个密码的 LM 哈希，看看是否能发现一些明显的模式：
- en: '![Table 4.1 – LM hash representations for different inputs ](image/B17616_04_Table_4.1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![表格 4.1 – 不同输入的 LM 哈希表示](image/B17616_04_Table_4.1.jpg)'
- en: Table 4.1 – LM hash representations for different inputs
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4.1 – 不同输入的 LM 哈希表示
- en: We can already tell that this isn’t an ordinary hashing algorithm.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以判断出，这并不是一个普通的哈希算法。
- en: 'The first two passwords have the same LM hash. The third and fourth passwords
    have the same second half. And finally, the last password has the same previous
    half repeated twice. Without pulling out any hacking tools, we’ve already figured
    out two important facts: the LM password is not case-sensitive, and the LM hash
    is two smaller hashes concatenated together! A Windows password that’s protected
    with the LM hash is actually two seven-character passwords hashed separately.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个密码具有相同的 LM 哈希。第三个和第四个密码的后半部分相同。最后，最后一个密码的前半部分重复了两次。通过这些信息，我们已经得出两个重要的结论：LM
    密码不区分大小写，并且 LM 哈希是两个较小的哈希值连接在一起！一个用 LM 哈希保护的 Windows 密码实际上是两个七字符密码分别哈希后的结果。
- en: Why are we concerned with an old and deprecated algorithm anyway? It’s very
    common for enterprise systems to require backward compatibility. The LM hash was
    stored by default, even on systems using the newer and stronger methods, until
    **Vista**. With Vista and beyond, it is possible to enable it. Many organizations
    enable storage of the LM hash to allow a legacy application to function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么要关心一个已经过时的算法呢？企业系统中常常需要向后兼容。即便是在使用更新且更强大的方法的系统中，LM 哈希也会默认存储，直到**Vista**发布。自
    Vista 及以后版本开始，它可以被禁用。许多组织会启用 LM 哈希存储，以允许旧版应用程序正常运行。
- en: 'To demonstrate this tremendous problem mathematically, let’s calculate the
    total number of possible 14-character passwords with only letters and numbers,
    and compare it to the total number of pairs of seven-character passwords:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了数学地演示这个巨大问题，我们来计算一下只有字母和数字的 14 字符密码的总可能数量，并与七字符密码对的总数量进行比较：
- en: 'The total possible number of 14-character passwords: **36^14 = 6.1409422 *
    10^21** (about 6.1 sextillion passwords)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14 字符密码的总可能数量：**36^14 = 6.1409422 * 10^21**（大约 6.1 戴克斯顿密码）
- en: 'The total possible number of seven-character pairs: **(36^7) + (36^7) = 156,728,328,192**
    (about 156.7 billion passwords)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七字符对的总可能数量：**(36^7) + (36^7) = 156,728,328,192**（大约 156.7 亿个密码）
- en: The second number is only 0.00000000255% as large as the first number.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数字只有第一个数字的0.00000000255%大小。
- en: With the advent of **Windows** **NT**, the LM hash was replaced with the NT
    hash. Whereas the LM hash is **DES**-based and only works on a non-case-sensitive
    version of a 14-character maximum password split in half, the NT hash is **MD4**-based
    and calculates the hash from the UTF-16 representation of the password. The results
    are 128 bits long in either case, and they’re both easy as pie to attack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**Windows NT**的出现，LM哈希被NT哈希所取代。LM哈希是基于**DES**的，只适用于非区分大小写、最多14个字符且被分成两部分的密码，而NT哈希是基于**MD4**的，计算密码的哈希值基于其UTF-16表示。无论哪种情况，结果都是128位长，并且都非常容易被攻击。
- en: Authenticating over the network – a different game altogether
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络身份验证——完全是另一场游戏
- en: So far, we’ve discussed Windows hashes as password equivalents, and we’ve also
    discussed what I like to call *naked hashes*. Those hashes never hit the network,
    though. The hash becomes the shared secret in an encrypted challenge-response
    mechanism. In NTLMv1, once the client connects to the server, a random 8-byte
    number is sent to the client – this is the challenge. The client takes the naked
    hash, and after adding some padding to the end, splits it into three pieces and
    DES encrypts these three pieces, separately, with the challenge – this forms a
    24-byte response. As the response is created with the challenge and a shared secret
    (the hash), the server can authenticate the client. NTLMv2 adds a client-side
    challenge to the process. Password crackers are aware of these protocol differences,
    so you can simply import the results of a capture and get straight to cracking
    it. As a rule of thumb, the more sophisticated algorithms require more time to
    crack their passwords.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了将Windows哈希作为密码等价物，也讨论了我喜欢称之为*裸哈希*的内容。然而，这些哈希从未出现在网络中。哈希值成为加密挑战-响应机制中的共享密钥。在NTLMv1中，一旦客户端连接到服务器，一个随机的8字节数字会发送到客户端——这就是挑战。客户端拿到裸哈希后，在末尾添加一些填充，并将其分成三部分，然后分别与挑战一起使用DES加密——这就形成了一个24字节的响应。由于响应是通过挑战和共享密钥（哈希）生成的，服务器可以验证客户端。NTLMv2在这一过程中加入了客户端挑战。密码破解者清楚这些协议的差异，因此你可以直接导入捕获的结果并开始破解。作为经验法则，更复杂的算法破解密码需要更多时间。
- en: So, you can either steal passwords from the SAM within Windows, or you can listen
    for encrypted network authentication attempts. The first option gets you naked
    hashes, but it requires a compromise of the target. We’ll be looking at post-exploitation
    later in this book, so for now, let’s see what happens when we attack network
    authentication.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可以选择从Windows的SAM中窃取密码，或者监听加密的网络身份验证尝试。第一个选项能得到裸哈希，但它需要对目标进行攻破。我们将在本书后面讨论后期利用的内容，因此现在我们先看看攻击网络身份验证时会发生什么。
- en: Capturing Windows passwords on the network
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上捕获Windows密码
- en: 'In the Kali Linux world, there is more than one way to set up an **SMB listener**,
    but now’s a good time to bring out the framework that needs no introduction: Metasploit.
    The Metasploit framework will play a major role in attacks covered throughout
    this book, but here, we’ll simply set up a quick and easy way for any Windows
    box on the network to attempt a file-sharing connection.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali Linux世界中，有不止一种方法可以设置**SMB监听器**，但现在是时候介绍一个不需要介绍的框架：Metasploit。Metasploit框架将在本书中覆盖的攻击中扮演重要角色，但在这里，我们仅简单设置一个快速且简单的方法，让网络上的任何Windows主机尝试文件共享连接。
- en: 'We start up the Metasploit console with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令启动Metasploit控制台：
- en: msfconsole
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfconsole
- en: 'The Metasploit framework comes with auxiliary modules – these aren’t exploiters
    with payloads designed to get your shell, but they are wonderful sidekicks on
    a pen test because they can perform things such as **fuzzing** or, in our case,
    **server authentication captures**. You can take the output from here and pass
    it right along to a cracker or to an exploit module to progress further in your
    attack. To get a feel for the auxiliary modules available to you, you can type
    this command in the MSF prompt:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit框架自带辅助模块——这些模块不是带有有效载荷的利用工具，不是用来获取Shell的，但它们在渗透测试中是非常有用的助手，因为它们可以执行像**模糊测试**或我们这次的**服务器身份验证捕获**这样的任务。你可以将这里的输出直接传递给密码破解工具或利用模块，继续推进你的攻击。为了了解可用的辅助模块，你可以在MSF提示符下输入以下命令：
- en: show auxiliary
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显示辅助功能
- en: We’ll be using the SMB capture auxiliary module. Before we configure the listener,
    let’s consider a real-world pen test scenario where this attack can be particularly
    useful.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SMB 捕获辅助模块。在配置监听器之前，让我们考虑一个实际的渗透测试场景，在这个场景中，这种攻击特别有用。
- en: A real-world pen test scenario – the chatty printer
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个实际的渗透测试场景 – 喧闹的打印机
- en: 'Imagine you have physical access to a facility by looking the part: suit, tie,
    and a fake ID badge. Walking around the office, you notice a multifunction printer
    and scanner. During the course of the day, you see employees walk up to the device
    with papers in hand, punch something into the user interface, scan the documents,
    and then walk back to their desks. What is likely happening here is that the scanner
    is taking the images and storing them in a file share so that the user can access
    them from their computer. In order to do this, the printer must authenticate to
    the file share. Printers are often left with default administrator credentials,
    allowing us to change the configuration. The accounts used are often domain administrators,
    or at the very least, have permissions to access highly sensitive data. How you
    modify the printer’s settings will depend on the specific model. Searching online
    for the user guide for the specific model is a no-brainer.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你通过穿着得体（西装、领带和假 ID）获得了一个设施的物理访问权限。走在办公室里，你注意到一台多功能打印机和扫描仪。一天中，你看到员工们手拿文件走到设备前，输入一些内容，扫描文件，然后回到自己的桌子。这里可能发生的情况是，扫描仪将图像保存到文件共享中，以便用户可以从计算机访问这些文件。为了实现这一点，打印机必须向文件共享进行身份验证。打印机通常会使用默认的管理员凭证，从而允许我们更改配置。使用的帐户通常是域管理员，或者至少具有访问高度敏感数据的权限。你如何修改打印机设置将取决于具体型号。在线搜索该型号的用户手册是显而易见的做法。
- en: The idea is to temporarily change the destination share to the **UNC** path
    of your Kali box. When I did this, I kept a close eye on the screen; once I captured
    the authentication attempts, I changed the settings back as quickly as I could
    to minimize any suspicion. The user’s documents never make it to the file share;
    they’ll likely assume a temporary glitch and think nothing of it if it only happens
    once. But, if multiple users are finding they consistently can’t get documents
    onto the file share, IT will be called.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是暂时将目标共享更改为你 Kali 主机的 **UNC** 路径。当我这么做时，我密切关注屏幕；一旦捕获到身份验证尝试，我尽快恢复设置，以最小化任何怀疑。用户的文件不会被上传到文件共享；他们可能会认为这是暂时的故障，如果只发生一次，他们不会在意。但如果多个用户发现他们始终无法将文件上传到文件共享，IT
    部门就会被通知。
- en: Configuring our SMB listener
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的 SMB 监听器
- en: 'We have the MSF console up and running, so let’s set up our SMB listener. We
    run this command at the MSF prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动并运行了 MSF 控制台，因此让我们设置 SMB 监听器。我们在 MSF 提示符下运行此命令：
- en: use server/capture/smb
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 server/capture/smb
- en: 'As with any Metasploit module, we can review the options available in this
    SMB capture module with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 Metasploit 模块一样，我们可以使用以下命令查看此 SMB 捕获模块的可用选项：
- en: show options
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显示选项
- en: 'The following screenshot illustrates the output of the preceding command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面命令的输出：
- en: '![Figure 4.1 – The options menu for the SMB capture auxiliary module ](image/Figure_4.01_B17616.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – SMB 捕获辅助模块的选项菜单](image/Figure_4.01_B17616.jpg)'
- en: Figure 4.1 – The options menu for the SMB capture auxiliary module
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – SMB 捕获辅助模块的选项菜单
- en: 'Let’s take a look at these settings in more detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些设置：
- en: '**CAINPWFILE** defines where captured hashes will be stored, but in the Cain
    format. **Cain** (the powerful sniffing and cracking suite written for Windows)
    will capture hashes as it does its job, and then you have the option to save the
    data for later. The file that’s created puts the hashes in a format Cain recognizes.
    You can point Cain to the file that’s created here, using this flag. We aren’t
    using Cain, so we leave this blank.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CAINPWFILE** 定义了捕获的哈希值将存储的位置，但采用 Cain 格式。**Cain**（为 Windows 编写的强大嗅探和破解套件）会在执行任务时捕获哈希值，然后你可以选择将数据保存以供后续使用。创建的文件将哈希值以
    Cain 能识别的格式保存。你可以通过此标志将 Cain 指向此处创建的文件。我们不使用 Cain，因此将此项留空。'
- en: '**CHALLENGE** defines the server challenge that is sent at the start of the
    authentication process. You’ll recall that hashes captured off the network are
    not naked hashes like you’d find in the SAM, as they’re password equivalents.
    They are encrypted as part of a challenge-response mechanism. What this means
    for us is we need to crack the captured hash with the same *challenge* (that is,
    a number that’s normally randomly generated) – so we define it, making it a known
    value. Why **1122334455667788**? This is simply a common default used in password
    crackers. The only key factor here is that we can predict the challenge, so, in
    theory, you can make this number whatever you want. I’m leaving it as the default
    so I don’t have to toy around with the cracker configuration later, but something
    to consider is whether an observant administrator would notice predictable challenges
    being used. Seeing a server challenge of **1122334455667788** during an SMB authentication
    is a dead giveaway that you’re playing shenanigans on the network.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CHALLENGE**定义了在身份验证过程开始时发送的服务器挑战。你会记得，通过网络捕获的哈希并不像你在SAM中看到的裸哈希那样直接，它们是密码的等效物。它们在挑战-响应机制中被加密。这对我们意味着，我们需要使用相同的*挑战*（即通常是随机生成的数字）来破解捕获的哈希——因此我们定义它，使其成为已知值。为什么是**1122334455667788**？这只是密码破解工具中常用的一个默认值。这里唯一的关键因素是我们可以预测这个挑战，因此，从理论上讲，你可以将这个数字设置为任何你想要的。我保留默认值，以便不必在稍后的破解配置中费心，但需要考虑的是，一个细心的管理员是否会注意到使用了可预测的挑战。看到SMB身份验证中的服务器挑战是**1122334455667788**，就可以明确知道你正在网络上进行恶作剧。'
- en: '**JOHNPWFILE** is the same setting as **CAINPWFILE**, but for John the Ripper.
    I know what the 19th-century British historian in you is saying: “*His name was
    Jack the Ripper.*” I’m referring to the password cracker, usually called *John*
    for short. We will be exploring John later, as it is probably the most popular
    cracker out there. For now, I’ll define something here, as the John format is
    fairly universal, and it will make my cracking job easier.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JOHNPWFILE**与**CAINPWFILE**设置相同，但适用于John the Ripper。我知道你这位19世纪的英国历史学家会说：“*他的名字是开膛手杰克*。”我指的是密码破解工具John，通常简称为*John*。我们稍后会探讨John，因为它可能是目前最流行的破解工具。现在，我在这里定义一个设置，因为John的格式相当通用，这会让我的破解工作更轻松。'
- en: '**SRVHOST** defines the IP address of the listening host. It has to point to
    your attacking box. The default of **0.0.0.0** should be fine for most cases,
    but this can be helpful to define when we are attached via multiple interfaces
    with different assignments.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRVHOST**定义了监听主机的IP地址。它必须指向你的攻击主机。**0.0.0.0**的默认值对于大多数情况应该是可以的，但当我们通过多个接口连接并具有不同的分配时，定义它会有所帮助。'
- en: '**SRVPORT** defines the local listening port, and as you can imagine, we’d
    only change this in special situations. This should usually stay as the default
    of **445** (SMB over IP).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRVPORT**定义了本地监听端口，正如你所想的那样，我们只会在特殊情况下更改它。通常它应该保持默认值**445**（SMB通过IP）。'
- en: The challenge/response process described here is NTLMv1\. NTLMv2 has the added
    element of a client-side challenge. Crackers are aware of this, and our SMB capture
    module will show you the client challenge when it captures an authentication attempt.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的挑战/响应过程是NTLMv1。NTLMv2增加了客户端挑战的元素。破解者对此有所了解，我们的SMB捕获模块会在捕获身份验证尝试时显示客户端挑战。
- en: 'Let’s define **SRVHOST** to the IP address assigned to our interface. First,
    I’ll run **ifconfig** and grep out **inet** to see my IP address, as shown in
    the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将**SRVHOST**定义为分配给我们接口的IP地址。首先，我将运行**ifconfig**并使用grep提取出**inet**，以查看我的IP地址，如下图所示：
- en: '![Figure 4.2 – Using grep to conveniently display eth0''s IP address assignment
    ](image/Figure_4.02_B17616.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 使用grep方便地显示eth0的IP地址分配](image/Figure_4.02_B17616.jpg)'
- en: Figure 4.2 – Using grep to conveniently display eth0’s IP address assignment
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 使用grep方便地显示eth0的IP地址分配
- en: 'Using the **set** command, we define **SRVHOST** with our IP address – that’s
    it. Even though this isn’t technically an exploit, we use the same command to
    fire off our module, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**set**命令，我们将**SRVHOST**定义为我们的IP地址——就这么简单。尽管这 technically 不是一个漏洞利用，我们仍然使用相同的命令来启动我们的模块，如下图所示：
- en: '![Figure 4.3 – Configuring and then starting the SMB listener ](image/Figure_4.03_B17616.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 配置并启动SMB监听器](image/Figure_4.03_B17616.jpg)'
- en: Figure 4.3 – Configuring and then starting the SMB listener
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 配置并启动SMB监听器
- en: And there you have it. The SMB listener runs in the background so you can keep
    working. The listener is running and all you need is to point a target at your
    IP address.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。SMB 监听器在后台运行，你可以继续工作。监听器正在运行，你只需要将目标指向你的 IP 地址。
- en: 'Check out the HTTP method for capturing NTLM authentication. Follow the same
    steps, except issue the following command at the MSF console prompt instead:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查看用于捕获 NTLM 身份验证的 HTTP 方法。遵循相同的步骤，只需在 MSF 控制台提示符下输入以下命令：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create an HTTP link so the user will authenticate within their browser,
    which is potentially useful in certain social engineering scenarios. You can even
    SSL-encrypt the session.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 HTTP 链接，用户将在浏览器中进行身份验证，这在某些社会工程学场景中可能会非常有用。你甚至可以对会话进行 SSL 加密。
- en: Authentication capture
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证捕获
- en: 'By Jove, we have a hit! The screen lights up with the captured authentication
    attempts:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 天呐，成功了！屏幕上显示了捕获的身份验证尝试：
- en: '![Figure 4.4 – Capturing the network credentials with our listener ](image/Figure_4.04_B17616.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 使用我们的监听器捕获网络凭证](image/Figure_4.04_B17616.jpg)'
- en: Figure 4.4 – Capturing the network credentials with our listener
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 使用我们的监听器捕获网络凭证
- en: 'We can open up our John capture file in nano to see the output formatted for
    cracking. Keep in mind, the module will name your John file with the name you
    specified as **JOHNPWFILE** and will concatenate the detected hashing algorithm.
    It does this so you can attack any different captured sets independently without
    sorting them first:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 nano 中打开我们的 John 捕获文件，查看格式化后的破解输出。请记住，该模块会将 John 文件命名为你指定的 **JOHNPWFILE**，并会附加检测到的哈希算法。这样做是为了让你可以独立攻击任何不同的捕获数据集，而无需先对其进行排序：
- en: '![Figure 4.5 – John-formatted credentials ](image/Figure_4.05_B17616.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – John 格式化的凭证](image/Figure_4.05_B17616.jpg)'
- en: Figure 4.5 – John-formatted credentials
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – John 格式化的凭证
- en: In this example, the target is sending us NTLMv2 credentials. Later in the book,
    we’ll discuss downgrading the security during post-exploitation on the compromised
    host so that we can nab weak hashes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，目标正在向我们发送 NTLMv2 凭证。稍后在本书中，我们将讨论在已攻陷主机的后期利用中如何降低安全性，以便捕获弱哈希。
- en: 'This attack worked, but there’s one nagging problem with it: we had to trick
    the device into trying to authenticate with our Kali machine. With the printer,
    we had to modify its configuration, and a successful attack means lost data for
    the unsuspecting user, requiring our timing to be impeccable if we want the anomaly
    to be ignored. Let’s examine another way to capture Windows authentication attempts,
    except this time, we’re going to capture credentials while a system is looking
    for local shares.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击成功了，但有一个困扰我们的问题：我们必须欺骗设备让它尝试与我们的 Kali 机器进行身份验证。对于打印机，我们必须修改其配置，而成功的攻击意味着无辜用户的数据丢失，如果我们希望异常被忽视，我们的时机必须完美无缺。让我们研究另一种捕获
    Windows 身份验证尝试的方法，这次我们将在系统查找本地共享时捕获凭证。
- en: Hash capture with LLMNR/NetBIOS NS spoofing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 LLMNR/NetBIOS NS 欺骗捕获哈希
- en: Windows machines are brothers, always willing to help out when a fellow host
    is feeling lost and lonely. We’re already used to relying on DNS for name resolution.
    We’re looking for a name, we query our DNS server, and if the DNS server doesn’t
    have the record matching the request, it passes it along to the next DNS server
    in line. It’s a hierarchical structure and it can go all the way up to the highest
    name authorities of the entire internet. Local Windows networks, on the other
    hand, are part of a special club. When you share the same local link as another
    Windows computer, you can broadcast your name request and the other Windows boxes
    will hear it and reply with the name if they have it. Packets of this protocol
    even have a DNS-like structure. The main difference is it isn’t hierarchical;
    it is only link-local, and it can’t traverse routers (can you imagine the large-scale
    **distributed denial of service** (**DDoS**) attacks if it could?) This special
    Windows treat is called **LLMNR**, which has a predecessor called **NetBIOS NS**.
    It doesn’t have to be *ON*, and secure networks should be disabling it via group
    policy to let DNS do its job. However, it’s very commonly overlooked.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 计算机就像兄弟一样，总是愿意在另一个主机迷失和孤单时提供帮助。我们已经习惯依赖 DNS 进行名称解析。我们要查找一个名字，查询我们的 DNS
    服务器，如果 DNS 服务器没有匹配的记录，它会将请求转发给下一个 DNS 服务器。它是一个层级结构，最远可以到达整个互联网的最高名称权限。另一方面，本地
    Windows 网络是一个特别的俱乐部。当你和另一台 Windows 计算机共享同一本地链路时，你可以广播你的名称请求，其他 Windows 计算机会听到并返回名称（如果它们有的话）。这种协议的数据包甚至具有类似
    DNS 的结构。主要的不同在于它不是层级的；它仅限于链路本地，并且无法穿越路由器（你能想象如果它能穿越路由器，会造成大规模的 **分布式拒绝服务攻击** (**DDoS**)
    吗？）这种特殊的 Windows 功能叫做 **LLMNR**，它的前身是 **NetBIOS NS**。它不一定要*开启*，安全网络应该通过组策略禁用它，让
    DNS 执行其工作。然而，它往往被忽视。
- en: 'I know what the hacker in you is saying: “*Since LLMNR and NetBIOS NS are broadcast
    protocols and rely on responses from machines sharing the link, we should be able
    to forge replies that point a requestor to an arbitrary local host.*” An excellent
    point! And since we’re talking about local Windows resources, redirecting a request
    for a file share to our listener is going to cause the victim to authenticate,
    except this time we wait for the target to initiate the communication – no social
    engineering tricks required here.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你心里的黑客在说：“*既然 LLMNR 和 NetBIOS NS 是广播协议，并依赖于共享链路的机器的响应，我们应该能够伪造回复，将请求指向任意本地主机。*”
    这是一个很好的观点！既然我们在讨论本地 Windows 资源，将对文件共享的请求重定向到我们的监听器将导致受害者进行身份验证，唯一不同的是这次我们等待目标发起通信——这里不需要社交工程技巧。
- en: 'Let’s get straight to it. There are a few ways to do this, including with Metasploit.
    But I’ll show you the real quick-and-dirty way of doing this in Kali: with **Responder**,
    a straightforward **Python** tool that will simply listen for these specially
    formatted broadcasts and kick back a spoofed answer. Remember, we’re listening
    for broadcasts – no promiscuous sniffing, no ARP spoofing, no man-in-the-middle
    at all. We’re just listening for messages that are actually intended for everyone
    on the subnet, by design.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始吧。实现这一点有几种方法，包括使用 Metasploit。但我将展示在 Kali 中一种快速简便的方法：使用 **Responder**，一个简单的
    **Python** 工具，它只会监听这些特殊格式的广播并返回伪造的答案。记住，我们是在监听广播——不进行任意嗅探、不做 ARP 欺骗、也不涉及中间人攻击。我们只是监听那些按设计实际上是发给子网内所有人的消息。
- en: 'Fire up Responder’s help page to review its features with the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Responder 的帮助页面，使用以下命令查看其功能：
- en: responder -h
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: responder -h
- en: 'Set your interface and Responder does the rest. However, take a look at the
    **–-lm** option. It lets us do the following: “*Force LM hashing downgrade for
    Windows XP/2003 and earlier.*” You’re probably thinking, “*my targets are going
    to be running Windows 10 or 7 – surely, that won''t work anymore?*” I wish this
    was entirely correct, but there are two considerations here. For one, remember
    the backward compatibility needs that are still surprisingly common; but also,
    keep in mind that this flag often forces a downgrade to some aspect of the communication.
    For example, in the first edition of this book, we showed how this feature forced
    a downgrade to NTLMv1\. Today, using Windows 10 in our lab, we found that Responder
    was successful in downgrading from SMBv2 to the older (and less secure) SMBv1\.
    One of the most important hacking life lessons is that most of our successes are
    just the culmination of many tiny successes.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的接口，Responder 会做其余的。不过，看看 **–-lm** 选项。它允许我们执行以下操作：“*强制 Windows XP/2003 及更早版本使用
    LM 哈希降级*。”你可能会想，“*我的目标运行的是 Windows 10 或 7——那应该不再有效了吧？*”我希望这是完全正确的，但这里有两个因素。首先，记住向后兼容性的需求仍然非常常见；其次，记住这个标志通常会迫使通信降级到某个方面。例如，在本书的第一版中，我们展示了如何使用此功能将通信降级到
    NTLMv1。今天，在我们的实验室中使用 Windows 10，我们发现 Responder 成功地将 SMBv2 降级到了较旧且不那么安全的 SMBv1。一个最重要的黑客人生课程就是，我们的大多数成功，实际上只是许多小成功的积累。
- en: 'With that in mind, I’m going to set up my listener with the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我将使用以下命令设置我的监听器：
- en: responder –I eth0 --lm
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: responder –I eth0 --lm
- en: 'The first thing we see is a summary of the enabled and disabled features. If
    you like the look of some of these, take some time to play with them. For example,
    Responder makes a great quick-and-dirty plain HTTP credentials harvester. Let’s
    see what it looks like when we start capturing events:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到的是已启用和已禁用功能的概述。如果你喜欢这些功能中的某些，可以花时间玩一玩它们。例如，Responder 是一个很棒的快速简便的纯 HTTP
    凭证收集工具。让我们看看开始捕获事件时的样子：
- en: '![Figure 4.6 – Poisoning events captured live by Responder ](image/Figure_4.06_B17616.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – Responder 捕获的中毒事件实时展示](image/Figure_4.06_B17616.jpg)'
- en: Figure 4.6 – Poisoning events captured live by Responder
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – Responder 捕获的中毒事件实时展示
- en: Meanwhile, back at our target PC – oh, dagnabbit! I fat-fingered the name of
    the printer file share I need to access. Oh well, I guess I’ll try again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在我们的目标计算机上——哦，天哪！我打错了我需要访问的打印机共享文件的名称。唉，算了，我再试一次。
- en: '![Figure 4.7 – What our victim sees ](image/Figure_4.07_B17616.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 受害者看到的内容](image/Figure_4.07_B17616.jpg)'
- en: Figure 4.7 – What our victim sees
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 受害者看到的内容
- en: 'Meanwhile, back at our attacking Kali box – excellent, we have ourselves an
    NTLMv2 authentication attempt. The only downside to this tool is it doesn’t take
    the time to gift-wrap the goodies for our dear friend John, so prepare this input
    for your cracker accordingly. Here’s what Responder presents to us. Note that
    we can just copy and paste out of this window:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在我们的攻击 Kali 服务器上——太好了，我们得到了一个 NTLMv2 认证尝试。这个工具的唯一缺点是它没有花时间将好东西精心包装给我们的亲爱的朋友
    John，所以请相应地准备输入给你的破解工具。以下是 Responder 给我们展示的内容。请注意，我们可以直接从这个窗口复制和粘贴：
- en: '![Figure 4.8 – LLMNR poisoned answer grabbing credentials ](image/Figure_4.08_B17616.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – LLMNR 中毒响应抓取凭证](image/Figure_4.08_B17616.jpg)'
- en: Figure 4.8 – LLMNR poisoned answer grabbing credentials
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – LLMNR 中毒响应抓取凭证
- en: You probably noticed that we did not define a server challenge! That’s right,
    we didn’t. The challenge was randomly generated, and you’ll want to make sure
    your cracker is using the right challenge value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们没有定义服务器挑战！没错，我们没有。挑战是随机生成的，你需要确保你的破解工具使用正确的挑战值。
- en: We’ve looked at nabbing Windows hashes off the network. Now, we have some juicy-looking
    credentials to break open and hopefully leverage to log in to all kinds of services,
    as we know how insidious password reuse is, no matter how good your pen test client’s
    training might be. Let’s move on to the art of password cracking.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何从网络中抓取 Windows 哈希。现在，我们有了一些看起来相当诱人的凭证，期待着破解它们，并希望能够用来登录各种服务，毕竟我们都知道密码重用有多么狡猾，不管你在渗透测试客户的培训多么好。接下来，让我们进入密码破解的艺术。
- en: Let it rip – cracking Windows hashes
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始破解——破解 Windows 哈希
- en: Password cracking was always one of my favorite parts of any assessment. It’s
    not just the thrill of watching tens of thousands of accounts succumb to the sheer
    power of even a modest PC – it is among the most useful things you can do for
    a client. Sure, you can conduct a pen test and hand over a really nice-looking
    report, but it’s the impact of the results that can mean the difference between
    bare-minimum compliance and an actual effort to effect some change in the organization.
    Nothing says “impact” quite like showing the executives of a bank their personal
    passwords.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 密码破解一直是我每次评估中最喜欢的部分之一。不仅仅是看着数以万计的账户屈服于即使是一台普通的个人电脑也具备的强大计算能力的刺激 – 对客户而言，这是你可以做的最有用的事情之一。当然，你可以进行渗透测试并交出一份外观漂亮的报告，但真正影响的是结果，它可能是区别于仅仅遵从最低合规标准和真正努力影响组织变革之间的差异。对一家银行的高管展示他们个人密码绝对是最能体现“影响力”的事情之一。
- en: 'There are some fundamentals we need to understand before we look at the tools.
    We need to understand what the hash cracking effort really is and apply some human
    psychology to our strategy. This is another aspect of password cracking that makes
    it so fun: the science and art of understanding how people think.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看工具之前，有一些基础知识我们需要了解。我们需要了解哈希破解的实际工作是什么，并将一些人类心理学应用到我们的策略中。这是密码破解的另一个方面，使其如此有趣：科学和艺术如何理解人们的思维方式。
- en: The two philosophies of password cracking
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码破解的两种哲学
- en: 'You’ll see two primary methodologies for password cracking – *dictionary* and
    *brute-force*. The distinction is somewhat of a misnomer; a hash function is a
    one-way function, so we can’t actually defeat the algorithm to find an original
    text – we can only find collisions (one of which will be the original text). There
    is no way around this needle-in-a-haystack effort, so really, any tactic is technically
    a use of brute-force computing speed. So, in this context:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到两种主要的密码破解方法 – *字典* 和 *暴力破解*。这种区分有点名不副实；哈希函数是单向函数，所以我们实际上无法击败算法找到原始文本 – 我们只能找到碰撞（其中一个将是原始文本）。在这个大海捞针的工作中，没有捷径，因此，任何策略从技术上讲都是利用暴力计算速度。因此，在这种情况下：
- en: '**Dictionary attack**: This employs a predefined list of values to hash. This
    list is often called a **dictionary** or a **wordlist**. Wordlists can be employed
    as defined, where every single entry is tried until the wordlist is exhausted,
    or it can be modified with rules, making the attack a hybrid attack. Rules apply
    specific modifications to the wordlist to search for variants of the original
    word. For example, imagine the wordlist entry is **password**. A rule may tell
    the cracker to try capitalizing the initial letter and then adding a number, **0-9**,
    to the end. This will increase the actual wordlist being searched to include **password1**,
    **password2**, and so on. When we consider password-creating habits and human-friendly
    adaptations to corporate password policy, rulesets tend to be our golden ticket
    to success in cracking. Be careful with the word *dictionary*, as this isn’t the
    same concept as the *English dictionary* sitting on your shelf. Suppose, for example,
    that a popular sitcom on TV has a joke that uses a made-up word like *shnerfles*.
    People watch the show, love the gag, and start incorporating the word into their
    passwords to make them memorable. Though you won’t see *shnerfles* in the English
    dictionary, any smart password cracker has already incorporated the word into
    their wordlist.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典攻击**：这种攻击使用预定义的数值列表进行哈希。这个列表通常被称为**字典**或**字典文件**。可以按照定义使用字典，直到字典文件耗尽为止，或者可以使用规则对其进行修改，使攻击变成混合攻击。规则会对字典应用特定的修改，以搜索原始单词的变体。例如，想象一下，字典文件中的条目是**password**。一条规则可能会告诉破解者尝试将初始字母大写，然后在末尾添加一个数字，**0-9**。这将扩展实际搜索的字典文件，包括**password1**、**password2**等等。当我们考虑到密码创建习惯和人性化适应企业密码政策时，规则集往往是我们成功破解的黄金钥匙。对于单词*字典*要小心，因为这与你书架上的*英语词典*不同。例如，假设电视上的一部流行情景喜剧使用了一个虚构的词*shnerfles*作为笑话。人们观看节目，喜欢这个笑话，并开始在他们的密码中加入这个词以便记住密码。尽管*shnerfles*不会出现在英语词典中，但任何聪明的密码破解者早已将这个词包含在他们的字典文件中。'
- en: '**Brute-force attack**: This puts together the full list of all possible combinations
    of a given character set. By its nature, a plain brute-force attack can take a
    very long time to complete. Whereas. with dictionary attacks, we used *rulesets*
    to enhance the attacks, we can modify the guesses of a brute-force attack with
    *masking*. Masking allows us to define different character sets to be used for
    certain positions in the password, greatly narrowing down the search space. For
    example, let’s say we want to search for any combination of letters, not just
    words that may be found in a wordlist, but we assume the user capitalized the
    first letter, and then added a couple of numbers to the end. In this example,
    the mask would set a capital letter character set for the first character position,
    followed by both uppercase and lowercase for the remaining letters, and then only
    digits for the last two character positions. To get an idea of what this can do
    to a search, let’s suppose we’re looking for a 10-character password, and the
    available characters are **a**-**z**, **A**-**Z**, **0**-**9**, and the 13 symbols
    along the top of the keyboard. Then, let’s apply a mask that only searches for
    a capital initial letter, and only numbers for the last two characters:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴力破解攻击**：这将组合出给定字符集的所有可能组合。按其本质，纯暴力破解攻击可能需要很长时间才能完成。而对于字典攻击，我们使用*规则集*来增强攻击，我们可以通过*掩码*修改暴力破解攻击的猜测。掩码允许我们为密码的某些位置定义不同的字符集，从而大大缩小搜索空间。例如，假设我们要查找任何字母组合，不仅仅是可能出现在字典列表中的单词，但我们假设用户将第一个字母大写，然后在末尾加了几个数字。在这个例子中，掩码会为第一个字符位置设置大写字母字符集，接下来的字母可以是大写或小写字母，最后两个字符位置只能是数字。为了更好地理解这能对搜索产生的影响，假设我们要查找一个10字符的密码，可用字符为**a**-**z**、**A**-**Z**、**0**-**9**，以及键盘上方的13个符号。那么，我们将应用一个掩码，只搜索以大写字母开头，并且最后两个字符只能是数字的密码。'
- en: '**Without mask**: **((26 * 2) + 10 + 13) ^ 10 = 5.6313515 * 10^18** (about
    5.63 quintillion passwords)'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有掩码**：**((26 * 2) + 10 + 13) ^ 10 = 5.6313515 * 10^18**（大约 5.63 quintillion个密码）'
- en: '**With mask**: **26 * (75^7) * (10^2) = 3.4705811 * 10^16** (about 34.7 quadrillion
    passwords)'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有掩码**：**26 * (75^7) * (10^2) = 3.4705811 * 10^16**（大约 34.7 quadrillion个密码）'
- en: 'You might be looking at that and thinking, “*those are both enormous numbers.*”
    But with a very simple mask – a single capital letter at the front and two digits
    at the end – we reduced the search space by more than 99.3%. If we had the processing
    power that would crunch the unmasked space in four days, our mask would reduce
    that to about 36 minutes. As you can see, masking is to brute-force cracking what
    rulesets are to dictionary attacks: essentially a golden ticket to success when
    you dump hashes from a domain controller on your client’s network.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看着这个数字想，“*这两个数字都太大了*。”但通过一个非常简单的掩码——前面一个大写字母，后面两个数字——我们将搜索空间减少了超过99.3%。如果我们拥有足够的计算能力，能够在四天内处理未加掩码的空间，使用这个掩码后，我们将把时间缩短到大约36分钟。如你所见，掩码对暴力破解的作用，就像规则集对字典攻击的作用一样：在你将哈希值从域控制器导出到客户网络时，它基本上是成功的金钥。
- en: The key point with both modification methods is to target the *psychological
    factors* of password selection. With known words, not many people will use a word
    without changing some character in a memorable way (and, in fact, many corporate
    password policies simply won’t allow unmodified dictionary words). With brute-force
    attacks, very few people will choose **kQM6R#ah*p** as a password, but our unmasked
    10-character search described just now will check it as well as quadrillions of
    other unlikely choices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 两种修改方法的关键点在于针对密码选择的*心理因素*。对于已知的词汇，很少有人会在不改变某个字符的情况下使用一个单词（实际上，许多公司密码政策根本不允许未修改的词典单词）。对于暴力破解攻击，极少有人会选择**kQM6R#ah*p**作为密码，但我们刚才描述的未加掩码的10字符搜索将检查它以及其他数万亿个不太可能的选择。
- en: Whereas rules *increase* the search space of a dictionary attack, masks are
    designed to *reduce* the search space of a brute-force attack.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 而规则*增加*了字典攻击的搜索空间，掩码的设计目的是*减少*暴力破解攻击的搜索空间。
- en: John the Ripper cracking with a wordlist
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典列表进行John the Ripper破解
- en: Finding the right wordlist and building your own is a hefty topic in its own
    right. Thankfully, Kali has some wordlists built in. For our demonstration, we’ll
    work with the **rockyou** wordlist – it’s popular and it’s quite large. I recommend,
    however, that you always consider it a general-purpose wordlist. Carrying around
    **rockyou** by itself and expecting to be a password cracker is like carrying
    around a single screwdriver and expecting to be a repairman. Sure, you’ll encounter
    the occasional job where it works fine, but you’ll come across screws of different
    sizes, and you’ll need the right tool for the job. When I was working with clients,
    I had many lists, and it wasn’t unusual for me to build new ones on the road.
    When I was working with businesses in Ohio, I made sure **buckeyes** was in my
    wordlist. Similarly, when I was working with businesses in Michigan, I made sure
    **spartans** was in my wordlist. These words are the names of sports teams – midwestern
    Americans love their football, and while policy won’t let them get away with just
    those words by themselves, cracking on those two words and then hybridizing the
    attack with a ruleset yielded me a lot of passwords. Of course, **rockyou** and
    any other wordlist is nothing more than a glorified text file. So, add stuff whenever
    it occurs to you!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 找到合适的词典并构建你自己的词典是一个大话题。幸运的是，Kali内置了一些词典。对于我们的演示，我们将使用**rockyou**词典——它很流行，而且相当庞大。不过，我建议你始终将其视为通用词典。仅携带**rockyou**并期望自己能成为密码破解者，就像携带一把单一的螺丝刀并期待成为维修工人一样。当然，你会遇到偶尔适用的情况，但你会遇到不同大小的螺丝，你需要合适的工具来完成工作。当我为客户工作时，我有很多词典，而且我常常在路上建立新的词典。当我为俄亥俄州的公司工作时，我确保**buckeyes**出现在我的词典中。同样地，当我为密歇根州的公司工作时，我确保**spartans**出现在我的词典中。这些词是运动队的名字——中西部的美国人热爱他们的橄榄球，虽然政策不会让他们仅仅凭借这些词就能通过，但我通过破解这两个词并将攻击与规则集混合使用，获得了大量的密码。当然，**rockyou**和任何其他词典不过是一个被美化的文本文件。所以，每当想到时，尽管添加内容！
- en: 'Kali keeps wordlists in **/usr/share/wordlists**, so let’s head over there
    and unzip **rockyou**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kali将词典保存在**/usr/share/wordlists**中，所以让我们去那里并解压**rockyou**：
- en: '![Figure 4.9 – Extracting the rockyou wordlist ](image/Figure_4.09_B17616.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 提取rockyou词典](image/Figure_4.09_B17616.jpg)'
- en: Figure 4.9 – Extracting the rockyou wordlist
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 提取rockyou词典
- en: 'Now that we have a wordlist, it’s time to check out where all the magic is
    defined for John – in his configuration file. Run this command to open it up in
    nano, keeping in mind that it’s a very large file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个词典，是时候查看John的配置文件，了解所有的“魔法”定义了什么。运行这个命令在nano中打开它，记住它是一个非常大的文件：
- en: nano /etc/john/john.conf
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nano /etc/john/john.conf
- en: 'There’s a lot going on here, and I encourage you to read the fine manual –
    but the juicy stuff is near the bottom, where the rulesets are defined. The convention
    is: **[list.rules:NAME]**, where **NAME** is the ruleset name you’d define in
    the command line. You can even nest rulesets inside other rulesets with **.include**.
    This will save you time when you want to define custom rules but need the basics
    included as well:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容，我鼓励你阅读详细手册——但最重要的部分在底部，那里定义了规则集。约定是：**[list.rules:NAME]**，其中**NAME**是你在命令行中定义的规则集名称。你甚至可以使用**.include**将规则集嵌套在其他规则集中。当你需要定义自定义规则但又需要包含基础规则时，这将节省你的时间：
- en: '![Figure 4.10 – Reviewing the John configuration file ](image/Figure_4.10_B17616.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 查看John配置文件](image/Figure_4.10_B17616.jpg)'
- en: Figure 4.10 – Reviewing the John configuration file
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 查看John配置文件
- en: 'Let’s be honest, the rules syntax looks Martian when you first encounter it.
    Expertise in John rules syntax is out of scope for this discussion, but I recommend
    checking out the comments in the configuration file and experimenting with some
    basics. The **Single** ruleset does some useful modifications for us and doesn’t
    take too long to run on a fast CPU, so let’s give it a shot with the hash we nabbed
    from the network:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坦诚一点，当你第一次遇到规则语法时，它看起来就像外星语言。掌握John规则语法超出了本讨论的范围，但我建议你查看配置文件中的注释，并尝试一些基础知识。**Single**规则集为我们做了一些有用的修改，并且在快速的CPU上运行并不需要太长时间，所以让我们尝试一下用从网络上获取的哈希值：
- en: '![Figure 4.11 – Running John against our captured hash ](image/Figure_4.11_B17616.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 用John破解我们捕获的哈希](image/Figure_4.11_B17616.jpg)'
- en: Figure 4.11 – Running John against our captured hash
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 用John破解我们捕获的哈希
- en: '**--wordlist** defines the dictionary file (that is, **rockyou**, in our demonstration).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--wordlist**定义了字典文件（也就是我们演示中的**rockyou**）。'
- en: '**--rules** defines the ruleset, which is itself defined in **john.conf**.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--rules** 定义了规则集，该规则集在 **john.conf** 中进行了定义。'
- en: '**--format** is the hash type that’s being imported (in our case, it’s **NetNTLMv2**).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--format** 是导入的哈希类型（在我们的案例中是 **NetNTLMv2**）。'
- en: Cracked passwords appear on the left and their corresponding usernames are in
    parentheses to the right. You can tap any key (except for *q*, which will quit)
    to see a cracking status, complete with the percentage of completion and the estimated
    local time of completion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 破解的密码显示在左侧，右侧是对应的用户名，括号中注明。你可以按任意键（除了 *q*，它会退出）查看破解状态，包括完成百分比和预计完成的本地时间。
- en: John the Ripper cracking with masking
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 John the Ripper 破解与掩码
- en: We can use masking to target specific patterns without a wordlist. Masks follow
    a simple syntax where each character pattern type is defined with either a range
    or a placeholder with a question mark. For example, an uppercase (ASCII) letter
    would be defined with **?u**, which would then be placed in the desired character
    position.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用掩码来定位特定模式，而无需使用字典列表。掩码遵循简单的语法，每个字符模式类型都通过范围或带有问号的占位符来定义。例如，大写字母（ASCII）将用
    **?u** 来定义，然后将其放置在所需的字符位置。
- en: 'Let’s look at some examples:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一些示例：
- en: '![Table 4.2 – Masking examples ](image/B17616_04_Table_4.2.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![表格 4.2 – 掩码示例](image/B17616_04_Table_4.2.jpg)'
- en: Table 4.2 – Masking examples
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4.2 – 掩码示例
- en: A special type of masking is *stacking*, where we hybridize dictionary cracking
    with masking. The syntax is like ordinary masking, except our **?w** placeholder
    defines the individual word in the list. For example, defining a wordlist with
    **--wordlist=** and then defining a mask with **?w?d?d?d?d** would take an individual
    word from the wordlist and look for all combinations of that word with four digits
    on the end.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的掩码是 *堆叠*，它将字典破解与掩码结合起来。语法与普通掩码类似，只不过我们的 **?w** 占位符定义了列表中的单个单词。例如，使用 **--wordlist=**
    定义一个单词列表，然后用 **?w?d?d?d?d** 定义一个掩码，这样就会从单词列表中取出一个单词，并查找该单词与四个数字组合的所有可能性。
- en: Reviewing your progress with the show flag
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用展示标志回顾你的进展
- en: Although John shows us plenty of data during the cracking effort, it’s nice
    to know that our results are automatically being saved somewhere so we can review
    them in a nice clean format. John makes management of large input files a snap
    by putting aside cracked hashes when we start up John again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 John 在破解过程中会显示大量数据，但知道我们的结果会自动保存在某个地方，以便我们可以以干净的格式查看它们，还是很不错的。John 通过在我们重新启动
    John 时将破解的哈希值存档，使得大规模输入文件的管理变得轻而易举。
- en: For example, let’s say we’re working on 25 hashes, and we only have 5 hours
    today to crack them, but we can continue tomorrow for several more hours. We can
    set up our attack, let John run for 5 hours, and then abort with *q* or *Ctrl*
    + *C*. Suppose we recovered 10 passwords in that time. When we fire up John tomorrow,
    the 10 passwords are already set aside, and John goes to work on the remaining
    15.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在破解 25 个哈希值，而今天我们只有 5 个小时来破解它们，但明天我们可以继续工作几个小时。我们可以设置攻击，让 John 运行 5
    小时，然后用 *q* 或 *Ctrl* + *C* 中止。假设在这段时间内我们恢复了 10 个密码。当我们明天重新启动 John 时，这 10 个密码已经被单独保存，John
    将开始破解剩余的 15 个。
- en: 'Instead of having an output file that we would review separately, John is designed
    to let us review results with the **--show** flag:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与其拥有一个我们单独查看的输出文件，John 被设计为让我们通过 **--show** 标志直接查看结果：
- en: '![Figure 4.12 – The John show flag ](image/Figure_4.12_B17616.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – John 展示标志](image/Figure_4.12_B17616.jpg)'
- en: Figure 4.12 – The John show flag
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – John 展示标志
- en: Export this data into an **Excel** spreadsheet as colon-delimited data, and
    you have a head start on managing even massive cracking projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数据导出为 **Excel** 电子表格，使用冒号分隔数据，这样你就能为管理即使是大规模的破解项目提供提前的支持。
- en: Here, kitty kitty – getting started with Hashcat
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 喵喵喵 – 开始使用 Hashcat
- en: Despite all of our work with John, I have to be honest – I don’t even use it
    anymore. By far the best all-purpose password cracker is **Hashcat**, and it’s
    included with Kali. You might wonder why I didn’t just open with Hashcat if it’s
    the best. Well, today’s best stand on the shoulders of yesterday’s champions,
    and John is the perfect introduction to understanding how cracking works. Hashcat
    is there for you when you’re ready to take it to the next level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们花了大量时间与 John 一起工作，但我必须坦诚—我现在甚至不再使用它了。迄今为止，最强大的通用密码破解工具是 **Hashcat**，它已包含在
    Kali 中。你可能会想，既然 Hashcat 是最好的，为什么我不一开始就使用它呢？嗯，今天最好的工具站在昨天的冠军肩膀上，而 John 是理解破解工作原理的完美入门工具。等你准备好迎接下一个层次时，Hashcat
    会为你提供支持。
- en: What’s so special about Hashcat? The primary advantage is raw speed – Hashcat
    is just faster thanks to its hardware optimizations. If you have slower hardware
    and you’re trying to eke out every last hash-per-second it has to offer, Hashcat
    is for you. On the other hand, for those of you with powerhouse PCs, Hashcat’s
    ability to leverage GPU power will blow you away. If you have Kali installed on
    a gaming laptop, fasten your seatbelt.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Hashcat 有什么特别之处？主要优势就是其原始速度——Hashcat 因其硬件优化而更加快速。如果你有较慢的硬件，并且试图挤出每一秒的哈希值，Hashcat
    非常适合你。另一方面，如果你有一台强大的 PC，Hashcat 利用 GPU 性能的能力将令你震撼。如果你在游戏笔记本上安装了 Kali，那就系好安全带吧。
- en: 'First, we’ll fire off the help page – this cracker is beastly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将启动帮助页面——这个破解工具非常强大：
- en: '[PRE1]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Yeah, that’s a wall of information. Don’t be intimidated – it’s very logical,
    and when you get used to it, the flexibility of this feature set is amazing. The
    primary concepts you need to be aware of are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个信息墙。不要感到害怕——它非常合乎逻辑，一旦你习惯了，它的功能灵活性将让你惊讶。你需要了解的主要概念如下：
- en: Attack mode
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击模式
- en: Hash mode
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希模式
- en: Wordlist/charset/rules
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词表/字符集/规则
- en: The *hash mode* refers to the type of hash you’re cracking. Hashcat accepts
    a truly impressive number of hash types, so make sure you review the help page
    for the full range. You’ll quickly discover that it isn’t just hashes – you can
    even try a locked **PDF** or a locked **7-Zip** file. We’ve been studying Net-NTLMv2
    in our preceding example, so we’ll be using hash mode **5600** today.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希模式* 指的是你正在破解的哈希类型。Hashcat 支持的哈希类型种类繁多，所以确保查看帮助页面，了解完整的哈希类型范围。你会很快发现，它不仅仅是哈希——你甚至可以尝试破解被锁定的
    **PDF** 或 **7-Zip** 文件。我们在前面的例子中已经研究了 Net-NTLMv2，所以今天我们将使用哈希模式 **5600**。'
- en: Hashcat has two kinds of dictionary attack – *straight* and *combination*. *Combination
    attack mode* allows you to specify one or two wordlists, and it will combine the
    words found in each. For example, suppose someone’s password contains **hardlypickled**.
    You probably won’t find that in a wordlist (now that I have written it in this
    book, maybe it’ll appear in an updated one, but I digress). However, you will
    find **hardly** and **pickled** in wordlists for the English language, and the
    combination attack mode is what will find their combination in the password.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Hashcat 有两种字典攻击方式——*直攻*和*组合*。*组合攻击模式*允许你指定一个或两个词表，它会将每个词表中的单词组合在一起。例如，假设某人的密码包含
    **hardlypickled**。你可能不会在词表中找到这个单词（现在我在书中写了它，可能在更新的词表中会出现，但我偏题了）。然而，你会在英文词表中找到
    **hardly** 和 **pickled**，而组合攻击模式就是用来找到它们在密码中的组合的。
- en: '*Brute-force attack mode* is self-explanatory, but Hashcat does it exceptionally
    well. You’ll specify your charset and use a placeholder with a question mark (like
    we did with John) to specify the length. The placeholder code is intuitive – **?l**
    is all lowercase, **?u** is all uppercase, **?d** is digits, and **?s** is symbols.
    The **?a** means *all*, and it’s a combination of those four charsets. Straight
    and combination attacks are great, but this fine-tuned brute-force attack, coupled
    with the speed of a solid GPU, was how I cracked most of the passwords I encountered
    in my professional experience. As we discussed, human memory plays a primary role
    when it comes to cracking passwords. Let’s look at an example.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*暴力破解模式* 不言自明，但 Hashcat 在这方面表现得异常出色。你需要指定字符集，并使用问号占位符（像我们在 John 中使用的那样）来指定密码长度。占位符代码非常直观——**?l**
    表示所有小写字母，**?u** 表示所有大写字母，**?d** 表示数字，**?s** 表示符号。**?a** 表示 *全部*，它是这四种字符集的组合。直攻和组合攻击都很棒，但这种精细调优的暴力破解攻击，加上强劲
    GPU 的速度，就是我在职业生涯中破解大多数密码的方法。正如我们所讨论的，人在破解密码时的记忆起着主导作用。让我们来看个例子。'
- en: 'Let’s imagine that we want to capture as many 10-character passwords as possible
    with a brute-force attack. We know that the password policy requires at least
    one symbol, one number, and one capital letter. Though plenty of people will put
    the required symbol at any random position, *memorable* passwords are more likely
    to have it after a word or at the very end of the password. When it comes to numbers,
    there could be any number of digits – but *memorable* passwords will often have
    two or four digits to represent a meaningful year. And of course, that capital
    letter is likely to be the first character of the password. Knowing and assuming
    these things, let’s look at some possible commands:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过暴力破解攻击尽可能多地捕获 10 个字符的密码。我们知道密码策略要求至少包含一个符号、一个数字和一个大写字母。虽然很多人会将所需的符号放在任意位置，但*易记*的密码更可能将其放在单词后面或密码的最后。至于数字，可能会有任意数量的数字，但*易记*的密码通常会有两位或四位数字来表示一个有意义的年份。当然，大写字母很可能是密码的第一个字符。了解并假设这些情况后，让我们看看一些可能的命令：
- en: '**# hashcat -m 5600 –a 3 ntlm.txt ?u?a?a?a?a?s?d?d?d?d**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**# hashcat -m 5600 –a 3 ntlm.txt ?u?a?a?a?a?s?d?d?d?d**'
- en: '**# hashcat -m 5600 –a 3 ntlm.txt ?u?a?a?a?a?d?d?d?d?s**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**# hashcat -m 5600 –a 3 ntlm.txt ?u?a?a?a?a?d?d?d?d?s**'
- en: '**# hashcat –m 5600 –a 3 ntlm.txt ?u?a?a?a?a?a?a?d?d?s**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**# hashcat –m 5600 –a 3 ntlm.txt ?u?a?a?a?a?a?a?d?d?s**'
- en: All three will have an uppercase letter at the starting position. The first
    one will have a symbol after the word (which could be made up of letters, numbers,
    or symbols) followed by four digits. The second one puts the symbol after the
    four digits. The last one uses two digits.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种情况的密码在开头都会有一个大写字母。第一个密码会在单词后面（单词可以由字母、数字或符号组成）加上一个符号，后面跟四个数字。第二个密码则将符号放在四个数字后面。最后一个密码使用两个数字。
- en: Of course, these commands are only looking for passwords that are exactly 10
    characters long. With the **–i** flag set, you enable *increment mode*, which
    will search all of the lengths up to your mask length. If you use this, keep in
    mind that the **Status** window will show you the time estimates for the current
    length.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些命令仅查找正好 10 个字符长的密码。设置 **–i** 标志后，您启用了*增量模式*，该模式将搜索所有最大长度以内的密码。如果使用此功能，请记住，**状态**窗口会显示当前长度的时间估算。
- en: 'Once you get your attack started, hit the *s* key for a status update:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始攻击，按下 *s* 键以获取状态更新：
- en: '![Figure 4.13 – Hashcat wrapping up its attack ](image/Figure_4.13_B17616.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – Hashcat 完成其攻击](image/Figure_4.13_B17616.jpg)'
- en: Figure 4.13 – Hashcat wrapping up its attack
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – Hashcat 完成其攻击
- en: As a proper treatment of password cracking could be an entire book on its own,
    we aren’t finished with the topic here. We’ll look at raiding compromised hosts
    for hashes in [*Chapter 16*](B17616_16_Final_VK_ePub.xhtml#_idTextAnchor292),
    *Escalating Privileges*, so we’ll revisit cracking against large inputs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密码破解的正确处理方式本身可能是一整本书的内容，因此我们在这里并没有完成这个话题。我们将在[*第 16 章*](B17616_16_Final_VK_ePub.xhtml#_idTextAnchor292)《提升权限》中，探讨如何对被攻破的主机进行哈希值提取，因此我们会再次回顾如何在大规模数据输入下进行破解。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the fundamental theory behind Windows passwords
    and their hashed representations. We looked at both raw hashes as they’re stored
    in the SAM and encrypted network hashes. We then reviewed the fundamental design
    flaws that make Windows hashes such a lucrative target for the pen tester. The
    Metasploit framework was introduced for the first time to demonstrate auxiliary
    modules. We used the SMB listener module to capture authentication attempts from
    misled Windows targets on the network. We then demonstrated a type of link-local
    name service spoofing that can trick a target into authenticating against our
    machine. With the captured credentials from our demonstration, we moved on to
    practical password cracking with John the Ripper and Hashcat. We covered the two
    primary methodologies of password cracking with John and demonstrated ways to
    fine-tune attacks concentrating on human factors.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Windows 密码及其哈希表示的基本理论。我们查看了 SAM 中存储的原始哈希以及加密的网络哈希。接着，我们回顾了使 Windows
    哈希成为渗透测试人员极具吸引力目标的基本设计缺陷。首次介绍了 Metasploit 框架，演示了辅助模块。我们使用 SMB 监听模块来捕获来自网络中误导的
    Windows 目标的认证尝试。然后，我们演示了一种可以欺骗目标通过我们的机器进行身份验证的本地链接名称服务欺骗技术。通过从我们的演示中捕获的凭证，我们继续使用
    John the Ripper 和 Hashcat 进行实际的密码破解。我们介绍了 John 的两种主要密码破解方法，并演示了如何针对人的因素精细调整攻击。
- en: In the next chapter, we will move on to more sophisticated network attacks.
    We’ll dive into the finer details of Nmap for recon and evasion. We’ll look at
    routing attacks and software upgrade attacks, and we’ll cover a crash course in
    **IPv6** from a pen tester’s perspective.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更复杂的网络攻击。我们将深入了解Nmap在侦察和规避中的细节。我们将研究路由攻击和软件升级攻击，并且从渗透测试的角度讲解**IPv6**的相关内容。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions to test your knowledge of this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，以测试你对本章内容的掌握。
- en: A null input to a hash function produces a null output. True or false?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向哈希函数输入空值会产生空输出。对还是错？
- en: The ____ effect refers to the cryptographic property where a small change to
    the input value causes a radical change in the output value.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ____效应指的是密码学特性，其中对输入值的微小变化会导致输出值发生剧烈变化。
- en: What two design flaws would cause a 14-character password stored as an LM hash
    to be significantly easier to crack?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪两种设计缺陷会导致存储为LM哈希的14字符密码变得更容易破解？
- en: Why do we need to define the server challenge when capturing Net-NTLMv1?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在捕获Net-NTLMv1时我们需要定义服务器挑战？
- en: What is the predecessor to LLMNR?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLMNR的前身是什么？
- en: Dictionary rulesets decrease the search space, whereas masks increase the brute-force
    search space. True or false?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典规则集减少了搜索空间，而掩码则增加了暴力破解的搜索空间。对还是错？
- en: What mask would you use to find a five-character password that starts with two
    digits, then has a symbol, and the remaining two characters are uppercase or lowercase
    letters after **Q** (inclusive) in the alphabet?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到一个五个字符的密码，前两个字符是数字，接下来是一个符号，剩下的两个字符是字母（大写或小写），并且它们必须位于字母表中的**Q**（包含）之后，你会使用什么掩码？
- en: Jack the Ripper is the most popular password cracker. True or false?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jack the Ripper是最流行的密码破解工具。对还是错？
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取有关本章所涵盖主题的更多信息，请查看以下资源：
- en: 'Masking syntax for John the Ripper:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: John the Ripper的掩码语法：
- en: '[https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/MASK](https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/MASK)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/MASK](https://github.com/magnumripper/JohnTheRipper/blob/bleeding-jumbo/doc/MASK)'
- en: 'Rules syntax for John the Ripper:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: John the Ripper的规则语法：
- en: '[http://www.openwall.com/john/doc/RULES.shtml](http://www.openwall.com/john/doc/RULES.shtml)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.openwall.com/john/doc/RULES.shtml](http://www.openwall.com/john/doc/RULES.shtml)'
- en: 'Overview of the capture auxiliary modules in Metasploit:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit中捕获辅助模块的概述：
- en: '[https://www.offensive-security.com/metasploit-unleashed/server-capture-auxiliary-modules/](https://www.offensive-security.com/metasploit-unleashed/server-capture-auxiliary-modules/)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.offensive-security.com/metasploit-unleashed/server-capture-auxiliary-modules/](https://www.offensive-security.com/metasploit-unleashed/server-capture-auxiliary-modules/)'
