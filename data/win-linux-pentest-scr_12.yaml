- en: '*Chapter 14*: Fuzzing Techniques'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*: 模糊测试技术'
- en: What is fuzzing? You’ve already done some fuzzing as part of our exercises elsewhere
    in this book. When we were exploring our vulnerable C programs, we would fire
    up the GNU Debugger and watch the state of the registers as we threw more and
    more data at the user prompt. We were modifying our input with each iteration
    and trying to cause a crash or at least some anomalous behavior. The inputs to
    the program can be malformed in some sense – an invalid format, adding unexpected
    or invalid characters, or simply providing too much data. The fuzzing target doesn’t
    even have to be a program – it could be a network service implementing some particular
    protocol, or even the encoder that generates a file in a particular format, such
    as a PDF or JPG. If you’ve ever worked in software development, then the idea
    should be immediately familiar. Fuzzing can find flaws that could negatively impact
    the user experience, but for security practitioners, it’s a way to find exploitable
    flaws.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是模糊测试？你已经在本书的其他部分做过一些模糊测试。当我们探索我们易受攻击的C程序时，我们会启动GNU调试器（GDB），并观察寄存器的状态，同时不断向用户提示输入更多的数据。我们在每次迭代中都会修改输入，**尝试**引发崩溃或至少一些异常行为。程序的输入可以在某种意义上是格式错误的——无效的格式、添加意外或无效的字符，或者简单地提供过多的数据。模糊测试的目标甚至不一定是一个程序——它可以是实现某种特定协议的网络服务，甚至是生成特定格式文件（如PDF或JPG）的编码器。如果你曾经从事过软件开发，那么这个概念应该非常熟悉。模糊测试可以找到那些可能负面影响用户体验的缺陷，但对于安全从业人员来说，它是一种发现可利用漏洞的方式。
- en: In this chapter, we’re going to dive deeper into fuzzing as an exploit research
    methodology. We’ll explore two real-world programs with overflow vulnerabilities,
    but we won’t reveal any specifics. It’ll be up to us to discover the facts needed
    to write a working exploit for the programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨模糊测试作为一种漏洞研究方法。我们将研究两个具有溢出漏洞的真实程序，但不会透露具体细节。最终，发现编写有效漏洞利用程序所需事实的工作将由我们来完成。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mutation fuzzing over the network against a server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对服务器的网络变异模糊测试
- en: Writing Python fuzzers for both client and server testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Python模糊测试程序，进行客户端和服务器测试
- en: Debugging the target programs to monitor memory during fuzzing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试目标程序，以便在模糊测试过程中监控内存
- en: Using offset discovery tools to find the right size for our payloads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用偏移量发现工具来找到适合我们有效载荷的大小
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将需要以下工具：
- en: Kali Linux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: A 32-bit Windows 7 testing VM with WinDbg installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了WinDbg的32位Windows 7测试虚拟机
- en: Taof for Windows
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Taof for Windows
- en: nfsAxe FTP Client version 3.7 for Windows
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nfsAxe FTP客户端版本 3.7（适用于Windows）
- en: 3Com Daemon version 2r10 for Windows
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3Com Daemon 版本 2r10（适用于Windows）
- en: Network fuzzing – mutation fuzzing with Taof proxying
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络模糊测试 – 使用Taof代理的变异模糊测试
- en: So far, this book has been exploring attacking perspectives that can be applied
    in the field. Fuzzing, on the other hand, is not an attack in the usual sense
    of the word. It’s a testing methodology; for example, QA engineers fuzz user interfaces
    all the time. So, when do we leverage fuzzing as pen testers? As an example, suppose
    you’ve just completed some reconnaissance against your client’s systems. You find
    a service exposed to the internet and discover that it reveals its full version
    information in a banner grab. You would not want to start fuzzing this service
    on the production network, but you could get your hands on a copy and install
    it in your lab using the information you have acquired from the target. We’re
    going to take a look at some network fuzzing that you may just end up doing in
    your hotel room after the first couple of days with your client.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书一直在探讨可以应用于现场的攻击视角。另一方面，模糊测试（Fuzzing）并不是通常意义上的攻击。它是一种测试方法论；例如，质量保证（QA）工程师经常对用户界面进行模糊测试。那么，作为渗透测试人员，我们何时会利用模糊测试呢？举个例子，假设你刚刚完成了对客户系统的某些侦察工作。你发现有一个服务暴露在互联网上，并且发现它在横幅抓取中显示了其完整的版本信息。你**不**会想要在生产网络上开始对这个服务进行模糊测试，但你可以获取一份副本并利用你从目标系统中获得的信息将其安装到你的实验室中。我们将看一看一些网络模糊测试，你很可能会在和客户合作的前几天后，在酒店房间里进行这些测试。
- en: As the name suggests, mutation fuzzing takes a given set of data and mutates
    it piece by piece. We’re going to do something similar here with a special tool
    designed to make a true artist out of you. Taof is written in Python, so once
    you have the dependencies, it can be run in Linux. For this demonstration, I’m
    going to run it in Windows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，*突变模糊测试* 采用给定的数据集，并逐步对其进行突变。在这里，我们将使用一个专门的工具做类似的事情，这个工具能够让你成为一个真正的艺术家。Taof
    是用 Python 编写的，因此一旦你安装了依赖项，它就可以在 Linux 上运行。在本次演示中，我将会在 Windows 上运行它。
- en: In our demo, we’re running the target FTP server on its own Windows 7 host and
    the proxy fuzzer on a separate host. However, you can do the same testing with
    a single host if you don’t have access to two Windows 7 VMs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，我们将目标 FTP 服务器运行在单独的 Windows 7 主机上，将代理模糊测试器运行在另一个主机上。然而，如果你没有两个 Windows
    7 虚拟机的访问权限，你也可以使用单一主机进行相同的测试。
- en: Configuring the Taof proxy to target the remote service
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Taof 代理以连接到远程服务
- en: 'Let’s start by configuring the target service. This is simple with our demonstration:
    just execute 3Com Daemon and it will start its servers automatically. On the left-hand
    side, you’ll see the different services; select **FTP Server** and then check
    the status window on the right-hand side to confirm that the service is listening
    on port **21**. In our demonstration, we can see that the listener has detected
    the locally assigned address; that is, **192.168.108.189**. Now, we know where
    to point the proxy:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从配置目标服务开始。这对于我们的演示来说很简单：只需执行 3Com Daemon，它会自动启动其服务器。在左侧，你将看到不同的服务；选择 **FTP
    服务器**，然后查看右侧的状态窗口，确认该服务是否正在监听 **21** 端口。在我们的演示中，我们可以看到监听器已经检测到了本地分配的地址，也就是 **192.168.108.189**。现在，我们知道该将代理指向哪里：
- en: '![Figure 14.1 – 3CDaemon ready for requests ](image/Figure_14.01_B17616.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 3CDaemon 准备接收请求](image/Figure_14.01_B17616.jpg)'
- en: Figure 14.1 – 3CDaemon ready for requests
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 3CDaemon 准备接收请求
- en: 'Now, we can switch over to Taof and click **Data retrieval** and then **Network
    Settings**. You can leave the local server address at **0.0.0.0** but set the
    port to whatever you like and remember it for connecting to the proxy in the next
    step. Punch in the IP address and port from the 3Com Daemon status window into
    **Remote settings**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以切换到 Taof 并点击 **数据获取**，然后选择 **网络设置**。你可以将本地服务器地址保持为 **0.0.0.0**，但是可以设置端口为你喜欢的任何值，并记住它，方便在下一步连接到代理时使用。在
    **远程设置** 中输入来自 3Com Daemon 状态窗口的 IP 地址和端口：
- en: '![Figure 14.2 – Taof proxy configuration ](image/Figure_14.02_B17616.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – Taof 代理配置](image/Figure_14.02_B17616.jpg)'
- en: Figure 14.2 – Taof proxy configuration
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – Taof 代理配置
- en: Once you click **OK**, you’ll be able to verify your settings before clicking
    **Start**. At this point, the proxy is running.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击 **确定**，你将能够在点击 **开始** 之前验证你的设置。此时，代理已经在运行。
- en: Fuzzing by proxy – generating legitimate traffic
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代理进行模糊测试 – 生成合法流量
- en: The idea is simple – Taof is functioning as an ordinary proxy server now, handling
    our traffic to and from the remote service on our behalf. This is so that Taof
    can learn what expected traffic looks like before the mutation fuzzing phase.
    Now, we can simply connect to the proxy with any FTP client. In our example, using
    the built-in FTP client and specifying the remote address as **127.0.0.1** and
    port as **1066** connected us to the server listening at **192.168.108.189** on
    port **21**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单——Taof 现在作为一个普通的代理服务器在运行，代表我们处理与远程服务之间的流量。这是为了让 Taof 在突变模糊测试阶段之前学习期望的流量模式。现在，我们只需要通过任何
    FTP 客户端连接到代理。在我们的示例中，使用内置的 FTP 客户端，并指定远程地址为 **127.0.0.1**，端口为 **1066**，这让我们连接到监听
    **192.168.108.189** 上 **21** 端口的服务器。
- en: In today’s age, working with insecure protocols in a Windows lab can be frustrating
    if you have Windows Firewall running in a default configuration. You may need
    to disable it for these tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的时代，如果你在 Windows 实验室中使用不安全的协议，而 Windows 防火墙以默认配置运行，那么工作可能会变得非常令人沮丧。你可能需要在进行这些测试之前禁用它。
- en: We’re looking to send normal authentication data, so go ahead and try logging
    in as **administrator**, **guest**, **pickles** – whatever you like. It doesn’t
    matter because we want to fuzz the authentication process. When you’ve sent some
    data, stop the Taof proxy and return to the **Request** window. You’ll see a **Request
    List**, where each item has associated contents. Browse the requests to get an
    idea of what happened. It’s also a good idea to check out the 3Com Daemon’s status
    window to see how the requests were handled.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算发送正常的身份验证数据，所以可以尝试以**管理员**、**访客**、**pickles**等身份登录 —— 随便你选择。无论如何，这都不重要，因为我们想要模糊测试身份验证过程。当你发送了一些数据后，停止
    Taof 代理并返回到**请求**窗口。你会看到一个**请求列表**，其中每个条目都有相关内容。浏览这些请求，了解发生了什么。查看 3Com Daemon
    的状态窗口，看看这些请求是如何被处理的，也是一个好主意。
- en: 'Now, let’s identify where the mutations will take place by setting fuzzing
    points. Select a request from the list, depending on what you’re trying to test.
    In our example, we want to mess around with authentication, so I’ve chosen the
    moment my client sent the **USER pickles** command. Once selected, click **Set
    fuzzing points**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过设置模糊点来确定突变将发生的位置。根据你想要测试的内容，从列表中选择一个请求。在我们的示例中，我们想要搞乱身份验证，因此我选择了我的客户端发送
    **USER pickles** 命令的时刻。选择后，点击**设置模糊点**：
- en: '![Figure 14.3 – Picking fuzzing points from the list of captured requests ](image/Figure_14.03_B17616.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 从捕获的请求列表中选择模糊点](image/Figure_14.03_B17616.jpg)'
- en: Figure 14.3 – Picking fuzzing points from the list of captured requests
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 从捕获的请求列表中选择模糊点
- en: 'If you’re like me, you probably think that Taof doesn’t look like much when
    you first power it up. They put the real juicy bits down here in the **Fuzz Request**
    dialog box. (I always felt that way about Cain – a humble GUI with remarkable
    power under the hood. But I digress.) In this box, we can see the raw binary request
    in hexadecimal representation, along with the ASCII form that would have appeared
    at the application level. Try highlighting portions of the request – the **From**
    and **To** boxes identify the range in character position of your fuzzing point.
    Also, note that there are four kinds of tests we can perform – let’s leave the
    three overflows enabled:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，可能会觉得 Taof 在首次启动时看起来不怎么样。它真正的“劲爆”部分就在下方的**模糊请求**对话框中。（我总是这样认为 Cain ——
    一个看起来不起眼的 GUI，但在引擎盖下却蕴含着强大的力量。话题有点跑偏了。）在这个框中，我们可以看到原始的二进制请求的十六进制表示，以及应用层显示的 ASCII
    形式。试着高亮选择请求的部分 —— **From** 和 **To** 框标识了模糊点的字符位置范围。此外，注意我们可以执行四种不同的测试 —— 让我们保留启用的三个溢出测试：
- en: '![Figure 14.4 – Configuring the fuzzing request ](image/Figure_14.04_B17616.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 配置模糊请求](image/Figure_14.04_B17616.jpg)'
- en: Figure 14.4 – Configuring the fuzzing request
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 配置模糊请求
- en: 'On a hunch, I’m going to start with the full field: **0** to **14**. In our
    example, I just want to skip the finesse and break the service. Click **Add**,
    then **OK**, then **Fuzzing**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉告诉我，我将从完整的字段开始：**0** 到 **14**。在我们的示例中，我只是想跳过细节，直接让服务崩溃。点击**添加**，然后**确定**，再点击**模糊**：
- en: '![Figure 14.5 – Watching our target succumb to one of the fuzzing requests
    ](image/Figure_14.05_B17616.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 观看我们的目标在一次模糊请求中崩溃](image/Figure_14.05_B17616.jpg)'
- en: Figure 14.5 – Watching our target succumb to one of the fuzzing requests
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 观看我们的目标在一次模糊请求中崩溃
- en: Tango down! We can see **+ Buffer overflows** on the screen, followed by repeated
    attempts to contact the server, but to no avail. We know there’s a buffer overflow
    vulnerability in this FTP server. However, we have no idea how to exploit it.
    At this point, we need a tool that will send payloads to crash the service in
    a manner that allows us to recover the offset to EIP. I know what the hacker in
    you is saying – *why not write it up in Python?* Phew, I’m glad to hear you say
    that.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 塔哥击败！我们看到屏幕上显示了**+ 缓冲区溢出**，随后不断尝试联系服务器，但没有成功。我们知道这个 FTP 服务器存在缓冲区溢出漏洞。然而，我们不知道如何利用这个漏洞。在这一点上，我们需要一个工具，它可以发送有效负载以崩溃服务，并以某种方式让我们恢复到
    EIP 的偏移量。我知道你心中的黑客在说什么 —— *为什么不在 Python 中编写呢？* 哇，听你这么说我松了一口气。
- en: Hands-on fuzzing with Kali and Python
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kali 和 Python 进行实战模糊测试
- en: This is just my opinion, but I consider writing our own scripts for fuzzing
    to be a necessity. Any programming language will allow us to construct special
    payloads, but Python is a personal favorite for interfacing with sockets and files.
    Let’s try to understand what’s happening behind the scenes with the protocol in
    play, and then construct Python scripts that can interact in expected ways. The
    targets will happily accept our payloads if our scripts can talk the talk. Let’s
    take a look at the vulnerable server first.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我的个人看法，但我认为编写我们自己的模糊测试脚本是必要的。任何编程语言都允许我们构建特殊的有效负载，但 Python 是我个人最喜欢的语言，用于与套接字和文件进行交互。让我们试着理解协议背后发生的事情，然后构建可以按预期方式进行交互的
    Python 脚本。如果我们的脚本能“说得通”，目标服务器将乐意接受我们的有效负载。首先让我们看一下脆弱的服务器。
- en: Picking up where Taof left off with Python – fuzzing the vulnerable FTP server
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Taof 用 Python 的最后一步开始——模糊测试脆弱的 FTP 服务器
- en: 'We configured Taof to fuzz on the **USER anonymous** request that was sent
    to 3Com Daemon, and we watched it crash. We know what both ends saw, but we need
    to understand what happened on the network. There’s no better tool than Wireshark
    for this task. Set up a sniffing session and then run the test again. Filter out
    the FTP communication and take a look at the conversation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置 Taof 对发送到 3Com Daemon 的 **USER anonymous** 请求进行模糊测试，并看到它崩溃了。我们知道两端发生了什么，但我们需要理解网络中发生了什么。没有比
    Wireshark 更好的工具来完成这项任务。设置一个嗅探会话，然后再次运行测试。过滤掉 FTP 通信，看看会话的内容：
- en: '![Figure 14.6 – Tracking the FTP conversation with Wireshark ](image/Figure_14.06_B17616.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – 使用 Wireshark 跟踪 FTP 会话](image/Figure_14.06_B17616.jpg)'
- en: Figure 14.6 – Tracking the FTP conversation with Wireshark
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 使用 Wireshark 跟踪 FTP 会话
- en: Note that after the three-way TCP handshake is completed and the connection
    has been established, the very first communication comes from the server in the
    form of an FTP 220 message. The client fires back the **USER anonymous** request
    and, as expected from any FTP server, a 331 comes back. After the **PASS** command,
    we get a 230 (if the server allows anonymous logins, of course). Don’t fall asleep
    on me – this particular sequence is important for us because we’re constructing
    the socket in Python. As you may recall from [*Chapter 8*](B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145),
    *Python Fundamentals*, we connected to a server with our newly created socket
    and initiated the communication.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在完成三次握手并建立连接后，服务器发出的第一个通信是 FTP 220 消息。客户端回复 **USER anonymous** 请求，正如任何 FTP
    服务器预期的那样，返回了 331 消息。接着是 **PASS** 命令，得到 230 消息（如果服务器允许匿名登录的话）。不要打瞌睡——这段特定的顺序对我们来说很重要，因为我们正在用
    Python 构建套接字。你可能还记得 [*第 8 章*](B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145)，《Python
    基础知识》一章中，我们用新建的套接字连接到服务器并发起了通信。
- en: 'We have to tell our script to wait for the server’s greeting before we send
    anything. What’s going to save us a lot of time is the fact that our fuzzer crashed
    the server with the **USER anonymous** request – that’s only the second packet
    in the established session! Thus, we can get away with one tiny little script
    – 10 lines, in my case. (Forget the final status message and put the fuzzing payload
    into the **webclient.send()** function, and you’re down to eight lines.) Let’s
    take a look:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须告诉脚本在发送任何数据之前等待服务器的问候。节省我们大量时间的是，事实上，我们的模糊测试工具通过**USER anonymous**请求让服务器崩溃——这仅仅是建立会话后的第二个数据包！因此，我们可以用一个非常简短的脚本来解决——在我这里是
    10 行。（忘掉最终的状态消息，把模糊测试有效负载放入**webclient.send()**函数中，你的代码就只剩下八行了。）让我们来看一下：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This adorable little program should look familiar. The difference here is very
    simple:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可爱的程序应该很熟悉。这里的区别非常简单：
- en: Our first order of business, immediately after establishing the TCP session,
    is to *receive* a message from the server. Note that no variable has been set
    up for it; we’re simply telling the script to receive a maximum of 512 bytes but
    we’re not provisioning a way to read the received message.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一件事，就是在建立 TCP 会话后立即*接收*服务器的消息。请注意，我们没有为此设置任何变量；我们只是告诉脚本接收最多 512 字节的数据，但并没有提供读取接收到的消息的方法。
- en: 'We send exactly what the server expects: a **USER anonymous** request. We’re
    building a fuzzer, though, so we concatenate the string stored in **fuzz**.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发送服务器期望的内容：**USER anonymous** 请求。不过，我们在构建一个模糊测试工具，所以我们将存储在 **fuzz** 中的字符串连接起来。
- en: Now, I was considering telling you about the logs that Taof creates in its home
    directory so that you can see the details of what the fuzzer did and when it detected
    a crash – but I won’t. I’ll leave it to you to find out what inputs it takes to
    crash the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我本打算告诉你关于Taof在其主目录中创建的日志，借此你可以查看模糊测试工具做了什么以及它何时检测到崩溃——但我不会这么做。我会留给你自己去发现是什么输入导致了服务器崩溃。
- en: Exploring with boofuzz
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用boofuzz进行探索
- en: 'Taof is great for lightweight and visual fuzzing tasks, but since we’re already
    playing with Python, we need to dive deeper with a modern tool: **boofuzz**. The
    mighty Sulley fuzzing framework is no longer supported, so boofuzz is a fork and
    successor of the original. The name honors its origins: Sulley got its name from
    the lovable blue monster from *Monsters, Inc.* as he is exceptionally fuzzy. (Or
    is he furry? That’s a debate for another book.) Sulley meets a sweet little girl
    from the human world and, not knowing her real name, dubs her *Boo* due to her
    penchant for jump scares. Sulley’s character takes on a bit of a fatherly role,
    so the creators felt it appropriate that the successor to the Sulley fuzzing framework
    is called boofuzz. Remember this little pop culture tidbit for your next trivia
    night.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Taof非常适合轻量级和可视化的模糊测试任务，但既然我们已经在使用Python，我们需要使用一个更深入的现代工具：**boofuzz**。强大的Sulley模糊测试框架已不再支持，因此boofuzz是原框架的一个分支和继任者。这个名字向其起源致敬：Sulley得名于《怪兽公司》中的可爱蓝色怪物，因为它特别毛茸茸。（还是说它是毛发？这是另一本书的讨论。）Sulley遇到了一位来自人类世界的小女孩，因不知道她的真实名字，便称她为*Boo*，因为她喜欢给人吓一跳的感觉。Sulley的角色有点像父亲，所以创造者觉得合适将Sulley模糊测试框架的继任者命名为boofuzz。记住这个小小的流行文化细节，或许能为你下次的答题夜带来惊喜。
- en: 'The main thing to know about boofuzz is that it isn’t a separate program like
    Taof; it’s a module that you import into your script, and you *teach* it how to
    interact with your target using its built-in *grammar*. Thus, naturally, your
    Python script that incorporates boofuzz’s power will start with the following
    line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于boofuzz，最重要的是它不像Taof那样是一个独立的程序；它是一个模块，你将其导入到脚本中，然后你用它内置的*语法*来*教导*它如何与目标互动。因此，自然而然地，包含boofuzz强大功能的Python脚本将从以下一行开始：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I can already hear the hacker in you: *We could build generators that will
    spit out the appropriate boofuzz-speaking script for our task!* Indeed you can,
    and there are great examples online. If you want to practice with HTTP, for example,
    go check out Boo-Gen. It will take an ordinary HTTP request as input and spit
    out a boofuzz script for the target HTTP service. For now, we’ll just experiment
    with FTP, but hopefully, the sheer power is obvious to you.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我能听到你内心的小黑客在说：*我们可以构建生成器，输出适合我们任务的boofuzz脚本！*的确如此，而且网上有很多很棒的例子。如果你想练习HTTP，可以去看看Boo-Gen。它会把一个普通的HTTP请求作为输入，生成一个适用于目标HTTP服务的boofuzz脚本。现在，我们先来尝试FTP，但希望你能从中看到它的巨大潜力。
- en: 'It goes without saying, but since boofuzz is written in Python, it’s incredibly
    versatile (no need to switch back to your Windows attacking box) and easy to fetch
    within Kali. Let’s get that done now. Keep in mind that you need Python 3’s **pip**
    for this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不用多说，因为boofuzz是用Python编写的，它非常灵活（不需要切换回你的Windows攻击盒子）且易于在Kali中获取。现在我们就来实现这一点。记住，你需要Python
    3的**pip**来完成此操作：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And that’s all there is to it. Getting boofuzz couldn’t be easier – but some
    people complain about the difficulty for beginners to get used to it. So, let’s
    look at the basics of boofuzz grammar.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。获取boofuzz并不难——但是有些人抱怨初学者很难适应它。所以，让我们来看一下boofuzz语法的基础。
- en: Impress your teachers – using boofuzz grammar
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给你的老师留下深刻印象——使用boofuzz语法
- en: 'Just like every C program must have a **main()** function, every boofuzz script
    must have a **session** object. Every fuzz session needs a target, and any target
    needs the connection type defined; this can be done with the **target** and **connection**
    objects, respectively. Every boofuzz script is a Russian nesting doll of objects
    that defines our connection type and target inside our session. It will look something
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个C程序必须有一个**main()**函数一样，每个boofuzz脚本必须有一个**session**对象。每个模糊测试会话都需要一个目标，而任何目标都需要定义连接类型；这可以分别通过**target**和**connection**对象来完成。每个boofuzz脚本就像一个俄罗斯套娃，定义了在会话中我们的连接类型和目标。它看起来大概是这样的：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You’ll probably be using the **TCPSocketConnection()** class for most tasks,
    but you have other options such as UDP, raw sockets, and even serial connections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在大多数任务中使用**TCPSocketConnection()**类，但你也有其他选择，比如UDP、原始套接字，甚至串行连接。
- en: 'When people complain about boofuzz’s relative difficulty for beginners, I imagine
    this has less to do with the module itself and more to do with the *protocol definition*
    required in each script. We need to teach boofuzz how to fuzz our target protocol.
    As you can imagine, this makes boofuzz a definitive resource for anyone working
    on proprietary protocols! For now, let’s take a look at FTP. Note that we’re going
    to point at the target FTP service running at **192.168.108.211**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们抱怨 boofuzz 对初学者相对较难时，我想这与模块本身关系不大，更大程度上是因为每个脚本中需要的*协议定义*。我们需要教会 boofuzz 如何对目标协议进行模糊测试。正如你能想象的，这使得
    boofuzz 成为任何处理专有协议的人的必备资源！现在，让我们来看看 FTP。请注意，我们将指向运行在 **192.168.108.211** 上的目标
    FTP 服务：
- en: '![Figure 14.7 – A boofuzz script for testing against FTP ](image/Figure_14.07_B17616.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 一个用于测试 FTP 的 boofuzz 脚本](image/Figure_14.07_B17616.jpg)'
- en: Figure 14.7 – A boofuzz script for testing against FTP
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 一个用于测试 FTP 的 boofuzz 脚本
- en: 'Each of these is a message definition – we’re defining **USER**, **PASS**,
    and **STOR** in this example, and each definition has children that dictate the
    actual contents of the message. We’ll invoke these definitions with the **session**
    object we made previously and then invoke **session.fuzz()**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每一项都是消息定义——在这个例子中，我们定义了 **USER**、**PASS** 和 **STOR**，每个定义都有子项，指明消息的实际内容。我们将通过之前创建的
    **session** 对象调用这些定义，然后调用 **session.fuzz()**：
- en: '![Figure 14.8 – Invoking the fuzz ](image/Figure_14.08_B17616.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 启动模糊测试](image/Figure_14.08_B17616.jpg)'
- en: Figure 14.8 – Invoking the fuzz
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 启动模糊测试
- en: 'Once you kick off your new script with Python 3, your terminal window will
    simply explode:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用 Python 3 启动了新的脚本，终端窗口会立刻“爆炸”：
- en: '![Figure 14.9 – Boofuzz in action from the command line ](image/Figure_14.09_B17616.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – 从命令行运行 Boofuzz](image/Figure_14.09_B17616.jpg)'
- en: Figure 14.9 – Boofuzz in action from the command line
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 从命令行运行 Boofuzz
- en: 'Gah! What is happening? This is boofuzz in action and verbosely keeping you
    informed of every step. Surely, we’ll need some kind of bird’s-eye view. With
    all of this noise, you may have missed it, but the very first line in this log
    is **Info: Web interface can be found at http://localhost:26000**. Well, thank
    goodness for that. Let’s check it out while the fuzzer is doing its work.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！发生了什么？这是 boofuzz 在运行，并且详细地向你报告每一步。肯定需要一些全局视角来查看。在所有这些噪音中，你可能错过了，但日志中的第一行是
    **信息：Web 界面可以在 http://localhost:26000 找到**。哦，谢谢上帝！让我们在模糊器工作时查看一下它。
- en: '![Figure 14.10 – Boofuzz in action from the control page ](image/Figure_14.10_B17616.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – 从控制页面运行 Boofuzz](image/Figure_14.10_B17616.jpg)'
- en: Figure 14.10 – Boofuzz in action from the control page
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 从控制页面运行 Boofuzz
- en: With that, we’ve seen the power and utility of boofuzz. As we’ve seen, the tool
    assumes you know what you’re doing and you understand the protocol. Perhaps you
    have a Wireshark dump of some proprietary protocol in a SCADA environment? boofuzz
    is one of the rare treats that will allow you to build a comprehensive fuzzing
    test from a simple Pythonic description of the target’s protocol.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们看到了 boofuzz 的强大功能和实用性。正如我们所见，工具假设你知道自己在做什么，并且理解协议。也许你有一份 SCADA 环境中某个专有协议的
    Wireshark 数据包？boofuzz 是为数不多的工具之一，它允许你通过简单的 Python 风格的目标协议描述，构建一个全面的模糊测试。
- en: Let’s wrap up the client’s perspective of the fuzzable server and look at what
    a server sees when talking with a fuzzable client.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下客户端在可模糊服务器上的视角，并查看当与可模糊客户端通信时，服务器所看到的内容。
- en: The other side – fuzzing a vulnerable FTP client
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一方 – 模糊测试易受攻击的 FTP 客户端
- en: We can run our fuzzer as a client to test against a service, but let’s keep
    an open mind – we can fuzz any mechanism that takes our input. Though the client
    initiates a conversation with a server, the client still takes input as part of
    its role in the conversation. Taof allowed us to play the client to fuzz a service
    – this time, we’re testing a client, so we need to run a service that provides
    the fuzzing input.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以作为客户端运行模糊器来测试服务，但让我们保持开放的心态——我们可以模糊任何接收我们输入的机制。尽管客户端发起与服务器的对话，但客户端仍然作为对话的一部分接受输入。Taof
    允许我们扮演客户端来模糊测试服务——这次，我们测试的是客户端，因此我们需要运行提供模糊输入的服务。
- en: 'We already know that the nfsAxe FTP client version 3.7 for Windows is vulnerable.
    Now, let’s play the role of a vulnerability discoverer and fuzz this client. We
    have our Windows 7 testing box ready to go, and the nfsAxe client is installed.
    Go ahead and fire up the client, and take a look around:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，适用于Windows的nfsAxe FTP客户端版本3.7存在漏洞。现在，让我们扮演一个漏洞发现者的角色，对这个客户端进行模糊测试。我们的Windows
    7测试盒已经准备好，nfsAxe客户端也已安装。启动客户端，看看里面的内容：
- en: '![Figure 14.11 – Configuring the vulnerable FTP client ](image/Figure_14.11_B17616.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11 – 配置易受攻击的FTP客户端](image/Figure_14.11_B17616.jpg)'
- en: Figure 14.11 – Configuring the vulnerable FTP client
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 配置易受攻击的FTP客户端
- en: Note that we can specify session credentials, or select **Anonymous** to cause
    the client to log in immediately with **anonymous:guest** (provided that the server
    supports it). We’ll test against this behavior to make things easier. So, we know
    that we need an FTP server, but it needs to respond to any input, regardless of
    its validity, because the objective is to put data back and see what happens inside
    the client. What better way to get this done than with a Python script that mimics
    an FTP server?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以指定会话凭据，或者选择**匿名**来使客户端立即使用**anonymous:guest**登录（前提是服务器支持）。为了简化测试，我们将针对这种行为进行测试。所以，我们知道我们需要一个FTP服务器，但它需要对任何输入做出响应，无论其有效性如何，因为目标是将数据发送回去，看看客户端内部发生了什么。还有什么比用Python脚本模拟FTP服务器更好的方法呢？
- en: Writing a bare-bones FTP fuzzer service in Python
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python编写一个简单的FTP模糊测试服务
- en: Back in [*Chapter 8*](B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145), *Python
    Fundamentals*, we built a server skeleton with nothing more than a core socket
    and listening port functionality. We also introduced a quick way to run something
    forever (well, until an event such as an interrupt) – **while True**. We’ll do
    something a little different for our fuzzing FTP server because we need to mimic
    the appearance of a legitimate FTP server that’s communicating with the client.
    We’ll also introduce the **try/except** construct in Python so that we can handle
    errors and interrupts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[*第8章*](B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145)，*Python基础知识*，我们仅用核心的socket和监听端口功能构建了一个服务器骨架。我们还介绍了一种快速运行某个程序的方法（好吧，直到遇到某个事件，比如中断）–
    **while True**。为了我们的模糊测试FTP服务器，我们会做些不同的事情，因为我们需要模拟一个与客户端通信的合法FTP服务器的外观。我们还将引入Python中的**try/except**结构，以便我们能够处理错误和中断。
- en: 'Fire up **vim fuzzy.py** and type out the following program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 启动**vim fuzzy.py**并输入以下程序：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Fun, right? Okay, let’s see what we did here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣吧？好吧，让我们看看我们做了些什么：
- en: The first **try/except** section allows the user to define the fuzzing payload.
    Note that we take input with **int(raw_input())**. If the returned value from
    **raw_input()** is a string, then **int()** will return a value error, which we
    can handle with **except ValueError**. This is just some pretty code, so it isn’t
    necessary, and for a pen tester on a time crunch, I’m sure you’ll just define
    the byte length directly in the code and modify it with Vim as you see fit.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个**try/except**部分允许用户定义模糊测试的有效载荷。注意，我们通过**int(raw_input())**来获取输入。如果**raw_input()**返回的是一个字符串，那么**int()**会返回一个值错误，我们可以通过**except
    ValueError**来处理这个错误。这只是一些漂亮的代码，不是必需的，对于时间紧迫的渗透测试人员来说，我敢打赌你会直接在代码中定义字节长度，并在Vim中根据需要进行修改。
- en: We declare the fuzzing payload as **fuzz** with **\x7a** as the byte. Use whatever
    you like, but I’ve been pretty sleepy lately, so I’m sticking with *z*. I can’t
    get *z*’s in real life; I may as well stuff them into vulnerable buffers.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将模糊测试的有效载荷声明为**fuzz**，其字节为**\x7a**。你可以使用任何你喜欢的字符，但我最近有点困，所以我决定使用*z*。现实生活中我拿不到*z*，不如把它塞进易受攻击的缓冲区里。
- en: Now comes the familiar part for anyone used to sockets in Python – we create
    a socket with **socket.socket(socket.AF_INET, socket.SOCK_STREAM)** and call it
    **server**. From there, we use **server.bind()** and **server.listen()** to stand
    up our server. Note that I’m passing **1** to **server.listen()**; we’re just
    testing with a single client, so **1** is all that is necessary.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，来到了熟悉的部分，任何熟悉Python中socket的人都会知道 – 我们通过**socket.socket(socket.AF_INET, socket.SOCK_STREAM)**创建一个socket，并将其命名为**server**。然后，我们使用**server.bind()**和**server.listen()**来启动服务器。注意，我将**1**传递给**server.listen()**；我们只是测试单个客户端，所以只需要**1**。
- en: If you connect to our fuzzy little server with an FTP client or netcat, you’ll
    see a conversation with FTP server response codes. Now, you can see that we’re
    just faking – we’re taking a kilobyte of responses and just tossing them in the
    trash, working our way up to sending the payload.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你用 FTP 客户端或 netcat 连接到我们的模糊小服务器，你会看到一个带有 FTP 服务器响应代码的对话过程。现在，你会看到我们只是在伪造——我们获取一个千字节的响应，然后把它们丢进垃圾桶，一步步发送有效载荷。
- en: We wrap up with two **except** sections for handling errors or *Ctrl* + *C*.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过两个 **except** 语句块来处理错误或 *Ctrl* + *C*。
- en: The trap is set – now, let’s see what happens when the vulnerable client unwittingly
    processes our fuzzing payload.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱已设置——现在，让我们看看当脆弱客户端不知情地处理我们的模糊负载时会发生什么。
- en: Crashing the target with the Python fuzzer
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 模糊测试工具崩溃目标
- en: Without further ado, fire up your fuzzer, configure it to send 256 bytes, and
    then switch over to your Windows 7 tester. Open the nfsAxe FTP client, select
    **Anonymous** access, and punch in Kali’s IP address for **Host ID**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不再废话，启动你的模糊测试工具，配置它发送 256 字节数据，然后切换到你的 Windows 7 测试机。打开 nfsAxe FTP 客户端，选择 **匿名**
    访问，并输入 Kali 的 IP 地址作为 **Host ID**。
- en: 'Connect and watch the results:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 连接并观察结果：
- en: '![Figure 14.12 – The test server’s perspective – payload sent ](image/Figure_14.12_B17616.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 测试服务器的视角 – 发送的有效载荷](image/Figure_14.12_B17616.jpg)'
- en: Figure 14.12 – The test server’s perspective – payload sent
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 测试服务器的视角 – 发送的有效载荷
- en: 'Okay, so that was a little boring, but it worked. The payload was received
    by the client and displayed in the status window:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，虽然有点无聊，但它有效。客户端接收到了有效载荷，并在状态窗口中显示了出来：
- en: '...'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '![Figure 14.13 – The vulnerable client’s perspective – payload received ](image/Figure_14.13_B17616.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13 – 脆弱客户端的视角 – 收到的有效载荷](image/Figure_14.13_B17616.jpg)'
- en: Figure 14.13 – The vulnerable client’s perspective – payload received
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 – 脆弱客户端的视角 – 收到的有效载荷
- en: Just for fun, execute the fuzzer again, but this time send 4,000 bytes. What
    does the client do?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，再次执行模糊测试工具，这次发送 4,000 字节。客户端会怎么做？
- en: '![Figure 14.14 – The vulnerable client has crashed! ](image/Figure_14.14_B17616.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14 – 脆弱客户端崩溃了！](image/Figure_14.14_B17616.jpg)'
- en: Figure 14.14 – The vulnerable client has crashed!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 – 脆弱客户端崩溃了！
- en: Winner, winner, chicken dinner! We just need to prepare our exploit and we’ll
    be on our way to arbitrary code execution. But wait – I hear the hacker in you
    now. *We know that the buffer is bigger than 256 bytes and smaller than 4,000
    bytes. Will we have to manually find the sweet spot across 3,744 bytes?* You are
    wise beyond your years but fear not. We could simply generate a long string of
    characters in a defined pattern, pass it as our fuzz payload, look for the characters
    that end up written over the EIP on the client side, identify that 4-byte pattern
    in the fuzz payload, and calculate the offset. We could do this by hand, but those
    friendly folks over at Metasploit have already thought of this one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利，胜利，鸡肉大餐！我们只需要准备我们的利用代码，就能开始执行任意代码了。但等等——我现在听到你内心的黑客声音了。*我们知道缓冲区的大小大于 256
    字节且小于 4,000 字节。我们是不是得手动在 3,744 字节中找到合适的“甜点”？* 你真是机智过人，但不用担心。我们可以简单地生成一串字符，按照一定模式构造，作为我们的模糊负载，观察在客户端
    EIP 上被覆盖的字符，识别这个 4 字节的模式，并计算出偏移量。我们本可以手动操作，但 Metasploit 的那些友好人士早就想到了这个问题。
- en: Fuzzy registers – the low-level perspective
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊寄存器 – 底层视角
- en: 'The fuzzing research we’ve done so far was effective in discovering the fact that
    these two FTP programs are vulnerable to overflows. Now, we need to understand
    what’s happening behind the scenes by watching the stack as we send fuzz payloads.
    Of course, this will be done with a debugger. Since we’re on Windows in this lab,
    we’ll fire up WinDbg and attach it to the vulnerable software PID. Since we’ve
    just finished toying around with the nfsAxe client, I’ll assume that’s still up
    and ready to go in your lab. Keep your 3Com Daemon lab handy, though, because
    the principles are the same. Let’s go down the rabbit hole with Metasploit’s offset
    discovery duo: **pattern_create** and **pattern_offset**.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们做的模糊测试研究有效地揭示了这两个 FTP 程序容易受到溢出攻击。现在，我们需要通过观察堆栈来了解幕后发生了什么，方法是发送模糊负载并借助调试器进行分析。当然，这一切都将在调试器下完成。由于我们在
    Windows 环境中进行实验，我们会启动 WinDbg 并将其附加到受漏洞影响的软件进程（PID）上。由于我们刚刚玩完 nfsAxe 客户端，我假设它还在你实验室中运行着。不过，保持
    3Com Daemon 实验室在手，因为原理是一样的。让我们跟随 Metasploit 的偏移发现工具组合：**pattern_create** 和 **pattern_offset**，一起深入挖掘。
- en: Calculating the EIP offset with the Metasploit toolset
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Metasploit 工具集计算 EIP 偏移量
- en: 'Head on over to the **tools** directory in Metasploit with **cd /usr/share/metasploit-framework/tools/exploit**.
    First, let’s generate a 4,000-byte payload, as we know that’s enough bytes to
    overwrite critical parts of memory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 Metasploit 中的 **tools** 目录，路径为 **cd /usr/share/metasploit-framework/tools/exploit**。首先，我们生成一个
    4,000 字节的负载，因为我们知道这个长度足以覆盖内存中的关键部分：
- en: '![Figure 14.15 – Generating the pattern payload ](image/Figure_14.15_B17616.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.15 – 生成模式负载](image/Figure_14.15_B17616.jpg)'
- en: Figure 14.15 – Generating the pattern payload
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 – 生成模式负载
- en: After a couple of seconds, a new text file will appear in your **home** directory.
    If you open it up, you’ll see 4,000 bytes of junk. Don’t be so fast to judge,
    though – it’s a specially crafted string that the offset finder, **pattern_offset.rb**,
    will use to find where our sweet spot lies.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，一个新的文本文件会出现在你的 **home** 目录中。如果你打开它，你会看到 4,000 字节的垃圾数据。不过别急着下结论——这是一个特别制作的字符串，偏移量查找器
    **pattern_offset.rb** 会用它来找到我们的位置。
- en: 'Now, open your fuzzer with Vim again, comment out the lines that take input,
    and set the **fuzz** variable. Add the following line after the comment lines:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次用 Vim 打开你的模糊测试程序，注释掉那些接收输入的行，并设置 **fuzz** 变量。在注释行之后添加以下代码：
- en: '[PRE55]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that **rstrip()** simply trims the new line from the end of the file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**rstrip()** 只是简单地去除文件末尾的换行符：
- en: '![Figure 14.16 – Modifying the server to deliver our special payload ](image/Figure_14.16_B17616.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.16 – 修改服务器以传送我们的特殊负载](image/Figure_14.16_B17616.jpg)'
- en: Figure 14.16 – Modifying the server to deliver our special payload
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16 – 修改服务器以传送我们的特殊负载
- en: 'Save your modified fuzzer and execute it again. You’ll notice that the payload
    is now 4,000 bytes long. But hold your horses – let’s not fire off the FTP client
    just yet (we already know it’ll crash). As we reviewed in [*Chapter 8*](B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145), *Python
    Fundamentals*, let’s link our FTP client to WinDbg – while the nfsAxe client is
    running, open WinDbg and hit *F6* to attach to a running process. Find the **ftp.exe**
    process and attach to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 保存修改后的模糊测试程序并重新执行。你会注意到负载现在是 4,000 字节长。但别急——我们暂时不要启动 FTP 客户端（我们已经知道它会崩溃）。正如我们在[*第
    8 章*](B17616_08_Final_VK_ePub.xhtml#_idTextAnchor145)《*Python 基础*》中回顾的那样，让我们将
    FTP 客户端与 WinDbg 链接——在 nfsAxe 客户端运行时，打开 WinDbg 并按 *F6* 键附加到正在运行的进程。找到 **ftp.exe**
    进程并附加到它：
- en: '![Figure 14.17 – Attaching to the vulnerable client in WinDbg ](image/Figure_14.17_B17616.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.17 – 在 WinDbg 中附加到易受攻击的客户端](image/Figure_14.17_B17616.jpg)'
- en: Figure 14.17 – Attaching to the vulnerable client in WinDbg
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17 – 在 WinDbg 中附加到易受攻击的客户端
- en: 'Now, you’re ready to connect to the fuzzer. After the 4,000 bytes are received
    by the client, it crashes – but we can see that the EIP register is overwritten
    with **0x43387143**. The manual fuzzer in you is anticipating something such as
    **0x41414141** or **0x7a7a7a7a**, but don’t forget that we’re using a unique pattern
    to find our offset, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好连接到模糊测试程序了。在客户端接收到 4,000 字节后，它会崩溃——但我们可以看到 EIP 寄存器被 **0x43387143** 覆盖了。你内心的手动模糊测试者期待的是类似
    **0x41414141** 或 **0x7a7a7a7a** 的值，但不要忘记，我们正在使用一个独特的模式来找到偏移量，正如这里所示：
- en: '![Figure 14.18 – Viewing register contents after the crash ](image/Figure_14.18_B17616.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.18 – 崩溃后查看寄存器内容](image/Figure_14.18_B17616.jpg)'
- en: Figure 14.18 – Viewing register contents after the crash
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18 – 崩溃后查看寄存器内容
- en: 'I know what the hacker in you is saying right now – *we’re on an Intel processor,
    so that’s a little-endian EIP address, isn’t it?* Not bad, young apprentice. This
    means that **0x43387143** is actually **43 71 38 43**. Doing a quick lookup on
    a hexadecimal ASCII table shows us the **Cq8C** pattern. Hold on to that value
    for the offset calculation with **pattern_offset.rb**:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你现在在想什么——*我们使用的是 Intel 处理器，所以这是一个小端字节序的 EIP 地址，对吧？* 不错，小徒弟。这意味着 **0x43387143**
    实际上是 **43 71 38 43**。快速查阅十六进制 ASCII 表，结果显示 **Cq8C** 的模式。记住这个值，待会儿用来进行 **pattern_offset.rb**
    的偏移量计算：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Figure 14.19 – Identifying the position of our payload that made it to EIP
    ](image/Figure_14.19_B17616.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.19 – 确定我们的负载到达 EIP 的位置](image/Figure_14.19_B17616.jpg)'
- en: Figure 14.19 – Identifying the position of our payload that made it to EIP
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19 – 确定我们的负载到达 EIP 的位置
- en: As you can see, **pattern_offset** knows what to look for within a given length
    provided to **pattern_create**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**pattern_offset** 知道要在 **pattern_create** 提供的给定长度内查找什么。
- en: 'I know what you’re wondering because I wondered the same thing: does the offset
    include the 4 bytes that overwrite the return address? In other words, if the
    offset is found to be 2,064 bytes, do we need to put in 2,060 bytes of fluff?
    Once again, the friendly neighborhood hackers at Metasploit considered that and
    decided to make it consistent. What you see is what you need in your exploit code.
    So, we’ll go back to our Python script one more time and multiply our junk byte
    by the exact offset value discovered by **pattern_offset**, and then concatenate
    the hex string of the memory location that execution will flow to:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么，因为我也曾有过同样的疑问：偏移量是否包括覆盖返回地址的 4 个字节？换句话说，如果偏移量为 2,064 字节，我们需要放入 2,060
    字节的填充数据吗？再一次，Metasploit 社区的友好黑客们已经考虑到了这一点，并决定让它保持一致。你看到的就是你在利用代码中需要的部分。因此，我们将再次回到我们的
    Python 脚本，将我们的垃圾字节乘以**pattern_offset**发现的确切偏移量值，然后连接执行将流向的内存位置的十六进制字符串：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s take a look at what this looks like in our script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的脚本中这个是什么样子的：
- en: '![Figure 14.20 – Testing our math ](image/Figure_14.20_B17616.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.20 – 测试我们的数学计算](image/Figure_14.20_B17616.jpg)'
- en: Figure 14.20 – Testing our math
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20 – 测试我们的数学计算
- en: 'Fire it off one more time and watch the EIP (as well as the **Exception Offset:**
    value in the Windows error message). Congratulations! You have all the pieces
    needed to construct a working exploit:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行一次，观察 EIP（以及 Windows 错误消息中的**异常偏移量（Exception Offset）：**值）。恭喜！你已经具备了构造一个有效利用的所有必要部分：
- en: '![Figure 14.21 – Payload size confirmed! ](image/Figure_14.21_B17616.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.21 – 有效载荷大小已确认！](image/Figure_14.21_B17616.jpg)'
- en: Figure 14.21 – Payload size confirmed!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21 – 有效载荷大小已确认！
- en: Our special gift is looking very pretty, but we still need to do a little math
    to wrap it up.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特别礼物看起来很漂亮，但我们仍然需要做一点数学运算来完成它。
- en: Shellcode algebra – turning the fuzzing data into an exploit
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shellcode 代数 – 将模糊测试数据转化为利用代码
- en: 'Like a giddy child running to buy candy, I pull up **msfvenom** to generate
    some shellcode. I have a Windows Meterpreter chunk of shellcode that tips the
    scales at 341 bytes. My little fuzz-and-crash script works, but with 2,064 bytes
    of *z* followed by the desired address. To make this work, I need to turn that
    into NOPs followed by shellcode. This becomes a simple matter of *x *+ *341* =
    *2,064*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一个兴奋的孩子跑去买糖果，我打开**msfvenom**来生成一些 shellcode。我有一段 Windows Meterpreter 的 shellcode，大小为
    341 字节。我的小模糊测试与崩溃脚本有效，但它包含 2,064 字节的*z*，后面跟着目标地址。为了使其生效，我需要将其转换为 NOPs，然后是 shellcode。这变成了一个简单的数学问题：*x*
    + *341* = *2,064*：
- en: '![Figure 14.22 – Allowing for shellcode in the final calculation ](image/Figure_14.22_B17616.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.22 – 在最终计算中考虑 shellcode](image/Figure_14.22_B17616.jpg)'
- en: Figure 14.22 – Allowing for shellcode in the final calculation
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22 – 在最终计算中考虑 shellcode
- en: 'One of the nice things about using Python for our exploits is that **msfvenom**
    is ready to spit out shellcode in a dump-and-go format:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 编写利用代码的一个好处是，**msfvenom**已经准备好以即取即用的格式输出 shellcode：
- en: '![Figure 14.23 – Incorporating the algebra in our exploit ](image/Figure_14.23_B17616.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.23 – 将代数融入我们的利用代码](image/Figure_14.23_B17616.jpg)'
- en: Figure 14.23 – Incorporating the algebra in our exploit
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23 – 将代数融入我们的利用代码
- en: I leave it to you to get your chosen shellcode executed. Happy hunting!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我把执行你选择的 shellcode 的任务留给你。祝你好运！
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced fuzzing as a testing methodology and an exploit
    research tool. We started with mutation fuzzing over the network to test an FTP
    server’s handling of mutated authentication requests. With this information, we
    developed Python scripts that automate the fuzzing process. While we were exploring
    Python fuzzing, we built a fuzzing server to provide input to a vulnerable FTP
    client. With both pieces of software, the goal was to crash them and learn what
    input from the fuzzer caused the crash. We wrapped up by looking at these crashes
    from a low-level register memory perspective. This was accomplished by attaching
    WinDbg to the vulnerable processes and examining memory after the crash. With
    Metasploit’s offset discovery tools, we demonstrated how to use debugging and
    fuzzing to write precise exploits.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们介绍了模糊测试作为一种测试方法论和漏洞研究工具。我们从通过网络进行变异模糊测试开始，测试 FTP 服务器对变异认证请求的处理。通过这些信息，我们开发了自动化模糊测试过程的
    Python 脚本。在探索 Python 模糊测试时，我们建立了一个模糊测试服务器，向易受攻击的 FTP 客户端提供输入。通过这两个软件，目标是使其崩溃，并了解来自模糊测试器的哪些输入导致了崩溃。最后，我们从低级寄存器内存的角度审视这些崩溃。通过将
    WinDbg 附加到易受攻击的进程并在崩溃后检查内存，我们实现了这一目标。通过 Metasploit 的偏移量发现工具，我们演示了如何利用调试和模糊测试编写精确的漏洞利用代码。
- en: In the next chapter, we will take a deeper look into the post-exploitation phase
    of a penetration test so that we can learn how hackers turn an initial foothold
    into a wide-scale compromise.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨渗透测试的后期利用阶段，以便了解黑客如何将初步的立足点转变为大规模的系统入侵。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的理解：
- en: Fuzzing is one of the more popular attacks because it results in shellcode execution.
    (True | False)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊测试是较为流行的攻击方式之一，因为它能够导致 shellcode 执行。（对 | 错）
- en: 'Identify the fuzzing points range 4 through 8 in this request: **USER administrator**.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个请求中，标识出模糊测试点范围 4 到 8：**USER administrator**。
- en: The **Exception Offset** value in the Windows crash dump is the same value that
    can be found in __________.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 崩溃转储中的 **Exception Offset** 值与 __________ 中找到的值相同。
- en: Name Metasploit’s two tools that are used together to find the EIP offset in
    an overflow.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列出 Metasploit 中用于一起查找溢出中 EIP 偏移量的两个工具。
- en: 'An attacker has just discovered that if execution lands at **0x04a755b1**,
    their NOP sled will be triggered and run down to their Windows shellcode. The
    vulnerable buffer is 2,056 bytes long and the shellcode is 546 bytes long. They
    use the following line of code to prepare the shellcode: **s = ''\x90'' * 1510
    + buf + ''\x04\xa7\x55\xb1''**. Why is this attack bound to fail?'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一名攻击者刚刚发现，如果执行流到达 **0x04a755b1**，他们的 NOP sled 将被触发并一直运行到他们的 Windows shellcode。易受攻击的缓冲区长
    2,056 字节，shellcode 长 546 字节。他们使用以下代码行准备 shellcode：**s = '\x90' * 1510 + buf +
    '\x04\xa7\x55\xb1'**。为什么这个攻击注定会失败？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延伸阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解更多关于本章内容的信息，请参考以下资源：
- en: 'Taof download: [https://sourceforge.net/projects/taof](https://sourceforge.net/projects/taof)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Taof 下载： [https://sourceforge.net/projects/taof](https://sourceforge.net/projects/taof)
- en: 'nfsAxe FTP Client version 3.7 for Windows installation: [http://www.labf.com/download/nfsaxe.exe](http://www.labf.com/download/nfsaxe.exe)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 版本 nfsAxe FTP 客户端 3.7 安装： [http://www.labf.com/download/nfsaxe.exe](http://www.labf.com/download/nfsaxe.exe)
- en: 'Vulnerable 3Com Daemon for Windows installation: [http://www.oldversion.com/windows/3com-daemon-2r10](http://www.oldversion.com/windows/3com-daemon-2r10)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 版本 3Com Daemon 漏洞安装： [http://www.oldversion.com/windows/3com-daemon-2r10](http://www.oldversion.com/windows/3com-daemon-2r10)
