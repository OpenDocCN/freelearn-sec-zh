- en: Miscellaneous Fun in Windows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 中的其他有趣内容
- en: In this chapter, we'll mainly focus on exploiting vulnerable software in Windows
    and proceed to use different techniques within privilege escalation. Subsequently,
    we'll also create backdoors and cover our tracks. This chapter will give a general
    idea of how we can leverage the power of a Python script to our advantage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注在 Windows 系统中利用易受攻击的软件，并使用不同的技术进行特权提升。随后，我们还将创建后门并掩盖痕迹。本章将大致介绍如何利用
    Python 脚本的强大功能来为我们所用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Privilege escalation – weak service file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权提升 – 弱服务文件
- en: Privilege escalation – preparing vulnerable software
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权提升 – 准备易受攻击的软件
- en: Privilege escalation – backdooring legitimate windows service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权提升 – 后门合法的 Windows 服务
- en: Privilege escalation – creating a new admin account and covering the tracks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权提升 – 创建新的管理员账户并掩盖痕迹
- en: Privilege escalation – weak service file
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特权提升 – 弱服务文件
- en: During a penetration testing phase, you may encounter a standard user where
    you don't have full privilege to access or modify a filesystem due to the **user
    access control** (**UAC**) and, each time you try to elevate your privilege, you
    will be prompted to the window that asks you to enter the administrator password.
    In this section, we will discuss one of the types of doing a **privilege escalation
    attack**, where you technically jump from a standard user to an administrator
    or system privilege. These types of attacks, which we will discuss, are called
    **privilege escalation via service file permission weakness**. The system will
    be vulnerable if the location of a service executable file is modifiable by the
    standard user. Then, it can be overwritten by another malicious executable. We
    may use this capability to gain system privilege(s) by booting our own executable
    in place of the service executable. Once the service is started after restarting
    the system, the replaced executable will run instead of the original service executable.
    So, in summary, we have a system privilege and we'll run an EXE, which belongs
    to a vulnerable software. Now, since this software EXE can be written by a standard
    user and within a standard user profile, we can simply replace it with a malicious
    EXE.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试阶段，你可能会遇到一个标准用户账号，在此账号下，由于**用户访问控制**（**UAC**），你没有完全的权限访问或修改文件系统，每次你试图提升权限时，都会弹出一个窗口，要求你输入管理员密码。在本节中，我们将讨论一种**特权提升攻击**的类型，你可以通过这种方式从标准用户权限提升到管理员或系统权限。这些我们将讨论的攻击方法，称为**通过服务文件权限漏洞进行特权提升**。如果服务可执行文件的位置可以被标准用户修改，则系统将变得易受攻击。此时，它可以被另一个恶意可执行文件覆盖。我们可以利用这一点，通过启动我们的恶意可执行文件来获取系统权限。一旦在重启系统后启动服务，被替换的可执行文件将运行，而不是原始的服务可执行文件。总之，我们已经获得了系统权限，并将运行一个属于易受攻击软件的
    EXE 文件。现在，由于该软件的 EXE 文件可以被标准用户在标准用户的配置文件中写入，因此我们可以简单地将其替换为恶意 EXE 文件。
- en: So, this software EXE can be written or modified by a user space, using a standard
    user. So, what we can do is, we can simply replace the software EXE with a malicious
    one. On the next three boots, our EXE is going to take a place and will be executed
    with the power of system privilege.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这款软件 EXE 文件可以由用户空间的标准用户写入或修改。所以，我们可以做的事情是，直接将软件 EXE 文件替换为恶意 EXE 文件。在接下来的三次启动中，我们的
    EXE 将取而代之，并将以系统权限执行。
- en: 'Here is a link on privilege escalation types with brief description for each
    type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于特权提升类型的链接，并简要描述每种类型：
- en: '[https://attack.mitre.org/wiki/Privilege_Escalation](https://attack.mitre.org/wiki/Privilege_Escalation). If
    you have some time, I recommend that you read this article.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://attack.mitre.org/wiki/Privilege_Escalation](https://attack.mitre.org/wiki/Privilege_Escalation)。如果你有时间，我建议你阅读这篇文章。'
- en: Privilege escalation – preparing vulnerable software
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特权提升 – 准备易受攻击的软件
- en: For this demonstration, I will be using a vulnerable software named **Photodex**
    taken from an Exploit Database website. You can download this software from [https://www.exploit-db.com/exploits/24872/](https://www.exploit-db.com/exploits/24872/). Once
    the software is downloaded, install this software on our target machine. Once
    it's finished, restart the machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次演示中，我将使用一款名为**Photodex**的易受攻击软件，该软件来源于 Exploit Database 网站。你可以从[https://www.exploit-db.com/exploits/24872/](https://www.exploit-db.com/exploits/24872/)下载此软件。下载完成后，将该软件安装到目标机器上。安装完成后，重启机器。
- en: So now, let's try and create a `nonadmin` standard account in our target Windows
    machine by going to Control Panel | Add or remove user accounts | Create a new
    account. Let's call this one `nonadmin`. After creating the account log into the
    `nonadmin` account and navigate to the `Photodex` directory created while installation
    at `C:\` drive and at the same time, open the Task Manager.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在目标 Windows 机器上创建一个 `nonadmin` 标准账户，方法是前往控制面板 | 添加或删除用户账户 | 创建一个新账户。我们将其命名为
    `nonadmin`。创建完账户后，登录到 `nonadmin` 账户，导航到安装时创建的 `Photodex` 目录，路径在 `C:\` 驱动器，同时打开任务管理器。
- en: You will be able to see the service name, which gets created by Photodex software,
    which is `ScsiAccess` under the Services tab. To get more information about this
    service, click on the Services button. In the Services window that opens, find
    the `ScsiAccess`, right-click on it and select Properties, you will be able to
    find the EXE file path for this service. Go and have a look into that directory,
    in my case, it is `C:\Program Files\Photodex\Pro Show Producer\ScsiAccess.exe`.
    Find the EXE file and right-click on it; notice that we don't need any admin privilege
    to Rename, Delete, Copy, or even Cut this file. So, technically, if I rename this
    file to `ABC`, for instance, and then replace a malicious file instead of this
    one, then we can take advantage of this vulnerability. Let's see what we can do
    with this vulnerability. In the next section, we will create a new service EXE
    file purely in Python. Then, we will replace the current one, which is the `sciaccess.exe`
    file and see what privilege we can gain access by doing so.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够在“服务”标签下看到由 Photodex 软件创建的服务名称，即 `ScsiAccess`。要获取更多关于此服务的信息，请点击“服务”按钮。在打开的“服务”窗口中，找到
    `ScsiAccess`，右键点击并选择“属性”，你将能够找到该服务的 EXE 文件路径。然后进入该目录，在我的例子中，它是 `C:\Program Files\Photodex\Pro
    Show Producer\ScsiAccess.exe`。找到 EXE 文件，右键点击它；注意，我们不需要任何管理员权限就能重命名、删除、复制甚至剪切这个文件。所以，理论上，如果我把这个文件重命名为
    `ABC`，例如，然后用一个恶意文件替代它，那么我们就可以利用这个漏洞。接下来，我们将看看如何利用这个漏洞。在下一部分，我们将纯粹使用 Python 创建一个新的服务
    EXE 文件。然后，我们将替换当前的 `sciaccess.exe` 文件，并看看通过这样做我们能获取哪些权限。
- en: Privilege escalation – backdooring legitimate windows service
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限提升 – 通过后门访问合法的 Windows 服务
- en: In this section, we will code a malicious service file to replace the legitimate
    one. Now, in order to replace the service file, our new malicious service file
    should be able to communicate with Windows service control manager. For instance,
    when you manually Start, Stop, Pause, or Resume the service, the Windows service
    control manager will send a signal or order to the EXE service file and in return,
    the service file should usually obey the service control manager's order. If,
    for any reason, the service file or the EXE file did not understand that signal,
    then the service control manager will fail to start the service and you will get
    an error saying `The service did not respond to the start or control request in
    a timely fashion`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将编写一个恶意服务文件来替换合法的服务文件。现在，为了替换服务文件，我们的新恶意服务文件应该能够与 Windows 服务控制管理器进行通信。例如，当你手动启动、停止、暂停或恢复服务时，Windows
    服务控制管理器会向 EXE 服务文件发送信号或命令，作为回应，服务文件通常会服从服务控制管理器的命令。如果由于某种原因，服务文件或 EXE 文件未能理解该信号，那么服务控制管理器将无法启动服务，并且你会收到一个错误提示：“服务没有及时响应启动或控制请求”。
- en: 'Now, let''s jump to the code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入代码部分：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First of all, some part of my code is inherited from a script that I found on
    ActiveState website. Here, you can find the original one [http://code.activestate.com/recipes/551780/](http://code.activestate.com/recipes/551780/).
    The second thing I recommend is to read more about Microsoft service control manager
    functionality. Here is a good start: [https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx). Last
    but not least, `pywin` library is a prerequisite library to create a Windows service
    in Python. You can download it from: [https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/).
    Our code can be divided into two sections. The first section is about initializing.
    In this section, we define a listener for Windows, that is, `servicemanager`.
    Then, we pass a `Service` class handler, so, whenever we get a signal from `servicemanager`,
    we will pass it to the `Service` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我的部分代码继承自我在ActiveState网站上找到的一个脚本。在这里，你可以找到原始脚本：[http://code.activestate.com/recipes/551780/](http://code.activestate.com/recipes/551780/)。其次，我建议阅读更多关于Microsoft服务控制管理器功能的资料。这里是一个不错的起点：[https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx)。最后但同样重要的是，`pywin`库是创建Windows服务的前置库。你可以从以下链接下载：[https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/)。我们的代码可以分为两个部分。第一部分是关于初始化的。在这一部分，我们为Windows定义一个监听器，即`servicemanager`。然后，我们传递一个`Service`类处理程序，因此每当我们从`servicemanager`接收到信号时，我们会将其传递给`Service`类。
- en: 'Let''s move to the second part:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入第二部分：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the second section, we define the action to do when we get a service manager
    signal and this will happen within the `Service` class. In the first two lines,
    we specify the service name and the display name. Note that the name that I have
    chosen, which is `ScsiAccess`, is similar to the original one for Photodex software.
    So, if we open the service from the Windows Task Manager, like we did in the previous
    section, the name exactly matches the service name for the vulnerable software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们定义了在接收到服务管理器信号时应该执行的操作，这将在`Service`类中发生。在前两行中，我们指定了服务名称和显示名称。请注意，我选择的名称`ScsiAccess`与Photodex软件的原始名称相似。因此，如果我们像上一部分那样从Windows任务管理器打开服务，名称将与脆弱软件的服务名称完全匹配。
- en: Next, we initialize the `ServiceFramework` and define in functions style what
    to do when we get a service manager signal. So, for example, if the service manager
    signal was pause, then we will `sleep` for `Sleep(sec*1000, True)` time of seconds.
    Also, if the signal was start, then we will tell the service manager that we are
    planning to run the service; this will happen via reporting back a `SERVICE_START_PENDING`
    status through `ReportServiceStatus()`. Then, within an exception handling, we
    will tell the service manager that we are currently running up the service and
    we will call the `start()` function. If any exception happened, then we will call
    the `SvcStop()` function here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化`ServiceFramework`，并以函数式的方式定义在接收到服务管理器信号时应该执行的操作。例如，如果服务管理器的信号是暂停，那么我们将`sleep`指定的秒数，即`Sleep(sec*1000,
    True)`。同样，如果信号是启动，那么我们会告诉服务管理器我们计划运行该服务；这将通过通过`ReportServiceStatus()`报告`SERVICE_START_PENDING`状态来完成。然后，在异常处理程序中，我们将告诉服务管理器我们正在启动服务，并且会调用`start()`函数。如果发生任何异常，我们将在这里调用`SvcStop()`函数。
- en: 'Once we execute the `start()` function, we mark the `ServiceStatus` flag as
    `True` and we will wait in a while loop for receiving a service stop signal from
    the service manager. If we get this signal, we move to `stop()` function, which
    will eventually switch the flag to `False`. Now, inside the `stop()` function,
    we will do a similar procedure to what we did in the `start()` function. So, we
    will tell the service manager that we are planning to stop the service then, we
    will execute the `stop()` function and finally we will tell the service manager
    that we are currently stopping the service. Now, within the `stop()` function,
    we mark the service status flag as `False` to break the infinite loop in the `start()`
    function. Now, if I export this script into EXE and replace it instead of the
    `sciaccess.exe` and restart the machine, it should work fine. However, I want
    to go an extra mile and to prove that we got system privilege. So, let''s make
    sure that the exploitation worked fine. For this purpose, I made a quick Python
    script to check whether we are running as admin or not:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了`start()`函数，我们将`ServiceStatus`标志设置为`True`，然后我们将在一个`while`循环中等待接收来自服务管理器的停止信号。如果我们收到此信号，我们将转到`stop()`函数，最终将标志切换为`False`。现在，在`stop()`函数内部，我们将执行与`start()`函数类似的过程。因此，我们会告诉服务管理器我们计划停止服务，然后执行`stop()`函数，最后告诉服务管理器我们当前正在停止服务。现在，在`stop()`函数中，我们将服务状态标志设置为`False`，以打破`start()`函数中的无限循环。现在，如果我将此脚本导出为EXE文件，并用它替代`sciaccess.exe`并重启机器，应该可以正常工作。然而，我想再进一步，证明我们获得了系统权限。那么，让我们确保利用过程正常工作。为此，我编写了一个快速的Python脚本来检查我们是否以管理员身份运行：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script will simply call the `IsUserAnAdmin()` function from Windows. If
    the returned value is `0`, it means that we are a standard user; otherwise, it
    means that we have admin privileges. To run this script, open Command Prompt as
    administrator and navigate to the `Desktop` then `Users` and type `python "Are
    we Admin.py"`. We'll get `[+] We are admin :)` as we are having admin privilege.
    This is because before initiating the Command Prompt, I did a right-click and
    selected Run as administrator.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将简单地调用Windows中的`IsUserAnAdmin()`函数。如果返回值是`0`，则表示我们是标准用户；否则，表示我们拥有管理员权限。要运行这个脚本，请以管理员身份打开命令提示符，并导航到`Desktop`然后是`Users`，然后输入`python
    "Are we Admin.py"`。如果我们拥有管理员权限，将显示`[+] We are admin :)`。这是因为在启动命令提示符之前，我右键点击并选择了“以管理员身份运行”。
- en: So, I'm going to use this little trick in our code, and I will inject the check
    admin script within our malicious service. Obviously, it should be executed once
    the service gets started, so it should be under the `start()` function. Once we
    run the service, we will create a text file on the desktop and inside that text
    file we will see what privilege are we running into.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我打算在我们的代码中使用这个小技巧，并将检查管理员权限的脚本注入到我们的恶意服务中。显然，它应该在服务启动时执行，因此应该位于`start()`函数内。一旦我们运行服务，我们将在桌面上创建一个文本文件，文件中将显示我们当前的权限。
- en: So, we will now export the script into EXE like we did in the previous chapter,
    and at this point, all we have to do is to replace the original EXE file with
    the generated one. Go to the original one of the Photodex software. Since the
    software is vulnerable, we will be able to replace this one. So, I'm going to
    rename this one to `access2` and I will simply copy and paste our malicious file
    here. If everything is working fine our service should run without any error and
    we should see a text file on the desktop and once we open it, should tell us the
    privilege that we run into. After restarting, you'll notice a `priv` text file on
    the desktop. If you open it, you'll see a text that says we are running as an
    administrator.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在将像上一章一样将脚本导出为EXE文件，到这时，我们需要做的就是用生成的文件替换原始的EXE文件。前往Photodex软件的原始文件位置。由于软件存在漏洞，我们可以替换这个文件。所以，我将把这个文件重命名为`access2`，然后简单地复制并粘贴我们的恶意文件。如果一切正常，我们的服务应该没有任何错误地运行，并且我们应该在桌面上看到一个文本文件，打开它后应该告诉我们当前运行的权限。重启后，你会注意到桌面上有一个`priv`文本文件。如果你打开它，你会看到一行文本，说明我们以管理员身份运行。
- en: Privilege escalation – creating a new admin account and covering the tracks
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提权攻击——创建一个新的管理员账户并掩盖痕迹
- en: 'In our previous section, we created a malicious Python service and replaced
    the legitimate one with it. Once the system has started, we verified that we get
    a system or admin privilege. Now, in this section, we''ll see how we can create
    a new admin account and then jump from the standard user to the admin account.
    So, what I have changed on the coding part is adding the following section to
    the previous code, which in summary will create a new admin account once the service
    gets started:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们创建了一个恶意的Python服务，并将合法服务替换掉。一旦系统启动，我们验证了我们获得了系统或管理员权限。现在，在这一节中，我们将看到如何创建一个新的管理员账户，然后从标准用户跳转到管理员账户。所以，我在代码部分做的修改是将以下部分添加到之前的代码中，简而言之，这段代码将会在服务启动后创建一个新的管理员账户：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, keep in mind that I have added the aforementioned section under the `start()`
    function. So here, we defined the new username called `Hacked`, and the group
    that it belongs to, which is `Administrators` group. Next, we create a user and
    the group information profile in a dictionary format. Then, inside the dictionary,
    we specify some values, such as `password`, `priv`, and `home_dir`. Finally, we
    create the new admin account and add it as a group member to the `Administrators`
    group. In case any exception happened during the creation phase, we will simply
    skip it. Now, before exporting the code into EXE and test, quickly verify the
    usernames that we got on the machine by running `net users` in Command Prompt
    and it will list the users in our machine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，记住，我已经在`start()`函数下添加了上述部分。在这里，我们定义了一个名为`Hacked`的新用户名，以及它所属的组，即`Administrators`组。接下来，我们在字典格式中创建一个用户和组信息配置文件。然后，在字典中，我们指定一些值，如`password`、`priv`和`home_dir`。最后，我们创建新的管理员账户并将其添加为`Administrators`组的成员。如果在创建过程中发生任何异常，我们将简单跳过它。现在，在导出代码为EXE并测试之前，快速验证一下我们在机器上获得的用户名，通过在命令提示符中运行`net
    users`，它会列出机器上的所有用户。
- en: Currently, we are logged into the `nonadmin` account. So, let's go ahead and
    do the EXE exporting here. Copy the script into the `Toexe` folder and rename
    it to `sciaccess`. Now, run the setup file. Then, copy the exported EXE file to
    replace our vulnerable software in the `Photodex\ProShow Producer` folder. At
    this point, if everything is working fine, then after a restart, we should see
    a new admin account listed called `Hacked`. Now, restart the machine and log into
    the `nonadmin` account. Fire up the Command Prompt. Now, if we type `net users`,
    we will get a new username called `Hacked`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们登录的是`nonadmin`账户。所以，让我们继续在这里导出EXE。将脚本复制到`Toexe`文件夹并重命名为`sciaccess`。现在，运行安装文件。然后，将导出的EXE文件复制并替换掉`Photodex\ProShow
    Producer`文件夹中的脆弱软件。此时，如果一切正常，重启后我们应该能看到一个名为`Hacked`的新管理员账户。现在，重启机器并登录到`nonadmin`账户。打开命令提示符。现在，如果我们输入`net
    users`，我们将看到一个新的用户名`Hacked`。
- en: If we type `net users Hacked`, we'll see at the bottom that we belong to the
    `Administrators` group. So, at this point, once we get admin privilege, we can
    do whatever we want. So, let's go evil and clear the Windows event logs from the
    Event Viewer by logging in with the Hacked admin account. This will help us cover
    our tracks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入`net users Hacked`，我们会看到底部显示我们属于`Administrators`组。所以，在这一点上，一旦我们获得管理员权限，就可以为所欲为。那么，让我们走上歧途，使用被黑的管理员账户登录并清除事件查看器中的Windows事件日志。这将有助于我们掩盖痕迹。
- en: Summary
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned the different ways to execute privilege escalation
    and exploit the vulnerabilities. We started with exporting a file to EXE and then
    moved to target a vulnerable software. After this, we initiated backdoor creation
    and subsequently covered our tracks to avoid detection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不同的特权提升方式和漏洞利用方法。我们从导出文件到EXE开始，然后转向针对脆弱软件。之后，我们开始创建后门并随后掩盖我们的痕迹，以避免被发现。
- en: In the next chapter, we'll deal with different types of encryption algorithms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将处理不同类型的加密算法。
