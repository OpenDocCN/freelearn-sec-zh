- en: Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 应用程序
- en: Go has a powerful HTTP package in the standard library. The `net/http` package
    is documented at [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)
    and contains the HTTP and HTTPS utilities. At first, I advise that you stay away
    from the community HTTP frameworks and stick to the Go standard library. The standard
    HTTP package includes functions for listening, routing, and templating. The built-in
    HTTP server is of production quality, and it binds directly to a port, eliminating
    the need for a separate httpd, such as Apache, IIS, or nginx. However, it is common
    to see nginx listening on the public port `80` and reverse proxying all requests
    to Go servers listening on local ports other than `80`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言在标准库中有一个强大的 HTTP 包。`net/http` 包的文档可以在[https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)找到，它包含了
    HTTP 和 HTTPS 的相关工具。一开始，我建议你远离社区的 HTTP 框架，专注于 Go 的标准库。标准 HTTP 包包括用于监听、路由和模板的函数。内置的
    HTTP 服务器具有生产级质量，并且直接绑定到端口，省去了使用单独的 httpd（如 Apache、IIS 或 nginx）的需要。然而，通常会看到 nginx
    监听公共端口 `80`，并将所有请求反向代理到 Go 服务器，该服务器监听的是其他本地端口。
- en: In this chapter, we cover the basics of running an HTTP server, using HTTPS,
    setting secure cookies, and escaping output. We also cover how to use the Negroni
    middleware package and implement custom middleware for logging, adding secure
    HTTP headers, and serving static files. Negroni takes an idiomatic Go approach
    and encourages the use of the standard library `net/http` handlers. It is very
    lightweight and builds on top of the existing Go structures. Additionally, other
    best practices related to running a web application are mentioned.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何运行 HTTP 服务器，使用 HTTPS，设置安全的 cookies，并转义输出。我们还介绍了如何使用 Negroni 中间件包，以及如何实现自定义中间件来进行日志记录、添加安全的
    HTTP 头信息和服务静态文件。Negroni 采用 Go 语言的惯用方法，并鼓励使用标准库 `net/http` 处理程序。它非常轻量，并且在现有的 Go
    结构之上构建。此外，还提到了一些与运行 Web 应用程序相关的最佳实践。
- en: HTTP client examples are also provided. Starting with making a basic HTTP request,
    we move on to making HTTPS requests and using client certificates for authentication
    and proxies for route traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 也提供了 HTTP 客户端示例。从基本的 HTTP 请求开始，我们接着学习如何发起 HTTPS 请求，并使用客户端证书进行身份验证，以及使用代理转发流量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: HTTP servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 服务器
- en: Simple HTTP servers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 HTTP 服务器
- en: TLS encrypted HTTP (HTTPS)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS 加密的 HTTP（HTTPS）
- en: Using secure cookies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的 cookies
- en: HTML escaping output
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 输出转义
- en: Middleware with Negroni
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Negroni 中间件
- en: Logging requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求日志记录
- en: Adding secure HTTP headers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加安全的 HTTP 头信息
- en: Serving static files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务静态文件
- en: Other best practices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他最佳实践
- en: Cross-site request forgery (CSRF) tokens
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF）令牌
- en: Preventing user enumeration and abuse
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止用户枚举和滥用
- en: Avoiding local and remote file inclusion vulnerabilities
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免本地和远程文件包含漏洞
- en: HTTP clients
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 客户端
- en: Making basic HTTP requests
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发起基本的 HTTP 请求
- en: Using a client SSL certificate
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端 SSL 证书
- en: Using proxies
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理
- en: Using System proxy
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系统代理
- en: Using an HTTP proxy
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 代理
- en: Using a SOCKS5 proxy (Tor)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SOCKS5 代理（Tor）
- en: HTTP server
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 服务器
- en: 'HTTP is an application protocol built on top of the TCP layer. The concept
    is relatively simple; you can craft a request using plain text. In the first line,
    you will provide the method, such as `GET` or `POST`, along with the path and
    the HTTP version you are conforming to. After that, you will provide a series
    of key and value pairs to describe your request. Generally, you need to provide
    a `Host` value so that the server knows which website you are requesting. A simple
    HTTP request might look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是构建在 TCP 层之上的应用层协议。其概念相对简单；你可以使用纯文本来构造请求。在请求的第一行，你将提供方法（如 `GET` 或 `POST`），路径以及你遵循的
    HTTP 版本。之后，你将提供一系列的键值对来描述你的请求。通常，你需要提供 `Host` 值，以便服务器知道你正在请求哪个网站。一个简单的 HTTP 请求可能如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You don't need to worry about all of the details in the HTTP specification though.
    Go provides a `net/http` package that comes with several tools for easily creating
    production-ready web servers, including support for HTTP/2.0 with Go 1.6 and newer.
    This section covers topics related to running and securing HTTP servers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需担心 HTTP 规范中的所有细节。Go 提供了 `net/http` 包，包含了多个工具，可以轻松创建生产就绪的 Web 服务器，包括对 HTTP/2.0（Go
    1.6 及更新版本）的支持。本节涵盖了与运行和保护 HTTP 服务器相关的主题。
- en: Simple HTTP servers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的 HTTP 服务器
- en: 'In this example, an HTTP server demonstrates how simple it is to create a listening
    server with the standard library. There is no routing or multiplexing yet. In
    this case, a specific directory is served through the server. `http.FileServer()`
    has directory listing built in, so if you make an HTTP request to `/`, then it
    will list the files available in the directory being served:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，一个HTTP服务器展示了使用标准库创建一个监听服务器是多么简单。此时还没有路由或复用。在这个例子中，服务器通过特定目录提供服务。`http.FileServer()`具有内置的目录列出功能，因此，如果你向`/`发送HTTP请求，它会列出正在提供服务的目录中的文件：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This next example shows how to route a path and create a function to handle
    incoming requests. This one won''t accept any command-line arguments, because
    it''s not quite a useful program on its own, but you can use this as a basic template:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何路由路径并创建一个处理传入请求的函数。这个示例不会接受任何命令行参数，因为它本身并不是一个特别有用的程序，但你可以将它作为一个基本模板：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: HTTP basic auth
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP基本认证
- en: 'HTTP basic auth works by taking the username and password, combining them with
    a colon separator, and encoding them using base64\. The username and password
    can commonly be passed as part of the URL, for example: `http://<username>:<password>@www.example.com`.
    Under the hood, what happens though is that the username and password are combined,
    encoded, and passed as an HTTP header.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基本认证的工作方式是通过将用户名和密码组合，并用冒号分隔符连接，然后使用base64编码。这些用户名和密码通常作为URL的一部分传递，例如：`http://<用户名>:<密码>@www.example.com`。但实际发生的情况是，用户名和密码被组合、编码，并作为HTTP头部传递。
- en: If you use this method of authentication, keep in mind that it is not encrypted.
    There is no protection for the username and password in transit. You always want
    to use encryption on the transport layer, which means adding TLS/SSL.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这种认证方法，请记住它是没有加密的。用户名和密码在传输过程中没有保护。你始终希望在传输层使用加密，这意味着需要添加TLS/SSL。
- en: HTTP basic auth is not widely used these days, but it is easy to implement.
    A more common approach is to build or use your own authentication layer in your
    application, such as comparing a username and a password to a user database full
    of salted and hashed passwords.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在HTTP基本认证不再广泛使用，但它很容易实现。一个更常见的方法是构建或使用你自己的认证层，例如将用户名和密码与一个包含加盐哈希密码的用户数据库进行比较。
- en: Refer to [Chapter 8](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml), *Brute Force*,
    for an example of creating a client and connecting to an HTTP server that requires
    HTTP basic authentication. The Go standard library provides only a method for
    HTTP basic auth as a client. It does not provide a method for checking basic auth
    on the server side.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第8章](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml)，*暴力破解*，了解如何创建一个客户端并连接到需要HTTP基本认证的HTTP服务器。Go标准库只提供了作为客户端的HTTP基本认证方法，并不提供在服务器端检查基本认证的方法。
- en: I would not recommend that you implement HTTP basic auth on a server any more.
    If you need to authenticate a client, use TLS certificates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我不再建议你在服务器上实现HTTP基本认证。如果你需要认证客户端，请使用TLS证书。
- en: Using HTTPS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS
- en: In [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    we walked you through the steps necessary to generate keys and then create your
    own self-signed certificate. We also gave you an example of how to run a TCP socket-level
    TLS server. This section will demonstrate how to create a TLS-encrypted HTTP server
    or an HTTPS server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*密码学*中，我们带你了解了生成密钥的步骤，并创建了自己的自签名证书。我们还给了你一个如何运行TCP套接字级TLS服务器的示例。本节将展示如何创建一个TLS加密的HTTP服务器或HTTPS服务器。
- en: TLS is the newer version of SSL, and Go has a standard package that supports
    it well. You need a private key and the signed certificate generated with that
    key. You can use a self-signed certificate or one signed by a recognized certificate
    authority. Historically, SSL certs signed by a trusted authority always cost money,
    but [https://letsencrypt.org/](https://letsencrypt.org/) changed the game when
    they began offering free and automated certificates signed by a widely trusted
    authority.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是SSL的更新版本，Go有一个标准包很好地支持它。你需要一个私钥和使用该密钥生成的签名证书。你可以使用自签名证书或由认可的证书颁发机构签名的证书。历史上，受信任的证书颁发机构签发的SSL证书通常是收费的，但[https://letsencrypt.org/](https://letsencrypt.org/)改变了这一格局，它们开始提供由广泛信任的证书颁发机构签发的免费自动化证书。
- en: If you need a certificate (`cert.pem`) for this example, refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, for an example of creating your own self-signed certificate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要此示例的证书（`cert.pem`），请参考 [第六章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*密码学*，获取创建自签名证书的示例。
- en: 'The following code demonstrates the most basic example of how to run an HTTPS
    server that serves a single web page. Refer to the examples in [Chapter 10](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml), *Web
    Scraping* for various HTTP honeypot examples and more HTTP server reference code.
    After initializing the HTTPS server in the source code, you can work with it the
    same way you work with the HTTP server object. Notice that the only difference
    between this and the HTTP server is that you call `http.ListenAndServeTLS()` instead
    of `http.ListenAndServe()`. Additionally, you must provide the certificate and
    key for the server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何运行一个基本的 HTTPS 服务器，该服务器提供单一的网页。有关各种 HTTP 欺骗陷阱示例和更多 HTTP 服务器参考代码，请参考
    [第十章](1b5ddb7b-00f9-47df-947c-e4d0ebeb94e5.xhtml)，*网页抓取*。在源代码中初始化 HTTPS 服务器后，你可以像操作
    HTTP 服务器对象一样操作它。请注意，这与 HTTP 服务器的唯一区别在于你调用的是 `http.ListenAndServeTLS()` 而非 `http.ListenAndServe()`。此外，你必须为服务器提供证书和密钥：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating secure cookies
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安全的 cookie
- en: Cookies themselves shouldn't ever contain sensitive information that the user
    should not be able to see. Attackers can target cookies to try and gather private
    information. The most common target is the session cookie. If the session cookie
    is compromised, an attacker can use the cookie to impersonate the user, and the
    server would allow it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie 本身不应包含用户不应看到的敏感信息。攻击者可能会通过攻击 cookie 来尝试收集私人信息。最常见的目标是会话 cookie。如果会话 cookie
    被盗取，攻击者可以利用该 cookie 冒充用户，服务器会允许这种行为。
- en: The `HttpOnly` flag asks the browser to prevent JavaScript from accessing the
    cookie, protecting against cross-site scripting attacks. The cookie will only
    get sent when making HTTP requests. If you do need a cookie to be accessed via
    JavaScript, just create a different cookie from the session cookie.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpOnly` 标志要求浏览器防止 JavaScript 访问 cookie，保护免受跨站脚本攻击。该 cookie 只会在进行 HTTP 请求时发送。如果你确实需要通过
    JavaScript 访问某个 cookie，只需创建一个与会话 cookie 不同的 cookie。'
- en: The `Secure` flag asks the browser to only transport the cookie with TLS/SSL
    encryption. This protects against session **sidejacking** attempts commonly done
    by sniffing a public unencrypted Wi-Fi network or a man-in-the-middle connection.
    Some websites will only put SSL on the login page to protect your password, but
    every connection after that is done in plain HTTP, and the session cookie can
    be stolen off the wire or, potentially, with JavaScript if the `HttpOnly` flag
    is missing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Secure` 标志要求浏览器仅使用 TLS/SSL 加密传输 cookie。这可以防止会话 **旁路攻击**，这类攻击通常通过嗅探公共的非加密 Wi-Fi
    网络或中间人连接进行。一些网站只在登录页面上启用 SSL 来保护密码，但之后的每一个连接都使用明文 HTTP，这时会话 cookie 可能会被从网络中窃取，或者如果缺少
    `HttpOnly` 标志，还可能通过 JavaScript 被盗取。'
- en: When creating a session token, make sure that it is generated using a cryptographically
    secure pseudo-random number generator. Session tokens should be at a minimum of
    128 bits. Refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*,
    for examples of generating secure random bytes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建会话令牌时，请确保使用加密安全的伪随机数生成器生成它。会话令牌的最小长度应为 128 位。参考 [第六章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*密码学*，获取生成安全随机字节的示例。
- en: 'The following example creates a simple HTTP server that has only one function,
    the `indexHandler()`. The function creates a cookie with the recommended security
    settings, and then calls `http.SetCookie()` before printing the body of the response
    and returning:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个简单的 HTTP 服务器，只有一个函数，即 `indexHandler()`。该函数会根据推荐的安全设置创建一个 cookie，然后调用
    `http.SetCookie()`，在打印响应主体并返回之前。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: HTML escaping output
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML 输出转义
- en: Go has a standard function to escape a string and prevent HTML characters from
    getting rendered.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个标准函数，用于转义字符串并防止 HTML 字符被渲染。
- en: 'When outputting any data received by the user to the response output, always
    escape it to prevent cross-site scripting attacks. This applies equally whether
    the user-supplied data comes from a URL query, a POST value, the user-agent header,
    a form, a cookie, or the database. The following snippet gives an example of escaping
    a string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在将用户接收到的任何数据输出到响应时，始终对其进行转义以防止跨站脚本攻击。无论用户提供的数据来自URL查询、POST值、用户代理头、表单、cookie还是数据库，这一规则都适用。以下代码片段展示了如何转义一个字符串：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Middleware with Negroni
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Negroni 的中间件
- en: Middleware is the term for functions that can be tied to the request/response
    flow and take action or make modification before passing it on to the next middleware
    and ultimately back to the client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是指可以绑定到请求/响应流程中的函数，这些函数可以在将请求传递给下一个中间件并最终返回给客户端之前进行操作或修改。
- en: Middleware is a series of functions run in order on each request. You can add
    more functions to this chain. We will take a look at some practical examples,
    such as blacklisting IP addresses, adding logging, and adding authorization checks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一系列按顺序运行的函数，针对每个请求。您可以向这个链中添加更多的函数。我们将通过一些实际示例来看看，比如 IP 地址黑名单、添加日志记录和添加授权检查。
- en: The order of middleware is important. For example, we may want to put the logging
    middleware first, and then the IP blacklisting middleware. We would want the IP
    blacklist module to run first, or at least near the beginning, so that other middlewares
    don't waste resources processing a request that will just be rejected anyway.
    You can manipulate the request and response before passing it on to the next middleware
    handler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的顺序非常重要。例如，我们可能希望先放置日志记录中间件，然后是 IP 黑名单中间件。我们希望 IP 黑名单模块先运行，或者至少在前面运行，以免其他中间件浪费资源处理那些注定会被拒绝的请求。您可以在将请求传递给下一个中间件处理器之前操作请求和响应。
- en: You may want to also build custom middleware for analytics, logging, blacklisting
    IP addresses, injecting headers, or rejecting certain user agents, such as `curl`,
    `python`, or `go`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想为分析、日志记录、IP 黑名单、注入头部或拒绝某些用户代理（如 `curl`、`python` 或 `go`）构建自定义中间件。
- en: 'These examples use the Negroni package. Before compiling and running these
    examples, you need to `go get` the package. The examples call `http.ListenAndServe()`,
    but you can just as easily modify them to use TLS with `http.ListenAndServeTLS()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用了 Negroni 包。在编译并运行这些示例之前，您需要 `go get` 该包。这些示例调用了 `http.ListenAndServe()`，但您也可以轻松修改它们以使用
    TLS，方法是使用 `http.ListenAndServeTLS()`：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following example creates a `customMiddlewareHandler()` function, which
    we will tell the `negroniHandler` interface to use. The custom middleware simply
    logs the incoming request URL and user agent, but you can do whatever you like,
    including modifying the request before it goes back to the client:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个 `customMiddlewareHandler()` 函数，我们将告诉 `negroniHandler` 接口使用它。自定义中间件仅记录传入的请求
    URL 和用户代理，但您可以根据需要进行修改，包括在请求返回客户端之前修改请求：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logging requests
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录请求
- en: 'Because logging is such a common task, Negroni comes with a logger middleware
    that you can use, as demonstrated in the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录是一个非常常见的任务，Negroni 提供了一个日志记录中间件，您可以使用它，正如以下示例所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding secure HTTP headers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加安全的 HTTP 头部
- en: Taking advantage of the Negroni package, we can easily create our own middleware
    to inject a set of HTTP headers to help improve security. You will need to evaluate
    each header to see whether it makes sense for your application. In addition, not
    every browser supports every one of these headers. This is a good baseline to
    begin with and modify to suit your needs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Negroni 包，我们可以轻松创建自定义中间件，注入一组 HTTP 头部，以帮助提高安全性。您需要评估每个头部，看看它是否适合您的应用程序。此外，并不是每个浏览器都支持这些头部中的每一个。这是一个良好的起点，您可以根据需要进行修改。
- en: 'The following headers are used in this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中使用了以下标题：
- en: '| **Header** | **Description** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **Header** | **Description** |'
- en: '| `Content-Security-Policy` | This defines what scripts or remote hosts are
    trusted and able to provide executable JavaScript |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `Content-Security-Policy` | 该头部定义哪些脚本或远程主机是受信任的，并且能够提供可执行的 JavaScript |'
- en: '| `X-Frame-Options` | This defines whether or not frames and iframes can be
    used and which domains are allowed to appear in frames |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `X-Frame-Options` | 该头部定义是否可以使用框架和内嵌框架，以及哪些域名可以出现在框架中 |'
- en: '| `X-XSS-Protection` | This tells the browser to stop loading if a cross-site
    scripting attack is detected; it is largely unnecessary if a good `Content-Security-Policy`
    header is defined |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `X-XSS-Protection` | 这告诉浏览器在检测到跨站脚本攻击时停止加载；如果定义了良好的 `Content-Security-Policy`
    头部，这通常是不必要的 |'
- en: '| `Strict-Transport-Security` | This tells the browser to use only HTTPS and
    not HTTP |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `Strict-Transport-Security` | 这告诉浏览器仅使用 HTTPS，而不是 HTTP |'
- en: '| `X-Content-Type-Options` | This tells the browser to use the MIME type provided
    by the server, and not to modify based upon guesses by MIME sniffing |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `X-Content-Type-Options` | 这告诉浏览器使用服务器提供的 MIME 类型，而不是基于 MIME 嗅探猜测进行修改 |'
- en: It is ultimately up to the client's web browser whether or not these headers
    are used or ignored. They do not guarantee any security without a browser that
    knows how to apply the header values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最终是否使用这些头部或忽略它们取决于客户端的 Web 浏览器。如果没有一个能够正确应用头部值的浏览器，它们并不能保证任何安全性。
- en: 'This example creates a function named `addSecureHeaders()`, which is used as
    an additional middleware handler to modify the response before it goes back to
    the client. Tweak the headers as needed for your application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个名为 `addSecureHeaders()` 的函数，作为额外的中间件处理程序，在响应返回给客户端之前修改响应头。根据需要调整头部以适应你的应用程序：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Serving static files
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: 'Another common web server task is to serve static files. It is worth mentioning
    the Negroni middleware handler for serving static files. Just add an additional
    `Use()` call and pass `negroni.NewStatic()` to it. Make sure that your static
    files directory contains only files that clients should access. In most cases,
    the static files directory contains CSS and JavaScript files for the client. Do
    not put database backups, configuration files, SSH keys, Git repositories, development
    files, or anything a client shouldn''t have access to. Add the static-file middleware
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的 Web 服务器任务是提供静态文件。值得一提的是 Negroni 中间件处理程序，它用于提供静态文件。只需添加额外的 `Use()` 调用，并传递
    `negroni.NewStatic()`。确保你的静态文件目录仅包含客户端应该访问的文件。在大多数情况下，静态文件目录包含客户端的 CSS 和 JavaScript
    文件。不要放置数据库备份、配置文件、SSH 密钥、Git 仓库、开发文件或任何客户端不应该访问的内容。像这样添加静态文件中间件：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Other best practices
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他最佳实践
- en: There are a few other things worth considering when creating a web application.
    Although they are not Go specific, it is worth taking these best practices into
    account when developing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Web 应用程序时，还有一些其他值得考虑的事项。虽然这些并非 Go 特有的，但在开发过程中，考虑这些最佳实践是值得的。
- en: CSRF tokens
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF 令牌
- en: '**Cross-Site Request Forgery**, or **CSRF**, tokens are a way of trying to
    prevent one website from taking action on your behalf against a different website.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）令牌是一种防止一个网站代替你在另一个网站上执行操作的方式。'
- en: CSRF is a common attack where a victim will visit a website with malicious code
    embedded that tries to make a request to a different site. For example, a malicious
    actor embeds JavaScript that makes a POST request to every bank website attempting
    to transfer $1,000 to the attacker's bank account. If the victim has an active
    session with one of those banks, and the bank does not implement CSRF tokens,
    the bank's website may accept the request and process it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 是一种常见的攻击方式，受害者会访问一个嵌入恶意代码的网站，该代码尝试向其他网站发起请求。例如，攻击者嵌入了一个 JavaScript，使其向每个银行网站发送一个
    POST 请求，试图将 1,000 美元转账到攻击者的银行账户。如果受害者在其中一个银行有活动会话，并且该银行未实现 CSRF 令牌，那么银行网站可能会接受并处理该请求。
- en: It is possible to be the victim of a CSRF attack even on a trusted site, if
    the trusted site is vulnerable to either reflective or stored cross-site scripting.
    CSRF has been on the *OWASP Top 10* since 2007 and remains there in 2017.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在受信任的网站上，如果该网站容易受到反射型或存储型跨站脚本攻击，仍然可能成为 CSRF 攻击的受害者。自 2007 年以来，CSRF 一直位于 *OWASP
    Top 10* 中，并在 2017 年继续位列其中。
- en: Go provides a `xsrftoken` package that you can read more about at [https://godoc.org/golang.org/x/net/xsrftoken](https://godoc.org/golang.org/x/net/xsrftoken).
    It provides a `Generate()` function to create tokens and a `Valid()` function
    to validate tokens. You can use their implementation of choose to develop your
    own to suit your needs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个 `xsrftoken` 包，你可以在 [https://godoc.org/golang.org/x/net/xsrftoken](https://godoc.org/golang.org/x/net/xsrftoken)
    上了解更多信息。它提供了一个 `Generate()` 函数用于生成令牌，和一个 `Valid()` 函数用于验证令牌。你可以使用他们的实现，或者根据你的需求开发自己的实现。
- en: To implement CSRF tokens, create a 16-byte random token and store it on the
    server associated to the user's session. You can use whatever backend you like
    to store the token, whether that is in memory, in a database, or in a file. Embed
    the CSRF token in the form as a hidden field. When processing the form on the
    server side, verify that the CSRF token is present and matches the user. Destroy
    the token after it is used. Do not reuse the same token.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现CSRF令牌，创建一个16字节的随机令牌，并将其存储在与用户会话相关联的服务器上。你可以使用任何后端存储令牌，无论是在内存中、数据库中还是文件中。将CSRF令牌嵌入到表单中作为隐藏字段。在服务器端处理表单时，验证CSRF令牌是否存在且与用户匹配。令牌使用后销毁，不要重复使用同一个令牌。
- en: 'The various requirements for implementing CSRF tokens have been covered in
    the previous sections:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实现CSRF令牌的各种要求已在前面的章节中介绍：
- en: 'Generating a token: In [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, a section titled *Cryptographically secure pseudo-random number
    generator (CSPRNG)* provides an example of generating random numbers, strings,
    and bytes.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成令牌：在[第6章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，《*加密学*》中，标题为《*加密安全伪随机数生成器（CSPRNG）*》的部分提供了一个生成随机数、字符串和字节的示例。
- en: 'Creating, serving, and processing an HTML form: In [Chapter 9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml),
    *Web Applications*, the section titled *HTTP server* provides information on creating
    a secure web server, and [Chapter 12](ae593b94-6855-4154-be69-5e21d78daced.xhtml),
    *Social Engineering*, has a section titled *HTTP POST form login honeypot* has
    an example of processing a POST request.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、提供和处理HTML表单：在[第9章](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml)，《*Web应用程序*》中，标题为《*HTTP服务器*》的部分提供了关于创建安全Web服务器的信息，而[第12章](ae593b94-6855-4154-be69-5e21d78daced.xhtml)，《*社会工程学*》中的《*HTTP
    POST表单登录蜜罐*》部分有一个处理POST请求的示例。
- en: 'Storing a token in a file: In [Chapter 3](88c1b677-61eb-4955-9fb9-7650ab33e7c8.xhtml),
    *Working with Files*, the section titled *Write bytes to a file* provides an example
    of storing data in a file.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储令牌到文件中：在[第3章](88c1b677-61eb-4955-9fb9-7650ab33e7c8.xhtml)，《*操作文件*》一节中，标题为《*将字节写入文件*》的部分提供了一个将数据存储到文件中的示例。
- en: 'Storing a token in a database: In [Chapter 8](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml),
    *Brute Force*, the section titled *Brute force database login* provides a blueprint
    for connecting to various database types.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将令牌存储在数据库中：在[第8章](7b009a9c-c906-4919-ae73-07b807521f0c.xhtml)，《*暴力破解*》中，标题为《*暴力破解数据库登录*》的部分提供了连接到各种数据库类型的蓝图。
- en: Preventing user enumeration and abuse
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止用户枚举和滥用
- en: 'The important things to remember here are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的要点如下：
- en: Don't let people figure out who has an account
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让人们知道谁有账户
- en: Don't let someone spam your users with your email server
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让某人利用你的邮箱服务器向用户发送垃圾邮件
- en: Don't allow people to figure out who is registered by brute force attempts
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要允许人们通过暴力破解尝试找出谁已注册
- en: Let's elaborate on the practical examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一些实际的例子。
- en: Registration
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: When someone attempts to register an email address, do not give the web client
    user any feedback about whether or not the account is registered. Instead, send
    an email to the address and simply give the web user a message saying, "An email
    has been sent to the address provided."
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人尝试注册一个电子邮件地址时，不要向网页客户端用户提供任何关于账户是否已注册的反馈。相反，向该邮箱地址发送邮件，并简单地给网页用户一个信息：“一封邮件已发送至提供的地址。”
- en: If they have never registered, everything is normal. If they are already registered,
    the web user does not get informed that the email is already registered. Instead,
    an email is sent to the user's address informing them that the email is already
    registered. This will remind them they have an account already and they can use
    the password reset tool, or let them know something is suspicious and someone
    may be doing something malicious.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们从未注册过，一切正常。如果他们已经注册，网页用户不会被告知该邮箱已经注册。相反，会向用户的邮箱地址发送一封邮件，告知该邮箱已被注册。这将提醒他们已经拥有一个帐户，可以使用密码重置工具，或者让他们知道某些情况可能存在异常，可能有人在进行恶意操作。
- en: Be careful that you do not allow an attacker to repeatedly attempt the login
    process and generate mass amounts of email to your real user.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不要允许攻击者反复尝试登录过程，产生大量邮件发送给真实用户。
- en: Login
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: Do not give the web user feedback about whether or not an email exists. You
    do not want someone to be able to try logging in with an email address and learn
    whether or not that address has an account just by the error message returned.
    For example, an attack could attempt to log in using a list of email addresses,
    and if the web server returns, "That password does not match," for some emails
    and "That email is not registered," for other emails, they can determine which
    emails are registered with your service.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不要向网页用户反馈电子邮件是否存在。你不希望用户通过尝试使用某个电子邮件地址登录并根据返回的错误信息判断该地址是否注册了账户。例如，攻击者可能会尝试使用一系列电子邮件地址登录，如果服务器返回“密码不匹配”的错误信息给某些电子邮件地址，而返回“该电子邮件未注册”的错误信息给其他地址，攻击者就能确定哪些电子邮件地址已注册。
- en: Resetting the password
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置密码
- en: Avoid allowing email spam. Rate limit the emails sent so that an attacker cannot
    spam your users by submitting the forgot password form multiple times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 避免允许电子邮件垃圾邮件。对发送的电子邮件进行速率限制，确保攻击者无法通过多次提交忘记密码表单来向用户发送垃圾邮件。
- en: When creating a reset token, ensure that it has good entropy so that it can't
    be guessed. Don't just create a token based on the time and the user ID because
    that can be guessed and brute forced too easily, as it lacks enough entropy. You
    should use at least 16-32 random bytes for a token to have decent entropy. Refer
    to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml), *Cryptography*, for
    examples of generating cryptographically secure random bytes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建重置令牌时，确保令牌具有良好的熵值，防止其被猜测。不要仅仅基于时间和用户ID来创建令牌，因为这样容易被猜测和暴力破解，因为熵值不足。你应该至少使用
    16-32 个随机字节来确保令牌具有足够的熵。有关生成加密安全随机字节的示例，请参考 [第 6 章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*密码学*。
- en: Also, set the token to expire after a short period. Anywhere from one hour to
    one day are good options depending on your application. Only allow one reset token
    at a time, and destroy a token after it is used so that it cannot be replayed
    and used again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，设置令牌在短时间后过期。根据应用程序的不同，1小时到1天之间是不错的选择。每次只允许使用一个重置令牌，并在使用后销毁该令牌，以防止其被重放和再次使用。
- en: User profiles
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户资料
- en: Similar to the login page, if you have user profile pages, be careful about
    allowing username enumeration. For example, if someone visits `/users/JohnDoe`
    and then `/users/JaneDoe`, and one returns a `404 Not Found` error, while the
    other returns an `401 Access Denied` error, the attacker can infer that one account
    actually exists and the other does not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于登录页面，如果你有用户资料页面，务必小心避免用户名枚举攻击。例如，如果某人访问 `/users/JohnDoe` 和 `/users/JaneDoe`，其中一个返回
    `404 Not Found` 错误，而另一个返回 `401 Access Denied` 错误，攻击者就可以推断出一个账户存在而另一个账户不存在。
- en: Preventing LFI and RFI abuse
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止 LFI 和 RFI 滥用
- en: '**Local File Inclusion** (**LFI**) and **Remote File Inclusion** (**RFI**)
    are other *OWASP Top 10* vulnerabilities. They refer to the danger of loading
    files from the local file system or a remote host that were not intended to be
    loaded, or loading the intended files but with contaminated data. Remote file
    includes are dangerous because a user may supply a remote file from a malicious
    server if precaution is not taken.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地文件包含** (**LFI**) 和 **远程文件包含** (**RFI**) 是另外两种 *OWASP Top 10* 漏洞。它们指的是从本地文件系统或远程主机加载本不应加载的文件，或者加载了本应加载的文件，但这些文件被污染了。远程文件包含尤其危险，因为如果没有采取预防措施，用户可能会提供来自恶意服务器的远程文件。'
- en: 'Do not open a file from the local file system if the filename is specified
    by the user without any sanitization. Consider an example where a file is returned
    by a web server upon request. The user may be able to request a file with sensitive
    system information, such as `/etc/passwd`, with a URL like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件名由用户指定而没有进行任何清理，切勿从本地文件系统中打开该文件。假设一个例子，文件是通过 Web 服务器响应用户请求返回的。用户可能能够请求一个包含敏感系统信息的文件，比如 `/etc/passwd`，URL
    可能是这样的：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This could be big trouble if the web server handled it like this (pseudocode):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Web 服务器像这样处理，可能会带来大麻烦（伪代码）：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can''t simply fix it by prepending a specific directory like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能仅仅通过在路径前添加特定的目录来修复这个问题：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This isn''t enough because attackers can use directory traversal to get back
    to the root of the filesystem, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不够，因为攻击者可以利用目录遍历攻击回到文件系统的根目录，如下所示：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Be sure to check for directory traversal attacks with any file inclusion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在任何文件包含操作中检查目录遍历攻击。
- en: Contaminated files
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被污染的文件
- en: If an attacker finds an LFI, or you provide a web interface to log files, you
    need to make sure that, even if the logs are contaminated, no code will execute.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者发现 LFI（本地文件包含漏洞），或者你提供了一个用于查看日志文件的 Web 界面，你需要确保即使日志被污染，也不会执行任何代码。
- en: An attacker can potentially contaminate your logs and insert malicious code
    by taking some action on your service that creates a log entry. Any service that
    generates a log that is loaded or displayed must be considered.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能通过在你的服务上采取某些行动来污染你的日志并插入恶意代码，从而创建一个日志条目。任何生成的日志都必须加载或显示时，都必须考虑到这一点。
- en: For example, web server logs can be contaminated by making an HTTP request to
    a URL that is actually code. Your logs will have a `404 Not Found` error and log
    the URL that was requested, which is actually code. If it were a PHP server or
    another scripted language, this opens up potential code execution, but, with Go,
    the worst case would be JavaScript injection, which could still be dangerous to
    the user. Imagine a scenario where a web application has an HTTP log viewer that
    loads a log file from disk. If an attacker makes a request to `yourwebsite.com/<script>alert("test");</script>`,
    then your HTML log viewer may actually end up rendering that code, if it is not
    escaped or sanitized properly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Web 服务器日志可能会被通过对一个实际上是代码的 URL 发起 HTTP 请求而污染。你的日志将会有 `404 Not Found` 错误，并记录被请求的
    URL，而该 URL 实际上是代码。如果是 PHP 服务器或其他脚本语言，这可能会导致潜在的代码执行，但在 Go 中，最糟糕的情况是 JavaScript
    注入，这对用户仍然可能是危险的。想象一下这样的场景：一个 Web 应用程序有一个 HTTP 日志查看器，它从磁盘加载日志文件。如果攻击者向 `yourwebsite.com/<script>alert("test");</script>`
    发起请求，那么如果 HTML 日志查看器没有正确地转义或清理代码，最终可能会渲染出这些代码。
- en: HTTP client
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 客户端
- en: Making HTTP requests is a core part of many applications these days. Go, being
    a web-friendly language, contains several tools for making HTTP requests in the
    `net/http` package.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，HTTP 请求是许多应用程序的核心部分。Go 语言作为一种 web 友好的语言，包含了多个用于发起 HTTP 请求的工具，这些工具位于 `net/http`
    包中。
- en: The basic HTTP request
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的 HTTP 请求
- en: 'This example uses the `http.Get()` function from the `net/http` standard library
    package. It will read the entire response body to a variable named `body` and
    then print it to standard output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了来自 `net/http` 标准库包的 `http.Get()` 函数。它将整个响应体读取到名为 `body` 的变量中，然后将其打印到标准输出：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the client SSL certificate
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端 SSL 证书
- en: If a remote HTTPS server has strict authentication and requires a trusted client
    certificate, you can specify the certificate file by setting the `TLSClientConfig`
    variable in the `http.Transport` object that is used by `http.Client` to make
    the GET request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程 HTTPS 服务器有严格的身份验证并且需要受信任的客户端证书，你可以通过设置 `http.Transport` 对象中的 `TLSClientConfig`
    变量来指定证书文件，该对象是 `http.Client` 用于发起 GET 请求的。
- en: 'This example makes a HTTP GET request similar to the previous example, but
    it does not use the default HTTP client provided by the `net/http` package. It
    creates a custom `http.Client` and configures it to use TLS with the client certificate.
    If you need a certificate or private key, refer to [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*, for examples of generating keys and self-signed certificates:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例发起了一个类似于前面示例的 HTTP GET 请求，但它没有使用 `net/http` 包提供的默认 HTTP 客户端。它创建了一个自定义的 `http.Client`
    并配置了它以使用带有客户端证书的 TLS。如果你需要证书或私钥，请参考 [第 6 章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml)，*加密学*，其中包含生成密钥和自签名证书的示例：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using a proxy
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理
- en: A forward proxy can be useful for many things, including viewing the HTTP traffic,
    debugging an application, reverse engineering an API, and manipulating headers,
    and it can potentially be used to increase your anonymity to the target server.
    However, be aware that many proxy servers still forward your original IP using
    an `X-Forwarded-For` header.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正向代理对许多用途非常有用，包括查看 HTTP 流量、调试应用程序、逆向工程 API 和修改头信息，它也可以用来增加你在目标服务器上的匿名性。然而，要注意，许多代理服务器仍然通过
    `X-Forwarded-For` 头部转发你的原始 IP。
- en: You can use your environment variables to set a proxy or explicitly set a proxy
    with your request. The Go HTTP client supports HTTP, HTTPS, and SOCKS5 proxies,
    such as Tor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用环境变量来设置代理，或者显式地在请求中设置代理。Go HTTP 客户端支持 HTTP、HTTPS 和 SOCKS5 代理，例如 Tor。
- en: Using system proxy
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统代理
- en: 'Go''s default HTTP client will respect the system''s HTTP(S) proxy if set through
    environment variables. Go uses the `HTTP_PROXY`, `HTTPS_PROXY` and `NO_PROXY` environment
    variables. The lowercase versions are also valid. You can set the environment
    variable before running the process or set the environment variable in Go with
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的默认 HTTP 客户端会尊重系统通过环境变量设置的 HTTP(S) 代理。Go 使用 `HTTP_PROXY`、`HTTPS_PROXY` 和
    `NO_PROXY` 环境变量。小写版本也有效。你可以在运行进程之前设置环境变量，或者使用以下方式在 Go 中设置环境变量：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After configuring the environment variable(s), any HTTP request made using the
    default Go HTTP client will respect the proxy settings. Read more about the default
    proxy settings at [https://golang.org/pkg/net/http/#ProxyFromEnvironment](https://golang.org/pkg/net/http/#ProxyFromEnvironment).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好环境变量后，任何使用默认 Go HTTP 客户端发起的 HTTP 请求都会遵循代理设置。了解更多关于默认代理设置的信息，请访问 [https://golang.org/pkg/net/http/#ProxyFromEnvironment](https://golang.org/pkg/net/http/#ProxyFromEnvironment)。
- en: Using a specific HTTP proxy
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特定的 HTTP 代理
- en: 'To explicitly set the proxy URL, ignoring environment variables, set the `ProxyURL`
    variable in a custom `http.Transport` object that is used by `http.Client`. The
    following example creates custom `http.Transport` and specifies `proxyUrlString`.
    The example only has a placeholder value for the proxy and must be replaced with
    a valid proxy. `http.Client` is then created and configured to use the custom
    transport with the proxy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 若要显式设置代理 URL，忽略环境变量，可以在自定义的 `http.Transport` 对象中设置 `ProxyURL` 变量，`http.Client`
    会使用该自定义传输对象。以下示例创建了一个自定义的 `http.Transport` 并指定了 `proxyUrlString`。该示例中代理的值为占位符，需要替换为有效的代理。然后创建并配置
    `http.Client` 使用带代理的自定义传输：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using a SOCKS5 proxy (Tor)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SOCKS5 代理（Tor）
- en: Tor is an anonymity service that attempts to protect your privacy. Do not use
    Tor unless you fully understand all of the implications. Read more about Tor at
    [https://www.torproject.org](https://www.torproject.org). This example demonstrates
    how to use Tor when making a request, but this applies equally to other SOCKS5
    proxies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Tor 是一个匿名性服务，旨在保护你的隐私。除非你完全理解所有的影响，否则不要使用 Tor。了解更多关于 Tor 的信息，请访问 [https://www.torproject.org](https://www.torproject.org)。此示例展示了如何在发起请求时使用
    Tor，但这同样适用于其他 SOCKS5 代理。
- en: To use a SOCKS5 proxy, the only modification needed is with the URL string of
    the proxy. Instead of using the HTTP protocol, use the `socks5://` protocol prefix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SOCKS5 代理，唯一需要修改的是代理的 URL 字符串。请使用 `socks5://` 协议前缀代替 HTTP 协议。
- en: 'The default Tor port is `9050`, or `9150` when using the Tor Browser bundle.
    The following example will perform a GET request for `check.torproject.org`, which
    will let you know if you are properly routing through the Tor network:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Tor 端口是 `9050`，或者在使用 Tor 浏览器捆绑包时是 `9150`。以下示例将执行一个 GET 请求到 `check.torproject.org`，通过该请求可以查看是否已正确通过
    Tor 网络进行路由：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basics of running a web server written in Go.
    You should now feel comfortable creating a basic HTTP and HTTPS server. Furthermore,
    you should understand the concept of middleware and know how to implement prebuilt
    and custom middleware using the Negroni package.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何运行用 Go 编写的 Web 服务器的基础知识。现在，你应该能够创建一个基本的 HTTP 和 HTTPS 服务器。此外，你应该理解中间件的概念，并知道如何使用
    Negroni 包实现预构建和自定义中间件。
- en: We also covered some best practices when trying to secure a web server. You
    should understand what a CSRF attack is, and how to prevent it. You should be
    able to explain local and remote file inclusion and what the risks are.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些确保 Web 服务器安全的最佳实践。你应该理解 CSRF 攻击是什么，以及如何防止它。你应该能够解释本地和远程文件包含的概念以及相关的风险。
- en: The web server in the standard library is of production quality, and it has
    everything you need to create a production-ready web application. There are a
    number of other frameworks for web applications, such as Gorilla, Revel, and Martini,
    but, ultimately, you will have to evaluate the features provided by each framework
    and see if they align with your project needs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 Web 服务器质量足以用于生产，它具备了创建生产就绪 Web 应用所需的一切。还有一些其他的 Web 应用框架，如 Gorilla、Revel
    和 Martini，但最终你需要评估每个框架提供的功能，看看它们是否符合你的项目需求。
- en: We also covered the HTTP client functions provided by the standard library.
    You should know how to make basic HTTP requests and authenticated requests using
    a client certificate. You should understand how to use an HTTP proxy when making
    requests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讲解了标准库提供的 HTTP 客户端函数。你应该知道如何使用客户端证书发起基本的 HTTP 请求和认证请求。你应该理解如何在发起请求时使用 HTTP
    代理。
- en: In the next chapter, we will explore web scraping to extract information from
    HTML-formatted websites. We will start with basic techniques, such as string matching
    and regular expressions, and also explore the `goquery` package for working with
    the HTML DOM. We will also cover how to use cookies to crawl with a logged-in
    session. Fingerprinting web applications to identify frameworks is also discussed.
    We will also cover crawling the web with both the breadth-first and depth-first
    approaches.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨网页抓取技术，从HTML格式的网站中提取信息。我们将从基本技术开始，例如字符串匹配和正则表达式，还将探讨`goquery`包用于处理HTML
    DOM。我们还将介绍如何使用Cookie在登录会话中进行爬取。此外，我们还会讨论指纹识别网站应用程序以识别框架。我们还将涵盖使用广度优先和深度优先方法爬取网络。
