- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Evaluating Input Validation Checks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估输入验证检查
- en: Failure to validate any input received from the client before using it in the
    application code is one of the most common security vulnerabilities found in web
    applications. This flaw is the source of major security issues, such as SQL injection
    and **Cross-Site Scripting** (**XSS**). Web penetration testers must evaluate
    and determine whether any input is reflected back or executed upon by the application.
    We’ll learn how to use Burp Suite to perform such tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 未能在应用程序代码中使用来自客户端的任何输入之前进行验证，是 Web 应用程序中最常见的安全漏洞之一。这一漏洞是导致重大安全问题的根源，如 SQL 注入和**跨站脚本攻击**（**XSS**）。Web
    渗透测试人员必须评估并确定应用程序是否会反射或执行任何输入。我们将学习如何使用 Burp Suite 执行此类测试。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖以下配方：
- en: Testing for reflected cross-site scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试反射型跨站脚本攻击
- en: Testing for stored cross-site scripting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试存储型跨站脚本攻击
- en: Testing for HTTP verb tampering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 HTTP 动词篡改
- en: Testing for HTTP parameter pollution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 HTTP 参数污染
- en: Testing for SQL injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 SQL 注入
- en: Testing for command injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试命令注入
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the recipes in this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的配方，您将需要以下内容：
- en: OWASP Broken Web Applications (VM)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP 破损 Web 应用程序 (VM)
- en: OWASP Mutillidae link
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP Mutillidae 链接
- en: Burp Suite Proxy Community or Professional ([https://portswigger.net/burp/](https://portswigger.net/burp/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burp Suite Proxy 社区版或专业版（[https://portswigger.net/burp/](https://portswigger.net/burp/)）
- en: Testing for reflected cross-site scripting
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试反射型跨站脚本攻击
- en: Reflected cross-site scripting occurs when malicious JavaScript is injected
    into an input field, parameter, or header and, after returning from the web server,
    is executed within the browser. Reflected XSS occurs when the execution of JavaScript
    reflects in the browser only and is not a permanent part of the web page. Penetration
    testers need to test all client values sent to the web server to determine whether
    XSS is possible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反射型跨站脚本攻击发生在恶意 JavaScript 被注入到输入字段、参数或头部中，返回自 Web 服务器后，在浏览器中执行。反射型 XSS 发生时，JavaScript
    的执行仅反射到浏览器中，并不是网页的永久一部分。渗透测试人员需要测试所有发送到 Web 服务器的客户端值，以确定是否可能发生 XSS。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using OWASP Mutillidae II, let’s determine whether the application protects
    against reflected XSS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OWASP Mutillidae II，让我们确定该应用程序是否能够防范反射型 XSS。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A3 - Cross Site Scripting (XSS)** | **Reflected (First Order)** | **Pen
    Test** **Tool Lookup**:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 OWASP Mutillidae II 菜单中，选择 **登录**，通过导航到 **OWASP 2013** | **A3 - 跨站脚本攻击（XSS）**
    | **反射型（第一类）** | **渗透测试工具查找**：
- en: '![Figure 8.1 – Multillidae landing page](image/B21173_08_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – Multillidae 登陆页面](image/B21173_08_001.jpg)'
- en: Figure 8.1 – Multillidae landing page
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Multillidae 登陆页面
- en: 'Select a tool from the drop-down listing and click the **Lookup Tool** button.
    Any value from the drop-down list will work for this recipe:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择一个工具，并点击 **Lookup Tool** 按钮。下拉列表中的任何值都可以用于此配方：
- en: '![Figure 8.2 – Pentest tool vote](image/B21173_08_002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 渗透测试工具投票](image/B21173_08_002.jpg)'
- en: Figure 8.2 – Pentest tool vote
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 渗透测试工具投票
- en: 'Switch to Burp Suite **Proxy** | **HTTP history** and find the HTTP message
    you just created by selecting the lookup tool. Note that in the request is a parameter
    called **ToolID**. In the following example, the value is **3**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Burp Suite **Proxy** | **HTTP history**，并通过选择查询工具找到您刚刚创建的 HTTP 消息。请注意，请求中有一个名为
    **ToolID** 的参数。在以下示例中，值为 **3**：
- en: '![Figure 8.3 – Proxy HTTP history view](image/B21173_08_003.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 代理 HTTP 历史视图](image/B21173_08_003.jpg)'
- en: Figure 8.3 – Proxy HTTP history view
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 代理 HTTP 历史视图
- en: 'Flip over to the **Response** tab and note the JSON returned from the request.
    You can find the JavaScript function in the response more easily by typing **PenTest**
    in the search box at the bottom. Note that **tool_id** is reflected in a response
    parameter called **toolIDRequested**. This may be an attack vector for XSS:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻到 **Response** 标签页，并注意从请求返回的 JSON。通过在底部的搜索框中键入 **PenTest**，您可以更容易地找到响应中的 JavaScript
    函数。请注意，**tool_id** 在响应参数 **toolIDRequested** 中被反射。这可能是 XSS 攻击的一个切入点：
- en: '![Figure 8.4 – toolIDRequested and tool_id](image/B21173_08_004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – toolIDRequested 和 tool_id](image/B21173_08_004.jpg)'
- en: Figure 8.4 – toolIDRequested and tool_id
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – toolIDRequested 和 tool_id
- en: 'Send the request over to **Repeater**. Add an XSS payload within the **ToolID**
    parameter immediately following the equals sign. Use a simple payload such as
    **<script>alert(1);</script>**:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求发送到**重复器**。在**ToolID**参数中，紧跟等号后添加 XSS 负载。使用一个简单的负载，如 **<script>alert(1);</script>**：
- en: '![Figure 8.5 – XSS payload in the ToolID parameter](image/B21173_08_005.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – ToolID 参数中的 XSS 负载](image/B21173_08_005.jpg)'
- en: Figure 8.5 – XSS payload in the ToolID parameter
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – ToolID 参数中的 XSS 负载
- en: 'Click **Send** and examine the returned JSON response, searching for **PenTest**.
    Notice our payload is returned exactly as input. It looks like the developer is
    not sanitizing any of the input data before using it. Let’s exploit the flaw:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**，检查返回的 JSON 响应，搜索 **PenTest**。请注意，我们的负载被原样返回。看起来开发人员在使用这些输入数据之前没有进行任何清理。让我们利用这个漏洞：
- en: '![Figure 8.6 – Payload reflected in response](image/B21173_08_006.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 负载在响应中反射](image/B21173_08_006.jpg)'
- en: Figure 8.6 – Payload reflected in response
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 负载在响应中反射
- en: Since we are working with JSON instead of HTML, we will need to adjust the payload
    to match the structure of the JSON returned. We will fool the JSON into thinking
    the payload is legitimate. We will modify the original **<script>alert(1);</script>**
    payload to **"}} )%****3balert(1)%3b//** instead.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在处理 JSON 而不是 HTML，我们需要调整负载以匹配返回的 JSON 结构。我们将欺骗 JSON 认为负载是合法的。我们将原始的 **<script>alert(1);</script>**
    负载修改为 **"}} )%3balert(1)%3b//**。
- en: Switch to the Burp Suite **Proxy** | **Intercept** tab. Turn **Interceptor**
    on with the **Intercept is** **on** button.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Burp Suite **代理** | **拦截** 标签。通过点击 **拦截器已开启** 按钮开启 **拦截器**。
- en: Return to Firefox, select another tool from the drop-down list, and click the
    **Lookup** **Tool** button.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Firefox，选择下拉列表中的另一个工具，并点击**查找工具**按钮。
- en: 'While **Proxy** | **Interceptor** has the request paused, insert the new payload
    of **"}} )%3balert(1)%3b//** immediately after the **ToolID** number:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**代理** | **拦截器**暂停请求时，立即在**ToolID**数字后插入新的负载 **"}} )%3balert(1)%3b//**：
- en: '![Figure 8.7 – Modified XSS payload for JSON](image/B21173_08_007.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 为 JSON 修改的 XSS 负载](image/B21173_08_007.jpg)'
- en: Figure 8.7 – Modified XSS payload for JSON
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 为 JSON 修改的 XSS 负载
- en: Click the **Forward** button. Turn **Interceptor** off by toggling to **Intercept**
    **is off**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**转发**按钮。通过切换到**拦截器已关闭**来关闭**拦截器**。
- en: 'Return to the Firefox browser and see the pop-up alert box displayed. You’ve
    successfully shown a **proof of concept** (**PoC**) for the reflected XSS vulnerability:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Firefox 浏览器，查看弹出的警告框显示。你已经成功展示了**概念验证**（**PoC**）以证明反射型 XSS 漏洞：
- en: "![Figure 8.8 – Evidence of XSS vulnerabili\uFEFFt\uFEFFy](image/B21173_08_008.jpg)"
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – XSS 漏洞的证据](image/B21173_08_008.jpg)'
- en: Figure 8.8 – Evidence of XSS vulnerability
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – XSS 漏洞的证据
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Due to inadequate input cleansing prior to using data received from the client,
    in this case, the penetration testing tool’s identifier is reflected in the response
    as it is received from the client, allowing an attack vector for an XSS attack.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在使用来自客户端的数据之前没有进行充分的输入清理，在这种情况下，渗透测试工具的标识符按原样反射在响应中，允许 XSS 攻击的攻击向量。
- en: Testing for stored cross-site scripting
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试存储型跨站脚本攻击
- en: Stored cross-site scripting occurs when malicious JavaScript is injected into
    an input field, parameter, or header and, after returning from the web server,
    is executed within the browser and becomes a permanent part of the page. Stored
    XSS occurs when the malicious JavaScript is stored in the database and is used
    later to populate the display of a web page. Penetration testers need to test
    all client values sent to the web server to determine whether XSS is possible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存储型跨站脚本攻击发生在恶意 JavaScript 被注入到输入字段、参数或头部后，返回自 web 服务器时，在浏览器中执行，并成为页面的一部分。存储型
    XSS 发生在恶意 JavaScript 被存储在数据库中，并在之后用于填充网页的显示内容。渗透测试人员需要测试所有发送到 Web 服务器的客户端值，以确定
    XSS 是否可能。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using OWASP Mutillidae II, let’s determine whether the application protects
    against stored cross-site scripting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OWASP Mutillidae II，我们来确定该应用程序是否能防止存储型跨站脚本攻击。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A3 - Cross Site Scripting (XSS)** | **Persistent (First Order)** |
    **Add to** **your blog**:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OWASP Mutillidae II 菜单中，选择**登录**，依次导航到 **OWASP 2013** | **A3 - 跨站脚本攻击（XSS）**
    | **持久型（第一阶）** | **添加到** **你的博客**：
- en: '![Figure 8.9 – Navigation to the stored XSS lesson](image/B21173_08_009.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 导航到存储型 XSS 漏洞教学](image/B21173_08_009.jpg)'
- en: Figure 8.9 – Navigation to the stored XSS lesson
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 导航到存储型 XSS 漏洞教学
- en: 'Place some verbiage into the text area. Before clicking the **Save Blog Entry**
    button, let’s try a payload with the entry:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本框中输入一些文字。在点击**保存博客条目**按钮之前，让我们尝试输入一个有效载荷：
- en: '![Figure 8.10 – Save your blog entry](image/B21173_08_010..jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 保存您的博客条目](image/B21173_08_010..jpg)'
- en: Figure 8.10 – Save your blog entry
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 保存您的博客条目
- en: After clicking the **Save Blog Entry** button, you should immediately see the
    popup of the JavaScript stored on the page.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存博客条目**按钮后，您应该立即看到页面上存储的 JavaScript 弹出窗口。
- en: '![Figure 8.11 – Evidence of stored XSS vulnerability](image/B21173_08_011..jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 存储型 XSS 漏洞证据](image/B21173_08_011..jpg)'
- en: Figure 8.11 – Evidence of stored XSS vulnerability
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 存储型 XSS 漏洞证据
- en: Click the **OK** button to close the popups. Reload the page and you will see
    the alert popup again. This is because your malicious script has become a permanent
    part of the page. You’ve successfully shown a PoC for the stored XSS vulnerability!
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮以关闭弹出窗口。重新加载页面，您将再次看到警告弹出窗口。这是因为您的恶意脚本已成为页面的一部分。您已成功展示了存储型 XSS 漏洞的
    PoC！
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Stored or persistent XSS occurs because the application not only neglects to
    sanitize the input but also stores the input within the database. Therefore, when
    a page is reloaded and populated with database data, the malicious script is executed
    along with that data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存储型或持久型 XSS 漏洞的发生是因为应用程序不仅没有对输入进行清理，而且还将输入存储在数据库中。因此，当页面重新加载并填充数据库数据时，恶意脚本会与数据一起执行。
- en: Testing for HTTP verb tampering
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTP 方法篡改
- en: HTTP requests can include methods beyond **GET** and **POST**. As a penetration
    tester, it is important to determine which other HTTP verbs (that is, methods)
    the web server allows. Support for other verbs may disclose sensitive information
    (for example, **TRACE**) or allow for a dangerous invocation of application code
    (for example, **DELETE**). Let’s see how Burp Suite can help test for HTTP verb
    tampering.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求可以包括除了**GET**和**POST**以外的方法。作为渗透测试员，确定Web服务器允许哪些其他HTTP方法非常重要。支持其他方法可能会泄露敏感信息（例如，**TRACE**）或允许危险地调用应用程序代码（例如，**DELETE**）。让我们看看
    Burp Suite 如何帮助测试 HTTP 方法篡改。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using Altoro Mutual ([https://demo.testfire.net](https://demo.testfire.net)),
    let’s determine whether the application has a **POST** request we can manipulate
    into using a **GET** instead. If possible, the **GET** request will expose sensitive
    data within the query string. We will login first, then map the application to
    look for something interesting like a money movement transaction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Altoro Mutual ([https://demo.testfire.net](https://demo.testfire.net))，让我们确定应用程序是否有一个**POST**请求，可以将其修改为**GET**请求。如果可能，**GET**请求将会暴露查询字符串中的敏感数据。我们将先进行登录，然后映射应用程序，寻找像资金转移交易这样的有趣内容。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: Navigate to [https://demo.testfire.net](https://demo.testfire.net). Click the
    **Sign** **In** button.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至[https://demo.testfire.net](https://demo.testfire.net)，点击**登录**按钮。
- en: '![Figure 8.12 – Altoro Mutual landing page](image/B21173_08_012..jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – Altoro Mutual 登陆页面](image/B21173_08_012..jpg)'
- en: Figure 8.12 – Altoro Mutual landing page
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – Altoro Mutual 登陆页面
- en: You are brought to the login form.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您已进入登录表单。
- en: '![Figure 8.13 – Altoro Mutual login page](image/B21173_08_013..jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – Altoro Mutual 登录页面](image/B21173_08_013..jpg)'
- en: Figure 8.13 – Altoro Mutual login page
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – Altoro Mutual 登录页面
- en: After login, navigate to **Transfer Funds** using the left menu.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，使用左侧菜单导航至**转账**。
- en: '![Figure 8.14 – Navigate to the Transfer Funds page](image/B21173_08_014..jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – 导航到转账页面](image/B21173_08_014..jpg)'
- en: Figure 8.14 – Navigate to the Transfer Funds page
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 导航到转账页面
- en: On the **Transfer Funds** page, select the **Checking** account and type an
    amount of money in the **Amount to Transfer** field. Do not transfer the money
    yet.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**转账**页面，选择**支票账户**并在**转账金额**字段中输入金额。此时不要进行转账。
- en: '![Figure 8.15 – Select the account to transfer to and type the amount](image/B21173_08_015..jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – 选择转账账户并输入金额](image/B21173_08_015..jpg)'
- en: Figure 8.15 – Select the account to transfer to and type the amount
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 选择转账账户并输入金额
- en: 'Go to **Proxy** | **Intercept** and toggle **Intercept** **is on**:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**代理** | **拦截**，并切换**拦截**为**开启**：
- en: '![Figure 8.16 – Turn proxy intercept on](image/B21173_08_016..jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 打开代理拦截](image/B21173_08_016..jpg)'
- en: Figure 8.16 – Turn proxy intercept on
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 打开代理拦截
- en: Return to the browser and click the **Transfer** **Money** button.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回浏览器并点击**转账** **按钮**。
- en: '![Figure 8.17 – Click the Transfer Money button](image/B21173_08_017..jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – 点击转账按钮](image/B21173_08_017..jpg)'
- en: Figure 8.17 – Click the Transfer Money button
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 点击转账按钮
- en: 'Inside **Proxy** | **Intercept**, you can easily change the verb from **POST**
    to **GET** by right-clicking and selecting **Change** **request method**:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**代理** | **拦截**中，你可以通过右键点击并选择**更改** **请求方法**，轻松将动词从**POST**改为**GET**：
- en: '![Figure 8.18 – Change POST to GET](image/B21173_08_018..jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – 将 POST 改为 GET](image/B21173_08_018..jpg)'
- en: Figure 8.18 – Change POST to GET
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 将 POST 改为 GET
- en: Note how the request is now a **GET** request and the account numbers are now
    exposed in the query string.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，现在请求是一个**GET**请求，且账户号码已在查询字符串中暴露。
- en: '![Figure 8.19 – See sensitive data in the GET query string](image/B21173_08_019..jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.19 – 在 GET 查询字符串中查看敏感数据](image/B21173_08_019..jpg)'
- en: Figure 8.19 – See sensitive data in the GET query string
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 在 GET 查询字符串中查看敏感数据
- en: Click the **Forward** button and toggle **Proxy** | **Intercept** **is off**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**前进**按钮，并切换**代理** | **拦截** **已关闭**。
- en: 'Notice the transfer was still successful as a **GET** request:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，转账仍然成功作为**GET**请求：
- en: "![Figure 8.20 – Transfer was successfu\uFEFFl](image/B21173_08_020..jpg)"
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.20 – 转账成功](image/B21173_08_020..jpg)'
- en: Figure 8.20 – Transfer was successful
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 转账成功
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Testing for HTTP verb tampering includes sending requests against the application
    using different HTTP methods and analyzing the response received. In this recipe,
    the web developers allowed both a **POST** and a **GET** verb to be used in a
    transfer of funds between two accounts. Why is this a finding? Because the original
    **POST** request held sensitive data in the body of the request, whereas a **GET**
    request exposes the data in a query string, which is captured easily in web logs
    of servers and sniffed on the network wire. As a tester, you need to perform this
    type of test against login sequences and other areas of the application where
    you see sensitive data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 HTTP 动词篡改包括使用不同的 HTTP 方法向应用程序发送请求并分析接收到的响应。在本实例中，网页开发人员允许在两个账户之间转账时使用**POST**和**GET**动词。为什么这会被发现？因为原始的**POST**请求将敏感数据放在请求的主体中，而**GET**请求则在查询字符串中暴露数据，这些数据很容易被捕获在服务器的网页日志中，并且在网络中被嗅探到。作为测试人员，你需要在登录序列和应用程序中其他涉及敏感数据的区域进行此类测试。
- en: Testing for HTTP parameter pollution
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTP 参数污染
- en: '**HTTP parameter pollution** (**HPP**) is an attack in which multiple HTTP
    parameters are sent to the web server with the same name. The intention is to
    determine whether the application responds in an unanticipated manner, allowing
    exploitation. For example, in a **GET** request, additional parameters can be
    added to the query string—in this fashion: **"&name=value"**—where **name** is
    a duplicate parameter name already known by the application code. Likewise, HPP
    attacks can be performed on **POST** requests by duplicating a parameter name
    in the **POST** body data.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP 参数污染**（**HPP**）是一种攻击，其中多个 HTTP 参数以相同的名称发送到 Web 服务器。其目的是确定应用程序是否以意外的方式响应，从而允许漏洞利用。例如，在**GET**请求中，可以将附加参数添加到查询字符串中，格式为：**"&name=value"**，其中**name**是应用程序代码中已经知道的重复参数名。同样，也可以通过在**POST**请求的**POST**主体数据中复制参数名来执行
    HPP 攻击。'
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using OWASP Mutillidae II, let’s determine whether the application allows HPP
    attacks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OWASP Mutillidae II，来判断该应用程序是否允许 HPP 攻击。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A1 - Injection (Other)** | **HTTP Parameter Pollution** | **Poll Question**:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 OWASP Mutillidae II 菜单中，选择**登录**，导航到**OWASP 2013** | **A1 - 注入（其他）** | **HTTP
    参数污染** | **投票问题**：
- en: '![Figure 8.21 – Navigate to the HTTP Parameter Pollution lesson](image/B21173_08_021..jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21 – 转到 HTTP 参数污染课程](image/B21173_08_021..jpg)'
- en: Figure 8.21 – Navigate to the HTTP Parameter Pollution lesson
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 转到 HTTP 参数污染课程
- en: 'Select a tool from one of the radio buttons, add your initials, and click the
    **Submit** **Vote** button:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从单选按钮中选择一个工具，添加你的首字母，然后点击**提交** **投票**按钮：
- en: '![Figure 8.22 – Vote for a tool](image/B21173_08_022..jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.22 – 投票选择工具](image/B21173_08_022..jpg)'
- en: Figure 8.22 – Vote for a tool
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22 – 投票选择工具
- en: 'Switch to the Burp Suite **Proxy** | **HTTP history** tab and find the request
    you just performed from the **User Poll** page. Note the parameter named **choice**.
    The value of this parameter is **nmap**. Right-click and send this request to
    **Repeater**:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Burp Suite **Proxy** | **HTTP history** 标签，找到您刚刚在 **User Poll** 页面上执行的请求。注意参数名为
    **choice**。该参数的值是 **nmap**。右键单击并将该请求发送到 **Repeater**：
- en: '![Figure 8.23 – Send to Repeater](image/B21173_08_023..jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.23 – 发送到重复器](image/B21173_08_023..jpg)'
- en: Figure 8.23 – Send to Repeater
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – 发送到重复器
- en: Switch to Burp Suite **Repeater** and add another parameter with the same name
    to the query string. Let’s pick another tool from the **User Poll** list and append
    it to the query string, for example, **&choice=tcpdump**. This will add two choices,
    **&choice=nmap** (original) and **&choice=tcpdump**. Click **Send** to send the
    request.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Burp Suite **Repeater**，并向查询字符串中添加另一个具有相同名称的参数。我们从 **User Poll** 列表中选择另一个工具，并将其附加到查询字符串中，例如，**&choice=tcpdump**。这将添加两个选择项，**&choice=nmap**（原始）和
    **&choice=tcpdump**。点击 **Send** 发送请求。
- en: 'Examine the response. Which choice did the application code accept? This is
    easy to find by searching for the **Your choice was** string. Clearly, the duplicate
    choice parameter value is the one the application code accepted to count in the
    **User** **Poll** vote:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查响应。应用程序代码接受了哪个选择？通过搜索 **Your choice was** 字符串可以轻松找到这个选择。显然，重复的选择参数值是应用程序代码接受的并计入
    **User** **Poll** 投票中的那个：
- en: "![Figure 8.24 – Validate your change was accepted by the se\uFEFFr\uFEFFver](image/B21173_08_024..jpg)"
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.24 – 验证您的更改是否被服务器接受](image/B21173_08_024..jpg)'
- en: Figure 8.24 – Validate your change was accepted by the server
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 – 验证您的更改是否被服务器接受
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The application code fails to check against multiple parameters with the same
    name when passed into a function. The result is that the application usually acts
    upon the last parameter match provided. This can result in odd behavior and unexpected
    results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码在传入函数时未检查具有相同名称的多个参数。结果是，应用程序通常只会对最后一个匹配的参数进行操作。这可能导致异常行为和意外结果。
- en: Testing for SQL injection
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 SQL 注入
- en: A SQL injection attack involves an attacker providing input to the database,
    which is received and used without any validation or sanitization. The result
    is divulging sensitive data, modifying data, or even bypassing authentication
    mechanisms.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击涉及攻击者向数据库提供输入，这些输入在没有任何验证或清理的情况下被接收并使用。结果是泄露敏感数据、修改数据，甚至绕过认证机制。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using the OWASP Mutillidae II **Login** page, let’s determine whether the application
    is vulnerable to **SQL injection** (**SQLi**) attacks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OWASP Mutillidae II **Login** 页面，我们来确定应用程序是否易受 **SQL 注入**（**SQLi**）攻击。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the OWASP Mutillidae II menu, select **Login** by navigating to **OWASP
    2013** | **A1-Injection (SQL)** | **SQLi – Bypass Authentication** | **Login**:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 OWASP Mutillidae II 菜单中，选择 **Login**，路径为 **OWASP 2013** | **A1-Injection (SQL)**
    | **SQLi – 绕过认证** | **Login**：
- en: '![Figure 8.25 – Navigate to the SQL injection authentication bypass lesson](image/B21173_08_025..jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.25 – 导航到 SQL 注入认证绕过课程](image/B21173_08_025..jpg)'
- en: Figure 8.25 – Navigate to the SQL injection authentication bypass lesson
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25 – 导航到 SQL 注入认证绕过课程
- en: On the **Login** screen, place invalid credentials in the **Username** and **Password**
    textboxes. For example, the username is **' or 1=1--** with no password. Click
    the **Login** button.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Login** 屏幕上，在 **Username** 和 **Password** 文本框中输入无效凭据。例如，用户名为 **' or 1=1--**，没有密码。点击
    **Login** 按钮。
- en: '![Figure 8.26 – Login using SQLi payload](image/B21173_08_026..jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.26 – 使用 SQLi 负载登录](image/B21173_08_026..jpg)'
- en: Figure 8.26 – Login using SQLi payload
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26 – 使用 SQLi 负载登录
- en: Switch to the Burp Suite **Proxy** | **HTTP history** tab. Find the request
    with the payload of **' or 1=1--<space>** within the **username** parameter and
    click the **Login** button. Use **Inspector** to see the contents of the SQL injection
    payload more easily.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Burp Suite **Proxy** | **HTTP history** 标签。找到包含 **' or 1=1--<space>** 的
    **username** 参数的请求，并点击 **Login** 按钮。使用 **Inspector** 更轻松地查看 SQL 注入负载的内容。
- en: '![Figure 8.27 – Use Inspector to see your URL-encoded payload](image/B21173_08_027..jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.27 – 使用 Inspector 查看您的 URL 编码负载](image/B21173_08_027..jpg)'
- en: Figure 8.27 – Use Inspector to see your URL-encoded payload
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 使用 Inspector 查看您的 URL 编码负载
- en: Return to the Firefox browser and note you are now logged in as admin!
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Firefox 浏览器，注意您现在已作为管理员登录！
- en: "![Figure 8.28 – Verify SQLi payload wo\uFEFFrked](image/B21173_08_028..jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.28 – 验证 SQLi 负载是否有效](image/B21173_08_028..jpg)'
- en: Figure 8.28 – Verify SQLi payload worked
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 – 验证 SQLi 有效载荷是否有效
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Without knowing any credentials, you can use a SQL injection payload, such as
    **' or 1=1--<space>**, to bypass the authentication mechanism. The application
    contains a SQL injection vulnerability because the SQL code used in the backend
    application is constructed using the values of the textbox as is, without any
    sanitization of user input. The admin account is the first account created in
    the database, so the database defaulted to that account when the SQL injection
    payload executed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知晓任何凭证的情况下，你可以使用 SQL 注入有效载荷，例如 **' or 1=1--<space>**，绕过身份验证机制。该应用程序存在 SQL
    注入漏洞，因为后端应用程序中使用的 SQL 代码直接使用文本框中的值构建，而没有对用户输入进行任何清理。管理员账户是数据库中第一个创建的账户，因此当 SQL
    注入有效载荷执行时，数据库默认使用该账户。
- en: There’s more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can re-do this recipe and use a SQL injection wordlist from **wfuzz** within
    Burp Suite **Intruder** to test many different payloads in the **Username** field.
    Examine the response for each attack in the results table to determine whether
    the payload successfully performed a SQL injection and you are logged in to the
    application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新执行这个操作，并使用来自 **wfuzz** 的 SQL 注入字典，通过 Burp Suite **Intruder** 测试 **用户名**
    字段中的多种有效载荷。检查每次攻击的响应，查看结果表中是否成功执行了 SQL 注入，并且你已经登录到应用程序。
- en: The construction of SQL injection payloads requires some knowledge of the backend
    database and the syntax required. A great resource to assist in the construction
    of SQL injection payloads is [https://pentestmonkey.net/category/cheat-sheet/sql-injection](https://pentestmonkey.net/category/cheat-sheet/sql-injection).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 构造 SQL 注入有效载荷需要一些关于后端数据库和所需语法的知识。一个非常有用的资源是 [https://pentestmonkey.net/category/cheat-sheet/sql-injection](https://pentestmonkey.net/category/cheat-sheet/sql-injection)。
- en: Testing for command injection
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令注入
- en: Command injection involves an attacker attempting to invoke a system command,
    normally performed in a terminal session, within an HTTP request instead. Many
    web applications allow system commands through the UI for troubleshooting purposes.
    A web penetration tester must test whether the web page allows further commands
    on the system that should normally be restricted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入是指攻击者试图在 HTTP 请求中调用系统命令，通常这些命令是在终端会话中执行的。许多 web 应用程序允许通过 UI 执行系统命令，通常用于故障排除。web
    渗透测试人员必须测试该网页是否允许执行本应受到限制的系统命令。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you will need the SecLists payload for Unix commands on a
    Unix- or Linux-based operating system:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，你需要获取适用于 Unix 命令的 SecLists 有效载荷，适用于 Unix 或 Linux 操作系统：
- en: '[https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/UnixAttacks.fuzzdb.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/UnixAttacks.fuzzdb.txt)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/UnixAttacks.fuzzdb.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/UnixAttacks.fuzzdb.txt)'
- en: 'Download the SecLists payload from GitHub:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GitHub 下载 SecLists 有效载荷：
- en: '[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
- en: Using the OWASP Mutillidae II **DNS Lookup** page, let’s determine whether the
    application is vulnerable to command injection attacks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OWASP Mutillidae II **DNS 查询**页面，我们来确定该应用程序是否容易受到命令注入攻击。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the OWASP Mutillidae II menu, select **DNS Lookup** by navigating to **OWASP
    2013** | **A1-Injection (Other)** | **Command Injection** | **DNS Lookup**:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OWASP Mutillidae II 菜单中，选择 **DNS 查询**，导航至 **OWASP 2013** | **A1-注入（其他）** |
    **命令注入** | **DNS 查询**：
- en: '![Figure 8.29 – Navigate to the Command Injection lesson](image/B21173_08_029..jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.29 – 导航到命令注入课程](image/B21173_08_029..jpg)'
- en: Figure 8.29 – Navigate to the Command Injection lesson
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 – 导航到命令注入课程
- en: 'On the **DNS Lookup** page, type the IP address **127.0.0.1** in the textbox
    and click the **Lookup** **DNS** button:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **DNS 查询** 页面，输入 IP 地址 **127.0.0.1**，然后点击 **查询** **DNS** 按钮：
- en: '![Figure 8.30 – Type in an IP address](image/B21173_08_030..jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.30 – 输入一个 IP 地址](image/B21173_08_030..jpg)'
- en: Figure 8.30 – Type in an IP address
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.30 – 输入一个 IP 地址
- en: Switch to the Burp Suite **Proxy** | **HTTP history** tab and look for the request
    you just performed. Right-click on **Send** **to Intruder**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 Burp Suite **代理** | **HTTP 历史记录** 标签页，找到你刚才执行的请求。右键点击 **发送** **到 Intruder**。
- en: 'In the **Intruder** | **Positions** tab, clear all suggested payload markers
    with the **Clear $** button. In the **target_host** parameter, place a pipe symbol
    (**|**) immediately following the **127.0.0.1** IP address. After the pipe symbol,
    place an **X**. Highlight the **X** and click the **Add $** button to wrap the
    **X** with payload markers:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Intruder** | **Positions**标签中，使用**Clear $**按钮清除所有建议的payload标记。在**target_host**参数中，紧接在**127.0.0.1**
    IP地址后放置一个管道符号（**|**）。在管道符号后放置一个**X**。选中**X**并点击**Add $**按钮，将**X**用payload标记包裹起来：
- en: '![Figure 8.31 – Add a substitution marker at the end of the parameter along
    with a pipe](image/B21173_08_031..jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.31 – 在参数末尾添加替代标记，并使用管道符](image/B21173_08_031..jpg)'
- en: Figure 8.31 – Add a substitution marker at the end of the parameter along with
    a pipe
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.31 – 在参数末尾添加替代标记，并使用管道符
- en: 'In the **Intruder** | **Payloads** tab, click the **Load** button. Browse to
    the location where you downloaded the **SecLists-master** wordlists from GitHub.
    Navigate to the location of the **UnixAttacks.fuzzdb.txt** wordlist and use the
    following to populate the **Payload settings [Simple list]** box: **SecLists-master/Fuzzing/UnixAttacks.fuzzdb.txt**:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Intruder** | **Payloads**标签中，点击**Load**按钮。浏览到你从GitHub下载的**SecLists-master**单词列表的位置。导航到**UnixAttacks.fuzzdb.txt**单词列表的位置，并使用以下路径填充**Payload设置
    [简单列表]**框：**SecLists-master/Fuzzing/UnixAttacks.fuzzdb.txt**：
- en: '![Figure 8.32 – Load wordlist](image/B21173_08_032..jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.32 – 加载单词列表](image/B21173_08_032..jpg)'
- en: Figure 8.32 – Load wordlist
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.32 – 加载单词列表
- en: Uncheck the **Payload encoding** box at the bottom of the **Payloads** tab page
    and then click the **Start** **Attack** button.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选**Payload编码**框，在**Payloads**标签页面底部，然后点击**Start** **Attack**按钮。
- en: 'Allow the attack to continue until you reach payload **50**. Notice the responses
    through the **Render** tab are around payload **45** or so. We can perform commands,
    such as **id** on the operating system, which displays the results of the commands
    on the web page:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许攻击继续进行，直到达到payload **50**。注意，通过**Render**标签看到的响应大约在payload **45**附近。我们可以执行如**id**之类的命令，它将在网页上显示命令的结果：
- en: "![Figure 8.33 – Evidence of command injection e\uFEFFxploit](image/B21173_08_033..jpg)"
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.33 – 命令注入漏洞的证据](image/B21173_08_033..jpg)'
- en: Figure 8.33 – Evidence of command injection exploit
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.33 – 命令注入漏洞的证据
- en: We can also right-click this request from the results table and send to **Repeater**
    to perform the attack again.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以右键点击结果表中的此请求，并发送到**Repeater**以再次执行攻击。
- en: '![Figure 8.34 – Send to Repeater](image/B21173_08_034..jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.34 – 发送到Repeater](image/B21173_08_034..jpg)'
- en: Figure 8.34 – Send to Repeater
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.34 – 发送到Repeater
- en: In **Repeater**, click **Send**, and on the response, click the **Render** tab
    to view the results of the command injection.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Repeater**中，点击**Send**，然后在响应中点击**Render**标签以查看命令注入的结果。
- en: "![Figure 8.35 – Repeat exploit to see ev\uFEFFidence](image/B21173_08_035..jpg)"
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.35 – 重复利用漏洞以查看证据](image/B21173_08_035..jpg)'
- en: Figure 8.35 – Repeat exploit to see evidence
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.35 – 重复利用漏洞以查看证据
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Failure to define and validate user input against an acceptable list of system
    commands can lead to command injection vulnerabilities. In this case, the application
    code does not confine system commands available through the UI, allowing visibility
    and execution of commands on the operating system that should be restricted.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未对用户输入进行定义和验证，并与系统命令的可接受列表进行匹配，就可能导致命令注入漏洞。在此情况下，应用程序代码没有限制通过UI访问的系统命令，允许查看并执行应受到限制的操作系统命令。
