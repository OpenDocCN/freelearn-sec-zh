- en: Chapter 2. Efficient Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 高效发现
- en: Content discovery and information gathering are typically the first steps when
    attacking an application. The goal is to figure out as much as possible about
    the application in the quickest manner possible. Time is a luxury we don't have
    and we must make the most of our limited resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内容发现和信息收集通常是攻击应用程序的第一步。目标是在最短的时间内尽可能多地了解应用程序。时间是我们没有的奢侈品，我们必须充分利用有限的资源。
- en: Efficiency can also help us to remain a bit quieter when attacking applications.
    Smart wordlists will reduce the number of requests we make to the server and return results
    faster. This isn't a silver bullet, but it's a good place to start.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 效率也可以帮助我们在攻击应用程序时保持稍微安静一些。智能词汇表将减少我们向服务器发出的请求数量，并更快地返回结果。这不是万灵药，但它是一个很好的起点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The different types of penetration testing engagements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的渗透测试参与
- en: Target mapping with various network and web scanners
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种网络和Web扫描仪进行目标映射
- en: Efficient brute-forcing techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的暴力破解技术
- en: Polyglot payloads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言有效载荷
- en: Types of assessments
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估类型
- en: Depending on the agreement with the client prior to the engagement, you may
    have some of the information required, a lot of information, or no information
    whatsoever. **White-box** testing allows for a thorough examination of the application.
    In this case, the attackers have essentially the same access as the developer.
    They not only have authenticated access to the application, but also its source
    code, any design documents, and anything else they'll need.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据与客户在参与之前的协议，你可能已经拥有所需的部分信息、大量信息，或者根本没有任何信息。**白盒**测试允许对应用程序进行彻底检查。在这种情况下，攻击者基本上拥有与开发者相同的访问权限。他们不仅有经过身份验证的访问权限，而且还可以访问源代码、任何设计文档以及他们需要的任何其他资源。
- en: White-box testing is typically conducted by internal teams and it is fairly
    time-consuming. A tester is provided with any information they require to fully
    assess the application or infrastructure. The benefit of providing testers with
    this level of knowledge is that they will be able to look at every bit of an application
    and check for vulnerabilities. This is a luxury that external attackers do not
    have, but it does make efficient use of limited time and resources during an engagement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试通常由内部团队执行，且相当耗时。测试人员会获得他们评估应用程序或基础设施所需的所有信息。提供这种知识水平的好处是，测试人员可以查看应用程序的每一部分，检查是否存在漏洞。这是外部攻击者所没有的奢侈品，但它确实能在参与过程中有效利用有限的时间和资源。
- en: '**Gray-box** scenarios are more common, as they provide just enough information
    to let the testers get right into probing the application. A client may provide
    credentials and a bit of information on the design of the infrastructure or application,
    but not much more. The idea here is that the client assumes that a malicious actor
    already has a certain level of access or knowledge, and the client needs to understand
    how much more damage can be done.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**灰盒**场景更为常见，因为它们提供了足够的信息，使测试人员能够直接开始探测应用程序。客户可能会提供凭据以及一些关于基础设施或应用程序设计的信息，但不会提供更多。这里的思路是客户假设恶意行为者已经获得了某种程度的访问权限或知识，客户需要了解还能够造成多少更大的破坏。'
- en: Finally, **black-box** testing will simulate an attack from the perspective
    of an outsider without any knowledge of the application or infrastructure. Companies
    that expose applications to the internet are subjected to constant attack by external
    threats. While it is important to remember that not all malicious actors are external,
    as disgruntled employees can cause just as much damage, malicious black-box type
    attacks are fairly common and can be very damaging.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**黑盒**测试将模拟从外部人员的角度发起的攻击，攻击者对应用程序或基础设施一无所知。公开应用程序到互联网的公司通常会受到外部威胁的持续攻击。虽然重要的是要记住，并非所有恶意行为者都是外部人员，因不满的员工也可能造成同样的破坏，但恶意的黑盒类型攻击相对常见，且可能造成严重损害。
- en: 'The following is a breakdown of the three common types of application penetration tests:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三种常见的应用程序渗透测试类型的细分：
- en: '| White-box | Gray-box | Black-box |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 白盒 | 灰盒 | 黑盒 |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Attacker has access to all information required. | Some information is available.
    | Zero knowledge. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 攻击者可以访问所有所需信息。 | 有部分信息可用。 | 完全不了解。 |'
- en: '| Testing with the highest privilege, that is, with developer knowledge. |
    Testing from the perspective of a threat that already has a certain level of access
    or knowledge. | Testing from the perspective of an external threat. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 以最高权限进行测试，即具有开发者知识的测试。| 从已具备一定访问权限或知识的威胁角度进行测试。| 从外部威胁角度进行测试。|'
- en: '| Typical information available includes the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可用的典型信息包括以下内容：'
- en: User accounts
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户账户
- en: Source code
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码
- en: Infrastructure design documents
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施设计文档
- en: Directory listing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录列表
- en: '| Provides the attacker with some information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| 向攻击者提供一些信息：'
- en: User accounts
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户账户
- en: High-level documentation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级文档
- en: The attacker will usually not have access to the source code, or other sensitive
    information
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 攻击者通常无法访问源代码或其他敏感信息
- en: '| No information is provided up-front and the attacker must gather everything
    they need through **open-source intelligence** (**OSINT**) or vulnerabilities
    that lead to information leakage. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 未提前提供任何信息，攻击者必须通过**开源情报**（**OSINT**）或导致信息泄漏的漏洞收集所需的所有信息。|'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the remainder of this book, we will approach our targets from a more gray-box
    perspective, simulating the typical engagement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将从更接近灰盒测试的角度接近我们的目标，模拟典型的渗透测试过程。
- en: Target mapping
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标映射
- en: The traditional `nmap` of the entire port range, with service discovery, is
    always a good place to start when gathering information on a target. **Nmap**
    is the network scanning tool of choice and has been for many years. It is still
    very powerful and very relevant. It is available on most platforms, including
    Kali, BlackArch, and even Windows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个端口范围进行传统的 `nmap` 扫描并进行服务发现，总是收集目标信息的一个好方法。**Nmap** 是选择的网络扫描工具，已经使用多年。它仍然非常强大且相关。它可用于大多数平台，包括
    Kali、BlackArch，甚至是 Windows。
- en: '**Metasploit Framework** (**MSF**) is a penetration testing framework commonly
    used by security professionals. Besides being a fantastic collection of easy-to-deliver
    exploits, it can also help to organize engagements. For target mapping specifically,
    you can leverage the workspace feature and neatly store your Nmap scan results
    in a database.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Metasploit Framework**（**MSF**）是渗透测试框架，通常由安全专业人员使用。除了是一个易于交付的漏洞利用工具集外，它还可以帮助组织渗透测试过程。特别是在目标映射方面，你可以利用工作区功能，并将
    Nmap 扫描结果整齐地存储在数据库中。'
- en: If the Kali Linux instance is fresh or Metasploit was recently installed, the
    database may need a kick to get it going.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Kali Linux 实例是新安装的，或者 Metasploit 最近安装过，数据库可能需要一些启动操作才能正常运行。
- en: 'In the Kali console prompt, start the **PostgreSQL** service using the `service`
    command. If successful, there should be no message returned:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 控制台提示符下，使用`service`命令启动**PostgreSQL**服务。如果成功，则不应返回任何消息：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Metasploit can then be started using the `msfconsole` command, which will drop
    us into a sub-prompt, prefixed with `msf` instead of the traditional bash prompt:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用`msfconsole`命令启动 Metasploit，这将使我们进入一个子提示符，提示符前缀是`msf`，而不是传统的 bash 提示符：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding series of commands will start the PostgreSQL database service,
    which Metasploit uses for storage. The Metasploit console is launched and we can
    check the database status using MSF's `db_status` command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令序列将启动 PostgreSQL 数据库服务，Metasploit 使用它来进行存储。Metasploit 控制台会启动，我们可以使用 MSF
    的`db_status`命令检查数据库状态。
- en: 'We can use the `exit` command to return to the bash terminal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`exit`命令返回到 bash 终端：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now use the Metasploit `msfdb` command to help us initialize (`init`)
    the database:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 Metasploit 的`msfdb`命令来帮助我们初始化（`init`）数据库：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `msfdb` command creates all of the necessary configuration files for Metasploit
    to be able to connect to the database. Once again, we can start the Metasploit
    console using the `msfconsole` command in the Linux prompt:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfdb`命令会创建所有必要的配置文件，供 Metasploit 连接到数据库。我们再次可以通过在 Linux 提示符下使用`msfconsole`命令启动
    Metasploit 控制台：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The YML database configuration file, created with the `msfdb init` command,
    can be passed to the `db_connect` Metasploit console command as with the `-y`
    switch:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`msfdb init`命令创建的 YML 数据库配置文件，可以与`-y`开关一起传递给`db_connect` Metasploit 控制台命令：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now create a workspace for the target application, which will help us
    to organize results from various MSF modules, scans, or exploits:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为目标应用程序创建一个工作区，这将帮助我们组织来自不同 MSF 模块、扫描或漏洞利用的结果：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `workspace` command without any parameters will list the available workspaces,
    marking the active one with an asterisk. At this point, we can start an Nmap scan
    from within MSF. The `db_nmap` MSF command is a wrapper for the Nmap scanning
    tool. The difference is that the results of the scan are parsed and stored inside the
    Metasploit database for easy browsing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`workspace` 命令不带任何参数时将列出可用的工作区，并用星号标记当前活动的工作区。此时，我们可以在 MSF 内部启动 Nmap 扫描。`db_nmap`
    MSF 命令是 Nmap 扫描工具的一个封装。不同之处在于，扫描结果会被解析并存储在 Metasploit 数据库中，便于浏览。'
- en: MSF's `db_nmap` takes the same switches as the normal `nmap`. In the following
    example, we are scanning for common ports and interrogating running services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: MSF 的 `db_nmap` 接受与正常的 `nmap` 相同的选项。在以下示例中，我们正在扫描常见端口并查询正在运行的服务。
- en: 'The target for this scan is an internal host, `10.0.5.198`. We are instructing
    Nmap to perform a service scan (`-sV`) without pinging hosts (`-Pn`), and using
    verbose output (`-v`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此次扫描的目标是一个内部主机，`10.0.5.198`。我们指示 Nmap 执行服务扫描（`-sV`），并且不对主机进行 ping 测试（`-Pn`），同时使用详细输出（`-v`）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the scan completes, the results can be queried and filtered using the
    `services` command. For example, we can look for all HTTP services discovered
    by using the `-s` switch:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描完成后，结果可以通过 `services` 命令进行查询和筛选。例如，我们可以使用 `-s` 选项查找所有发现的 HTTP 服务：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take note of the scope provided by the client. Some will specifically constrain
    application testing to one port, or sometimes even only one subdomain or URL.
    The scoping call is where the client should be urged not to limit the attack surface
    available to the tester.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意客户提供的范围。有些客户会特别限制应用程序测试在一个端口上，或者有时仅限于一个子域或 URL。此时应当劝告客户不要限制测试者可用的攻击面。
- en: Masscan
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Masscan
- en: 'Nmap is fully featured, with a ton of options and capabilities, but there is
    one problem: speed. For large network segments, Nmap can be very slow and sometimes
    can fail altogether. It''s not unusual for clients to request a penetration test
    on a huge IP space with little time allotted for the mapping and scanning phase.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 功能全面，拥有大量的选项和能力，但存在一个问题：速度。对于大型网络段，Nmap 可能非常慢，有时甚至完全失败。在渗透测试中，客户通常会要求在有限的时间内对庞大的
    IP 空间进行映射和扫描。
- en: The claim to fame of **masscan** is that it can scan the internet IP space in
    about six minutes. This is an impressive feat and it is certainly one of the fastest
    port scanners out there.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**masscan** 的最大亮点在于，它可以在大约六分钟内扫描整个互联网的 IP 空间。这是一个令人印象深刻的成就，毫无疑问，它是目前最快的端口扫描器之一。'
- en: During an engagement, we may wish to target web applications first and `masscan`
    can quickly return all open web ports with just a couple of switches.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，我们可能希望优先针对 Web 应用程序进行测试，`masscan` 可以通过几个简单的选项快速返回所有开放的 Web 端口。
- en: 'The familiar `-p` switch can be used to specify a series, or range, of ports
    to look for. The `--banners` switch will attempt to retrieve some information
    about any open ports that are discovered. For larger IP spaces, where time is
    of the essence, we can use the `--rate` switch to specify a large packet per second
    number, such as a million or more:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的 `-p` 选项可以用来指定一系列端口或端口范围进行查找。`--banners` 选项将尝试获取任何发现的开放端口的一些信息。对于较大的 IP 空间，时间至关重要时，我们可以使用
    `--rate` 选项指定一个较大的每秒数据包数，如一百万或更多：
- en: '![Masscan](graphics/B09238_02_01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Masscan](graphics/B09238_02_01.jpg)'
- en: 'Figure 2.1: A masscan of the 10.0.0.0/8 network'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：对 10.0.0.0/8 网络进行的 masscan 扫描
- en: 'We can see that the preceding scan was cancelled early with the *Ctrl* + *C*
    interrupt, and masscan saved its progress in a `paused.conf` file, allowing us
    to resume the scan at a later time. To pick up where we left off, we can use the
    `--resume` switch, passing the `paused.conf` file as the parameter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，之前的扫描由于 *Ctrl* + *C* 中断而提前取消，masscan 保存了其进度到 `paused.conf` 文件中，这使我们能够稍后恢复扫描。要从中断处继续，我们可以使用
    `--resume` 选项，并将 `paused.conf` 文件作为参数传递：
- en: '![Masscan](graphics/B09238_02_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Masscan](graphics/B09238_02_02.jpg)'
- en: 'Figure 2.2: Resuming a masscan session'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：恢复 masscan 会话
- en: Masscan's results can then be fed into either Nmap for further processing, or
    a web scanner for more in-depth vulnerability discovery.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Masscan 的结果可以传递给 Nmap 进行进一步处理，或者传递给 Web 扫描器以进行更深入的漏洞发现。
- en: WhatWeb
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WhatWeb
- en: Once we've identified one or more web applications in the target environment
    with masscan or Nmap, we can start digging a bit deeper. **WhatWeb** is a simple,
    yet effective, tool that can look at a particular web application and identity
    what technologies have been used to develop and run it. It has more than 1,000
    plugins, which can passively identify everything from what **content management
    system** (**CMS**) is running on the application, to what version of **Apache**
    or **NGINX** is powering the whole thing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过 masscan 或 Nmap 确定了目标环境中一个或多个 web 应用程序，我们就可以开始深入挖掘。**WhatWeb** 是一个简单但有效的工具，可以查看特定的
    web 应用程序，并识别出开发和运行该应用所使用的技术。它拥有超过 1,000 个插件，能够被动识别从应用上运行的**内容管理系统**（**CMS**），到运行整个应用的
    **Apache** 或 **NGINX** 版本等各种信息。
- en: 'The following diagram shows a more aggressive (`-a 3`) scan of `bittherapy.net`
    with WhatWeb. The `sed` command shown will format the output to something a bit
    easier to read:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了对 `bittherapy.net` 进行的更为激进的（`-a 3`）WhatWeb 扫描。所示的 `sed` 命令将格式化输出，使其更易阅读：
- en: '![WhatWeb](graphics/B09238_02_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![WhatWeb](graphics/B09238_02_03.jpg)'
- en: 'Figure 2.3: Running WhatWeb and filtering the results'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：运行 WhatWeb 并过滤结果
- en: A level-3 aggression scan will perform several more requests to help to improve
    the accuracy of results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 三级激进扫描将进行更多的请求，以帮助提高结果的准确性。
- en: WhatWeb is available on Kali Linux and most other penetration testing distributions.
    It can also be downloaded from [https://github.com/urbanadventurer/WhatWeb](https://github.com/urbanadventurer/WhatWeb).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: WhatWeb 可在 Kali Linux 和大多数其他渗透测试发行版上使用。也可以从 [https://github.com/urbanadventurer/WhatWeb](https://github.com/urbanadventurer/WhatWeb)
    下载。
- en: Nikto
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nikto
- en: '**Nikto** provides value during the initial phases of the engagement. It is
    fairly non-intrusive and with its built-in plugins, it can provide quick insight
    into the application. It also offers some more aggressive scanning features that
    may yield success on older applications or infrastructure.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nikto** 在任务的初期阶段提供了很大价值。它相对不具侵入性，并且凭借其内建插件，能够快速提供关于应用程序的洞察。它还提供一些更为激进的扫描功能，这些功能可能对旧的应用程序或基础设施产生成功效果。'
- en: 'If the engagement does not require the attackers to be particularly stealthy,
    it doesn''t hurt to run through the noisier Nikto options as well. Nikto can guess
    subdomains, report on unusual headers, and check the `robots.txt` file for interesting
    information:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务不要求攻击者特别隐蔽，那么也可以运行噪音较大的 Nikto 选项。Nikto 可以猜测子域名、报告不寻常的头信息，并检查 `robots.txt`
    文件中的有趣信息：
- en: '![Nikto](graphics/B09238_02_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Nikto](graphics/B09238_02_04.jpg)'
- en: 'Figure 2.4: A standard scan of the example.com domain'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：example.com 域的标准扫描
- en: Nikto outputs information on the HTTPS certificate, the server banner, any security-related
    HTTP headers that may be missing, and any other information that may be of interest.
    It also noticed that the server banner had changed between requests, indicating
    that a WAF may be configured to protect the application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto 输出关于 HTTPS 证书、服务器横幅、可能缺失的任何安全相关 HTTP 头信息，以及其他可能有用的信息。它还注意到服务器横幅在请求之间发生了变化，表明可能配置了
    WAF 来保护应用程序。
- en: Nikto can be downloaded from [https://github.com/sullo/nikto](https://github.com/sullo/nikto).
    It is also available in most penetration testing-focused Linux distributions,
    such as Kali or BlackArch.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto 可以从 [https://github.com/sullo/nikto](https://github.com/sullo/nikto) 下载。它也可以在大多数渗透测试专用的
    Linux 发行版上找到，如 Kali 或 BlackArch。
- en: CMS scanners
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMS 扫描器
- en: When the target is using a CMS, such as **Joomla**, **Drupal**, or **WordPress**,
    running an automated vulnerability testing tool should be your next step.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标使用 CMS（如**Joomla**、**Drupal**或**WordPress**）时，运行自动化漏洞测试工具应成为你的下一步。
- en: WordPress is a popular CMS because it provides plugins for almost any type of site,
    making it very customizable and widely-adopted, but also complex, with a large
    attack surface. There are tons of vulnerable plugins, and users typically don't
    upgrade them frequently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 是一个流行的 CMS，因为它提供几乎适用于任何类型站点的插件，使其非常可定制并广泛采用，但同时也很复杂，攻击面较大。它有大量易受攻击的插件，且用户通常不频繁升级这些插件。
- en: During a test, you may find a remotely exploitable vulnerability in one of the
    plugins that provides a shell, but more often than not, WordPress is a treasure
    trove of information. Usernames can be enumerated, passwords are often weak and easily
    brute-forced, or directory indexing may be enabled. The WordPress content folder
    sometimes also contains sensitive documents uploaded "temporarily" by the administrator.
    In later chapters, we will see how an improperly configured WordPress instance
    can be leveraged to attack the application server and move laterally through the
    network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，你可能会发现某个插件中存在一个可以远程利用的漏洞，提供一个 shell，但通常来说，WordPress 是一个信息宝库。用户名可以被枚举，密码往往较弱且容易暴力破解，或者目录索引可能已启用。WordPress
    的内容文件夹有时也包含管理员“临时”上传的敏感文件。在后续章节中，我们将看到如何利用配置不当的 WordPress 实例攻击应用服务器，并在网络中横向渗透。
- en: WordPress is not alone in this space. Joomla and Drupal are also very popular
    and sport many of the same vulnerabilities and configuration issues that are seen
    in WordPress installations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 并非唯一存在这种问题的系统。Joomla 和 Drupal 也非常流行，并且也存在许多与 WordPress 安装相同的漏洞和配置问题。
- en: 'There are a few scanners available for free that aim to test for low-hanging
    fruit in these CMSs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些免费的扫描器可供使用，旨在测试这些 CMS 中的低悬果实：
- en: '**WPScan** ([https://wpscan.org/](https://wpscan.org/)): A powerful tool aimed
    at testing WordPress installations'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WPScan** ([https://wpscan.org/](https://wpscan.org/)): 一个强大的工具，用于测试 WordPress
    安装'
- en: '**JoomScan** ([https://github.com/rezasp/joomscan](https://github.com/rezasp/joomscan)):
    As the name implies, a CMS scanner specializing in Joomla testing'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JoomScan** ([https://github.com/rezasp/joomscan](https://github.com/rezasp/joomscan)):
    如其名称所示，是一个专注于 Joomla 测试的 CMS 扫描器'
- en: '**droopescan** ([https://github.com/droope/droopescan](https://github.com/droope/droopescan)):
    A Drupal-specific scanner with some support for Joomla'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**droopescan** ([https://github.com/droope/droopescan](https://github.com/droope/droopescan)):
    一个专门针对 Drupal 的扫描器，同时支持一些 Joomla'
- en: '**CMSmap** ([https://github.com/Dionach/CMSmap](https://github.com/Dionach/CMSmap)):
    A more generic scanner and brute-forcer supporting WordPress, Joomla, and Drupal'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSmap** ([https://github.com/Dionach/CMSmap](https://github.com/Dionach/CMSmap)):
    一个更通用的扫描器和暴力破解工具，支持 WordPress、Joomla 和 Drupal'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding with a WordPress scan, make sure that it is hosted inside
    the engagement scope. Some CMS implementations will host the core site locally,
    but the plugins or content directories are on a separate **content delivery network**
    (**CDN**). These CDN hosts may be subject to a penetration testing notification
    form before they can be included in the test.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行 WordPress 扫描之前，请确保它托管在参与范围内。一些 CMS 实现会将核心站点托管在本地，但插件或内容目录则位于独立的**内容分发网络**（**CDN**）上。这些
    CDN 主机可能需要提交渗透测试通知表单，才能将其包含在测试中。
- en: We will cover CMS assessment tools, such as WPScan, in more detail in later
    chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中更详细地介绍 CMS 评估工具，如 WPScan。
- en: Efficient brute-forcing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的暴力破解
- en: A brute-force attack typically involves a barrage of requests, or guesses, to
    gain access or reveal information that may be otherwise hidden. We may brute-force
    a login form on an administrative panel in order to look for commonly used passwords
    or usernames. We may also brute-force a web application's root directory looking
    for common misconfiguration and misplaced sensitive files.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力破解攻击通常涉及大量请求或猜测，以获得访问权限或揭示可能隐藏的信息。我们可能会对管理面板的登录表单进行暴力破解，寻找常用的密码或用户名。我们还可能对
    Web 应用的根目录进行暴力破解，寻找常见的配置错误和错误放置的敏感文件。
- en: Many successful engagements were made so by weak credentials or application
    misconfiguration. Brute-forcing can help to reveal information that may have been
    obscured, or can grant access to a database because the developer forgot to change
    the default credentials.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多成功的渗透测试正是通过弱凭据或应用配置错误实现的。暴力破解可以帮助揭示可能被隐藏的信息，或者因开发人员忘记更改默认凭据而获得对数据库的访问权限。
- en: There are obvious challenges to brute-forcing. Primarily, it is time-consuming
    and can be very noisy. Brute-forcing a web service, for example, with the infamous
    `rockyou.txt` wordlist will no doubt wake up your friendly neighborhood **security
    operations center** (**SOC**) analyst and may put an end to your activities early.
    The `rockyou.txt` list has over 14 million entries and could eventually result
    in a successful credential guess, but it may be better to limit the flood of traffic
    to the target with a smaller, more efficient list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 强行破解存在明显的挑战。主要是它非常耗时，并且可能非常嘈杂。例如，使用臭名昭著的`rockyou.txt`词表对一个Web服务进行强行破解，毫无疑问会引起你友好的邻居**安全运营中心**（**SOC**）分析员的注意，并可能会早早地终止你的活动。`rockyou.txt`列表包含超过1400万个条目，最终可能会成功猜测凭证，但限制流量洪流并使用更小、更高效的列表可能更好。
- en: 'One of the better collections of common keywords, credentials, directories,
    payloads, and even webshells is the **SecLists** repository: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更好的常见关键词、凭证、目录、有效负载甚至Webshell集合是**SecLists**库：[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative, or supplement, to SecLists is **FuzzDB**. It is a similar collection
    of files containing various payloads that can help with brute-forcing, and it
    can also be downloaded from the GitHub repository at [https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代方案或补充方案是**FuzzDB**。它是一个类似的文件集合，包含各种有效负载，可以帮助进行强行破解，它也可以从GitHub库中下载：[https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)。
- en: 'Grabbing the latest copy of SecLists is easy using `git`, a popular version
    control system tool. We can pull down the repository using the `git clone` command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流行的版本控制系统工具`git`获取SecLists的最新副本非常容易。我们可以使用`git clone`命令拉取这个库：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'SecLists contains an ever-evolving database of compiled wordlists that can
    be used in discovery scans, brute-force attacks, and much more:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SecLists包含一个不断发展的编译词表数据库，可以用于发现扫描、强行破解攻击等多种用途：
- en: '| SecList Wordlist | Description |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| SecList Wordlist | 描述 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Discovery` | Web content, DNS, and common Nmap ports |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Discovery` | Web内容、DNS和常见的Nmap端口 |'
- en: '| `Fuzzing` | FuzzDB, Brutelogic, Polyglot payloads, and more |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Fuzzing` | FuzzDB、Brutelogic、Polyglot有效负载等 |'
- en: '| `IOCs` | Malware-related indicators of compromise |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `IOCs` | 恶意软件相关的妥协指标 |'
- en: '| `Miscellaneous` | Various wordlists that may have obscure uses |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Miscellaneous` | 可能有特殊用途的各种词表 |'
- en: '| `Passwords` | Large numbers of wordlists for common passwords, split into
    top-N files |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Passwords` | 大量的常见密码词表，按前N个文件拆分 |'
- en: '| `Pattern-Matching` | Wordlists for use when "grepping" for interesting information
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `Pattern-Matching` | 用于“grep”感兴趣信息的词表 |'
- en: '| `Payloads` | Webshells for common languages, Windows Netcat, and an EICAR
    test file |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Payloads` | 常见语言的Webshell、Windows Netcat和EICAR测试文件 |'
- en: '| `Usernames` | Lists of common names and login IDs |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Usernames` | 常见名字和登录ID的列表 |'
- en: The security community is a frequent contributor to SecLists, and it is good
    practice to pull the latest changes from GitHub before starting an engagement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安全社区是SecLists的频繁贡献者，在开始工作之前，从GitHub拉取最新的更改是个好习惯。
- en: Hopefully, target mapping has already provided a few key pieces of information
    that can help you to brute-force more efficiently. While Nikto and Nmap may not
    always find a quick and easy remote code execution vulnerability, they do return
    data that can be useful when deciding what wordlist to use for discovery.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 希望目标映射已经提供了一些有助于更有效强行破解的关键信息。虽然Nikto和Nmap可能无法总是找到快速且简单的远程代码执行漏洞，但它们确实返回了在决定使用哪个词表进行发现时可能有用的数据。
- en: 'Useful information can include the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的信息可能包括以下内容：
- en: 'The webserver software: Apache, NGINX, or IIS'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器软件：Apache、NGINX或IIS
- en: 'Server-side development language: ASP.NET, PHP, or Java'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端开发语言：ASP.NET、PHP或Java
- en: 'Underlying operating system: Linux, Windows, or embedded'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层操作系统：Linux、Windows或嵌入式
- en: '`robots.txt`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robots.txt`'
- en: Interesting response headers
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有趣的响应头
- en: 'WAF detection: *F5* or Akamai'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAF检测：*F5*或Akamai
- en: 'You can make assumptions about the application based on the very simple information
    shown in the preceding list. For example, an IIS web server is more likely to
    have an application developed in ASP.NET as opposed to PHP. While PHP is still
    available on Windows (via XAMPP), it is not as commonly encountered in production
    environments. In contrast, while there are Active Server Pages (ASP) processors
    on Linux systems, PHP or Node.js are much more common these days. While brute-forcing
    for files, you can take this into account when attaching the extension to the
    payload: `.asp` and `.aspx` for Windows targets, and `.php` for Linux targets
    is a good start.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据前面列表中展示的非常简单的信息对应用程序做出假设。例如，IIS web 服务器更可能运行用 ASP.NET 开发的应用程序，而非 PHP。尽管
    PHP 在 Windows 上仍然可用（通过 XAMPP），但在生产环境中不常见。相比之下，尽管 Linux 系统上也有 Active Server Pages
    (ASP) 处理器，PHP 或 Node.js 在当今环境中要更为常见。在进行文件暴力破解时，你可以在将扩展名附加到有效负载时考虑这一点：Windows 目标使用
    `.asp` 和 `.aspx`，而 Linux 目标则可以使用 `.php`，这是一个好的起点。
- en: The `robots.txt` file is generally interesting, as it can provide "hidden" directories
    or files, and can be a good starting point when brute-forcing for directories
    or files. The `robots.txt` file essentially provides instructions for legitimate
    crawler bots on what they're allowed to index and what they should ignore. This
    is a convenient way to implement this protocol, but it has the implication that
    this file must be readable by anonymous users, including yourself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`robots.txt` 文件通常很有趣，因为它可以提供“隐藏”的目录或文件，是进行目录或文件暴力破解时的一个良好起点。`robots.txt` 文件本质上是为合法的爬虫机器人提供指令，告诉它们可以索引什么，应该忽略什么。这是一种方便实现此协议的方式，但它意味着该文件必须对匿名用户（包括你自己）可读。'
- en: 'A sample `robots.txt` file will look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例 `robots.txt` 文件大致如下：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Google's crawlers will ignore the subdirectories, but you cannot. This is valuable
    information for the upcoming scans.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的爬虫会忽略子目录，但你不能忽略。这对即将进行的扫描来说是有价值的信息。
- en: Content discovery
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容发现
- en: 'We have already mentioned two tools that are very useful for initial discovery
    scans: **OWASP ZAP** and **Burp Suite**. Burp''s Intruder module is throttled
    in the free version but can still be useful for quick checks. Both of these attack
    proxies are available in Kali Linux and can be easily downloaded for other distributions.
    There are other command-line alternatives, such as **Gobuster**, which can be
    used to automate the process a bit more.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过两个在初步发现扫描中非常有用的工具：**OWASP ZAP** 和 **Burp Suite**。Burp 的 Intruder 模块在免费版中有速率限制，但仍然可以用于快速检查。这两个攻击代理都可以在
    Kali Linux 上使用，并且可以很容易地为其他发行版下载。还有其他命令行替代工具，比如 **Gobuster**，可以用来稍微自动化这个过程。
- en: Burp Suite
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Burp Suite
- en: As mentioned, Burp Suite comes bundled with the Intruder module, which allows
    us to easily perform content discovery. We can leverage it to look for hidden
    directories and files, and even guess credentials. It supports payload processing
    and encoding, which enables us to customize our scanning to better interface with
    the target application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Burp Suite 随 Intruder 模块捆绑，允许我们轻松地进行内容发现。我们可以利用它查找隐藏的目录和文件，甚至猜测凭证。它支持有效负载处理和编码，使我们能够定制扫描，以更好地与目标应用程序进行交互。
- en: 'In the Intruder module, you can leverage the same wordlists provided by SecLists
    and can even combine multiple lists into one attack. This is a powerful module
    with lots of features, including, but not limited to, the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Intruder 模块中，你可以利用 SecLists 提供的相同单词列表，甚至可以将多个列表组合成一个攻击。这是一个强大的模块，具有许多功能，包括但不限于以下内容：
- en: Cluster bomb attack, which is well suited for multiple payloads, such as usernames
    and passwords, which we will showcase later
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群炸弹攻击，适用于多个有效负载，例如用户名和密码，我们将在后面展示。
- en: Payload processing for highly customized attacks
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度定制化攻击的有效负载处理
- en: Attack throttling and variable delays for low and slow attacks
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击速率限制和低速攻击的可变延迟
- en: …and much more!
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …以及更多内容！
- en: We will cover these and others in later chapters.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中介绍这些内容和其他功能。
- en: '![Burp Suite](graphics/B09238_02_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite](graphics/B09238_02_05.jpg)'
- en: 'Figure 2.5: The Burp Suite Intruder module Payloads screen'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：Burp Suite Intruder 模块的有效负载屏幕
- en: The free version of Burp Suite is readily available in Kali Linux but, as we've
    noted in the preceding chapter, it is a bit limited. There are some restrictions
    in the Intruder module, notably the time-throttling of attack connections. For
    large payload counts, this may become a hindrance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的免费版可以在Kali Linux中轻松获取，但正如我们在上一章中提到的，它有些限制。Intruder模块中存在一些限制，特别是攻击连接的时间限制。对于大量负载，可能会成为障碍。
- en: The professional version of Burp Suite is highly recommended for those who test
    applications regularly. Burp Suite is also valuable when reverse engineering applications
    or protocols. It is quite common for modern applications or malware to communicate
    with external servers via HTTP. Intercepting, modifying, and replaying this traffic
    can be valuable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的专业版非常推荐给那些定期进行应用程序测试的人。Burp Suite在逆向工程应用程序或协议时也非常有价值。现代应用程序或恶意软件通过HTTP与外部服务器进行通信是很常见的。拦截、修改和重放这些流量非常有价值。
- en: OWASP ZAP
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OWASP ZAP
- en: The free alternative to Burp Suite is ZAP, a powerful tool in its own right,
    and it provides some of the discovery capabilities of Burp Suite.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的免费替代工具是ZAP，它本身就是一个强大的工具，并提供了Burp Suite的一些发现能力。
- en: 'The ZAP equivalent for Burp''s Intruder is the **Fuzzer** module, and it has
    similar functionality, as show in the following figure:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Burp的Intruder模块的ZAP等效模块是**Fuzzer**模块，具有类似的功能，如下图所示：
- en: '![OWASP ZAP](graphics/B09238_02_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![OWASP ZAP](graphics/B09238_02_06.jpg)'
- en: 'Figure 2.6: OWASP ZAP''s Fuzzer module configuration. As ZAP is open-source,
    there are no usage restrictions. If the goal is to perform a quick content discovery
    scan or credential brute-force, it may be a better alternative to the free version
    of Burp Suite.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：OWASP ZAP的Fuzzer模块配置。由于ZAP是开源的，因此没有使用限制。如果目标是进行快速的内容发现扫描或凭证暴力破解，它可能是Burp
    Suite免费版的更好替代方案。
- en: Gobuster
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gobuster
- en: Gobuster is an efficient command-line utility for content discovery. Gobuster
    does not come preinstalled on Kali Linux, but it is available on GitHub. As its
    name implies, Gobuster was written in the Go language and will require the golang
    compiler to be installed before it can be used for an attack.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Gobuster是一个高效的命令行工具，用于内容发现。Gobuster并未预安装在Kali Linux中，但它可以从GitHub获得。顾名思义，Gobuster是用Go语言编写的，并且在使用之前需要安装golang编译器。
- en: 'The steps to configure Gobuster are fairly easy on Kali Linux. We can start
    by issuing the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali Linux上配置Gobuster的步骤相当简单。我们可以通过执行以下命令开始：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command will globally install the Go compiler. This is required
    to build the latest version of Gobuster.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将全局安装Go编译器。这是构建Gobuster最新版本所必需的。
- en: 'Next, you need to make sure that the `GOPATH` and `GOBIN` environment variables
    are set properly. We will point `GOPATH` to a `go` directory in our home path
    and set `GOBIN` to the newly defined `GOPATH` value:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确保`GOPATH`和`GOBIN`环境变量正确设置。我们将`GOPATH`指向我们主目录中的`go`目录，并将`GOBIN`设置为新定义的`GOPATH`值：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now pull the latest version of Gobuster from GitHub using the `git clone`
    command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过`git clone`命令从GitHub拉取Gobuster的最新版本：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then get dependencies, and compile the Gobuster application. The `go
    get` and `go build` commands will generate the Gobuster binary in the local directory:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以获取依赖并编译Gobuster应用程序。`go get`和`go build`命令将在本地目录中生成Gobuster二进制文件：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the commands don''t produce output, the tool was compiled and is ready for
    use:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令没有产生输出，说明工具已被编译并准备好使用：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Gobuster has many useful features, including attacking through a proxy (such
    as a local Burp Suite instance), outputting to a file for further processing,
    or even brute-forcing subdirectories for a target domain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Gobuster具有许多有用的功能，包括通过代理（例如本地Burp Suite实例）进行攻击、将输出保存到文件以供进一步处理，甚至对目标域进行子目录的暴力破解。
- en: 'The following figure shows Gobuster performing a discovery scan on the `http://10.0.5.181`
    using a common web content file from the SecLists repository:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Gobuster使用SecLists库中的常见Web内容文件对`http://10.0.5.181`进行发现扫描：
- en: '![Gobuster](graphics/B09238_02_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Gobuster](graphics/B09238_02_07.jpg)'
- en: 'Figure 2.7: Sample Gobuster running on the 10.0.5.181 server'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：在10.0.5.181服务器上运行的Gobuster示例
- en: A command-line URL discovery tool may prove useful on systems where we cannot
    run a full-blown **graphical user interface** (**GUI**) application, such as Burp
    or ZAP.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法运行完整的**图形用户界面**（**GUI**）应用程序（例如Burp或ZAP）的系统上，命令行URL发现工具可能会非常有用。
- en: Persistent content discovery
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化内容发现
- en: The results of a particular scan can reveal interesting directories, but they're
    not always accessible, and directory indexing is increasingly rare in applications.
    Thankfully, by using content discovery scans we can look into directories for
    other misconfigured sensitive information. Consider a scenario where the application
    hosted on `http://10.0.5.181/` contains a particular directory that may be password
    protected. A common misconfiguration in applications is to protect the parent
    directory but incorrectly assume all subdirectories are also protected. This leads
    developers to drop more sensitive directories in the parent and leave them be.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 某次扫描的结果可能会揭示有趣的目录，但这些目录并不总是可以访问的，且应用程序中的目录索引越来越罕见。幸运的是，通过使用内容发现扫描，我们可以检查目录内是否存在其他配置错误的敏感信息。假设应用程序托管在`http://10.0.5.181/`，其中包含一个可能受到密码保护的特定目录。应用程序中的常见配置错误是保护父目录，却错误地认为所有子目录也会被保护。这导致开发人员将更敏感的目录放在父目录中，并忽略了它们。
- en: 'Earlier inspection of the `robots.txt` file revealed a few interesting directories:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前检查`robots.txt`文件时，发现了一些有趣的目录：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `admin` directory catches the eye, but attempting to access `/~admin/`
    returns an HTTP `403` Forbidden error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin`目录引起了注意，但尝试访问`/~admin/`返回了HTTP `403` Forbidden错误：'
- en: '![Persistent content discovery](graphics/B09238_02_08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![持久化内容发现](graphics/B09238_02_08.jpg)'
- en: 'Figure 2.8: Access to the directory is forbidden'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：访问该目录被禁止
- en: This may be discouraging, but we can't stop here. The target directory is too
    attractive to give up now. Using OWASP ZAP, we can start a new Fuzzer activity
    on this directory and see if we can find anything of interest that is not protected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能令人沮丧，但我们不能就此止步。目标目录太有吸引力，不值得放弃。通过使用OWASP ZAP，我们可以对该目录启动新的Fuzzer任务，看看是否能找到任何未受保护的有价值信息。
- en: 'Make sure that the cursor is placed at the end of the URL in the left-most
    pane. Click the **Add** button next to **Fuzz Locations** in the right-most pane:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保光标位于最左侧面板中的URL末尾。点击最右侧面板中**Fuzz Locations**旁边的**添加**按钮：
- en: '![Persistent content discovery](graphics/B09238_02_09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![持久化内容发现](graphics/B09238_02_09.jpg)'
- en: 'Figure 2.9: Fuzzer configuration, adding Fuzz Locations'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：Fuzzer配置，添加Fuzz Locations
- en: 'On the next screen, we can add a new payload to feed the **Fuzzer**. We will
    select the `raft-small-files.txt` wordlist from the SecLists repository:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，我们可以为**Fuzzer**添加一个新的负载。我们将从SecLists存储库中选择`raft-small-files.txt`字典：
- en: '![Persistent content discovery](graphics/B09238_02_10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![持久化内容发现](graphics/B09238_02_10.jpg)'
- en: 'Figure 2.10: Fuzzer configuration – the Add Payload screen'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：Fuzzer配置 – 添加负载屏幕
- en: Since we want to treat the `/~admin` URI as a directory and look for files within,
    we will have to use a string processor for the selected payload. This will be
    a simple **Prefix String** processor, which will prepend a forward-slash to each
    entry in our list.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望将`/~admin` URI视为目录并在其中查找文件，我们需要为选定的负载使用字符串处理器。这将是一个简单的**前缀字符串**处理器，它会在列表中的每个条目前添加一个正斜杠。
- en: '![Persistent content discovery](graphics/B09238_02_11.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![持久化内容发现](graphics/B09238_02_11.jpg)'
- en: 'Figure 2.11: Fuzzer configuration – the Add Processor screen'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：Fuzzer配置 – 添加处理器屏幕
- en: The Fuzzer task may take a while to complete, and it will produce lots of `403`
    or `404` errors. In this case, we were able to locate a somewhat hidden administration
    file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Fuzzer任务可能需要一段时间才能完成，并且会产生大量的`403`或`404`错误。在这种情况下，我们能够找到一个隐藏的管理文件。
- en: '![Persistent content discovery](graphics/B09238_02_12.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![持久化内容发现](graphics/B09238_02_12.jpg)'
- en: 'Figure 2.12: The completed Fuzzer scan shows an accessible hidden file'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：完成的Fuzzer扫描显示了一个可访问的隐藏文件
- en: The HTTP `200` response indicates that we have access to this file, even though
    the parent directory `/~admin/` was inaccessible. It appears we have access to
    the `admin.html` file contained within the enticing `admin` directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `200`响应表示我们能够访问此文件，即使父目录`/~admin/`不可访问。看来我们可以访问包含在引人注目的`admin`目录中的`admin.html`文件。
- en: Application security is hard to implement correctly, and it is even harder to
    maintain that initial security baseline as the application ages and evolves, and
    staff rotate. Access is granted and not removed; files are added with broken permissions;
    and underlying operating systems and frameworks become outdated, and remotely
    exploitable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序安全性难以正确实现，随着应用程序的老化、演变以及员工更替，保持初始的安全基准变得更加困难。访问权限被授予却未被撤销；文件被添加且权限错误；底层操作系统和框架逐渐过时，容易受到远程攻击。
- en: When running initial content discovery scans, it is important to remember not
    to stop at the first error message we see. Access control deficiencies are very
    common, and we could uncover various unprotected subdirectories or files if we
    are persistent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行初步内容发现扫描时，重要的是要记住不要停留在我们看到的第一个错误信息上。访问控制漏洞非常常见，如果我们坚持下去，可能会发现各种未保护的子目录或文件。
- en: Payload processing
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效载荷处理
- en: Burp Suite's Intruder module is a powerful ally to an attacker when targeting
    web applications. Earlier discovery scans have identified the secretive, but enticing,
    `/~admin/` directory. A subsequent scan of the directory itself uncovered an unprotected
    `admin.html` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 的 Intruder 模块是攻击者在针对 Web 应用程序时的强大盟友。早期的发现扫描已经识别出一个隐藏但诱人的 `/~admin/`
    目录。随后的目录扫描揭示了一个未保护的 `admin.html` 文件。
- en: 'Before we proceed, we will switch to the Burp Suite attack proxy and configure
    the **Target Scope** to the `vuln.app.local` domain:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将切换到 Burp Suite 攻击代理，并将 **目标范围** 配置为 `vuln.app.local` 域：
- en: '![Payload processing](graphics/B09238_02_13.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_13.jpg)'
- en: 'Figure 2.13: The Burp Suite Target Scope configuration screen'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：Burp Suite 目标范围配置屏幕
- en: 'The **Target Scope** allows us to define hosts, ports, or URLs that are to
    be included in the scope of the attack. This helps to filter out traffic that
    may not be related to our target. With Burp Suite configured as our attack proxy,
    we can visit the hidden `admin.html` URL and record the traffic in our proxy''s
    history:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标范围** 允许我们定义要包括在攻击范围内的主机、端口或 URL。这有助于过滤掉可能与我们目标无关的流量。配置 Burp Suite 作为我们的攻击代理后，我们可以访问隐藏的
    `admin.html` URL，并在代理历史中记录该流量：'
- en: '![Payload processing](graphics/B09238_02_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_14.jpg)'
- en: 'Figure 2.14: Accessing the hidden file through the browser succeeds'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14：通过浏览器访问隐藏文件成功
- en: 'Following the **Server Connectivity Test** link, we are greeted with a basic
    authentication realm **Admin Tools**, as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随 **服务器连接测试** 链接，我们进入了一个基本认证域 **管理员工具**，如图所示：
- en: '![Payload processing](graphics/B09238_02_15.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_15.jpg)'
- en: 'Figure 2.15: Authentication popup when attempting to follow the link'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15：尝试访问链接时的身份验证弹窗
- en: Our pentester reflexes kick in and we automatically type in the unfortunately
    common `admin/admin` credentials, but with no luck this time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的渗透测试反应迅速，本能地输入了不幸常见的 `admin/admin` 凭据，但这次没有成功。
- en: 'Since all of the interactions with the target are being recorded by the Burp
    proxy, we can simply pass the failed request on to the Intruder module, as shown
    in the following figure. Intruder will let us attack the basic authentication
    mechanism with little effort:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与目标的所有交互都被 Burp 代理记录，我们只需将失败的请求传递给 Intruder 模块，如下图所示。Intruder 将使我们能够轻松地攻击基本认证机制：
- en: '![Payload processing](graphics/B09238_02_16.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_16.jpg)'
- en: 'Figure 2.16: The HTTP history screen'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：HTTP 历史记录屏幕
- en: In the Intruder module, the defaults are good for the most part—we just have
    to select the Base64-encoded credentials portion of the `Authorization` header
    and click the **Add** button on the right-hand side. This will identify this position
    in the HTTP request as the payload location.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Intruder 模块中，默认设置大多是有效的——我们只需要选择 `Authorization` 头中的 Base64 编码凭据部分，并点击右侧的
    **添加** 按钮。这样就会将 HTTP 请求中的这一位置标记为有效载荷位置。
- en: 'The following shows the payload position selected in the `Authorization` header:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了在 `Authorization` 头部中选择的有效载荷位置：
- en: '![Payload processing](graphics/B09238_02_17.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_17.jpg)'
- en: 'Figure 2.17: Specifying a payload position in the Authorization header'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17：指定 Authorization 头中的有效载荷位置
- en: 'In the **Payloads** tab, we will select the **Custom iterator** payload type
    from the dropdown, as seen in the following figure:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **有效载荷** 标签中，我们将从下拉菜单中选择 **自定义迭代器** 有效载荷类型，如下图所示：
- en: '![Payload processing](graphics/B09238_02_18.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_18.jpg)'
- en: 'Figure 2.18: Configuring the Payload type'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：配置有效载荷类型
- en: 'The `Authorization` header contains the Base64-encoded plaintext values of
    the colon-separated username and password. To brute-force the application effectively,
    the payload will have to be in the same format. We will need to submit a payload
    that follows the same format that the `Authorization` header expects. For each
    brute-force request that the attack proxy will make, the payload will have to
    be the username and password separated by a colon, and wrapped by Base64 encoding:
    `base64([user_payload]:[password_payload])`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization`头部包含以冒号分隔的用户名和密码的Base64编码明文值。为了有效地暴力破解应用程序，载荷必须与此格式一致。我们需要提交一个按照`Authorization`头部要求的格式进行的载荷。每个攻击代理的暴力破解请求所使用的载荷都必须是由冒号分隔的用户名和密码，并进行Base64编码：`base64([user_payload]:[password_payload])`。'
- en: We can grab the already captured value in the `Authorization` header and pass
    it to Burp Suite's Decoder module. Decoder allows us to quickly process strings
    to and from various encoding schemes, such as Base64, URL encoding, GZip, and
    others.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取已捕获的`Authorization`头部的值，并将其传递给Burp Suite的Decoder模块。Decoder允许我们快速处理不同编码方案之间的字符串，如Base64、URL编码、GZip等。
- en: 'This figure shows how we can leverage Decoder to convert the value `YWRtaW46YWRtaW4=`
    from Base64 using the **Decode as...** dropdown. The result is listed in the bottom
    pane as `admin:admin`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了我们如何利用Decoder将`YWRtaW46YWRtaW4=`的Base64值转换为**解码为...**下拉框中显示的内容。结果会在底部窗格中列出为`admin:admin`：
- en: '![Payload processing](graphics/B09238_02_19.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![载荷处理](graphics/B09238_02_19.jpg)'
- en: 'Figure 2.19: The Burp Decoder screen'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：Burp Decoder屏幕
- en: Back in the Intruder module, for payload position 1, we will once again use
    a small wordlist from the SecLists `Usernames` collection called `top-usernames-shortlist.txt`.
    Our goal is to find low-hanging fruit, while minimizing the flood of requests
    that will hit the application. Using a short list of common high-value usernames
    is a good first step.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到入侵者模块，对于载荷位置1，我们将再次使用来自SecLists `Usernames`集合的一个小型字典文件，名为`top-usernames-shortlist.txt`。我们的目标是找到容易破解的账户，同时尽量减少对应用程序的请求压力。使用一个常见的高价值用户名短列表是一个不错的第一步。
- en: 'This figure shows that the list was loaded in payload position 1 using the
    **Load...** button in the **Payload Options**:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了如何使用**载荷选项**中的**加载...**按钮将字典列表加载到位置1中：
- en: '![Payload processing](graphics/B09238_02_20.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![载荷处理](graphics/B09238_02_20.jpg)'
- en: 'Figure 2.20: Payload position 1 configuration screen'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：载荷位置1配置屏幕
- en: The separator for position 1 should be colon (`:`). For payload position 2,
    you can use the `500-worst-passwords.txt` list from the SecLists passwords directory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 位置1的分隔符应为冒号（`:`）。对于位置2的载荷，你可以使用SecLists密码目录中的`500-worst-passwords.txt`列表。
- en: 'The following figure shows payload position 2 containing the loaded `500-worst-passwords.txt`
    contents:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了载荷位置2包含加载的`500-worst-passwords.txt`文件内容：
- en: '![Payload processing](graphics/B09238_02_21.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![载荷处理](graphics/B09238_02_21.jpg)'
- en: 'Figure 2.21: Payload position 2 configuration screen'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：载荷位置2配置屏幕
- en: The separator for position 2 should be left blank.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 位置2的分隔符应留空。
- en: 'At this point, each request sent to the application will contain an `Authorization`
    header in the following format:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，发送到应用程序的每个请求将包含如下格式的`Authorization`头部：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To complete the payload, we also have to instruct Intruder to Base64-encode
    the payload before sending it over the wire. We can use a payload processor to
    force Base64 encoding for every request.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成载荷配置，我们还需要指示入侵者在发送请求前将载荷进行Base64编码。我们可以使用一个载荷处理器来强制对每个请求进行Base64编码。
- en: In the **Payloads** tab, under **Payload Processing**, click **Add** and select
    the **Base64-encode** processor from the **Encode** category. We will also disable
    automatic URL encoding, as it may break the `Authorization` header.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在**载荷**标签下，点击**载荷处理**，选择**添加**，然后从**编码**类别中选择**Base64编码**处理器。我们还将禁用自动URL编码，因为它可能会破坏`Authorization`头部。
- en: 'The following URL shows the enabled **Base64-encode** processor:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下URL显示了启用的**Base64编码**处理器：
- en: '![Payload processing](graphics/B09238_02_22.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![载荷处理](graphics/B09238_02_22.jpg)'
- en: 'Figure 2.22: Payload processing rule – Base64-encode'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：载荷处理规则 - Base64编码
- en: 'Once the payload has been configured, we can begin the brute-force using the
    **Start Attack** button in the top-right corner of the **Intruder** module, as
    shown in the following figure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦载荷配置完成，我们可以通过点击**入侵者**模块右上角的**开始攻击**按钮，开始暴力破解，如下图所示：
- en: '![Payload processing](graphics/B09238_02_23.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![载荷处理](graphics/B09238_02_23.jpg)'
- en: 'Figure 2.23: Starting the attack'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23：开始攻击
- en: 'As with the content discovery scan, this credential brute-force will generate
    a fair amount of HTTP `401` errors. If we''re lucky, at least one will be successful,
    as seen in the figure that follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与内容发现扫描类似，这种凭证暴力破解会生成相当数量的 HTTP `401` 错误。如果幸运的话，至少会有一次是成功的，正如接下来的图所示：
- en: '![Payload processing](graphics/B09238_02_24.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_24.jpg)'
- en: 'Figure 2.24: Attack results screen'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24：攻击结果界面
- en: Now, because every request in the Intruder attack is recorded, we can inspect
    each one or sort all of them by column to better illustrate the results of the
    attack. In the preceding example, we can clearly see that the successful authentication
    request returned an HTTP status code of `200`, while the majority of the other
    requests returned an expected `401`. The status code is not the only way to determine
    success at a quick glance, however. A deviation in the content length of the response
    may be a good indicator that we are on the right track.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为每个入侵者攻击的请求都会被记录，我们可以检查每一个请求，或者通过列排序来更清晰地展示攻击结果。在前面的示例中，我们可以清楚地看到，成功的身份验证请求返回了
    HTTP 状态码 `200`，而大多数其他请求返回了预期的 `401`。不过，状态码并不是唯一能够快速判断攻击是否成功的方式。响应内容长度的偏差可能是一个很好的指标，表明我们正走在正确的道路上。
- en: Now that we have a payload that has successfully gained access to the Admin
    Tools authentication realm, we can run it through the Decoder module to see the
    plaintext credentials.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个有效载荷，成功获取了 Admin Tools 身份验证区域的访问权限，我们可以通过解码器模块查看明文凭证。
- en: 'This figure shows the Decoder module revealing the guessed credentials:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了解码器模块揭示的猜测凭证：
- en: '![Payload processing](graphics/B09238_02_25.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_25.jpg)'
- en: 'Figure 2.25: Burp Suite Decoder'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25：Burp Suite 解码器
- en: Credential brute-forcing is just one of the many uses for Intruder. You can
    get creative with custom payloads and payload processing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证暴力破解只是入侵者模块众多用途之一。您可以利用自定义有效载荷和有效载荷处理来发挥创意。
- en: Consider a scenario where the `vuln.app.local` application generates PDF files
    with sensitive information and stores them in an unprotected directory called
    `/pdf/`. The filenames appear to be the MD5 digest of the date the file was generated,
    but the application will not generate a PDF file every day. You could try and
    guess each day manually, but that's not ideal. You can even spend some time whipping
    up a Python script that can automate this task. The better alternative is to leverage
    Burp Suite to do this easily with a few clicks. This has the added benefit of
    recording the attack responses in one window for easy inspection.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个场景，`vuln.app.local` 应用程序生成包含敏感信息的 PDF 文件，并将其存储在一个名为 `/pdf/` 的未保护目录中。文件名似乎是文件生成日期的
    MD5 摘要，但应用程序并不会每天都生成 PDF 文件。你可以尝试手动猜测每一天的文件名，但那并不理想。你甚至可以花点时间编写一个 Python 脚本来自动化这个任务。更好的替代方法是利用
    Burp Suite，通过几次点击轻松完成这一任务。此外，这种方法还有一个好处，就是可以在一个窗口中记录攻击响应，方便检查。
- en: Once again, we can send a previously recorded request to the target `/pdf/`
    folder directly to the Intruder module.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次将之前记录的请求直接发送到目标 `/pdf/` 文件夹，传递给入侵者模块。
- en: 'This figure shows that the PDF''s name, minus the extension, is identified
    as the payload position using the **Add** button:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示，PDF 文件的名称（不包括扩展名）被识别为有效载荷位置，并使用**添加**按钮进行标识：
- en: '![Payload processing](graphics/B09238_02_26.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_26.jpg)'
- en: 'Figure 2.26: Intruder Payload Positions configuration screen'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26：入侵者有效载荷位置配置界面
- en: 'The following figure shows the **Dates** payload type options available in
    Intruder:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在入侵者模块中可用的**日期**有效载荷类型选项：
- en: '![Payload processing](graphics/B09238_02_27.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![有效载荷处理](graphics/B09238_02_27.jpg)'
- en: 'Figure 2.27: Intruder''s Payloads screen'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27：入侵者的有效载荷界面
- en: In this attack, you will use the **Dates** payload type with the proper date
    format, going back a couple of years. The payload processor will be the MD5 hash
    generator, which will generate a hash of each date and return the equivalent string. This
    is similar to our **Base64-encode** processor from the previous attack.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在此攻击中，您将使用**日期**有效载荷类型，并使用适当的日期格式，回溯几年的数据。有效载荷处理器将是 MD5 哈希生成器，它将生成每个日期的哈希值并返回相应的字符串。这类似于我们在上一轮攻击中使用的**Base64编码**处理器。
- en: Once again, the payload options have been configured and we can start the attack.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次配置好有效载荷选项后，我们可以开始攻击。
- en: 'The following figure shows a few requests with the `200` HTTP status code and
    a large length indicating a PDF file is available for download:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一些带有`200` HTTP状态码和大长度的请求，表示可以下载PDF文件：
- en: '![Payload processing](graphics/B09238_02_28.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![负载处理](graphics/B09238_02_28.jpg)'
- en: 'Figure 2.28: Intruder attack Results screen'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28：入侵者攻击结果屏幕
- en: Intruder will generate the payload list based on our specified date format and
    calculate the hash of the string, before sending it to the application, all with
    a few clicks. In no time, we have discovered at least three improperly protected,
    potentially sensitive documents that are available anonymously.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵者将根据我们指定的日期格式生成负载列表，并计算字符串的哈希值，然后在几次点击后将其发送到应用程序。在很短的时间内，我们发现了至少三个未受适当保护、可能包含敏感信息的文档可以匿名访问。
- en: Polyglot payloads
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言负载
- en: A polyglot payload is defined as a piece of code that can be executed in multiple
    contexts in the application. These types of payloads are popular with attackers
    because they can quickly test an application's input controls for any weaknesses,
    with minimal noise.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 多语言负载被定义为可以在应用程序中的多个上下文中执行的代码片段。攻击者喜欢这种类型的负载，因为它们可以快速测试应用程序的输入控件是否存在任何弱点，而且干扰很小。
- en: 'In a complex application, user input can travel through many checkpoints—from
    the URL through a filter, into a database, and back out to a decoder, before being
    displayed to the user, as illustrated in the following figure:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的应用程序中，用户输入可能会经过许多检查点——从URL经过过滤器，进入数据库，再返回到解码器，最后显示给用户，如下图所示：
- en: '![Polyglot payloads](graphics/B09238_02_29.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![多语言负载](graphics/B09238_02_29.jpg)'
- en: 'Figure 2.29: Typical data flow from user to application'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29：用户到应用程序的典型数据流
- en: Any one of the steps along the way can alter or block the payload, which may
    make it more difficult to confirm the existence of a vulnerability in the application.
    A polyglot payload will attempt to exploit an injection vulnerability by combining
    multiple methods for executing code in the same stream. This attempts to exploit
    weaknesses in the application payload filtering, increasing the chance that at
    least one portion of the code will be missed and will execute successfully. This
    is made possible by the fact that JavaScript is a very forgiving language. Browsers
    have always been an easy barrier of entry for developers, and JavaScript is rooted
    in a similar philosophy.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 沿途的任何一步都可能改变或阻止负载，这可能会使确认应用程序中漏洞存在变得更加困难。多语言负载将尝试通过在同一流中结合多种执行代码的方法来利用注入漏洞。这试图利用应用程序负载过滤的弱点，增加代码至少有一部分被忽略并成功执行的机会。这是由于JavaScript是一种非常宽容的语言。浏览器一直是开发者的一个简单的入门障碍，而JavaScript根植于类似的哲学。
- en: 'The OWASP **cross-site scripting** (**XSS**) Filter Evasion Cheat Sheet contains
    examples of polyglot payloads, which can also evade some application filters:
    [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP **跨站脚本**（**XSS**）绕过过滤器的秘籍包含了一些多语言负载的示例，这些负载也可以规避一些应用程序过滤器：[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)。
- en: 'A good example of a strong polyglot payload can be found on GitHub from researcher
    Ahmed Elsobky:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的强多语言负载示例可以在研究员Ahmed Elsobky的GitHub上找到：
- en: '[PRE18]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At first glance, this appears rather messy, but every character has a purpose.
    This payload was designed to execute JavaScript in a variety of contexts, whether
    the code is reflected inside an HTML tag or right in the middle of another piece
    of JavaScript. The browser's HTML and JavaScript parsers are extremely accommodating.
    They are case-insensitive, error-friendly, and they don't care much about indenting,
    line endings, or spacing. Escaped or encoded characters are sometimes converted
    back to their original form and injected into the page. JavaScript in particular
    does its very best to execute whatever code is passed to it. A good polyglot payload
    will take advantage of all of this, and seek to evade some filtering as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎有些混乱，但每个字符都有其目的。这个负载旨在在各种上下文中执行JavaScript，无论代码是反映在HTML标签内部还是直接位于另一段JavaScript代码中。浏览器的HTML和JavaScript解析器非常包容。它们不区分大小写，对错误友好，并且不太关心缩进、换行或空格。转义或编码的字符有时会被转换回其原始形式并注入到页面中。特别是JavaScript会尽其所能执行传递给它的任何代码。一个好的多语言负载将利用所有这些，并试图规避一些过滤。
- en: 'The first thing a sharp eye will notice is that most of the keywords, such
    as `textarea`, `javascript`, and `onload,` are randomly capitalized:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的观察者首先会注意到，大多数关键字，如`textarea`、`javascript`和`onload,`，都是随机大写的：
- en: '[PRE19]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This may seem like a futile attempt to evade application firewall input filters,
    but you''d be surprised how many are poorly designed. Consider the following **regular
    expression** (**regex**) input filter:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是试图逃避应用防火墙输入过滤器的徒劳尝试，但你会惊讶地发现，许多设计都很糟糕。考虑以下**正则表达式**（**regex**）输入过滤器：
- en: '[PRE20]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A regex is a piece of text defining a search pattern. Some WAFs may use regex
    to try and find potentially dangerous strings inside HTTP requests.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一段定义搜索模式的文本。一些WAF可能会使用正则表达式来尝试查找HTTP请求中的潜在危险字符串。
- en: 'This will effectively prevent JavaScript code from being injected via the `onclick`
    event, but with one glaring flaw: it doesn''t take into account case-sensitivity.
    Regular expressions have many modifiers, such as the `g` in the preceding example,
    and by default most engines require the `i` modifier to ignore case, or else they
    will not match and the filter is vulnerable to bypass.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效地防止通过`onclick`事件注入JavaScript代码，但有一个明显的缺陷：它没有考虑大小写敏感性。正则表达式有许多修饰符，例如前面示例中的`g`，并且默认情况下，大多数引擎需要`i`修饰符来忽略大小写，否则它们不会匹配，过滤器也会容易被绕过。
- en: 'The following figure shows Regex101''s visualization of the preceding regex
    applied to a sample test string. We can see that only two of the four payloads
    tested matched the expression, while all four would execute JavaScript code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了Regex101将前面的正则表达式应用于一个示例测试字符串的可视化效果。我们可以看到，四个测试的有效载荷中只有两个与该表达式匹配，而所有四个都将执行JavaScript代码：
- en: '![Polyglot payloads](graphics/B09238_02_30.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![多语言有效载荷](graphics/B09238_02_30.jpg)'
- en: 'Figure 2.30: Regex filter visualization'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30：正则表达式过滤器可视化
- en: Tip
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When assessing an application's regex-based input filter, Regex101 is a great
    place to test it against several payloads at once. Regex101 is an online tool
    available for free at [https://regex101.com](https://regex101.com).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估应用程序的基于正则表达式的输入过滤器时，Regex101是一个很好的地方，可以同时测试多个有效载荷。Regex101是一个免费的在线工具，网址是[https://regex101.com](https://regex101.com)。
- en: Many times, developers work under unrealistic time constraints. When a penetration
    testing report highlights a particular input sanitization issue, developers are
    pressured to turn in a security fix that was quickly written, insufficiently tested,
    and remediates only part of the problem. It is often too time-consuming and expensive
    to implement a potentially application-breaking framework to handle input filtering,
    and shortcuts are taken at security's expense.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，开发人员在不现实的时间压力下工作。当渗透测试报告指出特定的输入清理问题时，开发人员面临压力，需要提交一个快速编写、安全性不足、只修复部分问题的安全修复。实施一个可能会破坏应用程序的框架来处理输入过滤通常既耗时又昂贵，因此往往在安全性上采取捷径。
- en: 'The Elsobky payload also aims to exploit being passed through an engine that
    processes hex-encoded values escaped with a backslash. JavaScript and Python,
    for example, will process two alphanumeric characters preceded by `\x` as one
    byte. This could bypass certain in-line XSS filters that perform primitive string
    compare checks:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Elsobky有效载荷的目标还包括通过引擎处理经过反斜杠转义的十六进制编码值。例如，JavaScript和Python会将以`\x`为前缀的两个字母数字字符处理为一个字节。这可以绕过某些执行原始字符串比较检查的内联XSS过滤器：
- en: '[PRE21]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is possible that the payload may be stripped of most of the other keywords,
    but when the filter reaches `\x3c` and `\x3e`, it interprets them as benign strings
    of four characters. The application may parse the string and inadvertently return
    the one-byte equivalent of the escaped hexadecimal characters `<` and `>` respectively.
    The result is an `<svg>` HTML element that executes arbitrary JavaScript via the
    `onload` event.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有效载荷会被剥离掉大部分其他关键字，但当过滤器遇到`\x3c`和`\x3e`时，它会将其解释为无害的四个字符字符串。应用程序可能会解析该字符串，并不经意地返回转义的十六进制字符`<`和`>`的一个字节等效值。结果是一个`<svg>`HTML元素，通过`onload`事件执行任意JavaScript。
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Scalable Vector Graphics** (**SVG**) is an element on a page that can be
    used to draw complex graphics on the screen without binary data. SVG is used in
    XSS attacks mainly because it provides an `onload` property, which will execute
    arbitrary JavaScript code when the element is rendered by the browser.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**可伸缩矢量图形**（**SVG**）是网页上的一个元素，可以在屏幕上绘制复杂的图形，而无需使用二进制数据。SVG在XSS攻击中使用，主要因为它提供了`onload`属性，当元素被浏览器渲染时，会执行任意的JavaScript代码。'
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More examples of the power of this particular polyglot are on Elsobky''s GitHub
    page: [https://github.com/0xSobky](https://github.com/0xSobky).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于此特定多语言代码强大功能的示例，见 Elsobky 的 GitHub 页面：[https://github.com/0xSobky](https://github.com/0xSobky)。
- en: 'A powerful polyglot payload is able to execute some code in a variety of injection
    scenarios. The Elsobky payload can also be useful when reflected in the server
    HTTP response:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的多语言代码负载能够在多种注入场景下执行一些代码。Elsobky 的负载也可以在反射到服务器 HTTP 响应时发挥作用：
- en: '[PRE22]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The URL encoded characters `%0d` and `%0a` represent newline and carriage return.
    These characters are largely ignored by HTML and JavaScript parsers, but they
    are significant in the HTTP request or response header.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: URL 编码字符`%0d`和`%0a`表示换行和回车。这些字符在 HTML 和 JavaScript 解析器中大多被忽略，但它们在 HTTP 请求或响应头中具有重要意义。
- en: 'If the target application fails to filter user input properly, in some cases
    it may take the arbitrary value and add it as part of the HTTP response. For example,
    in an attempt to set a "Remember me" cookie, the application reflects the payload
    unfiltered in the HTTP response headers, which results in XSS in the user''s browser:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标应用未正确过滤用户输入，在某些情况下，它可能会将任意值作为 HTTP 响应的一部分返回。例如，在尝试设置“记住我”Cookie时，应用程序未过滤负载，直接在
    HTTP 响应头中反射该负载，从而在用户的浏览器中造成 XSS：
- en: '[PRE23]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we pass in the polyglot as the username to remember, the HTTP response headers
    are altered and the body will contain attacker-controlled data as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将多语言负载作为用户名传入并记住，HTTP 响应头会被更改，正文将包含攻击者控制的数据，如下所示：
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The server responds with the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应如下：
- en: '[PRE25]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The response is a bit mangled, but we do have code execution. The URL encoded carriage
    return characters `%0D%0A%0d%0a` are interpreted as part of the HTTP response.
    In the HTTP protocol, two sets of carriage returns and line feeds indicate the
    end of the header, and anything that follows this will be rendered by the browser
    as part of the page.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 响应有些被篡改，但我们确实实现了代码执行。URL 编码的回车字符`%0D%0A%0d%0a`被解释为 HTTP 响应的一部分。在 HTTP 协议中，两个回车和换行符表示头部的结束，后续的任何内容都将被浏览器渲染为页面的一部分。
- en: Same payload, different context
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相同负载，不同上下文
- en: There are many other contexts in which this polyglot can successfully execute
    code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他上下文可以使这个多语言代码成功执行代码。
- en: 'If the polyglot payload is reflected inside the `value` property of the username
    input, the browser''s interpretation of the code clearly shows a broken input
    field and a malicious `<svg>` element. The HTML code before the payload is processed
    looks like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多语言负载反射到用户名输入框的`value`属性中，浏览器对代码的解释清楚地显示了一个损坏的输入字段和一个恶意的`<svg>`元素。负载处理前的 HTML
    代码如下所示：
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This figure shows how the browser views the HTML code after the payload has
    been processed:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了浏览器在处理负载后如何查看 HTML 代码：
- en: '![Same payload, different context](graphics/B09238_02_31.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![相同负载，不同上下文](graphics/B09238_02_31.jpg)'
- en: 'Figure 2.31: Reflected XSS payload'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31：反射型 XSS 负载
- en: The polyglot will also execute code if reflected inside an HTML comment, such
    as `<!-- Comment! [payload] -->`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多语言负载反射到 HTML 注释中，它也会执行代码，如`<!-- Comment! [payload] -->`。
- en: The payload contains the end of comment indicator `-->`, which leaves the rest
    of the text to be interpreted by the browser as HTML code. Once again, the `<svg>`
    element's `onload` property will execute our arbitrary code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 该负载包含注释结束指示符`-->`，这使得浏览器将其余文本解释为 HTML 代码。再次，`<svg>`元素的`onload`属性将执行我们的任意代码。
- en: 'This figure shows how the browser views the HTML code after the payload has
    been processed:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了浏览器在处理负载后如何查看 HTML 代码：
- en: '![Same payload, different context](graphics/B09238_02_32.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![相同负载，不同上下文](graphics/B09238_02_32.jpg)'
- en: 'Figure 2.32: Reflected XSS payload'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32：反射型 XSS 负载
- en: Our polyglot is also useful if reflected inside some code setting up a regex
    object, such as `var expression = /[payload]/gi`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多语言负载反射到设置正则表达式对象的某些代码中，它也会有用，如`var expression = /[payload]/gi`。
- en: 'We can test this behavior inside the browser console with the preceding sample
    code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器控制台中通过以下示例代码测试此行为：
- en: '![Same payload, different context](graphics/B09238_02_33.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![相同负载，不同上下文](graphics/B09238_02_33.jpg)'
- en: 'Figure 2.33: Polyglot visualization'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33：多语言代码可视化
- en: We can see that strategically placed comment indicators, such as `/*`, `*/`,
    and `//`, will cause the browser to ignore the majority of the payload, resulting
    in valid JavaScript.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，战略性地放置注释指示符，如`/*`、`*/`和`//`，将导致浏览器忽略大部分负载，从而产生有效的 JavaScript。
- en: 'It''s subtle, but the code execution happens here:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的差别，但代码执行发生在这里：
- en: '[PRE27]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The multi-line comments are ignored, and JavaScript will execute anything between
    the parenthesis. In this context, `oNcliCk` does not represent a mouse event binder,
    but instead it is used to store the return of the `alert()` function, which results
    in arbitrary code execution.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释会被忽略，JavaScript会执行括号之间的任何内容。在这种情况下，`oNcliCk`并不是表示鼠标事件绑定器，而是用来存储`alert()`函数的返回值，从而导致任意代码执行。
- en: Code obfuscation
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码混淆
- en: Not all application firewalls strip input of malicious strings and let the rest
    go through. Some inline solutions will drop the connection outright, usually in
    the form of a `403` or `500` HTTP response. In such cases, it may be difficult
    to determine which part of the payload is considered safe and which triggered
    the block.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的应用防火墙都会剥离输入中的恶意字符串，允许其余的内容通过。一些内联解决方案会直接断开连接，通常表现为`403`或`500`的HTTP响应。在这种情况下，可能很难确定负载中的哪个部分被认为是安全的，哪个部分触发了阻止。
- en: By design, inline firewalls have to be fairly fast and they cannot introduce
    significant delay when processing incoming data. The result is usually simple
    logic when attempting to detect **SQL injection** (**SQLi**) or XSS attacks. Random
    capitalization may not fool these filters, but you can safely assume that they
    do not render on the fly every requested HTML page, let alone execute JavaScript
    to look for malicious behavior. More often than not, inline application firewalls
    will look for certain keywords and label the input as potentially malicious. For
    example, `alert()` may trigger the block, while `alert` by itself would produce
    too many false-positives.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 按照设计，内联防火墙必须非常快速，并且在处理传入数据时不能引入显著的延迟。结果通常是简单的逻辑，试图检测**SQL注入**（**SQLi**）或XSS攻击。随机大写可能无法欺骗这些过滤器，但你可以放心地认为它们不会在每个请求的HTML页面上即时渲染，更不用说执行JavaScript来寻找恶意行为了。通常，内联应用防火墙会寻找特定的关键字，并将输入标记为潜在的恶意。例如，`alert()`可能会触发阻止，而单独的`alert`则会产生过多的误报。
- en: To increase the chances of success and lower the noise, we can change the way
    the `alert()` function is called in seemingly unlimited ways — all thanks to JavaScript.
    We can test this in the browser console by inspecting the native `alert()` function.
    The `window` object will hold a reference to it and we can confirm this by calling
    the function without parentheses. The console will indicate that this is a built-in
    function with `[native code]` displayed as its body. This means that this is not
    a custom user-defined function and it is defined by the browser core.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加成功的机会并降低噪声，我们可以通过似乎无限的方式来改变`alert()`函数的调用方式——这一切都要归功于JavaScript。我们可以在浏览器控制台中测试，通过检查原生的`alert()`函数。`window`对象会保存对它的引用，我们可以通过不带括号调用该函数来确认这一点。控制台会显示它是一个内建函数，并且以`[native
    code]`显示其函数体。这意味着这不是一个自定义的用户定义函数，而是由浏览器核心定义的。
- en: In JavaScript, we have multiple ways of accessing properties of an object, including
    function references such as `alert`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们有多种方式访问对象的属性，包括像`alert`这样的函数引用。
- en: 'This figure shows how we can access the same function directly or using array
    notation, with an `"alert"` string inside square brackets:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了我们如何直接访问相同的函数，或者使用数组表示法，在方括号内加入`"alert"`字符串：
- en: '![Code obfuscation](graphics/B09238_02_34.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![代码混淆](graphics/B09238_02_34.jpg)'
- en: 'Figure 2.34: Different ways to access the alert() function'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34：访问`alert()`函数的不同方式
- en: To bypass rudimentary filters, which may drop suspicious strings, such as `alert`(`1`),
    we can leverage some simple encoding.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过基础的过滤器，这些过滤器可能会丢弃可疑的字符串，如`alert`(`1`)，我们可以利用一些简单的编码方式。
- en: 'Using JavaScript''s `parseInt` function, we can get the integer representation
    of any string, using a custom base. In this case, we can get the base 30 representation
    of the `"alert"` string. To convert the resulting integer back to its string equivalent,
    we can leverage the built-in `toString()` method while passing the integer base
    as the first parameter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript的`parseInt`函数，我们可以获取任何字符串的整数表示形式，使用自定义的进制。在这种情况下，我们可以获取`"alert"`字符串的30进制表示形式。为了将得到的整数转换回其字符串等效形式，我们可以利用内建的`toString()`方法，同时将整数的进制作为第一个参数：
- en: '![Code obfuscation](graphics/B09238_02_35.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![代码混淆](graphics/B09238_02_35.jpg)'
- en: 'Figure 2.35: The "alert" string encoding and decoding'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35：“alert”字符串的编码与解码
- en: Now that we know `8680439..toString(30)` is the equivalent of string `"alert"`,
    we can use the `window` object and array notation to access the native code for
    the `alert()` function.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 `8680439..toString(30)` 等于字符串 `"alert"`，我们可以使用 `window` 对象和数组表示法来访问 `alert()`
    函数的原生代码。
- en: 'This figure shows how we can call the `alert()` function using the obfuscated
    string:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了我们如何使用混淆后的字符串调用 `alert()` 函数：
- en: '![Code obfuscation](graphics/B09238_02_36.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![代码混淆](graphics/B09238_02_36.jpg)'
- en: 'Figure 2.36: Executing alert() with an encoded string'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.36：使用编码字符串执行 alert()
- en: We can follow the same process to obfuscate a call to the `console.log()` function.
    Much like most available native functions, `console` is accessible through the
    `window` object as well.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照相同的过程对 `console.log()` 函数的调用进行混淆。与大多数可用的原生函数一样，`console` 也可以通过 `window`
    对象访问。
- en: 'The following figure shows how we can encode the strings `console` and `log`,
    and utilize the same array notation to access properties and subproperties until
    we reach the native code for `console.log()`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们如何对字符串 `console` 和 `log` 进行编码，并使用相同的数组表示法访问属性和子属性，直到我们到达 `console.log()`
    的原生代码：
- en: '![Code obfuscation](graphics/B09238_02_37.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![代码混淆](graphics/B09238_02_37.jpg)'
- en: 'Figure 2.37: Encoding the entire console.log command'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37：对整个 console.log 命令进行编码
- en: For the traditional strongly-typed language developer, this convention looks
    alien. As we've already seen, JavaScript engines are very forgiving and enable
    a variety of ways to execute code. In the preceding examples, we are decoding
    the base 30 integer representation of our function and passing it as a key to
    the `window` object.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统的强类型语言开发者来说，这种约定看起来很陌生。正如我们之前所看到的，JavaScript 引擎非常宽容，并且允许以多种方式执行代码。在之前的示例中，我们解码了函数的
    base 30 整数表示，并将其作为键传递给 `window` 对象。
- en: 'After some modification, the Elsobky payload could be made a bit more stealthy
    with obfuscation. It could look something like the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些修改，Elsobky 载荷可以通过混淆处理变得更加隐蔽。它可能看起来像下面这样：
- en: '[PRE28]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `top` keyword is a synonym for window and can be used to reference anything
    you need from the `window` object.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 关键字是 `window` 的同义词，可以用来引用你需要的任何 `window` 对象中的内容。'
- en: With just a minor change, the polyglot payload is still effective and is now
    more likely to bypass rudimentary inline filters that may attempt to filter or
    block the discovery attempts.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个小小的修改，polyglot 载荷仍然有效，并且现在更有可能绕过一些简单的内联过滤器，这些过滤器可能会尝试过滤或阻止发现尝试。
- en: Brutelogic offers a great list of XSS payloads with many other ways to execute
    code unconventionally at `https` `://brutelogic.com.br/blog/cheat-sheet/`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Brutelogic 提供了一个很棒的 XSS 载荷列表，并且有许多其他不传统的方式来执行代码，网址为 `https` `://brutelogic.com.br/blog/cheat-sheet/`。
- en: Resources
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'Consult the following resources for more information on penetration testing
    tools and techniques:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下资源获取更多关于渗透测试工具和技术的信息：
- en: '**Metasploit**: [https://www.metasploit.com/](https://www.metasploit.com/)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Metasploit**：[https://www.metasploit.com/](https://www.metasploit.com/)'
- en: '**WPScan**: [https://wpscan.org/](https://wpscan.org/)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WPScan**：[https://wpscan.org/](https://wpscan.org/)'
- en: '**CMSmap**: [https://github.com/Dionach/CMSmap](https://github.com/Dionach/CMSmap)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSmap**：[https://github.com/Dionach/CMSmap](https://github.com/Dionach/CMSmap)'
- en: '**Recon-NG** (**available in Kali Linux or via the Bitbucket repository**):
    [https://bitbucket.org/LaNMaSteR53/recon-ng](https://bitbucket.org/LaNMaSteR53/recon-ng)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Recon-NG**（**可在 Kali Linux 中使用或通过 Bitbucket 仓库访问**）：[https://bitbucket.org/LaNMaSteR53/recon-ng](https://bitbucket.org/LaNMaSteR53/recon-ng)'
- en: '**OWASP XSS Filter Evasion Cheat Sheet**: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OWASP XSS 过滤器规避备忘单**：[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
- en: '**Elsobky''s GitHub page**: [https://github.com/0xSobky](https://github.com/0xSobky)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Elsobky 的 GitHub 页面**：[https://github.com/0xSobky](https://github.com/0xSobky)'
- en: '**Brutelogic cheat sheet**: [https://brutelogic.com.br/blog/cheat-sheet/](https://brutelogic.com.br/blog/cheat-sheet/)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Brutelogic 备忘单**：[https://brutelogic.com.br/blog/cheat-sheet/](https://brutelogic.com.br/blog/cheat-sheet/)'
- en: '**SecLists repository**: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SecLists 仓库**：[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
- en: '**FuzzDB**: [https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FuzzDB**：[https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)'
- en: Exercises
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Complete the following exercises:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习：
- en: Create a copy of the SecLists and FuzzDB repositories in your tools folder and
    study the available wordlists
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工具文件夹中创建SecLists和FuzzDB存储库的副本，并研究可用的单词列表。
- en: Download and compile Gobuster
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并编译Gobuster
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at improving your efficiency for gathering information
    on a target, and covered several ways to do this. If stealth is paramount during
    an engagement, efficient content discovery can also reduce the chance that the
    blue team will notice the attack.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了提高在目标上收集信息效率的方法，并介绍了几种方法。如果在一次攻击中隐秘性至关重要，高效的内容发现也可以减少蓝队注意到攻击的机会。
- en: Time-tested tools, such as Nmap and Nikto, can give us a head start, while WPScan
    and CMSmap can hammer away at complex CMS that are frequently misconfigured and
    seldom updated. For larger networks, masscan can quickly identify interesting
    ports, such as those related to web applications, allowing for more specialized
    tools, such as WhatWeb and WPScan, to do their job faster.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 经过时间考验的工具，如Nmap和Nikto，可以让我们提前了解情况，而WPScan和CMSmap可以攻击那些经常配置错误且很少更新的复杂CMS。对于较大的网络，masscan可以快速识别有趣的端口，比如与Web应用程序相关的端口，从而使更专业的工具，如WhatWeb和WPScan，更快地完成工作。
- en: Web content and vulnerability discovery scans with Burp or ZAP can be improved
    with proper wordlists from repositories, such as SecLists and FuzzDB. These collections
    of known and interesting URLs, usernames, passwords, and fuzzing payloads can
    greatly improve scan success and efficiency.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自存储库（如SecLists和FuzzDB）的适当单词列表，可以改善使用Burp或ZAP进行的Web内容和漏洞发现扫描。这些已知和有趣的URL、用户名、密码和模糊负载的集合可以极大地提高扫描成功率和效率。
- en: In the next chapter, we will look at how we can leverage low-hanging fruit to
    compromise web applications.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用易得的机会来攻击Web应用程序。
