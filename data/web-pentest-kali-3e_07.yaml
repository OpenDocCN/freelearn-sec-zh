- en: Cross-Site Request Forgery, Identification, and Exploitation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF），识别和利用
- en: '**Cross-Site Request Forgery** (**CSRF**) is often mistakenly perceived as
    a vulnerability that is similar to XSS. XSS exploits the trust a user has in a
    particular site, which makes the user believe any information presented by the
    website. On the other hand, CSRF exploits the trust that a website has in a user''s
    browser, which has the website execute any request coming from an authenticated
    session without verifying if the user wanted to perform that specific action.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）经常被错误地视为与XSS类似的漏洞。XSS利用用户对特定站点的信任，使用户相信网站呈现的任何信息。另一方面，CSRF利用网站对用户浏览器的信任，使网站在未验证用户是否要执行特定操作的情况下执行来自经过身份验证的会话的任何请求。'
- en: In a CSRF attack, the attacker makes authenticated users perform unwanted actions in
    the web application in which they are authenticated. This is accomplished through
    an external site that the user visits, which triggers these actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSRF攻击中，攻击者使经过身份验证的用户在其经过身份验证的Web应用程序中执行不需要的操作。这是通过用户访问的外部站点触发这些操作来实现的。
- en: 'CSRF can exploit every web application function that requires a single request
    within an authenticated session if sufficient defense is not implemented. Here
    are some examples of the actions that attackers can perform through a CSRF attack:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未实施足够的防御措施，CSRF可以利用需要在经过身份验证的会话中进行的每个Web应用程序功能。以下是攻击者可以通过CSRF攻击执行的一些操作的示例：
- en: Changing user details, such as email address and date of birth, in a web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web应用程序中更改用户详细信息，例如电子邮件地址和出生日期
- en: Making fraudulent banking transactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行欺诈性的银行交易
- en: Conducting fraudulent up-voting and down-voting on websites
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网站上进行欺诈性的点赞和点踩
- en: Adding items to a shopping cart on an e-commerce website or buying items without
    the user's knowledge
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电子商务网站上添加商品到购物车或在用户不知情的情况下购买商品
- en: Preconditions for a CSRF attack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSRF攻击的先决条件
- en: Since CSRF leverages an authenticated session, the victim must have an active
    authenticated session in the target web application. The application should also
    allow transactions within a session without asking for re-authentication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSRF利用了经过身份验证的会话，受害者必须在目标Web应用程序中拥有活动的经过身份验证的会话。该应用程序还应允许在会话中进行交易而无需重新进行身份验证。
- en: CSRF is a blind attack, and the response from the target web application is
    not sent to the attacker, but to the victim. The attacker must have knowledge
    about the parameters of the website that would trigger the intended action. For
    example, if you want to change the registered email address of the victim on the
    website, as an attacker you would identify the exact parameter that you need to
    manipulate to make this change. Therefore, the attacker would require proper understanding
    of the web application, which can be done by interacting with it directly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF是一种盲目攻击，目标Web应用程序的响应不会发送给攻击者，而是发送给受害者。攻击者必须了解触发所需操作的网站参数。例如，如果您想在网站上更改受害者的注册电子邮件地址，作为攻击者，您需要确定需要操纵以进行此更改的确切参数。因此，攻击者需要对Web应用程序有适当的理解，这可以通过直接与其交互来实现。
- en: Additionally, the attacker needs to find a way to trick the user into clicking
    on a prebuilt URL, or to visit an attacker-controlled website if the target application
    is using the `POST` method. This can be achieved using a social engineering attack.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，攻击者需要找到一种方法来诱使用户点击预先构建的URL，或者如果目标应用程序使用`POST`方法，则访问受攻击者控制的网站。这可以通过社交工程攻击来实现。
- en: Testing for CSRF flaws
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试CSRF漏洞
- en: 'The description of the CSRF vulnerability clearly suggests that it is a business
    logic flaw. An experienced developer would create web applications that would
    always include a user confirmation screen when performing critical tasks such
    as changing a password, updating personal details, or when making critical decisions
    in a financial application such as an online bank account. Testing for business
    logic flaws is not the job of automated web application scanners, as they work
    with predefined rules. For example, most of the automated scanners test for the
    following items to confirm the existence of a CSRF flaw in the URL:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF漏洞的描述明确表明它是一种业务逻辑缺陷。有经验的开发人员会创建Web应用程序，始终在执行关键任务（如更改密码、更新个人详细信息或在金融应用程序（如在线银行账户）中做出关键决策时）包括用户确认屏幕。测试业务逻辑缺陷不是自动化Web应用程序扫描器的工作，因为它们使用预定义规则。例如，大多数自动化扫描器会测试以下项目以确认URL中是否存在CSRF漏洞：
- en: Checking for common antiCSRF token names in the request and response
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查请求和响应中常见的反CSRF令牌名称
- en: Trying to determine whether the application is checking the referrer field by
    supplying a fake referrer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试确定应用程序是否通过提供虚假引用者来检查引用者字段
- en: Creating mutants to check whether the application is correctly verifying the
    token value
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建变异体以检查应用程序是否正确验证令牌值
- en: Checking for tokens and editable parameters in the query string
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查查询字符串中的令牌和可编辑参数
- en: All of the preceding methods used by most automated application scanners are
    prone to false positives and false negatives. The application would be using an
    entirely different mitigation technique to defeat a CSRF attack and thus render
    these scanning tools useless.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数自动化应用程序扫描器使用的先前方法容易产生误报和漏报。应用程序将使用完全不同的缓解技术来防御CSRF攻击，从而使这些扫描工具无效。
- en: The best way to analyze the application for a CSRF flaw is first to gain a complete
    understanding on the functionality of the web application. Fire up a proxy, such
    as Burp or ZAP, and capture the traffic to analyze the request and response. You
    can then create a HTML page, replicating the vulnerable code identified from the
    proxy. The best way to test for CSRF flaws is to do it manually.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 分析应用程序中的CSRF漏洞的最佳方法是首先完全了解Web应用程序的功能。启动代理，如Burp或ZAP，并捕获流量以分析请求和响应。然后，您可以创建一个HTML页面，复制从代理中识别出的易受攻击的代码。测试CSRF漏洞的最佳方法是手动进行。
- en: 'An application is likely to be vulnerable to CSRF flaws if it doesn''t include
    any special header or form parameter when performing server-side changes through
    an authenticated user''s session. For example, the following screenshot shows
    a request to add a comment to a picture in **Peruggia**, a vulnerable application
    included in the **OWASP BWA** virtual machine. You''ll notice that there is no
    special header that could identify one request from another on the server side.
    Also, the `GET` and `POST` parameters are used to identify the action to be executed,
    the image affected, and the contents of the comment:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在通过经过身份验证的用户会话执行服务器端更改时没有包含任何特殊的头部或表单参数，那么它很可能容易受到CSRF漏洞的攻击。例如，下面的屏幕截图显示了对**Peruggia**中的图片添加评论的请求，该应用程序是**OWASP
    BWA**虚拟机中的一个易受攻击的应用程序。您会注意到在服务器端没有特殊的头部可以识别一个请求与另一个请求的区别。此外，`GET`和`POST`参数用于标识要执行的操作、受影响的图像以及评论的内容：
- en: '![](img/00190.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00190.jpeg)'
- en: 'Sometimes, applications use verification tokens, but the implementation of
    them is insecure. The following screenshot shows a request from Mutillidae II
    | OWASP 2013 | A8 - Cross Site Request Forgery (CSRF) | Register User, using security
    level 1\. You can see that there is a `csrf_token` parameter in the request for
    registering a new user. However, it is only four digits long and seems easily
    predictable. Actually, in this particular case, the token always has the same
    value: `7777`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序使用验证令牌，但其实现是不安全的。下面的屏幕截图显示了使用安全级别1的Mutillidae II | OWASP 2013 | A8 -
    跨站请求伪造（CSRF）| 注册用户的请求。您可以看到请求中有一个`csrf_token`参数用于注册新用户。然而，它只有四位数，并且似乎很容易预测。实际上，在这种特殊情况下，令牌的值始终相同：`7777`：
- en: '![](img/00191.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00191.jpeg)'
- en: 'Other examples of flawed implementations of CSRF prevention tokens are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他实现CSRF防护令牌的错误示例包括：
- en: '**Include the token as a cookie**: Browsers automatically send cookies corresponding
    to the visited sites in requests, which will render the implementation of an otherwise
    secure token useless.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将令牌作为cookie包含：浏览器会自动在请求中发送与访问的站点对应的cookie，这将使本来安全的令牌实现变得无效。
- en: '**User or client information is used as a token**: Information such as IP address,
    username, or personal information can be used as a token. This unnecessarily exposes
    the user information, and such information can be gathered through social engineering
    or **Open Source Intelligence** (**OSINT**) in targeted attacks.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户或客户端信息作为令牌：IP地址、用户名或个人信息等信息可以用作令牌。这样做会不必要地暴露用户信息，并且可以通过社会工程学或有针对性的攻击中的开源情报（OSINT）收集此类信息。
- en: '**Allow tokens to be reused**: Even if for a short period of time, if the server
    allows for a token to be used multiple times, an attack can still be performed.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许重复使用令牌**：即使只允许短时间内重复使用令牌，仍然可以进行攻击。'
- en: '**Client-side only checks**: If the application verifies that the user is actually
    executing certain actions only using client-side code, an attacker can still bypass
    those checks using JavaScript, be it via an XSS exploitation, or in the attacking
    page, or simply by replaying the final request.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅客户端检查：如果应用程序仅使用客户端代码验证用户是否实际执行某些操作，攻击者仍然可以使用JavaScript绕过这些检查，无论是通过XSS利用还是在攻击页面中，或者仅仅是重放最终请求。
- en: Exploiting a CSRF flaw
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用CSRF漏洞
- en: Exploiting this vulnerability through a `GET` request (parameters sent within
    the URL) is as easy as convincing the user to browse to a malicious link that
    will perform the desired action. On the other hand, to exploit a CSRF vulnerability
    in a `POST` request requires creating an HTML page with a form or script that
    submits the request.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`GET`请求（参数在URL中发送）利用此漏洞就像说服用户浏览到执行所需操作的恶意链接一样简单。另一方面，要利用`POST`请求中的CSRF漏洞，需要创建一个包含表单或脚本的HTML页面来提交请求。
- en: Exploiting CSRF in a POST request
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用POST请求中的CSRF漏洞
- en: 'In this section, we will focus on exploiting a `POST` request. We will use
    Peruggia''s user-creation functionality for this exercise. The first step is that
    you need to know how the request that you want to replicate works; if you log
    in as admin to Peruggia and create a new user while capturing the traffic with
    Burp Suite, you can see that the request appears as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍利用`POST`请求的漏洞。我们将使用Peruggia的用户创建功能进行练习。第一步是了解要复制的请求的工作原理；如果您以管理员身份登录Peruggia并在使用Burp
    Suite捕获流量时创建一个新用户，您会发现请求如下所示：
- en: '![](img/00192.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00192.jpeg)'
- en: 'The request only includes the `newuser` (username) and `newuserpass` (password)
    parameters. Thus, once the request and parameters that make the change are identified,
    we need to do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请求只包括`newuser`（用户名）和`newuserpass`（密码）参数。因此，一旦确定了进行更改的请求和参数，我们需要执行以下操作：
- en: Create an HTML page that generates the request with those parameters and the
    information that you want to use.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个生成带有这些参数和要使用的信息的请求的HTML页面。
- en: Convince the user to browse to your page and submit the request. The latter
    may not be necessary, as you can have the page autosubmit the form.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说服用户浏览到您的页面并提交请求。后者可能是不必要的，因为您可以让页面自动提交表单。
- en: 'An elaborate HTML, like the following, is required to accomplish our objective.
    In this, example the vulnerable server is `10.7.7.5`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个复杂的HTML页面来实现我们的目标。在这个例子中，易受攻击的服务器是`10.7.7.5`：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The resulting page will look like the following screenshot. The bottom section
    is the Firefox developer tools panel. It can be activated using the *F12* key:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的页面将如下屏幕截图所示。底部部分是Firefox开发者工具面板，可以使用*F12*键激活：
- en: '![](img/00193.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00193.jpeg)'
- en: 'In a regular penetration test, this may work as **proof of concept** (**PoC**)
    and be enough to demonstrate the existence of a vulnerability. A more sophisticated
    version could include deceptive content and script code to autosubmit the request
    once the page is loaded:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规渗透测试中，这可能作为**概念验证**（**PoC**）有效，并足以证明存在漏洞。更复杂的版本可以包含欺骗性内容和脚本代码，以在页面加载后自动提交请求：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To test this PoC page, open Peruggia and start a session with the `admin` user
    (password: `admin`) and load the attacking page in a different tab or window of
    the same browser:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此PoC页面，请打开Peruggia并使用`admin`用户（密码：`admin`）启动会话，并在同一浏览器的不同标签页或窗口中加载攻击页面：
- en: '![](img/00194.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00194.jpeg)'
- en: 'Next, click on the Submit button or simply load the page, if using the scripted
    version, and the request will be processed by the server as if it were sent by
    an authenticated user. Using the browser''s developer tools, you can check that
    the request was sent to the target server and processed properly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击提交按钮或者如果使用脚本版本，则只需加载页面，服务器将处理该请求，就好像它是由经过身份验证的用户发送的一样。使用浏览器的开发者工具，您可以检查请求是否已发送到目标服务器并得到正确处理。
- en: '![](img/00195.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00195.jpeg)'
- en: CSRF on web services
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务上的CSRF
- en: It's not uncommon for today's web applications to perform tasks using calls
    to web services instead of normal HTML forms. These requests are done through
    JavaScript using the XMLHttpRequest object, which allows developers to create
    an HTTP request and customize parameters such as method, headers, and body.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的Web应用程序通常使用对Web服务的调用来执行任务，而不是使用普通的HTML表单。这些请求通过JavaScript使用XMLHttpRequest对象完成，该对象允许开发人员创建HTTP请求并自定义方法、头部和主体等参数。
- en: 'Web services often receive requests in formats different from the standard
    HTML form (for example, `parameter1=value1&parameter2=value2`), such as JSON and
    XML. The following example code snippet sends an address update request in JSON
    format:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务通常接收与标准HTML表单不同格式的请求（例如，`parameter1=value1&parameter2=value2`），例如JSON和XML。以下示例代码片段以JSON格式发送地址更新请求：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The body for this request (that is, the `POST` data) may look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求的主体（即`POST`数据）可能如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you try to send this exact string as a `POST` parameter within an HTML form,
    it will result in an error on the server and your request won''t be processed.
    Submitting the following form, for example, will not process the parameters correctly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将此精确字符串作为HTML表单中的`POST`参数发送，服务器将出现错误，并且您的请求将无法处理。例如，提交以下表单将无法正确处理参数：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a couple of ways to make it possible to exploit a CSRF to a request
    using JSON or XML formats.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以利用CSRF对使用JSON或XML格式的请求进行攻击。
- en: 'Oftentimes, web services allow parameters in different formats, including the
    HTML form format; so your first option is to change the `Content-Type` header
    of the request to `application/x-www-form-urlencoded`. This is done simply by
    sending the request through an HTML form. Instead of trying to send the JSON string;
    however, you can create a form containing one input for each parameter in the
    string. In our example, a simple version of the HTML code would be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web服务允许以不同格式传递参数，包括HTML表单格式；因此，您的第一个选择是将请求的`Content-Type`头更改为`application/x-www-form-urlencoded`。只需通过HTML表单发送请求即可实现此目的。但是，您不需要尝试发送JSON字符串；相反，您可以创建一个包含字符串中每个参数的输入的表单。在我们的示例中，HTML代码的简单版本如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the `Content-Type` header of the request is not allowed, and the web service
    only accepts JSON or XML formats, then you need to replicate (or create) the script
    code that generates the request following the same example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的`Content-Type`头不被允许，而Web服务只接受JSON或XML格式，则需要复制（或创建）生成请求的脚本代码，按照相同的示例进行操作：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the use of `xhr.withCredentials=true;`. This allows JavaScript to get
    the cookies stored in the browser for the target domain and send them along with
    the request. Additionally, the state change event handler is omitted, as you don't
    need to capture the response.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用了`xhr.withCredentials=true;`。这允许JavaScript获取浏览器中存储的目标域的cookie，并将其与请求一起发送。此外，省略了状态更改事件处理程序，因为您不需要捕获响应。
- en: This last option has several drawbacks, as JavaScript behavior is limited in
    current day browsers and servers in terms of cross-site operations. For example,
    depending on the server's **Cross-Origin Resource Sharing** (**CORS**) configuration,
    applications may need to perform a preflight check before sending a cross-site
    request. This means that browsers will automatically send an `OPTIONS` request
    to check the methods allowed by that server before sending anything. If the requested
    method is not allowed for cross-origin requests, the browser will not send it.
    Another example of protection, this time in browsers, is the aforementioned **same-origin
    policy**, which by default makes browsers protect the server's resources from
    being accessed via script code by other websites.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最后的选择有几个缺点，因为当前浏览器和服务器在跨站操作方面对JavaScript的行为有限制。例如，根据服务器的**跨域资源共享**（**CORS**）配置，应用程序可能需要在发送跨站请求之前执行预检查。这意味着浏览器将自动发送一个`OPTIONS`请求，以检查该服务器允许的方法。如果请求的方法不允许进行跨域请求，浏览器将不会发送它。另一个保护的例子是浏览器中的**同源策略**，默认情况下，它使浏览器保护服务器的资源免受其他网站的脚本代码访问。
- en: Using Cross-Site Scripting to bypass CSRF protections
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用跨站脚本（XSS）绕过CSRF保护
- en: When an application is vulnerable to **Cross-Site Scripting** (**XSS**), an
    attacker can use that flaw (via scripting code) to read the variable containing
    the unique token and either send it to an external site and open the malicious
    page in a new tab, or use the same script code to send the request, also bypassing
    the CORS and same-origin policies, as the request will be made by the same site
    via local scripts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序容易受到**跨站脚本**（**XSS**）攻击时，攻击者可以利用该漏洞（通过脚本代码）读取包含唯一令牌的变量，并将其发送到外部站点并在新标签中打开恶意页面，或者使用相同的脚本代码发送请求，同时绕过CORS和同源策略，因为请求将由同一站点通过本地脚本进行。
- en: Let's look at the scenario where scripting code can be used to make the application
    perform a request on itself. You will use WebGoat's *CSRF Token By-Pass* (Cross-Site
    Scripting (XSS) | CSRF Token By-Pass) exercise. As expressed in the instructions,
    you need to abuse the fact that the *new post* functionality in a newsgroup allows
    the injection of HTML and JavaScript code in order to perform an unauthorized
    request to transfer funds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用脚本代码使应用程序执行自身请求的情况。您将使用WebGoat的*CSRF Token By-Pass*（跨站脚本（XSS）| CSRF Token
    By-Pass）练习。根据说明，您需要滥用新闻组中的*新帖子*功能允许注入HTML和JavaScript代码，以执行未经授权的转账请求。
- en: 'The following screenshot shows the transfer funds page, which you can load
    adding the `&transferFunds=main` parameter to the lesson''s URL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了转账页面，您可以通过将`&transferFunds=main`参数添加到课程的URL中来加载它：
- en: '![](img/00196.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00196.jpeg)
- en: 'If you inspect the source code of the form, you can see that it has a hidden
    field called `CSRFToken`, which will change every time you load the page. This
    appears to be completely random:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查表单的源代码，您会看到它有一个名为`CSRFToken`的隐藏字段，每次加载页面时都会更改。这似乎是完全随机的：
- en: '![](img/00197.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00197.jpeg)
- en: 'In order to execute a CSRF in this form, you will need to exploit the XSS vulnerability
    in the comment form to have it load the transfer form inside an `iframe` tag using
    JavaScript. This will set the value to transfer and automatically submit the form.
    To do this, use the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这个表单中执行CSRF攻击，您需要利用评论表单中的XSS漏洞，使用JavaScript将转账表单加载到一个`iframe`标签中。这将设置值为transfer并自动提交表单。要做到这一点，请使用以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Thus, when the page contained in the iframe is completely loaded, it will call
    the `frame_loaded` function, which sets the value of the `transferFunds` field
    to `54321` (the amount to be transferred) and submits the request. Notice that
    the `form.submit();` line is commented. This is for demonstration purposes only
    in order to prevent the automatic submission.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当iframe中包含的页面完全加载完成时，它将调用`frame_loaded`函数，该函数将`transferFunds`字段的值设置为`54321`（要转移的金额）并提交请求。请注意，`form.submit();`行被注释掉了。这仅用于演示目的，以防止自动提交。
- en: 'Now browse to the vulnerable page:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览到易受攻击的页面：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set a title for your post, write or paste your code in the Message field, and
    submit it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的帖子设置一个标题，在消息字段中编写或粘贴您的代码，然后提交它。
- en: '![](img/00198.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00198.jpeg)
- en: 'After doing this, you will see your message''s title at the bottom of the page,
    just below the Submit button. If you click on it as a victim would do, you can
    see how it loads the amount to transfer that was set in the code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将在页面底部看到您的消息标题，就在提交按钮下方。如果您像受害者一样点击它，您可以看到它如何加载在代码中设置的要转移的金额：
- en: '![](img/00199.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00199.jpeg)
- en: 'To test autosubmission, just post a new message, removing the comment on the
    `form.submit();` line. The result of opening the message will appear similar to
    the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试自动提交，请发布一条新消息，删除`form.submit();`行上的注释。打开消息的结果将类似于以下屏幕截图：
- en: '![](img/00200.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00200.jpeg)
- en: 'The next screenshot, from Burp Suite''s proxy history, shows how the requests
    were made by the browser in the previous example. Shown first is the request to
    load a message with code injected, in our case, message 66 (parameter `Num=66`).
    Next, the malicious message loads the iframe with the fund transfer page (parameter
    `transferFunds=main`). Finally, according to the code, when this page finishes
    loading the script code, it fills in the amount to transfer and submits the request
    with a valid CSRF token:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图来自Burp Suite的代理历史记录，显示了浏览器在前面的示例中如何发出请求。首先显示的是加载带有注入代码的消息的请求，在我们的例子中是消息66（参数`Num=66`）。接下来，恶意消息加载了包含资金转移页面的iframe（参数`transferFunds=main`）。最后，根据代码，当此页面完成加载脚本代码时，它填写要转移的金额并使用有效的CSRF令牌提交请求：
- en: '![](img/00201.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00201.jpeg)
- en: Preventing CSRF
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防CSRF攻击
- en: Preventing CSRF is all about ensuring that the authenticated user is the person
    requesting the operation. Due to the way browsers and web applications work, the
    best choice is to use a token to validate operations, or, when possible, use a
    CAPTCHA control.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 预防CSRF攻击的关键是确保经过身份验证的用户是请求操作的人。由于浏览器和Web应用程序的工作方式，最好的选择是使用令牌来验证操作，或者在可能的情况下使用验证码控件。
- en: A CSRF attack is easier to execute when the vulnerable parameter is passed through
    the `GET` method. Therefore, avoid it in the first place and use the `POST` method
    wherever possible. It does not fully mitigate the attack, but it makes the attacker's
    task more difficult.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当易受攻击的参数通过`GET`方法传递时，执行CSRF攻击更容易。因此，首先避免使用它，并在可能的情况下使用`POST`方法。这并不能完全消除攻击，但可以增加攻击者的难度。
- en: As attackers will try to break token generation or validation systems, it is
    very important to produce them securely; that is, in a way that attackers cannot
    guess them. You must also make them unique for each user and each operation, because
    reusing them voids their purpose. These tokens are usually included in a header
    field in every request or in a hidden input in HTML forms. Avoid including them
    in cookies, as they are automatically sent by the browser along with every request
    on a per-domain basis.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于攻击者将尝试破解令牌生成或验证系统，因此安全地生成它们非常重要；也就是说，攻击者无法猜测它们。您还必须使它们对每个用户和每个操作都是唯一的，因为重用它们会使它们失去作用。这些令牌通常包含在每个请求的标头字段中，或者包含在HTML表单的隐藏输入中。避免将它们包含在cookie中，因为它们会随着每个请求在每个域的基础上由浏览器自动发送。
- en: CAPTCHA controls and re-authentication are intrusive and annoying for users
    at some point, but if the criticality of the operation merits it, they may be
    willing to accept them in exchange for the extra level of security they provide.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CAPTCHA控件和重新认证在某些情况下对用户来说是侵入性和烦人的，但如果操作的重要性值得，他们可能愿意接受它们，以换取额外的安全级别。
- en: Furthermore, CORS policies should be configured on the server, as they can prevent
    some attacks which are done via script code through the web browser. CORS policies
    will prevent JavaScript running in a different tab or browser window in order
    to access data/resources on the server if the URL loaded in that window is not
    part of the same origin (such as host, port, or protocol).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应该在服务器上配置CORS策略，因为它们可以防止通过Web浏览器的脚本代码进行的一些攻击。如果加载在该窗口中的URL不属于同一源（例如主机、端口或协议），CORS策略将阻止在不同标签或浏览器窗口中运行的JavaScript访问数据/资源。
- en: More information about preventing CSRF can be found at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有关防止CSRF的更多信息，请访问[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet)。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about CSRF and how it abuses the trust relationship
    between the server and web browsers. You saw how to detect applications that may
    be vulnerable, reviewed an exploitation procedure, and practiced with an example,
    analyzing how it would work in web services. You also learned of a way to bypass
    token protection and the CORS and same-origin policies when combined with an XSS
    vulnerability.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了CSRF以及它如何滥用服务器和Web浏览器之间的信任关系。您了解了如何检测可能存在漏洞的应用程序，审查了一种利用过程，并通过一个示例进行了实践，分析了它在Web服务中的工作原理。您还了解了一种绕过令牌保护、CORS和同源策略的方法，结合XSS漏洞使用。
- en: As in previous chapters, the last section of this one was about defense. We
    reviewed recommended methods for preventing or mitigating CSRF vulnerabilities
    in your own applications or in those of your clients.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，本章的最后一节是关于防御的。我们审查了在您自己的应用程序或客户的应用程序中预防或减轻CSRF漏洞的推荐方法。
- en: The next chapter will be a brief introduction to cryptography, focusing on the
    basics that a penetration tester needs to know, such as distinguishing between
    encryption, hashing and encoding, identifying weak cryptographic implementations
    and exploiting common vulnerabilities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将简要介绍密码学，重点介绍渗透测试人员需要了解的基础知识，例如区分加密、哈希和编码，识别弱密码实现并利用常见漏洞。
