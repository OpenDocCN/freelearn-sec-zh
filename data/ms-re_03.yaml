- en: The Low-Level Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级语言
- en: The main piece of knowledge required in advance for any reverse engineer is
    assembly language. Understanding assembly language is like learning the ABCs of
    reversing. It may look hard at first, but eventually it will become like a muscle
    memory. Assembly language is the language that is used to communicate with the
    machine. The source code of a program can be understood by humans but not by the
    machine. The source code has to be compiled down to its assembly language code
    form for the machine to understand it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何反向工程师在开始之前需要掌握的主要知识是汇编语言。理解汇编语言就像学习反向工程的 ABC。它可能一开始看起来很难，但最终会变得像肌肉记忆一样。汇编语言是与计算机交流的语言。程序的源代码是人类可以理解的，但机器无法理解。源代码必须被编译成汇编语言代码形式，才能被计算机理解。
- en: But, as humans, what if the source code is not available? Our only way to understand
    what a program does is to read its assembly codes. In a way, what we are building
    here is a way to turn an assembly language code back to the source code. That
    would be why this is called reversing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为人类，如果源代码不可用呢？我们唯一能够理解程序如何运行的方式就是读取它的汇编代码。从某种程度上来说，我们在这里构建的是一种将汇编语言代码还原为源代码的方法。这就是为什么它被称为反向工程。
- en: We will provide a brief introduction to assembly language, focusing on the x86
    Intel architecture. So, why x86? There are a lot of architectures out there, such
    as 8080, ARM, MIPS, PowerPC, and SPARC, but we are focusing on Intel x86 as it
    is the most popular and widely used architecture today.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍汇编语言，重点讲解 x86 英特尔架构。那么，为什么选择 x86 呢？市面上有很多架构，如 8080、ARM、MIPS、PowerPC 和
    SPARC，但我们专注于英特尔 x86，因为它是当今最流行和广泛使用的架构。
- en: In this chapter, we will get to learn the basics of assembly language. We will
    start by reviewing binary numbers, followed by using assembly language instructions
    to implement binary arithmetic, we will then learn how to compile our own low-level
    program, and, finally, how to debug a program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习汇编语言的基础知识。我们将从回顾二进制数开始，然后使用汇编语言指令实现二进制算术，接着学习如何编译自己的低级程序，最后学习如何调试程序。
- en: 'This chapter has been divided into sections. We will learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已被划分为多个部分。我们将学习以下内容：
- en: Binary numbers, bases, and the ASCII table
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数、进制和 ASCII 表
- en: x86 architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86 架构
- en: Assembly language instructions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编语言指令
- en: Tools used to edit and compile an assembly-language source code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编辑和编译汇编语言源代码的工具
- en: Debugging tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具
- en: Exceptions and error handling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常和错误处理
- en: Windows APIs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows API
- en: High-level language constructs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级语言结构
- en: We will include instructions to set up and develop your assembly language code.
    This also comes with exercises that may help to inspire you to develop programs
    using assembly language.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供设置和开发汇编语言代码的说明。这里还包含一些练习，可能会激发你使用汇编语言开发程序的灵感。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is best, but not required, that the reader has some background knowledge
    of any programming language. Having a programming background will help the reader
    to understand assembly language more quickly. There are references given at the
    end of this chapter that the reader can use for further programming development
    and research not provided in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最好但不是必需的，读者具备一定的编程语言背景。拥有编程背景将帮助读者更快地理解汇编语言。本章末尾提供了一些参考资料，读者可以利用它们进行进一步的编程开发和研究，这些内容在本书中没有提供。
- en: 'Some tools that we will use here include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此使用的一些工具包括：
- en: Binary editors, such as HxD Editor or HIEW (Hacker's View)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制编辑器，如 HxD 编辑器或 HIEW（黑客视图）
- en: Text editors, such as Notepad++
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器，如 Notepad++
- en: Binary numbers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制数
- en: Computers were designed to electronically process and store data using signals.
    A signal is like an on/off switch, where both the "on" and "off" positions can
    be denoted by the numbers "1" and "0" respectively. These two numbers are what
    we call binary numbers. The next section will discuss how binary numbers are used
    and how this relates to other number bases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是设计用来通过信号进行电子数据处理和存储的。信号就像一个开关，其中“开”和“关”位置分别用数字“1”和“0”表示。这两个数字就是我们所说的二进制数。下一部分将讨论二进制数如何使用，以及它与其他进制的关系。
- en: Bases
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进制
- en: The place value of a digit in a number determines its value at that position.
    In the standard decimal numbers, the value of a place is ten times the value of
    the place on its right. The decimal number system is also called base-10, which
    is composed of digits from 0 to 9.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数字中每个位置的值决定了该位置的值。在标准的十进制数字中，一个位置的值是它右边位置值的十倍。十进制数字系统也叫做基数为10的系统，它由数字0到9组成。
- en: 'Let''s say that position 1 is at the right-most digit of the whole number,
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设位置1在整个数字的最右边，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sum of all represented numbers is the actual value. Following this concept
    will help us to read or convert into other number bases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表示的数字之和就是实际值。遵循这个概念将帮助我们读取或转换成其他数字基数。
- en: 'In base-2 numbers, the value of a place is 2 times the value of the place on
    its right. Base-2 uses only 2 digits, composed of 0 and 1\. In this book, we will
    append a small `b` to denote that the number is of base-2 format. Base-2 numbers
    are also called binary numbers. Each digit in a binary string is called a bit.
    Consider the following as an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制数中，一个位置的值是它右边位置值的2倍。二进制只使用2个数字，分别是0和1。在本书中，我们会在数字后面加上小写字母`b`，表示该数字是二进制格式。二进制数字也被称为二进制数。二进制字符串中的每一位被称为比特。以下是一个例子：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In base-16 numbers, the value of a place is 16 times the value of the place
    on its right. It is composed of digits 0 to 9 and letters A to F where A is equivalent
    to 10, B is 11, C is 12, D is 13, E is 14, and F is 15\. We will denote base-16
    numbers, also known as hexadecimal numbers, with the letter `h`. In this book,
    hexadecimal numbers with an odd number of digits will be prefixed with `0` (zero).
    Hexadecimal numbers can also instead be prefixed with "0x" (zero and a lowercase
    x). The `0x` is a standard used on various programming languages denoting that
    the number next to it is of hexadecimal format:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制数中，一个位置的值是它右边位置值的16倍。十六进制由数字0到9和字母A到F组成，其中A等于10，B等于11，C等于12，D等于13，E等于14，F等于15。在本书中，我们将用字母`h`表示十六进制数字。十六进制数字如果位数为奇数，将前面加上`0`（零）。十六进制数字也可以用"0x"（零和小写字母x）作为前缀。`0x`是多种编程语言中表示该数字为十六进制格式的标准：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Converting between bases
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基数转换
- en: We have already converted hexadecimal and binary numbers into decimal, or base-10\.
    Converting base-10 into other bases simply requires division of the base being
    converted into, while taking note of the remainders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将十六进制和二进制数转换成了十进制数，或者说是基数为10的数。将基数为10的数字转换成其他基数，只需要对要转换的基数进行除法运算，同时记录余数。
- en: The following is an example for base-2
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个二进制的例子
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is an example for base-16:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个十六进制的例子：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Converting from hexadecimal into binary simply requires knowing how many binary
    digits there are in a hexadecimal digit. The highest digit for a hexadecimal number
    is `0Fh` (15) and is equivalent to `1111b`. Take note that there are 4 binary
    digits in a hexadecimal digit. An example conversion is shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将十六进制转换为二进制只需要知道十六进制数字中有多少个二进制位。十六进制数中最高的数字是`0Fh`（15），它等于`1111b`。请注意，每个十六进制数字等于4个二进制位。这里展示了一个转换的例子：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Split the binary number into four digits each when converting from binary into
    hexadecimal, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在从二进制转换为十六进制时，将二进制数分为每四位一组，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, why the use of base-2 and base-16 in computers, rather than our daily base-10
    usage? Well, for base-2, there are two states: an on and an off signal. A state
    can easily be read and transmitted electronically. Base-16 compresses the representation
    of the binary equivalent of a decimal number. Take 10 for instance: this number
    is represented as `1010b` and consumes 4 bits. To maximize the information that
    can be stored in 4 bits, we can represent numbers from 0 to 15 instead.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么计算机使用二进制和十六进制，而不是我们日常使用的十进制呢？对于二进制来说，有两种状态：开和关信号。状态可以很容易地被电子方式读取和传输。十六进制压缩了十进制数的二进制等效表示。例如，数字10：这个数字表示为`1010b`，并占用4个位。为了最大化4个位可以存储的信息，我们可以表示0到15之间的数字。
- en: 'A 4-bit value is also called a nibble. It is half of a byte. Bytes can represent alphabets,
    numbers, and characters. This representation of characters is mapped in the ASCII
    table. The ASCII table has three sections: control, printable, and extended characters.
    There are 255 (`FFh`) ASCII characters. Lists of printable characters that can
    be typed on the keyboard and some of the extended characters with keyboard format
    can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 4 位值也叫做 nibble，是字节的一半。字节可以表示字母、数字和字符。这些字符的表示在 ASCII 表中进行了映射。ASCII 表有三部分：控制字符、可打印字符和扩展字符。ASCII
    表有 255 个字符（`FFh`）。可打印字符的列表以及一些扩展字符与键盘格式，可以在 [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch3)
    找到。
- en: Though not directly visible from the English language keyboard, symbols can
    still be displayed by using the character's equivalent code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从英文键盘上无法直接看到符号，但可以通过使用字符的等效代码来显示。
- en: Binary arithmetic
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制算术
- en: 'Since a byte is the common unit used in computers, let''s play with it. We
    can start with basic arithmetical functions: addition, subtraction, multiplication,
    and division. The pencil-and-paper method is still a strong method for doing binary
    math. Binary arithmetic is similar to doing arithmetic in decimal numbers. The
    difference is that there are only two numbers used, 1 and 0.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字节是计算机中常用的单位，我们来玩玩它。我们可以从基本的算术运算开始：加法、减法、乘法和除法。传统的纸笔方法仍然是进行二进制运算的一种强大方法。二进制算术与十进制数的算术非常相似，唯一的区别是只有
    1 和 0 两个数字。
- en: 'Addition is carried out as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 加法按以下方式进行：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An example of subtraction is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个减法示例如下：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multiplication is carried out as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法操作如下进行：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Division in binary works as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制除法按以下方式进行：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Signed numbers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有符号数
- en: Binary numbers can be structured as signed or unsigned. For signed numbers or
    integers, the most significant bit dictates what sign the number is in. This requires
    a defined size of the binary such as `BYTE`, `WORD`, `DWORD`, and `QWORD`. A `BYTE`
    has a size of 8 bits. A `WORD` has 16 bits while a DWORD (double `WORD`) has 32
    bits. A `QWORD` (quad `WORD`) has 64 bits. Basically, the size doubles as it progresses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数可以按有符号或无符号进行构造。对于有符号数或整数，最高有效位决定了数值的符号。这要求二进制数有明确的大小，比如 `BYTE`、`WORD`、`DWORD`
    和 `QWORD`。`BYTE` 大小为 8 位，`WORD` 大小为 16 位，`DWORD`（双 `WORD`）为 32 位，`QWORD`（四倍 `WORD`）为
    64 位。基本上，随着位数的增加，大小会加倍。
- en: 'In our example, let''s use a `BYTE`. Identifying a positive binary number is
    easy. In positive numbers, the most significant bit, or 8^(th) bit in a byte,
    is 0\. The rest of the bits from 0 to the 7th bit is the actual value. For a negative
    binary number, the most significant bit is set to 1\. However, the value set from
    0 to the 7th bit is then calculated for a two''s complement value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，假设使用 `BYTE`。识别一个正数的二进制表示很简单。在正数中，最高有效位或字节中的第 8 位为 0，剩余的从第 0 位到第 7 位的值即为实际数值。对于负数的二进制表示，最高有效位设置为
    1，然而从第 0 位到第 7 位的值则需要计算为 2 的补码值：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The "2''s complement" of a value is calculated in two steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值的“2 的补码”通过两步计算：
- en: Reverse 1s and 0s, so that 1 becomes 0 and 0 becomes 1, for example, `1010b`
    becomes `0101b`. This step is called the one's complement.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转 1 和 0，使得 1 变为 0，0 变为 1，例如，`1010b` 变为 `0101b`。这一步叫做 1 的补码。
- en: Add 1 to the result of the previous step, for example, `0101b + 1b = 0110b`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一步的结果加 1，例如，`0101b + 1b = 0110b`。
- en: 'To write down the binary equivalent of -63, assuming it is a `BYTE`, we only
    take bits 0 to 7:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要写出 -63 的二进制等价表示，假设它是一个 `BYTE`，我们只取第 0 位到第 7 位：
- en: 'Convert into binary using the previous procedure:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前述方法转换为二进制：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Do "1''s complement" as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做“1 的补码”如下：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add 1 to the preceding outcome to get the "2''s complement" result:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的结果上加 1，得到“2 的补码”结果：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since this is a negative number, set the most significant bit to 1:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个负数，所以将最高有效位设置为 1：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s how to write the decimal of a negative binary number:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何写下负二进制数的十进制表示：
- en: 'Take note that the significant bit is 1, and so a negative sign:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，符号位是 1，因此为负号：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Take the "1''s complement," then add 1:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先做“1 的补码”，然后加 1：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Convert the result to decimal, and place the – sign at the beginning, since
    this is a negative number:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果转换为十进制，并将负号放在最前面，因为这是一个负数：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: x86
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86
- en: Like any other programming language, assembly language has its own variables,
    syntax, operations, and functions. Every line of code is processes a small amount
    of data. In other words, every byte is read or written per line of code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他编程语言一样，汇编语言有其自身的变量、语法、操作和函数。每一行代码处理的是一小部分数据。换句话说，每一行代码读取或写入一个字节的数据。
- en: Registers
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器
- en: 'In programming, processing data requires variables. You can simply think of
    registers as variables in assembly language. However, not all registers are treated
    as plain variables, but rather, each register has a designated purpose. The registers
    are categorized as being one of the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，处理数据需要使用变量。你可以简单地将寄存器视为汇编语言中的变量。然而，并非所有寄存器都被当作普通变量使用，而是每个寄存器都有其特定的用途。寄存器可以被分类为以下几种类型：
- en: General purpose registers
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用寄存器
- en: Segment registers
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段寄存器
- en: Flag registers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志寄存器
- en: Instruction pointers
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令指针
- en: 'In x86 architecture, each general purpose register has its designated purpose
    and is stored at `WORD` size, or 16 bits, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86架构中，每个通用寄存器都有其指定的用途，并且按`WORD`大小存储，即16位，具体如下：
- en: Accumulator (AX)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累加器（AX）
- en: Counter (CX)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器（CX）
- en: Data (DX)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据寄存器（DX）
- en: Base (BX)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基址寄存器（BX）
- en: Stack pointer (SP)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈指针（SP）
- en: Base pointer (BP)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基址指针（BP）
- en: Source index (SI)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源索引（SI）
- en: Destination index (DI)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的索引（DI）
- en: 'For registers AX, BX, CX, and DX, the least and most significant bytes can
    be accessed by smaller registers. For AX, the lower 8 bits can be read using the
    AL register, while the upper 8 bits can be read using the AH register, as shown
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于寄存器AX、BX、CX和DX，可以通过较小的寄存器访问最低和最高有效字节。对于AX，低8位可以使用AL寄存器读取，而高8位可以使用AH寄存器读取，如下所示：
- en: '![](img/9526322d-72c7-40e5-be7b-4114fb6d614c.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9526322d-72c7-40e5-be7b-4114fb6d614c.png)'
- en: When running code, the system needs to identify where the code is at. The Instruction
    Pointer (IP) register is the one that contains the memory address where the next
    assembly instruction to be executed is stored.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码时，系统需要识别代码所在的位置。指令指针（IP）寄存器包含下一个要执行的汇编指令所在的内存地址。
- en: 'System states and logical results of executed code are stored in the **FLAGS
    register**. Every bit of the FLAGS register has its own purpose, with some of
    the definitions given in the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码的系统状态和逻辑结果存储在**FLAGS寄存器**中。FLAGS寄存器的每一位都有其特定的用途，以下表格列出了其中的一些定义：
- en: '| **Offset** | **Abbreviation** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **缩写** | **描述** |'
- en: '| 0 | CF | Carry flag. This flag is set when an addition operation requires
    a bit to be carried. It is also set when a bit needs to be borrowed in a subtraction
    operation. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0 | CF | 进位标志。当加法操作需要进位时，设置此标志。当减法操作需要借位时，也会设置此标志。 |'
- en: '| 1 |  | Reserved |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  | 保留 |'
- en: '| 2 | PF | Parity flag. This flag indicates if the number of set bits is odd
    or even from the last instruction operation. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 2 | PF | 奇偶标志。此标志指示上一条指令操作中设置的位数是奇数还是偶数。 |'
- en: '| 3 |  | Reserved |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 3 |  | 保留 |'
- en: '| 4 | AF | Adjust flag. This is used in Binary-Coded Decimals (BCD). This flag
    is set when a carry happens from the low to high nibble or when a borrow happens
    from the high to low nibble of a byte. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 4 | AF | 调整标志。用于二进制编码十进制（BCD）。当低位到高位的进位或高位到低位的借位发生时，设置此标志。 |'
- en: '| 6 | ZF | Zero flag. This flag is set when the result of the last instruction
    operation is zero. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ZF | 零标志。当上一条指令操作的结果为零时，设置此标志。 |'
- en: '| 7 | SF | Sign flag. This flag is set when the result of the last instruction
    operation is a negative number. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 7 | SF | 符号标志。当上一条指令操作的结果为负数时，设置此标志。 |'
- en: '| 8 | TF | Trap flag. This is used when debugging. This flag is set when breakpoints
    are encountered. Setting the trap flag can cause an exception on every instruction,
    enabling debugging tools to control step-by-step debugging. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 8 | TF | 陷阱标志。用于调试时。当遇到断点时，设置此标志。设置陷阱标志会导致每条指令都触发异常，从而启用调试工具进行逐步调试。 |'
- en: '| 9 | IF | Interrupt flag. If this flag is set, the processor responds to interrupts.
    Interrupts are instances where errors, external events, or exceptions are triggered
    from hardware or software.  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 9 | IF | 中断标志。如果设置了此标志，处理器会响应中断。中断是指由硬件或软件触发的错误、外部事件或异常。 |'
- en: '| 10 | DF | Direction flag. When set, data is read from memory backwards. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 10 | DF | 方向标志。当设置时，数据从内存中倒序读取。 |'
- en: '| 11 | OF | Overflow flag. It is set if an arithmetic operation results in
    a value larger than what the register can contain. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 11 | OF | 溢出标志。如果算术操作的结果超过寄存器能容纳的值，则会设置此标志。 |'
- en: '| 12 to 13 | IOPL | Input/output privilege level. The IOPL shows the ability
    of the program to access IO ports. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 12 到 13 | IOPL | 输入/输出特权级。IOPL显示程序访问IO端口的能力。 |'
- en: '| 14 | NT | Nested task flag. This controls the chaining of interrupt tasks
    or processes. If set, then it is linked to the chain. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 14 | NT | 嵌套任务标志。它控制中断任务或进程的链式执行。如果设置，则与链表链接。 |'
- en: '| 15 |  | Reserved |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 15 |  | 保留 |'
- en: '| 16 | RF | Resume flag. It temporarily disables debug exceptions so the next
    instruction being debugged can be interrupted without a debug exception. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 16 | RF | 恢复标志。它暂时禁用调试异常，以便下一条正在调试的指令可以在不产生调试异常的情况下被中断。 |'
- en: '| 17 | VM | Virtual mode. Sets the program to run in compatibility with 8086
    processors. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 17 | VM | 虚拟模式。设置程序与8086处理器兼容运行。'
- en: '| 18 | AC | Alignment check. This flag is set when data written on a memory
    reference, such as the stack, is a non-word (for 4 byte boundaries) or non-doubleword
    (for 8 byte boundaries). However, this flag was more useful before the 486-architecture
    days. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 18 | AC | 对齐检查。该标志在内存引用（如栈）上的数据是非字（4字节边界）或非双字（8字节边界）时设置。然而，在486架构之前，这个标志更为有用。
    |'
- en: '| 19 | VIF | Virtual interrupt flag. Similar to the interrupt flag, but works
    when in virtual mode. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 19 | VIF | 虚拟中断标志。类似于中断标志，但在虚拟模式下工作。 |'
- en: '| 20 | VIP | Virtual interrupt pending flag. Indicates that triggered interrupts
    are waiting to be processed. Works in Virtual mode. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 20 | VIP | 虚拟中断挂起标志。表示已触发的中断正在等待处理。仅在虚拟模式下工作。 |'
- en: '| 21 | ID | Identification flag. Indicates if the CPUID instruction can be
    used. The CPUID can determine the type of processor and other processor info.
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 21 | ID | 标识符标志。指示是否可以使用CPUID指令。CPUID可以确定处理器类型及其他处理器信息。 |'
- en: '| 22 |  | Reserved |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 22 |  | 保留 |'
- en: '| 23 to 31 |  | Reserved |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 23 到 31 |  | 保留 |'
- en: '| 32 to 63 |  | Reserved |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 32 到 63 |  | 保留 |'
- en: All of these flags have a purpose, but the flags that are mostly monitored and
    used are the carry, sign, zero, overflow, and parity flags.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些标志都有其目的，但最常被监控和使用的标志是进位标志、符号标志、零标志、溢出标志和奇偶标志。
- en: All these registers have an "extended" mode for 32-bits. It can accessed with
    a prefixed "E" (`EAX`, `EBX`, `ECX`, `EDX`, `ESP`, `EIP`, and `EFLAGS`). The same
    goes with 64-bit mode, which can be accessed with a prefixed "R" (`RAX`, `RBX`,
    `RCX`, `RDX`, `RSP`, and `RIP`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些寄存器都有一个“扩展”模式用于32位。它可以通过前缀“E”访问（`EAX`、`EBX`、`ECX`、`EDX`、`ESP`、`EIP`和`EFLAGS`）。64位模式也是如此，可以通过前缀“R”访问（`RAX`、`RBX`、`RCX`、`RDX`、`RSP`和`RIP`）。
- en: 'The memory is divided into sections such as the code segment, stack segment,
    data segment, and other sections. The segment registers are used to identify the
    starting location of these sections, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内存被划分为不同的段，例如代码段、栈段、数据段和其他段。段寄存器用于标识这些段的起始位置，如下所示：
- en: Stack segment (SS)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈段（SS）
- en: Code segment (CS)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码段（CS）
- en: Data segment (DS)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据段（DS）
- en: Extra segment (ES)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展段（ES）
- en: F segment (FS)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F段（FS）
- en: G segment (GS)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G段（GS）
- en: When a program loads, the operating system maps the executable file to the memory.
    The executable file contains information to which data maps respective segments.
    The code segment contains the executable code. The data segment contains the data
    bytes, such as constants, strings, and global variables. The stack segment is
    allocated to contain runtime function variables and other processed data. The
    extra segment is similar to the data segment, but this space is commonly used
    to move data between variables. Some 16-bit operating systems, such as DOS, make
    use of the SS, CS, DS, and ES since there are only 64 kilobytes allocated per
    segment. However, in modern operating systems (32-bit systems and higher) these
    four segments are set in the same memory space, while FS and GS point to process
    and thread information respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序加载时，操作系统会将可执行文件映射到内存。可执行文件包含有关数据如何映射到相应段的信息。代码段包含可执行代码。数据段包含数据字节，如常量、字符串和全局变量。栈段被分配用于存储运行时函数变量和其他处理过的数据。扩展段与数据段类似，但此空间通常用于在变量之间移动数据。一些16位操作系统，如DOS，由于每个段只分配64KB的内存，因此使用SS、CS、DS和ES。然而，在现代操作系统（32位及更高系统）中，这四个段被设置在同一内存空间中，而FS和GS分别指向进程和线程信息。
- en: Memory addressing
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存寻址
- en: The start of a piece of data, a series of bytes, stored in the memory can be
    located using its memory address. Every byte stored in the memory is assigned
    a memory address that identifies its location. When a program is executed by a
    user, the executable file is read, then mapped by the system to an allocated memory
    address. The executable file contains information on how it maps it, so that all
    executable code is in the code section, all initialized data is in the data section,
    and uninitialized data is in the BSS section. Code instructions found in the code
    section are able to access data in the data section using memory addresses, which
    can be hard-coded. Data can also be a list of addresses pointing to another set
    of data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一段数据的起始位置，即存储在内存中的一系列字节，可以通过其内存地址来定位。存储在内存中的每个字节都有一个内存地址，用来标识它的位置。当用户执行程序时，系统会读取可执行文件，然后将其映射到一个分配的内存地址。可执行文件包含了如何进行映射的信息，确保所有的可执行代码都在代码段内，所有初始化的数据都在数据段内，未初始化的数据则在BSS段内。代码段中的代码指令可以通过内存地址访问数据段中的数据，这些地址可以是硬编码的。数据也可以是一个地址列表，指向另一组数据。
- en: Endianness
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节序
- en: When reading or writing data to memory, we use the registers or memory to process
    them as `BYTE`, `WORD`, `DWORD`, or even `QWORD`. Depending on the platform or
    program, data is read in little-endian or big-endian form.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取或写入数据到内存时，我们使用寄存器或内存以`BYTE`、`WORD`、`DWORD`甚至`QWORD`的形式来处理它们。根据平台或程序，数据可能以小端或大端格式进行读取。
- en: 'In little-endian, a chunk of data read into a `DWORD` is reversed. Let''s take
    the following piece of data as an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在小端格式中，当数据块被读取为`DWORD`时，它会被反转。我们以以下数据为例：
- en: '`AA BB CC DD`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AA BB CC DD`'
- en: When the data on a file or memory looks like this, in little-endian format,
    it will be read as `DDCCBBAAh` in a `DWORD` value. This endianness is common to
    Windows applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件或内存中的数据以小端格式呈现时，它将在`DWORD`值中读取为`DDCCBBAAh`。这种字节序在Windows应用程序中很常见。
- en: In the big-endian system, the same chunk of data will be read as `AABBCCDDh`.
    The advantage of using the big-endian form arises when reading streaming data
    such as file, serial, and network streams.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在大端系统中，相同的数据块将被读取为`AABBCCDDh`。使用大端格式的优势在于读取流式数据时，例如文件、串行数据和网络流。
- en: 'The advantage of reading in little-endian is that the address you read it from
    remains fixed, regardless of whether it is read as `BYTE`, `WORD`, or `DWORD`.
    For example, consider the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小端格式读取的优势在于，读取的地址保持固定，无论它是作为`BYTE`、`WORD`还是`DWORD`来读取。例如，考虑以下情况：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we attempt to read the data from address the `0x00000000`
    address. When read as `BYTE`, it will be `AAh`. When read as a `WORD`, it will
    be `AAh`. When read as a `DWORD`, it will be `AAh`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试从`0x00000000`地址读取数据。当以`BYTE`读取时，它将是`AAh`。当以`WORD`读取时，它将是`AAh`。当以`DWORD`读取时，它将是`AAh`。
- en: But when in big endian, when read as a `BYTE`, it will be `AAh`. When read as
    a `WORD`, it will be `AA00h`. When read as a `DWORD`, it will be `AA000000h`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但在大端格式中，当以`BYTE`读取时，它将是`AAh`。当以`WORD`读取时，它将是`AA00h`。当以`DWORD`读取时，它将是`AA000000h`。
- en: There are actually a lot more advantages over the other. Either of these can
    be used by an application depending on its purpose. In `x86` assembly, the little-endian
    format is the standard.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，相较于其他方式，这里有很多优势。这些方式中的任何一种都可以根据应用的目的使用。在`x86`汇编中，小端格式是标准。
- en: Basic instructions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本指令
- en: 'Assembly language is made up of direct lines of code that follow this syntax:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言由一行行的代码组成，遵循这种语法：
- en: '![](img/24fb4ebb-a025-441f-96ea-0233fbe2e22d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24fb4ebb-a025-441f-96ea-0233fbe2e22d.png)'
- en: The label is used to define the location of the instruction line. It is generally
    used during development of an assembly code without prior knowledge of the address
    where the code will be placed in the memory. Some debuggers are able to support
    having the user label addresses with a readable name. A mnemonic is a human readable
    instruction, such as MOV, ADD and SUB. Every mnemonic is represented by a byte
    number or a couple of bytes called an opcode. The operands are the instruction's
    arguments. This is normally read as `destination, source` . In the instruction
    shown above, the `eax` register is the destination and the doubleword data stored
    at address 0x0AD4194\. Finally, we can add comments to every instruction line
    of our program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 标签用于定义指令行的位置。它通常在没有事先知道代码将放置在哪个内存地址的情况下，在开发汇编代码时使用。一些调试器能够支持用户为地址添加可读的名称。助记符是人类可读的指令，例如
    MOV、ADD 和 SUB。每个助记符由一个或多个字节表示，称为操作码。操作数是指令的参数，通常按 `目标，源` 的顺序读取。在上面显示的指令中，`eax`
    寄存器是目标，而存储在地址 `0x0AD4194` 处的双字数据是源。最后，我们可以在程序的每条指令行中添加注释。
- en: In assembly language, code comments are denoted by a semicolon (;)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，代码注释用分号（;）表示。
- en: Opcode bytes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作码字节
- en: 'Every instruction has an equivalent opcode (operation code) byte:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令都有一个等效的操作码（操作代码）字节：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, the MOV instruction is equivalent to the `B8` opcode
    byte. The `MOV` instruction at the `00A92D81` address is equivalent to `B9`. The
    difference between the two `MOV` instructions is the register into which the `DWORD`
    value is moved. There are a total of 5 bytes consumed in `MOV EAX, 80000000h`.
    It consists of the opcode byte, `B8`, and the operand value, `80000000h`. The
    same number of bytes is also used in `MOV ECX, 2`, and `MUL ECX` uses 2 bytes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，MOV 指令等价于 `B8` 操作码字节。位于 `00A92D81` 地址的 `MOV` 指令等价于 `B9`。这两条 `MOV` 指令的区别在于它们将
    `DWORD` 值移入的寄存器不同。`MOV EAX, 80000000h` 总共消耗了 5 个字节，其中包括操作码字节 `B8` 和操作数值 `80000000h`。`MOV
    ECX, 2` 也使用了相同数量的字节，而 `MUL ECX` 使用了 2 个字节。
- en: '`MOV EAX, 80000000h` is located at `00A92D7ch`. Add 5 bytes (becomes `00A92D81`)
    and we get to the address of the next instruction. Viewing the code in the memory
    would look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOV EAX, 80000000h` 位于 `00A92D7ch`。加上 5 个字节（变为 `00A92D81`），我们就能找到下一个指令的地址。在内存中查看代码会像这样：'
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A dump of memory is usually shown in memory dumpers in paragraphs or 16 bytes
    per line and address aligned to `10h`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 内存转储通常以段落或每行 16 字节的方式显示在内存转储工具中，地址对齐为 `10h`。
- en: 'Assembly language instructions can be categorized as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言指令可以按以下类别划分：
- en: Copying and accessing data instructions (for example, MOV, LEA, and MOVB)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据复制和访问指令（例如，MOV、LEA 和 MOVB）
- en: Arithmetic instructions (for example, ADD, SUB, MUL, and DIV)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术指令（例如，ADD、SUB、MUL 和 DIV）
- en: Binary logic instructions (for example, XOR, NOT, SHR, and ROL)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制逻辑指令（例如，XOR、NOT、SHR 和 ROL）
- en: Flow control (for example, JMP, CALL, CMP, and INT)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程控制（例如，JMP、CALL、CMP 和 INT）
- en: Copying data
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据复制
- en: The MOV  instruction is used to move data. With this, data is moved either to
    or from a register or a memory address.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: MOV 指令用于移动数据。通过它，数据可以在寄存器和内存地址之间进行移动。
- en: '`mov eax, 0xaabbccdd`  places the `0xaabbccdd` value in the `eax` register.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov eax, 0xaabbccdd` 将 `0xaabbccdd` 的值放入 `eax` 寄存器。'
- en: '`mov eax, edx` places the data value from the`edx` register to the `eax `register.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov eax, edx` 将 `edx` 寄存器中的数据值放入 `eax` 寄存器。'
- en: 'Let''s take the following memory entries as an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下内存条目为例：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Reading data may require using directives to help the assembler. We use `byte
    ptr`, `word ptr`, or `dword ptr`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据可能需要使用指令来帮助汇编器。我们使用 `byte ptr`、`word ptr` 或 `dword ptr`：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The memory will look like this afterward:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 内存随后将如下所示：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: MOV and LEA
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MOV 和 LEA
- en: 'MOV is used to read the value at a given address, while LEA (Load Effective
    Address) is used to get the address instead:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: MOV 用于读取给定地址处的值，而 LEA（加载有效地址）则用于获取地址：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, how is the LEA instruction helpful if you can calculate the address by
    yourself? Let''s take the following C code as an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你自己可以计算地址，LEA 指令又有什么帮助呢？让我们以以下 C 代码为例：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The C code starts with defining `test[10]`, an array of `struct Test`, which
    contains two integers, `x` and `y`. The `for-loop` statement takes the value of
    `y` and the pointer address of `y` in a `struct test` element.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C 代码从定义 `test[10]` 开始，这是一个包含两个整数 `x` 和 `y` 的 `struct Test` 数组。`for` 循环语句取 `y`
    的值和 `y` 在 `struct test` 元素中的指针地址。
- en: 'Let''s say the base of the test array is in EBX, the `for-loop` counter, `i`,
    is in `ECX`, the integers are `DWORD` values, and so `struct Test` will contain
    two `DWORD` values. Knowing that a `DWORD` has 4 bytes, the equivalent of `value
    = test[i].y;` in assembly language will look like `mov edx, [ebx+ecx*8+4]`. Then,
    the equivalent of `p = &test[i].y;` in assembly language will look like `lea esi,
    [ebx+ecx*8+4]`. Indeed, without using LEA, the address can still be calculated
    with arithmetic instructions. However, calculating for the address could be done
    much more easily using LEA:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设测试数组的基址在EBX中，`for-loop`计数器`i`在`ECX`中，整数为`DWORD`类型，因此`struct Test`将包含两个`DWORD`值。知道`DWORD`有4个字节，那么`value
    = test[i].y;`在汇编语言中的等价代码将是`mov edx, [ebx+ecx*8+4]`。接着，`p = &test[i].y;`在汇编语言中的等价代码将是`lea
    esi, [ebx+ecx*8+4]`。实际上，即使不使用LEA，地址仍然可以通过算术指令进行计算。然而，使用LEA可以更加轻松地计算地址：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code shows that the six lines of code can be optimized to three
    lines using the LEA instruction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码显示，六行代码可以通过使用LEA指令优化为三行。
- en: Arithmetic operations
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算
- en: x86 instructions are based on the CISC architecture, where arithmetical instructions
    such as ADD, SUB, MUL, and DIV have a more low-level set of operations behind
    them. Arithmetical instructions work with the help of a set of flags that indicates
    certain conditions to be met during the operation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: x86指令基于CISC架构，其中像ADD、SUB、MUL和DIV这样的算术指令背后有一组更底层的操作。算术指令依赖一组标志来指示在操作过程中需要满足的特定条件。
- en: Addition and subtraction
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法与减法
- en: In addition (ADD) and subtraction (SUB), the OF, SF, and CF flags are affected.
    Let's see some examples of usage as instruction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在加法（ADD）和减法（SUB）中，`OF`、`SF`和`CF`标志会受到影响。我们来看一些指令的使用示例。
- en: '`add eax, ecx` adds whatever value is in the `ecx` register to the value in
    `eax`. The results of adding `eax` and `ecx` goes into `eax`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`add eax, ecx`将`ecx`寄存器中的值加到`eax`中的值，`eax`中存储的是`eax`和`ecx`相加的结果。'
- en: 'Let''s take the following example to see how it sets the OF, SF and CF flags:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来看它是如何设置`OF`、`SF`和`CF`标志的：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The registers are DWORDs. The `ecx` and `ebx` registers were set with `0x0fffffff`
    (‭268,435,455‬), adding these results to `0x1ffffffe` (‭536,870,910‬). SF was
    not set, since the result did not touch the most significant bit (MSB). CF was
    not set because the result is still within the capacity of a `DWORD`. Assuming
    that both were signed numbers, the result is still within the capacity of a signed
    `DWORD` number:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是DWORD类型。`ecx`和`ebx`寄存器被设置为`0x0fffffff`（‭268,435,455‬），将这些结果加上`0x1ffffffe`（‭536,870,910‬）。由于结果没有触及最高有效位（MSB），`SF`标志没有被设置。由于结果仍然在`DWORD`的范围内，`CF`标志没有被设置。假设这两个数是有符号数，结果仍然在有符号`DWORD`的范围内：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result in `ecx` becomes `0xfffffffe` (`-2`). `CF = 0`; `SF = 1`; `OF = 1`.
    Assuming that both `ecx` and `ebx` were unsigned, the CF flag will not be set.
    Assuming that both `ecx` and `ebx` were signed numbers and both are positive numbers,
    the `OF` flag will be set. And since the most significant bit becomes `1`, the
    `SF` flag is also set.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecx`中的结果变为`0xfffffffe`（`-2`）。`CF = 0`；`SF = 1`；`OF = 1`。假设`ecx`和`ebx`都是无符号数，`CF`标志不会被设置。假设`ecx`和`ebx`都是有符号数且都是正数，则`OF`标志会被设置。由于最高有效位变为`1`，`SF`标志也被设置。'
- en: 'Now, how about adding two negative numbers? Let''s consider the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，两个负数相加会怎么样呢？我们来考虑以下示例：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Basically, we're adding both `ecx` and `ebx`, containing `0x80000000` (-2,147,483,648),
    the result of which becomes zero (0). `CF = 1`; `SF = 0`; `OF = 1`. The SF flag
    was not set since the `MSB` of the result is 0\. Adding both MSB of ecx and ebx
    will definitely exceed the capacity of a `DWORD` value. At the signed number perspective,
    the OF flag is also set, since adding both negative values exceeds the signed
    `DWORD` capacity.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在将`ecx`和`ebx`相加，这两个寄存器的值为`0x80000000`（-2,147,483,648），结果变为零（0）。`CF =
    1`；`SF = 0`；`OF = 1`。由于结果的最高有效位（MSB）是0，因此`SF`标志没有被设置。将`ecx`和`ebx`的最高有效位相加肯定会超出`DWORD`值的容量。从有符号数的角度来看，由于将两个负值相加超出了有符号`DWORD`的容量，`OF`标志也被设置。
- en: 'Let''s try the borrow concept in this next example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个示例中尝试借位概念：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What happens here is that we are subtracting `0x80000000` (-2,147,483,648) from
    `0x7fffffff` (‭2,147,483,647‬). In fact, what we are expecting is the sum of 2,147,483,648
    and 2,147,483,647\. The result in `ecx` becomes `0xffffffff` (-1). CF = 1; SF
    = 1; OF = 1\. Remember that we are doing a subtraction operation, thereby causing
    CF to be set, due to borrowing. The same goes for the OF flag.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，我们正在从 `0x7fffffff` (‭2,147,483,647‬) 中减去 `0x80000000` (-2,147,483,648)。事实上，我们期望的是
    2,147,483,648 和 2,147,483,647 的和。`ecx` 中的结果变为 `0xffffffff` (-1)。CF = 1；SF = 1；OF
    = 1。记住，我们正在执行一个减法操作，因此由于借位，CF 会被置为 1。OF 标志也是如此。
- en: Increment and decrement instructions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加和减少指令
- en: 'The INC instruction simply adds 1, while DEC subtracts 1\. The following code
    results in `eax` becoming zero (0):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: INC 指令简单地加 1，而 DEC 减去 1。以下代码将导致 `eax` 变为零 (0)：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code results in `eax` becoming `0xffffffff`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将导致 `eax` 变为 `0xffffffff`：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Multiplication and division instructions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法和除法指令
- en: 'MUL is used for multiplication and DIV for division. In multiplication, we
    expect that multiplying values would exceed the capacity of the register value.
    Hence the product is stored in AX, `DX:AX` or `EDX:EAX` (long or `QWORD`):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: MUL 用于乘法，DIV 用于除法。在乘法中，我们期望乘积的值超出寄存器的容量。因此，乘积将存储在 AX，`DX:AX` 或 `EDX:EAX`（长整型或
    `QWORD`）中：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The product stored in eax is zero (0), and `edx` now contains `0x00000001`.
    `SF =0`; `CF = 1`; and `OF = 1`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 eax 中的乘积为零 (0)，而 `edx` 现在包含 `0x00000001`。`SF =0`；`CF = 1`；`OF = 1`。
- en: For division, the dividend is placed in `AX`, `DX:AX`, or `EDX:EAX`, and after
    the division operation, the quotient is placed in `AL`, `AX`, or `EAX`. The remainder
    is stored in `AH`, `DX`, or `EDX`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除法，被除数放入 `AX`，`DX:AX` 或 `EDX:EAX` 中，除法操作后，商放入 `AL`，`AX` 或 `EAX` 中。余数存储在 `AH`，`DX`
    或 `EDX` 中。
- en: Other signed operations
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有符号操作
- en: '**NEG**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**NEG**'
- en: This operation does a two's complement.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作执行二进制补码操作。
- en: Consider the following as an example: `NEG EAX` or `NEG dword ptr [00403000]`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例：`NEG EAX` 或 `NEG dword ptr [00403000]`。
- en: If `EAX` were `01h`, it becomes `FFFFFFFFh` (-1).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `EAX` 为 `01h`，它将变为 `FFFFFFFFh` (-1)。
- en: '**MOVSX**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**MOVSX**'
- en: This moves a `BYTE` to WORD or WORD to `DWORD`, including the sign. It is a
    more flexible instruction than CBW, CWDE, CWD, since it accommodates operands.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将 `BYTE` 移动到 WORD 或将 WORD 移动到 `DWORD`，并包括符号。它比 CBW、CWDE、CWD 更灵活，因为它能容纳更多操作数。
- en: Consider the following as an example: `MOVSX EAX, BX`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例：`MOVSX EAX, BX`。
- en: If BX were `FFFFh` (-1) and the sign flag is set, EAX will be `FFFFFFFFh` (-1).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 BX 为 `FFFFh` (-1) 且符号标志被设置，则 EAX 将为 `FFFFFFFFh` (-1)。
- en: '**CBW**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**CBW**'
- en: Similar to MOVSX, it converts a `BYTE` into `WORD`, including the sign. The
    affected register is AL and AX. This is an instruction without any operands and
    is similar to MOVSX.  The effect turns the byte AL extend to its word counterpart,
    AX.   Such conversion is dentoed with a "->" sign.  For example,  `AL -> AX` means
    we are extending the 8-bit number to a 16-bit without compromising the stored
    value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 MOVSX，它将 `BYTE` 转换为 `WORD`，包括符号。受影响的寄存器是 AL 和 AX。这是一条不带操作数的指令，类似于 MOVSX。其效果是将字节
    AL 扩展为其对应的字（AX）。这种转换用“->”符号表示。例如，`AL -> AX` 表示我们将 8 位数字扩展为 16 位而不改变存储的值。
- en: If AL were `FFh` (-1), AX will be `FFFFh` (-1).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AL 为 `FFh` (-1)，则 AX 将变为 `FFFFh` (-1)。
- en: '**CWDE**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**CWDE**'
- en: This is similar to CBW, but converts a `WORD` into `DWORD`. It affects `AX->EAX`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 CBW 类似，但将 `WORD` 转换为 `DWORD`。它影响 `AX->EAX`。
- en: '**CWD**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**CWD**'
- en: This is similar to CBW, but converts a `WORD` into `DWORD`. It affects `AX->
    DX:AX`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 CBW 类似，但将 `WORD` 转换为 `DWORD`。它影响 `AX-> DX:AX`。
- en: '**IMUL/IDIV**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**IMUL/IDIV**'
- en: This performs MUL and DIV, but accepts operands from other registers or memory.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行 MUL 和 DIV，但接受来自其他寄存器或内存的操作数。
- en: Bitwise algebra
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算代数
- en: Boolean algebra or bitwise operations are necessary in low-level programming
    since it can perform simple calculations by changing the bits of a number. It
    is commonly used in cryptography's obfuscation and decoding.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数或位运算在底层编程中是必要的，因为它可以通过改变数字的位来执行简单的计算。它通常用于加密中的混淆和解码。
- en: '**NOT**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOT**'
- en: This operation reverses the bits.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作会反转位。
- en: 'Consider the following as an example: `NOT AL`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例：`NOT AL`
- en: If AL equals `1010101b` (`55h`), it becomes `10101010b` (`AAh`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AL 等于 `1010101b` (`55h`)，它将变为 `10101010b` (`AAh`)。
- en: '**AND**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**AND**'
- en: This operation sets `bit` to `1` if both are `1`s, otherwise it sets `bit` to
    `0`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作如果两个值都是 `1`，则将 `bit` 设置为 `1`，否则将 `bit` 设置为 `0`。
- en: 'Consider the following as an example: `AND AL, AH`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例：`AND AL, AH`
- en: If AL equals `10111010b` (`BAh`) and AH equals `11101101b` (`EDh`), AL becomes
    `10101000b` (`A8h`).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AL 等于 `10111010b`（`BAh`）且 AH 等于 `11101101b`（`EDh`），则 AL 变为 `10101000b`（`A8h`）。
- en: '**OR**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**OR**'
- en: This operation sets `bit` to `0` if both are `0`s, else it sets `bit` to `1`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作如果两个比特都是 `0`，则将比特设置为 `0`，否则将比特设置为 `1`。
- en: Consider the following as an example: `OR AL, AH`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为例：`OR AL, AH`
- en: If AL equals `10111010b` (`BAh`) and AH equals `11101100b` (`ECh`), AL becomes
    `11111110b` (`FEh`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AL 等于 `10111010b`（`BAh`）且 AH 等于 `11101100b`（`ECh`），则 AL 变为 `11111110b`（`FEh`）。
- en: '**XOR**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**XOR**'
- en: This operation sets bit to `0` if both bits are equal, else it sets bit to `1`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作如果两个比特相等，则将比特设置为 `0`，否则设置为 `1`。
- en: Consider the following as an example: `XOR EAX, EAX`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为例：`XOR EAX, EAX`
- en: 'XOR-ing the same value will become `0`. Thus `EAX` becomes `0`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对相同的值进行 XOR 操作将结果变为 `0`。因此，`EAX` 变为 `0`：
- en: '`XOR AH, AL`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`XOR AH, AL`'
- en: If AH were `100010b` (`22h`) and AL were `1101011b` (`6Bh`), AH becomes `1001001b`
    (`49h`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AH 为 `100010b`（`22h`）且 AL 为 `1101011b`（`6Bh`），则 AH 变为 `1001001b`（`49h`）。
- en: '**SHL/SAL**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHL/SAL**'
- en: This operation shifts bits to the left.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作将位向左移动。
- en: Consider the following as an example: `SHL AL, 3`
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为例：`SHL AL, 3`
- en: If `AL` were `11011101b` (`DDh`), shifting it to the left by `3` makes AL equal
    to `11101000b` (`E8h`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `AL` 为 `11011101b`（`DDh`），将其向左移动 `3` 位后，AL 等于 `11101000b`（`E8h`）。
- en: '**SHR/SAR**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**SHR/SAR**'
- en: This operation shifts bits to the right.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作将位向右移动。
- en: Consider the following as an example: `SHR AL, 3`
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为例：`SHR AL, 3`
- en: If `AL` were `11011101b` (`DDh`), shifting it to the right by `3` makes AL equal
    to `011011b` (`1Bh`).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `AL` 为 `11011101b`（`DDh`），将其向右移动 `3` 位后，AL 等于 `011011b`（`1Bh`）。
- en: '**ROL**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROL**'
- en: This operation rotates bits to the left.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作将位向左旋转。
- en: Consider the following as an example: `ROL AL, 3`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为例：`ROL AL, 3`
- en: if `AL` were `11011101b` (`DDh`), rotating it to the left by `3` makes AL equal
    to `11101110b` (`EEh`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `AL` 为 `11011101b`（`DDh`），将其向左旋转 `3` 位后，AL 等于 `11101110b`（`EEh`）。
- en: '**ROR**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROR**'
- en: This operation rotates bits to the right.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作将位向右旋转。
- en: Consider the following as an example: `ROR AL, 3`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为例：`ROR AL, 3`
- en: If `AL` were `11011101b` (`DDh`), rotating it to the right by `3` makes AL equal
    to `10111011b` (`BBh`).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `AL` 为 `11011101b`（`DDh`），将其向右旋转 `3` 位后，AL 等于 `10111011b`（`BBh`）。
- en: Control flow
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: The beauty of a program is that we can carry out a number of different behaviors
    based on condition and state. For example, we can make a certain task repeat until
    a counter reaches a defined maximum. In C programming, the program's flow is controlled
    by instructions such as the `if-then-else` and `for-loop` statements. The following
    are common instructions used in assembly language, in conjunction with program
    control flow. The affected register in this is the index pointer IP/EIP, which
    holds the current address where the next instruction to execute is located.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的美妙之处在于，我们可以根据条件和状态执行多种不同的行为。例如，我们可以让某个任务重复执行，直到计数器达到定义的最大值。在 C 语言编程中，程序的流控制由诸如
    `if-then-else` 和 `for-loop` 语句来实现。以下是汇编语言中常用的控制流指令，结合程序控制流使用。受影响的寄存器是索引指针 IP/EIP，它保存当前地址，指向下一条待执行的指令。
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Short for jump, this means that the operand is an address that it will go to.
    It sets the EIP to the next instruction line. There are two main variations for
    the address: direct and indirect.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转的简写，表示操作数是它将跳转到的地址。它将 EIP 设置为下一条指令行。地址有两种主要的变体：直接和间接。
- en: A `JMP` using a direct address would literally jump to the given address. Consider
    as an example: `JMP  00401000`. This will set the `EIP` to `00401000h`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接地址的 `JMP` 将字面意义地跳转到给定的地址。例如，考虑 `JMP 00401000`。这将把 `EIP` 设置为 `00401000h`。
- en: 'A `JMP` using an indirect address would jump to an address that can only be
    known when the jump is executed. The address has to be retrieved or calculated
    somehow prior to the `JMP` instruction. Here are some examples:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用间接地址的 `JMP` 指令将跳转到一个只能在跳转执行时才能知道的地址。该地址必须在 `JMP` 指令之前通过某种方式获取或计算。以下是一些示例：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**CALL and RET**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**CALL 和 RET**'
- en: 'Similar to `JMP`, this goes to the address stated in the operand, but stores
    the address of the next instruction to the stack after the CALL instruction. The
    address is stored in the stack and will be used by the `RET` instruction later
    to point `EIP` back to it. For example, consider the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `JMP`，这将跳转到操作数中声明的地址，但在 `CALL` 指令执行后，将下一条指令的地址存储到堆栈中。该地址存储在堆栈中，稍后由 `RET`
    指令使用，以将 `EIP` 指向该地址。例如，考虑以下情况：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the CALL happens at the address `00401000`, the top of the stack will contain
    the value `00401005h`, which will be the return address. The code passes it to
    the instruction at the address `00401100`, where `EAX` is set to `F00bF00Bh`.
    Then the `RET` instruction retrieves the return address from the top of the stack
    and sets the EIP.  A subroutine or procedure is the term used for the lines of
    instructions from the call.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用发生在地址`00401000`时，堆栈顶部将包含值`00401005h`，这是返回地址。代码将它传递给地址`00401100`处的指令，在那里`EAX`被设置为`F00bF00Bh`。然后，`RET`指令从堆栈顶部获取返回地址并设置
    EIP。子程序或过程是指从调用到返回地址的指令序列。
- en: The `RET` instruction can optionally have an operand. The operand is the number
    of stack `DWORDs` it will release before retrieving the return address. This is
    useful when the stack is used within the subroutine as it serves as a cleanup
    of the used stack.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`RET`指令可以选择带有一个操作数。操作数是它在获取返回地址之前将释放的堆栈`DWORD`的数量。当堆栈在子程序中被使用时，这非常有用，因为它作为清理已用堆栈的操作。'
- en: '**Conditional jumps**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件跳转**'
- en: 'These are jumps that depend on the flags and the counter register:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是依赖于标志位和计数器寄存器的跳转指令：
- en: '| **Instruction** | **Flags** | **Description** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **标志位** | **描述** |'
- en: '| `JZ/JE` | ZF = 1 | Jump if zero/Jump if equal |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `JZ/JE` | ZF = 1 | 如果为零/如果相等，则跳转 |'
- en: '| `JNZ/JNE` | ZF = 0 | Jump if not zero/Jump if not equal |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `JNZ/JNE` | ZF = 0 | 如果不为零/如果不相等，则跳转 |'
- en: '| `JS` | SF = 1 | Jump if sign |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `JS` | SF = 1 | 如果符号位为1，则跳转 |'
- en: '| `JNS` | SF = 0 | Jump if not sign |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `JNS` | SF = 0 | 如果没有符号位，则跳转 |'
- en: '| `JC/JB/JNAE` | CF = 1 | Jump if carry/Jump if below/Jump if not above or
    equal |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `JC/JB/JNAE` | CF = 1 | 如果有进位/如果小于/如果不大于或等于，则跳转 |'
- en: '| `JNC/JNB/JAE` | CF = 0 | Jump if not carry/jump if not below/Jump if above
    or equal |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `JNC/JNB/JAE` | CF = 0 | 如果没有进位/如果不小于/如果大于或等于，则跳转 |'
- en: '| `JO` | OF = 1 | Jump if overflow |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `JO` | OF = 1 | 如果溢出，则跳转 |'
- en: '| `JNO` | OF = 0 | Jump if not overflow |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `JNO` | OF = 0 | 如果没有溢出，则跳转 |'
- en: '| `JA/JNBE` | CF = 0 and ZF = 0 | Jump if above/Jump if not below or equal
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `JA/JNBE` | CF = 0 且 ZF = 0 | 如果大于/如果不小于或等于，则跳转 |'
- en: '| `JNA/JBE` | CF = 1 or ZF = 1 | Jump if not above/Jump if below or equal |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `JNA/JBE` | CF = 1 或 ZF = 1 | 如果不大于/如果小于或等于，则跳转 |'
- en: '| `JG/JNLE` | ZF = 0 and SF = OF | Jump if greater/Jump if not less or equal
    |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `JG/JNLE` | ZF = 0 且 SF = OF | 如果大于/如果不小于或等于，则跳转 |'
- en: '| `JNG/JLE` | ZF = 1 or SF != OF | Jump if not greater/Jump if less or equal
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `JNG/JLE` | ZF = 1 或 SF != OF | 如果不大于/如果小于或等于，则跳转 |'
- en: '| `JL/JNGE` | SF != OF | Jump if less/Jump if not greater or equal |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `JL/JNGE` | SF != OF | 如果小于/如果不大于或等于，则跳转 |'
- en: '| `JNL/JGE` | SF = OF | Jump if not less/Jump if greater or equal |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `JNL/JGE` | SF = OF | 如果不小于/如果大于或等于，则跳转 |'
- en: '| `JP/JPE` | PF = 1 | Jump if parity/Jump if parity is even |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `JP/JPE` | PF = 1 | 如果有奇偶校验/如果偶校验为真，则跳转 |'
- en: '| `JNP/JPO` | PF = 0 | Jump if not parity/Jump if parity is odd |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `JNP/JPO` | PF = 0 | 如果没有奇偶校验/如果奇偶校验为假，则跳转 |'
- en: '| `JCXZ` | CX = 0 | Jump if CX is zero. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `JCXZ` | CX = 0 | 如果 CX 为零，则跳转。 |'
- en: '| `JECXZ` | ECX = 0 | Jump if ECX is zero. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `JECXZ` | ECX = 0 | 如果 ECX 为零，则跳转。 |'
- en: '| `LOOP` | ECX > 0 | Jump if ECX is not zero. Decrements ECX. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `LOOP` | ECX > 0 | 如果 ECX 不为零，则跳转。减少 ECX。 |'
- en: '| `LOOPE` | ECX > 0 and ZF = 1 | Jump if ECX is not zero and zero flag is set.
    Decrements ECX. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `LOOPE` | ECX > 0 且 ZF = 1 | 如果 ECX 不为零且零标志设置，则跳转。减少 ECX。 |'
- en: '| `LOOPNE` | ECX > 0 and ZF = 0 | Jump if ECX is not zero and zero flag is
    not set. Decrements ECX. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `LOOPNE` | ECX > 0 且 ZF = 0 | 如果 ECX 不为零且零标志未设置，则跳转。减少 ECX。 |'
- en: '**Flagging instructions**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**标志设置指令**'
- en: Besides the arithmetic, bit-wise operations, interrupts, and return values from
    functions, these instructions are also able to set flags.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术、位操作、外部中断和函数返回值之外，这些指令还可以设置标志位。
- en: '**CMP** performs a SUB instruction on the first and second operands, but does
    not modify the registers or the immediate value. It only affects the flags.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**CMP**执行一个 SUB 指令，在第一个和第二个操作数上，但不修改寄存器或立即数。它只会影响标志位。'
- en: '**TEST** performs an AND instruction on the first and second operands, but
    does not modify the registers or the immediate value. It only affects the flags.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**TEST**对第一个和第二个操作数执行 AND 指令，但不修改寄存器或立即数。它只会影响标志位。'
- en: Stack manipulation
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈操作
- en: 'The stack is a memory space where data is temporarily stored. Adding and removing
    data in the stack is in a first-in-last-out method. Subroutines compiled from
    programs in C initially allocate space in the stack, called a stack frame, for
    its uninitialized variables. The address of the top of the stack is stored in
    the ESP register:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个临时存储数据的内存空间。栈中数据的添加和移除遵循先进后出的原则。由C程序编译的子程序最初会在栈中分配空间，称为栈帧，用于其未初始化的变量。栈顶的地址存储在ESP寄存器中：
- en: '![](img/2c2c1b04-c690-41f9-972c-bdc59768bcbf.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c2c1b04-c690-41f9-972c-bdc59768bcbf.png)'
- en: 'The stack is controlled by two common instructions: `PUSH` and `POP`.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 栈由两个常见指令控制：`PUSH`和`POP`。
- en: '**PUSH** decreases the top-of-stack address by a `DWORD` size, for a 32-bit
    address space, then stores the value from its operand.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUSH** 将栈顶地址减小`DWORD`大小，在32位地址空间中，然后存储其操作数的值。'
- en: 'Consider the following as an example: `PUSH 1`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，请考虑以下内容：`PUSH 1`
- en: If the top of the stack, stored in ESP, is at address `002FFFFCh`, then the
    ESP becomes `002FFFF8h` and stores `1` at the new ESP address.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈顶地址（存储在ESP中）为地址`002FFFFCh`，则ESP变为`002FFFF8h`，并将`1`存储到新的ESP地址。
- en: '**POP** retrieves the value from the top of the stack (ESP) then stores it
    to the register or memory space indicated in the operand. Then ESP is increased
    by a `DWORD` size.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**POP** 从栈顶（ESP）检索值，然后将其存储到操作数指示的寄存器或内存空间中。随后，ESP增加`DWORD`大小。'
- en: Consider the following as an example: `POP EAX`
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，请考虑以下内容：`POP EAX`
- en: If the address of the top of the stack, stored in ESP, is at address `002FFFF8h`,
    and the stored `DWORD` value at the top of the stack is `0xDEADBEEF`, then `0xDEADBEEF`
    will be stored in `EAX`, while ESP becomes `002FFFFCh`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈顶地址（存储在ESP中）为地址`002FFFF8h`，并且栈顶存储的`DWORD`值为`0xDEADBEEF`，那么`0xDEADBEEF`将被存储到`EAX`寄存器中，而ESP变为`002FFFFCh`。
- en: '**PUSHA/PUSHAD** both push all the general purpose registers to the stack in
    this order (for 32-bit builds): `EAX`, `ECX`, `EDX`, `EBX`, `EBP`, `ESP`, `EBP`,
    `ESI`, and `EDI`. `PUSHA` is intended for 16-bit operands, while `PUSHAD` is for
    32-bit operands. However, both may be synonymous to each other, adapting to the
    current operand size.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUSHA/PUSHAD** 都会将所有通用寄存器按此顺序压入栈中（适用于32位构建）：`EAX`、`ECX`、`EDX`、`EBX`、`EBP`、`ESP`、`EBP`、`ESI`
    和 `EDI`。`PUSHA`适用于16位操作数，而`PUSHAD`适用于32位操作数。不过，二者可能是同义的，取决于当前的操作数大小。'
- en: '**POPA/POPAD** both pop all the general purpose registers from the stack and
    retrieved in a reverse order as stored by `PUSHA`/`PUSHAD`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**POPA/POPAD** 都将所有通用寄存器从栈中弹出，并按与`PUSHA`/`PUSHAD`存储顺序的相反顺序恢复。'
- en: '**PUSHF** pushes the `EFLAGS` to stack.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUSHF** 将`EFLAGS`压入栈中。'
- en: '**POPF** pops the `EFLAGS` from stack.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**POPF** 将`EFLAGS`从栈中弹出。'
- en: '**ENTER** is commonly used at the start of a subroutine. It is used to create
    a stack frame for the subroutine. Internally, `ENTER 8,0` may roughly be equivalent
    to the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**ENTER** 通常用于子程序的开始。它用于为子程序创建栈帧。从内部来看，`ENTER 8,0`可能大致等同于以下操作：'
- en: '[PRE38]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`LEAVE`is used to reverse what the `ENTER` instruction did eventually destroying
    the stack frame created.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`LEAVE`用于撤销`ENTER`指令的操作，最终销毁创建的栈帧。'
- en: Tools – builder and debugger
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具 – 构建器和调试器
- en: Before we proceed with more instructions, it would be best to try actually programming
    with assembly language. The tools we will need are a text editor, the assembly
    code builder, and the debugger.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续更多指令之前，最好尝试一下实际使用汇编语言编程。我们需要的工具是文本编辑器、汇编代码构建器和调试器。
- en: Popular assemblers
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行的汇编器
- en: All programming languages need to be built to become an executable on the system
    platform that the program was built for. Unless you want to enter each opcode
    byte in a binary file, developers have made tools to convert that source code
    to an executable that contains code that the machine can understand. Let's take
    a look at some of the most popular assembly language builders today.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都需要被构建成可执行文件，以便在程序构建所针对的系统平台上运行。除非你想手动输入每个操作码字节到二进制文件中，开发者们已经制作了工具，将源代码转换为机器可以理解的可执行文件。让我们来看一下目前最流行的汇编语言构建器。
- en: MASM
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MASM
- en: Also known as Microsoft Macro Assembler, MASM has been around for more than
    30 years. It is maintained by Microsoft and is part of the Visual Studio product.
    It was developed for compiling x86 source code to executable code.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 也叫做微软宏汇编器（Microsoft Macro Assembler），MASM已经存在超过30年。它由微软维护，是Visual Studio产品的一部分。MASM用于将x86源代码编译成可执行代码。
- en: 'Compiling takes two steps: compiling the source into an object file, then linking
    all necessary modules required by the object file into a single executable.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 编译分为两个步骤：将源代码编译成目标文件，然后将目标文件所需的所有模块链接成一个单独的可执行文件。
- en: '![](img/05a5158f-4a56-4937-b53b-d8679d4349f3.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05a5158f-4a56-4937-b53b-d8679d4349f3.png)'
- en: 'The MASM package comes along with a text editor that has the menu containing
    the compiler and linker to build the source as an executable. This comes very
    handy as there is no need to go to the command line to run the compiler and linker
    to build the executable. A simple "`Console Build All`" command on the following
    source generates an executable that can be run in the command terminal:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 套件自带一个文本编辑器，菜单中包含编译器和链接器，用于将源代码构建为可执行文件。这非常方便，因为不需要通过命令行运行编译器和链接器来构建可执行文件。只需在以下源代码上执行
    "`Console Build All`" 命令，即可生成一个可以在命令终端中运行的可执行文件：
- en: '![](img/7f6bf1c8-9526-49ca-8ba6-f9fa3530185f.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f6bf1c8-9526-49ca-8ba6-f9fa3530185f.png)'
- en: MASM can be downloaded from [http://www.masm32.com/](http://www.masm32.com/).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 可以从 [http://www.masm32.com/](http://www.masm32.com/) 下载。
- en: NASM
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NASM
- en: '**NASM** is the abbreviation of **Netwide Assembler**. NASM is very similar
    to MASM with slight differences between its syntax, directives, and variable declaration.
    A great thing about NASM is that sectioning of code and data is easily identified:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**NASM** 是 **Netwide Assembler** 的缩写。NASM 与 MASM 非常相似，主要在语法、指令和变量声明上有些许不同。NASM
    的一个优点是代码和数据的分段非常容易识别：'
- en: '![](img/5b418ac9-d780-473b-839b-f2da606d8f7c.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b418ac9-d780-473b-839b-f2da606d8f7c.png)'
- en: 'Both MASM and NASM also require compiling and linking to build the executable:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 和 NASM 也都需要编译和链接来构建可执行文件：
- en: '![](img/3e1eb06b-897f-465c-bb71-92cd4a60f41b.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e1eb06b-897f-465c-bb71-92cd4a60f41b.png)'
- en: However, unlike MASM, the installer package does not have its own editor. NASM
    is very popular in the Linux community due to its development as opensource software.
    The package contains only the compiler for the object file; you'll have to download
    a GCC  compiler to generate the executable.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 MASM 不同，NASM 的安装包没有自带编辑器。NASM 在 Linux 社区非常受欢迎，因为它作为开源软件进行开发。该包仅包含用于目标文件的编译器；你需要下载
    GCC 编译器来生成可执行文件。
- en: The official website for downloading NASM is at [https://www.nasm.us/](https://www.nasm.us/).
    For Windows, MinGW ([http://www.mingw.org/](http://www.mingw.org/)) can be used
    to generate the executable.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 NASM 的官方网站是 [https://www.nasm.us/](https://www.nasm.us/)。对于 Windows，可以使用
    MinGW ([http://www.mingw.org/](http://www.mingw.org/)) 来生成可执行文件。
- en: FASM
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FASM
- en: 'FASM, or Flat Assembler, is similar MASM and NASM. Like MASM, it has its own
    source editor. Like NASM, the sections are easily identifiable and configured,
    and the software comes in flavors for both Windows and Linux:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: FASM 或 Flat Assembler 类似于 MASM 和 NASM。像 MASM 一样，它有自己的源代码编辑器；像 NASM 一样，代码段易于识别和配置，并且该软件有适用于
    Windows 和 Linux 的版本：
- en: '![](img/bb02f798-7ebf-42d1-9582-61ae313a338d.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb02f798-7ebf-42d1-9582-61ae313a338d.png)'
- en: FASM can be downloaded from [http://flatassembler.net/](http://flatassembler.net/).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: FASM 可以从 [http://flatassembler.net/](http://flatassembler.net/) 下载。
- en: In our assembly language programming, we will use FASM, since we can use its
    editor in both Windows and Linux.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的汇编语言编程中，我们将使用 FASM，因为我们可以在 Windows 和 Linux 上使用它的编辑器。
- en: x86 Debuggers
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86 调试器
- en: Debuggers are program developers' tools for tracing through their code.  These
    tools are used to validate that the program  follows the expected behavior.  With
    a debugger, we can trace our code line per line.  We get to see every instruction
    in action as it make changes to the registers and data stored in the memory. 
    In reversing, debuggers are used to analyze programs at its low-level. With what
    we learned about assembly language, the target compiled program, and a debugger,
    we are able to do reverse engineering.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是程序开发者用于跟踪代码的工具。这些工具用于验证程序是否按照预期的行为执行。通过调试器，我们可以逐行跟踪代码，看到每条指令的执行情况，以及它如何更改寄存器和存储在内存中的数据。在逆向工程中，调试器用于分析程序的低级细节。通过我们对汇编语言、目标编译程序和调试器的了解，我们能够进行逆向工程。
- en: Besides the tools introduced in this book,  there are a lot of tools available
    in the internet that may have more or less features.  The point is that reverse
    engineering rely on the tools and we need to keep ourselves updated with the latest
    tool. Feel free to download other tools that you want to explore and see which
    one makes your reversing feel more comfortable.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本书介绍的工具外，互联网上还有许多工具，它们可能有更多或更少的功能。关键是逆向工程依赖于工具，我们需要保持自己对最新工具的了解。随意下载其他你想探索的工具，看看哪个工具让你的逆向过程更舒适。
- en: WinDbg
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinDbg
- en: Developed by Microsoft to perform debugging on Microsoft Windows, `WinDbg` is
    a powerful tool that can debug in user and kernel mode. It can load memory dumps
    and crash dumps caused by errors flagged by Windows itself. In kernel mode, it
    can be used to remotely debug a device driver or a Windows operating system. It
    can load symbol files linked to the program that aid the developer or analyst
    in identifying the proper library function format and other information.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinDbg`是由微软开发的用于在Microsoft Windows上进行调试的强大工具，支持在用户模式和内核模式下调试。它可以加载内存转储和由于Windows自身错误标记的崩溃转储。在内核模式下，它可以远程调试设备驱动程序或Windows操作系统。它可以加载与程序关联的符号文件，帮助开发人员或分析师识别正确的库函数格式及其他信息。'
- en: '`WinDbg` has a graphical user interface, and by default, shows a command box
    where you can type in and enter commands. You can add a set of information windows
    and dock them. It can show the disassembly, registers and flags, the stack (using
    the memory dump window), and a memory dump of whichever address entered:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinDbg`有一个图形用户界面，默认情况下显示一个命令框，你可以在其中输入并执行命令。你可以添加一组信息窗口并将其停靠。它可以显示反汇编、寄存器和标志、堆栈（使用内存转储窗口），以及输入的任何地址的内存转储：'
- en: '![](img/5dbd1ab2-e79e-4484-8ad7-e06a7c380859.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dbd1ab2-e79e-4484-8ad7-e06a7c380859.png)'
- en: '`Windbg` can be downloaded from [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Windbg`可以从[https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/.)'
- en: Ollydebug
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ollydebug
- en: 'This is the most popular debugger on the x86 32-bit Windows platform due to
    its lightweight package file size. Its default interface shows the important information
    needed by a reverse engineer: a disassembly view where tracing happens; registers
    and flags panes; and the stack and memory views.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在x86 32位Windows平台上最流行的调试器，因为它的包文件非常轻量。其默认界面显示了逆向工程师需要的重要信息：一个反汇编视图，用于跟踪；寄存器和标志窗格；以及堆栈和内存视图。
- en: '![](img/e2ddfff3-b669-4358-ad27-c87246f0c788.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2ddfff3-b669-4358-ad27-c87246f0c788.png)'
- en: OllyDebug can be downloaded from [http://www.ollydbg.de/](http://www.ollydbg.de/).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDebug可以从[http://www.ollydbg.de/](http://www.ollydbg.de/)下载。
- en: x64dbg
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x64dbg
- en: This debugger is most recommended as the developers keep this up-to-date, working
    with the community. It also supports both 64- and 32-bit Windows platforms with
    a lot of useful plugins available. It has a similar interface as Ollydebug.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调试器最为推荐，因为开发者保持它的更新，并与社区合作。它也支持64位和32位Windows平台，并提供许多有用的插件。它的界面与Ollydebug类似。
- en: '![](img/8ef58c36-fd12-42e1-bd98-7400c929b7e8.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ef58c36-fd12-42e1-bd98-7400c929b7e8.png)'
- en: '`x64dbg` can be downloaded from [https://x64dbg.com/](https://x64dbg.com/).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`x64dbg`可以从[https://x64dbg.com/](https://x64dbg.com/)下载。'
- en: Hello World
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: We are going to use `FASM` for building our first assembly language program.
    And we will debug the executable using `x64dbg`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`FASM`来构建我们的第一个汇编语言程序。然后我们将使用`x64dbg`调试该可执行文件。
- en: Installation of FASM
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装FASM
- en: Using our Windows setup, download FASM from [http://flatassembler.net/](http://flatassembler.net/),
    [then extract FASM into a folder of your choice:](http://flatassembler.net/)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的Windows设置，从[http://flatassembler.net/](http://flatassembler.net/)下载FASM，[然后将FASM解压到你选择的文件夹中：](http://flatassembler.net/)
- en: '![](img/874ec904-69c3-461e-bc2b-6fb260e5f8d8.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/874ec904-69c3-461e-bc2b-6fb260e5f8d8.png)'
- en: Run `FASMW.EXE` to bring up the `FASM` GUI.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`FASMW.EXE`来启动`FASM`图形界面。
- en: It works!
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它可以工作！
- en: In your text editor, write down the following code, or you can simply do a Git
    clone of the data at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中写下以下代码，或者你可以直接从[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/fasmhello.asm)做Git克隆。
- en: '[PRE39]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Save it by clicking on File->Save as..., then click on Run->Compile:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“文件”->“另存为...”，然后点击“运行”->“编译”来保存：
- en: '![](img/fd0bc3e2-c137-493b-923b-2fe735592745.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0bc3e2-c137-493b-923b-2fe735592745.png)'
- en: 'The executable file will be located where the source was saved:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件将位于源文件保存的位置：
- en: '![](img/033636a3-403a-4022-a97f-719688e1af09.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/033636a3-403a-4022-a97f-719688e1af09.png)'
- en: 'If "`Hello World!`" did not show up, one thing to note is that this is a console
    program. You''ll have to open up a command terminal and run the executable from
    there:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示 "`Hello World!`"，需要注意的是，这是一个控制台程序。你必须打开一个命令终端并从那里运行可执行文件：
- en: '![](img/789c36b3-17b6-4b7c-842e-f46d71f4f63d.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/789c36b3-17b6-4b7c-842e-f46d71f4f63d.png)'
- en: Dealing with common errors when building
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理构建过程中常见的错误
- en: '**Write Failed Error** – This means that the builder or compiler is not able
    to write to the output file. It is possible that the executable file it was going
    to build to is still running. Try looking for the program that was run previously
    and terminate it. You can also terminate it from the process list or Task Manager.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**写入失败错误** — 这意味着构建器或编译器无法写入输出文件。可能是它要构建的可执行文件仍在运行。尝试查找之前运行的程序并终止它。你也可以从进程列表或任务管理器中终止它。'
- en: '**Unexpected Characters** – Check for the syntax at the indicated line. Sometimes
    the included files also need to be updated because of changing syntax on recent
    versions of the builder.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**意外字符** — 检查指定行的语法。有时候，包含的文件也需要因为构建器的最新版本而更新语法。'
- en: '**Invalid argument** – Check for the syntax at the indicated line. There might
    be missing parameters of a definition or a declaration.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**无效的参数** — 检查指定行的语法。可能是定义或声明缺少参数。'
- en: '**Illegal instruction** – Check for the syntax at the indicated line. If you
    are sure that the instruction is valid, it might be that the builder version doesn''t
    match where the instruction was valid. While updating the builder to the most
    recent version, also update the source to comply with the recent version.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**非法指令** — 检查指定行的语法。如果你确信指令是有效的，可能是构建器版本与该指令有效的版本不匹配。在更新构建器到最新版本的同时，也要更新源文件以符合最新版本的要求。'
- en: Dissecting the program
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖程序
- en: Now that we have built our program and got it working, let's discuss what the
    program contains and is intended for.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了程序并使其正常工作，让我们讨论一下程序包含了什么以及它的用途。
- en: 'A program is mainly structured with a code section and a data section. The
    code section, as its name states, is where program codes are placed. On the other
    hand, the data section is where the data, such as text strings, used by the program
    code is located. There are requirements before a program can be compiled. These
    requirements define how the program will be built. For example, we can tell the
    compiler to build this program as a Windows executable, instead of a Linux executable.
    We can also tell the compiler which line in the code should the program start
    running. An example of a program structure is given here:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 程序主要由代码部分和数据部分构成。代码部分，顾名思义，就是放置程序代码的地方。而数据部分是程序代码使用的数据，如文本字符串所在的位置。程序在编译之前有一些要求。这些要求定义了程序将如何构建。例如，我们可以告诉编译器将这个程序构建为
    Windows 可执行文件，而不是 Linux 可执行文件。我们还可以告诉编译器程序应该从代码的哪一行开始运行。下面给出了一个程序结构的示例：
- en: '![](img/9c1e0b16-c1e2-4849-b2c3-5bbb2b908af0.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c1e0b16-c1e2-4849-b2c3-5bbb2b908af0.png)'
- en: We can also define the external library functions that the program will be using.
    This list is described under a separate sections called the Import section. There
    are various sections that can be supported by a compiler. An example of these
    extended sections include the resource section, which contains data such as icons
    and images.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义程序将使用的外部库函数。这个列表在一个单独的部分中描述，称为导入部分。编译器可以支持各种不同的部分。这些扩展部分的一个例子是资源部分，其中包含图标和图片等数据。
- en: With the a basic picture of a what a program is structured, let see how our
    program was written. The first line, `format PE CONSOLE`, indicates that the program
    will be compiled as a Windows PE executable file and built to run on the console,
    better known in Windows as Command Prompt.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有了程序结构的基本概念后，让我们看看我们的程序是如何编写的。第一行，`format PE CONSOLE`，表示程序将被编译为一个 Windows PE
    可执行文件，并构建为在控制台上运行，Windows 中更常见的称呼是命令提示符。
- en: The next line, `entry start`, means that the program will start running code
    located at the `start` label. The name of the label can be changed as desired
    by the programmer. The next line, `include '%include%\win32a.inc'`, will add declarations
    from the FASM library file `win32a.inc`. The declared functions expected are for
    calling the `printf` and `ExitProcess` API functions discussed in the `idata`
    section.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，`entry start`，表示程序将开始执行位于`start`标签的代码。标签的名称可以由程序员根据需要进行更改。下一行，`include '%include%\win32a.inc'`，将添加来自FASM库文件`win32a.inc`的声明。预期声明的函数用于调用`printf`和`ExitProcess`
    API函数，这些函数将在`idata`部分讨论。
- en: 'There are three sections built in this program: the `data`, `code`, and `idata`
    sections. The section names here are labeled as `.data`, `.code`, and `.idata`.
    The permissions for each section are also indicated as either `readable`, `writeable`,
    and `executable`. The `data` section is where integers and text strings are placed
    and listed using the define byte (`db`) instruction. The `code` section is where
    lines of instruction code are executed. The `idata` section is where imported
    API functions are declared.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序中有三个内建部分：`data`、`code`和`idata`部分。这里的部分名称被标记为`.data`、`.code`和`.idata`。每个部分的权限也被指示为`可读`、`可写`和`可执行`。`data`部分是放置整数和文本字符串的地方，并使用定义字节（`db`）指令列出。`code`部分是执行指令代码的地方。`idata`部分是导入的API函数声明的地方。
- en: 'On the next line, we see that the data section is defined as a `writeable`
    section:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，我们看到数据部分被定义为`可写`部分：
- en: '[PRE40]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The program''s `.data` section contains two constant variables, `message` and `msgformat`.
    Both text strings are `ASCIIZ` (`ASCII-Zero`) strings, which means that they are
    terminated with a zero (0) byte. These variables are defined with the `db` instruction:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`.data`部分包含两个常量变量，`message`和`msgformat`。这两个文本字符串是`ASCIIZ`（ASCII-Zero）字符串，这意味着它们以零（0）字节结尾。这些变量是通过`db`指令定义的：
- en: '[PRE41]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next line defines the code section. It is defined with read and execute
    permissions:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行定义了代码部分。它被定义为具有读取和执行权限：
- en: '[PRE42]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is in the `.code` section where the `start:` label is and where our code
    is. Label names are prefixed with a colon character.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`.code`部分是`start:`标签所在的位置，也是我们代码的位置。标签名称前缀是冒号字符。'
- en: 'In C programming, `printf` is a function commonly used to print out messages
    to the console using the C syntax, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在C编程中，`printf`是一个常用于打印消息到控制台的函数，使用的C语法如下：
- en: '`int printf ( const char * format, ... );`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`int printf ( const char * format, ... );`'
- en: 'The first parameter is the message containing format specifiers. The second
    parameter contains the actual data that fills up the format specifiers. In assembly
    language perspective, the `printf` function is an API function that is in the
    `msvcrt` library. An API function is set up by placing the arguments in the memory
    stack space before calling a function. If your program is built in C, a function
    that requires 3 parameters (for example, `myfunction(arg1, arg2, arg3)`) will
    have the following as an equivalent in assembly language:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是包含格式说明符的消息。第二个参数包含填充格式说明符的实际数据。从汇编语言的角度来看，`printf`函数是一个在`msvcrt`库中的API函数。通过将参数放入内存堆栈空间中来设置API函数，然后调用该函数。如果你的程序是用C语言编写的，需要3个参数的函数（例如，`myfunction(arg1,
    arg2, arg3)`）在汇编语言中的等效代码如下：
- en: '[PRE43]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For a 32-bit address space, the `push` instruction is used to write a `DWORD`
    (32 bits) of data on the top of the stack. The address of the top of the stack
    is stored in the ESP register. When a `push` instruction is executed, the ESP
    decreases by 4\. If the argument is a text string or a data buffer, the address
    is push-ed to the stack. If the argument is a number value, the value is directly
    push-ed to the stack.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于32位地址空间，使用`push`指令将一个`DWORD`（32位）数据写入堆栈的顶部。堆栈顶部的地址存储在ESP寄存器中。当执行`push`指令时，ESP值减少4。如果参数是文本字符串或数据缓冲区，则将地址推送到堆栈。如果参数是数值，则将值直接推送到堆栈。
- en: 'Following the same API calling structure, with two arguments, our program called
    `printf` in this manner:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的API调用结构，带有两个参数，我们的程序以这种方式调用了`printf`：
- en: '[PRE44]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the data section, the addresses, labeled as `message` and `msgformat`, are
    pushed to the stack as a setup before calling the `printf` function. Addresses
    are usually placed in square brackets, `[]`. As discussed previously, the value
    at the address is used instead. The `printf` is actually a label that is the local
    address in the program declared in the `.idata` section. `[printf]` then means
    that we are using the address of the `printf` API function from the `msvcrt` library.
    Thus, `call [printf]` will execute the `printf` function from the `msvcrt` library.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据部分，地址`message`和`msgformat`作为调用`printf`函数前的设置被推入栈中。地址通常放在方括号`[]`中。如前所述，使用的是地址中的值。`printf`实际上是一个标签，它是程序中在`.idata`部分声明的本地地址。[printf]表示我们正在使用`msvcrt`库中`printf`
    API函数的地址。因此，`call [printf]`将执行来自`msvcrt`库的`printf`函数。
- en: 'The same goes for `ExitProcess`. `ExitProcess` is a `kernel32` function that
    terminates the running process. It requires a single parameter, which is the exit
    code. An exit code of 0 means that the program will terminate without any errors:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ExitProcess`也是一样的。`ExitProcess`是一个`kernel32`函数，用于终止正在运行的进程。它需要一个参数，即退出码。退出码为0表示程序将无错误地终止：
- en: '[PRE45]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In C syntax, this code is equivalent to `ExitProcess(0)`, which terminates the
    program with a success result defined with zero.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语法中，这段代码等同于`ExitProcess(0)`，它终止程序并返回一个由零定义的成功结果。
- en: 'The program''s `.idata` section contains external functions and is set with
    read and write permissions:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`.idata`部分包含外部函数，并设置为可读写权限：
- en: '[PRE46]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the following code snippet, there are two portions. The first part indicates
    which library files the functions are located in. The `library` command is used
    to set the libraries required, and uses the syntax `library <library name>, <library
    file>`. A backslash, `\`, is placed to indicate that the next line is a continuation
    of the current line:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，有两个部分。第一部分指示函数所在的库文件。`library`命令用于设置所需的库，并使用语法`library <库名>, <库文件>`。反斜杠`\`表示下一行是当前行的延续：
- en: '[PRE47]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once the libraries are declared, specific API functions are indicated using
    the `import` command. The syntax is `import <library name>, <function name>, <function
    name in library file>`. Two external API functions are imported here, *kernel32*'s
    *ExitProcess* and *msvcrt*'s *printf:*
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库被声明，使用`import`命令来指定特定的API函数。语法为`import <库名>, <函数名>, <库文件中的函数名>`。这里导入了两个外部API函数，*kernel32*的*ExitProcess*和*msvcrt*的*printf*：
- en: '[PRE48]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A annotated version of the program can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的注释版本可以在[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/blob/master/ch3/FASM%20commented.txt)找到
- en: 'The library of API functions can be found in the MSDN library ([https://msdn.microsoft.com/en-us/library](https://msdn.microsoft.com/en-us/library)),
    which also has an offline version packaged in the Visual Studio installer. It
    contains detailed information about what the API function is for and how to use
    it. The online version looks like the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: API函数库可以在MSDN库中找到（[https://msdn.microsoft.com/en-us/library](https://msdn.microsoft.com/en-us/library)），该库也有一个离线版本，包含在Visual
    Studio安装程序中。它提供了有关API函数的用途以及如何使用它的详细信息。在线版本如下所示：
- en: '![](img/bb928665-6664-4b30-83ca-ee18a0962334.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb928665-6664-4b30-83ca-ee18a0962334.png)'
- en: After Hello
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Hello之后
- en: We encountered an external call to the `printf` and `ExitProcess` API functions.
    These specific functions were developed for Windows as a means of communication
    between the user-mode and the kernel-mode. Generally, for most operating systems,
    the kernel is responsible for literally displaying the output on the monitor,
    writing files to the disk, reading keyboard strokes, transmitting data to USB
    ports, sending data to the printer, transmitting data to the network wire, and
    so forth. In essence, everything that has something to do with hardware has to
    go through the kernel. Our program, however, is in the user-mode, and we use the
    APIs to tell the kernel to do stuff for us.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了对 `printf` 和 `ExitProcess` API 函数的外部调用。这些特定的函数是为 Windows 开发的，作为用户模式和内核模式之间的通信手段。通常，对于大多数操作系统来说，内核负责实际在显示器上显示输出、将文件写入磁盘、读取键盘输入、向
    USB 端口传输数据、发送数据到打印机、通过网络传输数据等等。从本质上讲，所有与硬件相关的操作都必须通过内核。然而，我们的程序处于用户模式中，我们使用 API
    来告诉内核为我们执行操作。
- en: Calling APIs
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 API
- en: 'Calling APIs within our program just requires us to define the library file
    where the API function is, and the API name itself. As we did with our Hello World
    program, we import the API function by setting it up in the import section:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中调用 API 只需要定义包含 API 函数的库文件和 API 函数本身的名称。正如我们在 Hello World 程序中所做的，我们通过在导入部分设置它来导入
    API 函数：
- en: '[PRE49]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And then we call the APIs with a CALL instruction, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过 CALL 指令调用 API，如下所示：
- en: '[PRE50]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Common Windows API libraries
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 Windows API 库
- en: '**KERNEL32** contains base functions of Windows that are responsible for file
    I/O operations and memory management, including processes and threads management.
    Some functions are helpers for calling more native APIs in the NTDLL library.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**KERNEL32** 包含 Windows 的基础函数，负责文件 I/O 操作和内存管理，包括进程和线程管理。有些函数是用于调用 NTDLL 库中更原生
    API 的辅助函数。'
- en: '**USER32** contains functions that deal with the display and graphical interface,
    such as program windows, menu, and icons. It also contains functions that controls
    window messages.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**USER32** 包含处理显示和图形界面的函数，例如程序窗口、菜单和图标。它还包含控制窗口消息的函数。'
- en: '**ADVAPI32** contains functions that has to do with the Windows registry.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**ADVAPI32** 包含与 Windows 注册表相关的函数。'
- en: '**MSVCRT** contains standard C library functions from Microsoft Visual C++
    runtime, such as printf, scanf, malloc, strlen, fopen, and getch.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSVCRT** 包含来自 Microsoft Visual C++ 运行时的标准 C 库函数，例如 printf、scanf、malloc、strlen、fopen
    和 getch。'
- en: '**WS2_32**, **WININET**, **URLMON**, and **NETAPI32** are libraries that contain
    functions that have to do with networking and internet communication.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**WS2_32**、**WININET**、**URLMON** 和 **NETAPI32** 是包含与网络和互联网通信相关的函数的库。'
- en: Short list of common API functions
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见 API 函数简短列表
- en: 'The API functions can be categorized based on their purposes. A complete list
    can be found at the MSDN Library, but the most common ones are listed here:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: API 函数可以根据其用途进行分类。完整列表可以在 MSDN 库中找到，但这里列出了最常见的函数：
- en: '| **Purpose** | **API functions** |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| **用途** | **API 函数** |'
- en: '| **Console output** | `KERNEL32!GetStdHandle, MSVCRT!printf` |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| **控制台输出** | `KERNEL32!GetStdHandle, MSVCRT!printf` |'
- en: '| **File handling** | `KERNEL32!ReadFile, KERNEL32!WriteFile, KERNEL32!CreateFile`
    |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| **文件处理** | `KERNEL32!ReadFile, KERNEL32!WriteFile, KERNEL32!CreateFile` |'
- en: '| **Memory management** | `KERNEL32!VirtualAlloc, KERNEL32!VirtualProtect,
    MSVCRT!malloc` |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| **内存管理** | `KERNEL32!VirtualAlloc, KERNEL32!VirtualProtect, MSVCRT!malloc`
    |'
- en: '| **Process and threads** | `KERNEL32!ExitProcess, KERNEL32!CreateProcess, KERNEL32!CreateThread,
    SHELL32!ShellExecute` |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| **进程和线程** | `KERNEL32!ExitProcess, KERNEL32!CreateProcess, KERNEL32!CreateThread,
    SHELL32!ShellExecute` |'
- en: '| **Window management** | `USER32!MessageBoxA, USER32!CreateWindowExA, ``USER32!RegisterWindowMessageW`
    |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| **窗口管理** | `USER32!MessageBoxA, USER32!CreateWindowExA, USER32!RegisterWindowMessageW`
    |'
- en: '| **Strings** | `MSVCRT!strlen, MSVCRT!printf` |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| **字符串处理** | `MSVCRT!strlen, MSVCRT!printf` |'
- en: '| **Network communication** | `WININET!InternetAttemptConnect, WS2_32!socket, WS2_32!connect,
    URLMON!URLDownloadToFile` |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| **网络通信** | `WININET!InternetAttemptConnect, WS2_32!socket, WS2_32!connect,
    URLMON!URLDownloadToFile` |'
- en: '| **Cryptography** | `CryptDecrypt, CryptEncrypt` |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| **加密** | `CryptDecrypt, CryptEncrypt` |'
- en: '| **Registry** | `RegDeleteKey, RegCreateKey, RegQueryValueExW, RegSetValueExW`
    |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| **注册表** | `RegDeleteKey, RegCreateKey, RegQueryValueExW, RegSetValueExW`
    |'
- en: Debugging
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: At certain points, our program may produce unpredictable errors or invalid output.
    In that case, we need to trace what went wrong, by debugging each line of code.
    But before that, there are some general debug commands we need to know.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，我们的程序可能会产生不可预测的错误或无效输出。在这种情况下，我们需要通过逐行调试代码来追踪出错的原因。但在此之前，有一些常用的调试命令我们需要了解。
- en: 'Single-stepping a program means debugging per line of code. There are two modes
    to single step: step into and step over. During debugging, when the line being
    debugged is a CALL instruction, single-step debugging continues in the subroutine
    when a **step into** mode is used. The **step over** mode, however doesn''t enter
    the subroutine, but rather lets the subroutine finish up running and the single
    step continues on the line after the CALL instruction. See the following comparison:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 单步调试意味着逐行调试程序代码。单步调试有两种模式：step into 和 step over。在调试过程中，当被调试的行是一个 CALL 指令时，使用
    **step into** 模式时，单步调试会进入子程序继续调试。而 **step over** 模式则不会进入子程序，而是让子程序继续执行，单步调试会在
    CALL 指令后的下一行继续。请看以下对比：
- en: '| Step into | Step over |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| Step into | Step over |'
- en: '|'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A **run** or **continue** makes the debugger execute instructions continuously
    until the program terminates, encounters an error, or until it encounters a manually
    set breakpoint.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**run** 或 **continue** 使调试器连续执行指令，直到程序终止、遇到错误，或遇到手动设置的断点。'
- en: 'Placing a **breakpoint** is a way to enable to the debugger to interrupt a
    code that was set to freely run. For example, if I placed a breakpoint at address
    0040200A in the following code, and let the debugger automatically run every instruction
    starting from 00402000, the debugger stops at address 0040200A and leaves the
    user to continue doing single steps or run:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 **断点** 是让调试器中断已设置为自由运行的代码的一种方法。例如，如果我在以下代码的地址 0040200A 处设置了一个断点，并让调试器从 00402000
    开始自动运行每条指令，调试器会在地址 0040200A 处停止，并允许用户继续进行单步调试或继续运行：
- en: '[PRE53]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let's debug our Hello World program.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调试我们的 Hello World 程序。
- en: Download x64dbg from [https://x64dbg.com/](https://x64dbg.com/).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://x64dbg.com/](https://x64dbg.com/)下载 x64dbg。
- en: 'It is a ZIP archive that you will have to extract. And once extracted, open
    the x96dbg.exe from the release folder. This will show the launcher dialog where
    you get to select x32dbg (for 32-bit debugging) and x64dbg (for 64-bit debugging)
    as your debugger:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 ZIP 压缩包，你需要解压它。解压后，打开 release 文件夹中的 x96dbg.exe。这将显示启动对话框，你可以选择 x32dbg（用于
    32 位调试）和 x64dbg（用于 64 位调试）作为调试器：
- en: '![](img/cda8c465-709d-42de-9e08-e09bfaab749f.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda8c465-709d-42de-9e08-e09bfaab749f.png)'
- en: 'The Hello World program we developed is a 32-bit program, thus, select x32dbg.
    Then click on File->Open, then browse and open the helloworld.exe program. Opening
    it will show you where the EIP is at in the disassembly window as follows:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的 Hello World 程序是一个 32 位程序，因此请选择 x32dbg。然后点击 File->Open，浏览并打开 helloworld.exe
    程序。打开后，你会在反汇编窗口中看到 EIP 的位置，如下所示：
- en: '![](img/62671264-1b8c-49d4-8d23-6afd32415c6f.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62671264-1b8c-49d4-8d23-6afd32415c6f.png)'
- en: 'At the bottom of the window, it says: "System breakpoint reached!" EIP is at
    a high-memory region address and the window title also indicates "Module: ntdll.dll
    - Thread: Main Thread." All of this suggests that we are not yet in the helloworld
    program, but rather still in the ntdll.dll code that loads up the helloworld program
    to memory, initializes it and then starts to run it. If you go to Options->Preferences,
    and in the Events table of the Settings window, by default, the System Breakpoint*
    is checked. This causes the debugger to pause in the ntdll.dll before we even
    reach our helloworld code. Uncheck the System Breakpoint*, click on Save, then
    exit the debugger, as shown here:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的底部，它显示：“系统断点已触发！”EIP 位于高内存区域地址，窗口标题也显示“模块：ntdll.dll - 线程：主线程”。所有这些都表明我们还没有进入
    helloworld 程序，而是仍然在加载 helloworld 程序到内存、初始化并开始运行的 ntdll.dll 代码中。如果你进入 Options->Preferences，在设置窗口的
    Events 表格中，默认情况下，**系统断点** 是勾选的。这会导致调试器在我们进入 helloworld 代码之前就停在 ntdll.dll 中。取消勾选系统断点，点击保存，然后退出调试器，如下所示：
- en: '![](img/5cd8c14a-4bd3-4524-a7d2-d9b71e2973bc.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cd8c14a-4bd3-4524-a7d2-d9b71e2973bc.png)'
- en: 'Now that we have removed the System Breakpoint, repeat loading the helloworld
    program. The EIP should now be in the helloworld code:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经移除了系统断点，请重新加载 helloworld 程序。此时，EIP 应该已经位于 helloworld 代码中：
- en: '![](img/24d781b2-f654-431d-acf8-d24936f65f21.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24d781b2-f654-431d-acf8-d24936f65f21.png)'
- en: 'Click on the Debug menu. You should see that there are keyboard keys assigned
    to Step into, Step over, Run and more debugging options:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 点击调试菜单。你应该会看到有键盘快捷键分配给“单步进入”、“单步跳过”、“运行”以及更多调试选项：
- en: '![](img/1a0c8fcf-67f7-461a-8227-ca1a1e49d4b8.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a0c8fcf-67f7-461a-8227-ca1a1e49d4b8.png)'
- en: The stack frame window is located at the lower right pane. Take note of the
    information there, then press `*F7*` or *F8* to do a single step. The `PUSH helloworld.401000`
    instruction just placed the address of "`Hello World`" text string at the top
    of the stack. At the upper right pane where the registers and flags are, all changes
    have their text colored red. With the stack moving its address, ESP should change.
    And since we are now on the next line of instruction code, EIP should have also
    changed.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈帧窗口位于右下方。注意那里的信息，然后按 `*F7*` 或 *F8* 执行单步操作。`PUSH helloworld.401000` 指令刚刚将 "`Hello
    World`" 文本字符串的地址压入堆栈顶部。在右上方的寄存器和标志窗口中，所有变化的文本都会显示为红色。随着堆栈地址的变化，ESP 也会发生变化。由于我们现在执行的是下一条指令代码，EIP
    也应有所改变。
- en: 'Do another single step to push the address of "`%s`" to the stack. You should
    now be in address `0040200A`. At this point, doing a step over will execute the
    `printf` function and be at address 00402010\. Out of curiosity, let''s do a step
    into instead. This leads us in the `msvcrt` library, where the `printf` function
    is:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 再执行一步，推动 "`%s`" 的地址压入堆栈。此时，你应该已经在地址 `0040200A`。此时，执行单步跳过会执行 `printf` 函数，并到达地址
    `00402010`。出于好奇，我们不妨选择单步进入。这会带我们进入 `msvcrt` 库，`printf` 函数就在其中：
- en: '![](img/97fe9783-f71b-4277-9ba7-3914935d1475.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97fe9783-f71b-4277-9ba7-3914935d1475.png)'
- en: 'To get back to our `helloworld` program, we can do a "`Run to user code`,"
    which has a mapped key of *Alt *+ *F9* or an "`Execute till return`" *Ctrl *+
    *F9*. The user code pertains to our hello world program. Doing a "`Run to user
    code`" will bring us to address `00402010`, which is the instruction after the
    `printf` call. Doing an "`Execute till return`" will bring us to the address where
    the `RET` instruction is. Let''s do an "`Execute till return`" instead:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到我们的 `helloworld` 程序，可以执行 "`Run to user code`"（映射快捷键为 *Alt* + *F9*）或 "`Execute
    till return`"（*Ctrl* + *F9*）。用户代码指的是我们的 Hello World 程序。执行 "`Run to user code`"
    会将我们带到地址 `00402010`，即 `printf` 调用之后的指令。执行 "`Execute till return`" 会将我们带到 `RET`
    指令所在的地址。我们不妨选择执行 "`Execute till return`"：
- en: '![](img/a6190ea8-0505-49f7-a5a0-bab9faef4bea.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6190ea8-0505-49f7-a5a0-bab9faef4bea.png)'
- en: Now take a look at the stack. As discussed previously about the `CALL-RET` instructions,
    a `CALL` stores the address of the next instruction at the top of the stack. At
    this point, the address stored at the top of the stack is `00402010`. Make a single
    step and we should be back in our `hello world` program.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看堆栈。正如之前讨论的 `CALL-RET` 指令，`CALL` 会将下一条指令的地址存储在堆栈顶部。此时，存储在堆栈顶部的地址是 `00402010`。进行单步操作后，我们应该回到我们的
    `hello world` 程序。
- en: Just continue doing step overs. The last two instructions should terminate the
    program and the debugging will stop.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行单步跳过。最后两条指令应该会终止程序，调试会停止。
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Assembly language is a low-level language that uses instructions to communicate directly with
    the computer system. Logic used in computers is based on an on-and-off concept,
    from which binary 1s and 0s were derived. We have learned how to read and write
    binary from various number bases, and how to do arithmetic and bitwise computations.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言是一种低级语言，通过指令与计算机系统直接通信。计算机中使用的逻辑基于开关概念，从中衍生出了二进制 1 和 0。我们已经学会了如何从不同的数字进制中读写二进制，以及如何进行算术和位运算。
- en: We introduced popular assemblers and debuggers that we can use to build and
    validate our program. Then, we used FASM to code and build our Win32 low-level
    hello world program that uses APIs to communicate with the kernel. We validated
    our built executable program using `x64dbg` to debug it. Debugging our hello world
    program is a good start for us to get introduced to the world of reverse engineering.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了可以用来构建和验证我们程序的流行汇编器和调试器。接着，我们使用 FASM 编写并构建了我们的 Win32 低级 Hello World 程序，该程序使用
    API 与内核进行通信。我们通过使用 `x64dbg` 调试器验证了我们构建的可执行程序。调试我们的 Hello World 程序是我们进入逆向工程世界的一个良好开端。
- en: Practice makes perfect. We have a listed a few suggested programs that can be
    developed using assembly language.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 熟能生巧。我们列出了一些可以使用汇编语言开发的推荐程序。
- en: Knowing the lowest level of a code is a good start for our reverse engineering
    journey. As you finish up this book, assembly language will feel somewhat like
    a walk in the park.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 了解代码的最低层次是我们逆向工程之旅的良好起点。当你完成本书的学习时，汇编语言会感觉像是在公园里散步一样轻松。
- en: Further reading
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Intel's documentation contains the complete list of x86 instructions and describes
    the syntax and use of each instruction in assembly language. You can get these
    documents from [http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的文档包含了完整的x86指令列表，并描述了每个指令在汇编语言中的语法和使用方法。你可以从[http://www.intel.com/products/processor/manuals/](http://www.intel.com/products/processor/manuals/)获取这些文档。
