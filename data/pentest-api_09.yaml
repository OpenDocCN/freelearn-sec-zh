- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: API Abuse and Business Logic Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 滥用与业务逻辑测试
- en: With this chapter, we will finish the fourth part of our book. We just learned
    about **data exposure** and **information leakage**, which are unfortunately very
    common nowadays. It is also unfortunate that there are even more dangerous ways
    to break API protection controls. Abusing the right way of using endpoints is
    one of them. Exploiting the API logic is another fearsome one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成本书的第四部分。我们刚刚学习了**数据暴露**和**信息泄露**，这两者在当今社会中非常常见。不幸的是，甚至还有更危险的方式来破坏
    API 保护控制。滥用正确使用端点的方法就是其中之一。利用 API 逻辑漏洞则是另一个令人恐惧的方式。
- en: '**API abuse** refers to the misuse of an API beyond its intended purpose, leading
    to security vulnerabilities, data breaches, or service disruptions. **Business
    logic testing** involves identifying vulnerabilities in the application’s business
    rules and workflows. This ensures that the application behaves as intended in
    all scenarios. Together, these tests help secure APIs against misuse and logical
    flaws.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 滥用**是指超出其预期用途的 API 滥用，导致安全漏洞、数据泄露或服务中断。**业务逻辑测试**涉及识别应用程序业务规则和工作流中的漏洞，确保应用程序在所有场景下都能按预期运行。结合这些测试，有助于保护
    API 防止滥用和逻辑缺陷。'
- en: In this chapter, we will stay engaged with the advanced API topics, but we will
    learn why the business logic behind an API can impact the frequency and/or depth
    at which API endpoints are exploited. We will begin by dissecting what business
    logic is and how it may have vulnerabilities. Then, we will take a look at abuse
    scenarios, simulating environments where such logic can be explored in a bad way.
    Finally, using a method like the one we applied in [*Chapter 8*](B19657_08.xhtml#_idTextAnchor131),
    we will search for vulnerabilities in business logic. I hope you enjoy this journey.
    Let’s go on it together!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将继续讨论高级 API 话题，但我们将学习为什么 API 背后的业务逻辑可能会影响 API 端点被利用的频率和/或深度。我们将首先解析什么是业务逻辑及其可能存在的漏洞。然后，我们将看看滥用场景，模拟可以不正当地探索此类逻辑的环境。最后，使用像在[*第
    8 章*](B19657_08.xhtml#_idTextAnchor131)中应用的方法，我们将搜索业务逻辑中的漏洞。希望你能喜欢这段旅程。让我们一起开始吧！
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding business logic vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解业务逻辑漏洞
- en: Exploring API abuse scenarios
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 API 滥用场景
- en: Testing for business logic vulnerabilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑漏洞测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’ll leverage the same environment as the one pointed out in previous chapters,
    such as an Ubuntu distro. Some other new relevant utilities will be mentioned
    in the corresponding sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用与前几章提到的环境相同的环境，例如 Ubuntu 发行版。其他一些相关的新工具将在相应的章节中提到。
- en: We will create more code in this chapter, which we’ll leverage to simulate and
    test some vulnerabilities, this time focused on business logic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写更多的代码，用于模拟和测试一些漏洞，这一次我们将重点关注业务逻辑。
- en: Understanding business logic vulnerabilities
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解业务逻辑漏洞
- en: To understand what types of vulnerabilities may arise from the business logic
    behind API endpoints and their applications, we first have to understand what
    business logic is. Well, it is nothing other than several processes, rules, and
    workflows that define how data can be processed by software. To reach specific
    business objectives, the software needs to handle interactions with the users,
    as well as transactions and data handling. In other words, it’s the implementation
    of business specificities into code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解可能源自 API 端点背后业务逻辑及其应用的漏洞类型，我们首先需要理解什么是业务逻辑。简单来说，它就是一系列定义数据如何被软件处理的流程、规则和工作流。为了实现特定的业务目标，软件需要处理与用户的交互、事务和数据处理。换句话说，它是业务特性在代码中的实现。
- en: Using web commerce as a common scenario, the business logic part of the application
    (that could also be represented by APIs and their endpoints) handles various tasks
    such as the maintenance of the shopping cart, the insertion of discount codes,
    all logistics activities (such as calculating shipping costs and estimated delivery
    time), and finally, the processing or transferring to a trusted third party of
    payments. The final purpose is to ensure that the application behaves as it was
    designed to, such that all phases are deterministic and not probabilistic. That’s
    a very important point to remember.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络商务作为一个常见的场景，应用程序的业务逻辑部分（也可以由API和它们的端点表示）处理各种任务，如维护购物车、插入折扣代码、所有物流活动（如计算运费和预计交货时间），最终处理或将支付转移到可信第三方。最终目的是确保应用程序按设计行为，使所有阶段都是确定性的而不是概率性的。这是一个非常重要的记点。
- en: 'If it is not yet obvious, you could ask why business logic is so important.
    Well, it does the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在还不明显，你可以问为什么业务逻辑如此重要。好吧，它做以下工作：
- en: '**Maintains integrity and efficiency**: It guarantees that the application
    operates smoothly and handles data with integrity.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护完整性和效率**：它保证应用程序运行顺畅，并具有数据完整性。'
- en: '**Converts business rules**: By following some methodologies, business policies
    and rules are translated into lines of code. This allows the application to perform
    tasks such as validating user input, enforcing security measures, managing data
    flow, and complying with regulations. Imagine a banking application – its business
    logic would enforce rules around transaction limits, account access, and fraud
    detection.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换业务规则**：通过遵循某些方法论，将业务政策和规则转化为代码行。这使应用程序能够执行诸如验证用户输入、执行安全措施、管理数据流和遵守法规等任务。想象一下银行应用程序
    - 它的业务逻辑将强制执行关于交易限制、账户访问和欺诈检测的规则。'
- en: '**Automates processes**: By encapsulating these rules within the application,
    businesses can automate complex tasks, reduce errors, and ensure consistent execution
    of business activities.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化流程**：通过在应用程序内封装这些规则，企业可以自动化复杂任务，减少错误，并确保业务活动的一致执行。'
- en: '**Impacts reliability and security**: Robust business logic directly affects
    the software’s reliability, security, and ultimately, user satisfaction.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影响可靠性和安全性**：强大的业务逻辑直接影响软件的可靠性、安全性，最终影响用户的满意度。'
- en: In simple terms, business logic is the software’s rulebook, making sure it runs
    efficiently and fulfills the specific needs of the business it serves.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，业务逻辑是软件的规则书，确保它运行高效并满足所服务业务的特定需求。
- en: 'Nice! Now that we have established some groundwork on the subject, we can talk
    about the vulnerabilities that may affect it. They can usually bypass traditional
    security measures such as firewalls and **Intrusion Detection Systems** (**IDSs**),
    and they are dangerous for the following reasons:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！现在我们已经在这个主题上建立了一些基础，我们可以谈谈可能影响它的漏洞。它们通常可以绕过传统的安全措施，如防火墙和**入侵检测系统（IDS）**，对以下原因非常危险：
- en: Their target is the core business.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的目标是核心业务。
- en: They are difficult to detect and block.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们难以检测和阻止。
- en: 'There are some methods to cause errors in business logic:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以导致业务逻辑中的错误：
- en: '**Workflow tampering**: With this, we change the sequence of operations to
    overcome security protections or to obtain unauthorized access.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流篡改**：通过这种方式，我们改变操作的顺序，以克服安全保护或获取未经授权的访问。'
- en: '**Validation bypass**: With this, we look for ways to skip or manipulate some
    validations.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证绕过**：通过这种方式，我们寻找跳过或操纵某些验证的方法。'
- en: '**Inconsistent error handling**: In this, we identify patterns in error messages
    that could possibly leak sensitive data or the API behavior.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不一致的错误处理**：在这种情况下，我们识别错误消息中可能泄露敏感数据或API行为的模式。'
- en: '**Escalate privileges**: In this, through the leverage of some failure in the
    API’s code or some system supporting it, we gain higher levels of access.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**升级权限**：通过利用API代码中的某些失败或支持它的系统，我们获得了更高级别的访问权限。'
- en: '**Concurrency issues**: APIs that implement concurrency may be vulnerable to
    this, where we can exploit race conditions or failures in logic synchronization.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发问题**：实施并发性的API可能会对此产生漏洞，我们可以利用竞争条件或逻辑同步中的失败。'
- en: '**Manipulate transactions**: Through this, we directly interfere with the logic’s
    operations to impose inconsistencies or to obtain some benefit, usually financial.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操纵交易**：通过这种方式，我们直接干预逻辑操作，施加不一致性或获得某些好处，通常是财务方面的。'
- en: There were some notable incidents that deserve mention to illustrate how API
    business logic’s vulnerabilities can cause devastating damage to companies. You
    will find links with more information about all of them in the *Further reading*
    section. In April 2021, an independent security researcher discovered a vulnerability
    in an API used by **Experian** to assess individuals’ creditworthiness. This API
    used minimal authentication information, making it easy to exploit. Attackers
    could retrieve sensitive personal data, including **Fair Isaac Corporation** (**FICO**)
    scores and credit risk factors, using easily obtainable public information. This
    incident highlighted the risks of weak authentication and excessive data exposure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些显著的事件值得一提，以说明API业务逻辑漏洞如何对公司造成毁灭性的损害。您将在*进一步阅读*部分找到更多关于它们的信息链接。2021年4月，一位独立安全研究人员发现了**Experian**用于评估个人信用价值的API的漏洞。该API使用最少的身份验证信息，容易被利用。攻击者可以使用轻松获得的公共信息检索敏感个人数据，包括**Fair
    Isaac Corporation**（**FICO**）分数和信用风险因素。这一事件凸显了弱身份验证和过度数据暴露的风险。
- en: In the same month and year, security researchers from the **Sick Codes** security
    firm uncovered vulnerabilities in John Deere’s APIs, which allowed them to access
    user accounts and sensitive data without authentication. John Deere is a global
    company that produces agricultural, construction, and forestry equipment and solutions.
    The researchers were able to identify customers of John Deere, including major
    Fortune 1,000 companies, and retrieve personal data associated with their equipment.
    The lack of rate limiting and authentication controls in these APIs posed significant
    security risks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一年同一月，来自**Sick Codes**安全公司的安全研究人员揭示了John Deere的API中的漏洞，这使他们能够无需身份验证访问用户账户和敏感数据。John
    Deere是一家全球性公司，生产农业、建筑和林业设备及解决方案。研究人员能够识别John Deere的客户，包括一些财富1000强企业，并检索与其设备相关联的个人数据。这些API中缺乏速率限制和身份验证控制，构成了重大安全风险。
- en: In December 2021, hackers exploited a vulnerability in the X (which was still
    called Twitter at the time) API to access the personal data of over 5.4 million
    users. By submitting email addresses or phone numbers to the API, attackers could
    retrieve the associated accounts. This breach exposed usernames, phone numbers,
    and email addresses, significantly affecting user trust and confidence in X.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在2021年12月，黑客利用X（当时仍称为Twitter）API中的漏洞，获取了超过540万用户的个人数据。通过向API提交电子邮件地址或电话号码，攻击者可以检索相关联的账户。此次泄露暴露了用户名、电话号码和电子邮件地址，严重影响了用户对X的信任和信心。
- en: Again in December 2021, FlexBooker, a social media scheduling platform, experienced
    an API breach that exposed 3.7 million user records. The breach, caused by vulnerabilities
    in their AWS configuration, led to the download of sensitive user data and system
    downtime. The breach stemmed from flaws in how FlexBooker configured its access
    controls on AWS, which can be seen as a business logic issue related to API security.
    The exposed user data resided within FlexBooker’s system, likely accessed through
    a compromised API. This incident underscores the importance of securing API endpoints
    and storage systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在2021年12月，社交媒体调度平台FlexBooker遭遇了API泄露，泄露了370万用户记录。由于其AWS配置中的漏洞导致了敏感用户数据的下载和系统停机。该泄露源于FlexBooker在AWS上配置访问控制的缺陷，可以视为与API安全相关的业务逻辑问题。泄露的用户数据存储在FlexBooker的系统内，可能是通过被入侵的API访问的。这一事件强调了保护API端点和存储系统的重要性。
- en: 'In January 2022, the **Texas Department of Insurance** had an API endpoint
    publicly exposed (for nearly three years) due to a software error. This breach
    exposed 1.8 million records containing Social Security numbers, addresses, and
    other personal information. There were two problems: a vulnerable web application,
    and data that was exposed. This vulnerability resided within the application’s
    code, suggesting a problem with business logic implementation. Among the exposed
    data, there were names, Social Security numbers, addresses, dates of birth, and
    details of claims. The incident highlighted the importance of continuous monitoring
    and proper configuration of API endpoints to protect sensitive data.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2022 年 1 月，**德克萨斯州保险部**因软件错误暴露了一个 API 端点（持续了近三年）。该漏洞暴露了包含社会安全号码、地址及其他个人信息的 180
    万条记录。问题有两个：一个是脆弱的 Web 应用程序，另一个是暴露的数据。此漏洞存在于应用程序的代码中，表明业务逻辑实现存在问题。在暴露的数据中，包括了姓名、社会安全号码、地址、出生日期和索赔详情。此事件突显了持续监控和正确配置
    API 端点以保护敏感数据的重要性。
- en: Now that we have covered what API business logic is and the problems that may
    be caused as part of API vulnerabilities, let’s learn how we can abuse APIs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了什么是 API 业务逻辑以及 API 漏洞可能导致的问题，让我们学习如何滥用 API。
- en: Exploring API abuse scenarios
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 API 滥用场景
- en: 'API abuse is related to the unexpected use of an API in a way that deviates
    from its intended purpose or project/design. This can naturally uncover security
    vulnerabilities, which in turn can cause data breaches and/or service interruptions.
    Some common ways of abusing an API include the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: API 滥用与以偏离其预期目的或项目/设计的方式意外使用 API 相关。这通常会暴露出安全漏洞，进而可能导致数据泄露和/或服务中断。滥用 API 的一些常见方式包括：
- en: '**Credential stuffing**: By using stolen credentials, access to the API is
    gained.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭证填充**：通过使用被盗的凭证获得 API 访问权限。'
- en: '**Data scraping**: Consists of exfiltrating large volumes of data from an API,
    which usually violates terms of service or its privacy policies.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据抓取**：从 API 中提取大量数据，通常违反了服务条款或隐私政策。'
- en: '**Endpoint discovery**: It’s accomplished with the use of automation tools
    to discover and exploit “hidden” (forgotten or undocumented) API endpoints.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点发现**：通过使用自动化工具发现并利用“隐藏”（遗忘或未文档化）API 端点来实现。'
- en: '**Mass assignment**: You send unexpected data fields to the endpoint to manipulate
    internal object properties.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量赋值**：你向端点发送意外的数据字段，以操控内部对象属性。'
- en: '**Parameter tampering**: Consists of changing API parameters to be able to
    access data or features that would be denied or restricted by default.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数篡改**：通过修改 API 参数，访问那些默认情况下会被拒绝或限制的数据或功能。'
- en: '**Rate limiting violations**: Done by exceeding the maximum number of allowed
    requests per unit of time, which usually leads to DoS attacks.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制违规**：通过超过单位时间内允许的最大请求次数来实现，通常会导致 DoS 攻击。'
- en: We have theoretically and practically covered some of the aforementioned methods.
    Let’s dive deeper into the ones that are completely new. For each method, we will
    have a dummy API written in Python and the steps that you may follow to accomplish
    the attack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在理论和实践中涵盖了上述一些方法。现在，让我们深入探讨那些全新的方法。对于每种方法，我们将有一个用 Python 编写的虚拟 API 和你可以遵循的攻击步骤。
- en: Credential stuffing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭证填充
- en: 'This is a universal type of attack whereby criminals use a large database of
    stolen or leaked credentials to attempt to gain unauthorized access to user accounts
    that are accessible via API endpoints. The main intent here is to leverage what
    many human beings do in their daily lives: reusing the same password throughout
    various systems and websites. Criminals make use of automated tools to help them
    speed up these attacks. It is possible to generate millions of attempts in short
    periods of time. This is not the same as brute force attacks, wherein you need
    to generate random passwords and sometimes usernames or read them from dictionary
    files, or even rainbow tables (when the targets are hashes). Credential stuffing
    does use actual usernames and passwords.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种通用类型的攻击，犯罪分子利用大量被盗或泄露的凭证数据库，试图通过API端点获得对用户帐户的未授权访问。这里的主要目的是利用许多人在日常生活中的行为：在多个系统和网站上重复使用相同的密码。犯罪分子使用自动化工具来帮助加速这些攻击。在短时间内，可以生成数百万次尝试。这与暴力破解攻击不同，暴力破解攻击需要生成随机密码，有时还需要用户名，或者从字典文件中读取它们，甚至使用彩虹表（当目标是哈希值时）。凭证填充使用的是实际的用户名和密码。
- en: The damage of such attacks is based on their capability to overcome basic security
    countermeasures. Once valid credentials pairs are presented, if the protection
    mechanisms are based only on password length and complexity, they can easily be
    bypassed. They are especially dangerous to applications that deal with sensitive
    data since even small breaches can cause severe damage to the company’s reputation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的危害基于它们能够克服基本安全防护的能力。一旦提供了有效的凭证对，如果保护机制仅依赖于密码的长度和复杂度，就很容易被绕过。它们对于处理敏感数据的应用程序尤其危险，因为即使是小规模的泄露也可能对公司声誉造成严重损害。
- en: On the subject of reputation, credential stuffing also imposes a reasonable
    economic impact. Research from the **Ponemon Institute** ([https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks](https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks))
    concluded that the average cost of this type of attack is around USD $6 million,
    including the expenses of incident response, customer notification, compliance,
    and regulatory fines. That’s without accounting for reputation. This is enough
    to bankrupt many small companies. To mitigate such threats, robust security measures
    need to be applied such as **Multi-Factor Authentication** (**MFA**), **User Entity
    and Behavior Analytics** (**UEBA**), and anomaly detection (nowadays, this is
    usually implemented with a **Machine Learning** (**ML**) solution).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在声誉问题上，凭证填充攻击也会带来相当大的经济影响。**Ponemon Institute**的研究（[https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks](https://ag.ny.gov/publications/business-guide-credential-stuffing-attacks)）得出结论，这种类型的攻击平均成本约为600万美元，其中包括事件响应、客户通知、合规和监管罚款的费用。还不包括声誉损失。这足以让许多小公司破产。为了减轻此类威胁，需要应用强大的安全措施，例如**多因素认证**（**MFA**）、**用户实体和行为分析**（**UEBA**）以及异常检测（现在通常通过**机器学习**（**ML**）解决方案实现）。
- en: Creating the dummy target
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟目标
- en: 'Credential stuffing is usually implemented with automated tools, such as **Sentry
    MBA**, **Snipr**, or **OpenBullet**. We will apply **OpenBullet 2** ([https://github.com/openbullet/OpenBullet2](https://github.com/openbullet/OpenBullet2)),
    a superset of the initial version, to implement our attack. For that sake, the
    following dummy API will be used as a target. This code is available at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证填充通常通过自动化工具实现，如**Sentry MBA**、**Snipr**或**OpenBullet**。我们将使用**OpenBullet 2**（[https://github.com/openbullet/OpenBullet2](https://github.com/openbullet/OpenBullet2)），这是初始版本的超集，来实现我们的攻击。为此，以下虚拟API将作为目标。该代码可在[https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/api_credential.py)找到：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Observe that the API has a single endpoint, to deal with the login process.
    It also has a function that applies a basic rate-limiting control. When the number
    of failed attempts is greater than or equal to five in one minute, the request
    is denied. There are only two dummy users. As we did not actually steal any credentials,
    we will create a file with other dummy usernames and passwords, including the
    ones present in the API. The purpose here is just to show that this logic is vulnerable
    to credential stuffing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，API 只有一个端点，用于处理登录过程。它还包含一个实现基本速率限制控制的功能。当一分钟内失败的尝试次数大于或等于五次时，请求将被拒绝。这里只有两个虚拟用户。由于我们并未真正窃取任何凭证，我们将创建一个包含其他虚拟用户名和密码的文件，包括
    API 中存在的那些。此处的目的是展示该逻辑易受凭证填充攻击的影响。
- en: 'We will run this API as a Docker container since, as you’ll see next, our attack
    tool will also run like that. This is not exactly required. You could also run
    the Python code directly on your host system. However, to be able to access its
    5000/TCP port from a container, you’d have to tweak the container’s network a
    bit, since this communication might not be allowed at first depending on the Docker
    version you are using. To keep it safe, it’s easier to simply run both software
    as containers. If you don’t specify anything different while starting up the container
    or in its `Dockerfile`, they will both share the same Docker network (the `bridge`
    one):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为 Docker 容器运行这个 API，因为如你所见，我们的攻击工具也将以这种方式运行。虽然这并非绝对必要，你也可以直接在宿主系统上运行 Python
    代码。但为了能从容器中访问其 5000/TCP 端口，你需要稍微调整一下容器的网络配置，因为根据你使用的 Docker 版本，默认情况下可能不允许这种通信。为了确保安全，最好将这两个软件都作为容器运行。如果在启动容器时或在其
    `Dockerfile` 中没有指定其他设置，它们将共享同一个 Docker 网络（即 `bridge` 网络）。
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Great! So, to run this Python code as a Docker container, we need a `Dockerfile`
    file. The following content is just a suggestion. You are free to use any other
    container image that includes Python. I just recommend that you choose a light
    one to keep it small. For your convenience, this Dockerfile can be downloaded
    from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！那么，为了将这段 Python 代码作为 Docker 容器运行，我们需要一个 `Dockerfile` 文件。以下内容仅为建议，你可以自由选择其他包含
    Python 的容器镜像。我推荐选择一个轻量级的镜像，以保持它的体积小。为了方便你，这个 Dockerfile 可以从 [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/Dockerfile)
    下载：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `requirements.txt` file that’s mentioned twice is a single-line file containing
    only `Flask`. I’m not sure about your Docker knowledge. So, let me give you a
    brief explanation here. This Dockerfile will expose `port 5000` (enabling other
    containers and the host itself to connect to it through this port), install Flask,
    and copy all of the current directory’s contents (including the `api_credential.py`
    Python file itself) to the container’s current directory (which is `/app`). Then,
    it will run the application. To put this container to work, type the following
    commands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所提到的 `requirements.txt` 文件是一个单行文件，只包含 `Flask`。我不确定你对 Docker 的了解程度，所以在这里简要解释一下。这个
    Dockerfile 会暴露 `port 5000`（允许其他容器和宿主机通过该端口连接），安装 Flask，并将当前目录的所有内容（包括 `api_credential.py`
    Python 文件本身）复制到容器的当前目录（即 `/app`）。然后，它会运行应用程序。要让这个容器工作，输入以下命令：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first command parses the `Dockerfile`, downloads the specified image, tags
    it as `api`, and follows the rest of the contents to finish building such an image.
    The second command effectively runs the container by mapping the host’s `port
    5000` to the container’s `port 5000`, naming it `credential_api`, and picking
    the previously built `api` image. Now we are good to move to the attack tool.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令解析 `Dockerfile`，下载指定的镜像，将其标记为 `api`，并根据其余内容完成镜像构建。第二个命令实际上通过将宿主机的 `port
    5000` 映射到容器的 `port 5000` 来运行容器，并将其命名为 `credential_api`，同时选择先前构建的 `api` 镜像。现在我们可以继续使用攻击工具了。
- en: Setting up OpenBullet2
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 OpenBullet2
- en: 'OpenBullet2 has a native client for Windows. As we are not using this operating
    system, we will go with the other option: the web client. There is more than one
    path to install this second way. You can first install Microsoft’s .NET runtime
    environment, download OpenBullet2 (which includes Windows’ DLL files), and then
    use .NET to run it. This may impose some difficulties depending on the system
    you are using. On Ubuntu, I personally prefer to take the Docker approach. You
    just need to create a directory that the container will use to store configurations
    and attacks’ captured data, and then run the following command (which is in the
    product’s documentation):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBullet2 有一个适用于 Windows 的原生客户端。由于我们不使用这个操作系统，我们将选择另一种方式：Web 客户端。安装这种方式有不止一种路径。你可以首先安装
    Microsoft 的 .NET 运行时环境，下载 OpenBullet2（其中包括 Windows 的 DLL 文件），然后使用 .NET 来运行它。根据你使用的系统，这可能会遇到一些困难。在
    Ubuntu 上，我个人更倾向于采用 Docker 方法。你只需要创建一个目录，容器将使用该目录来存储配置和攻击时捕获的数据，然后运行以下命令（此命令在产品文档中有说明）：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, I specified a local `UserData` directory under my current directory
    that will be mounted on the container as `/app/UserData` volume (the `-v` option
    means volume). This command names the container `openbullet2` (`--name`) and runs
    it in interactive mode (`-it`), which is good to allow you to watch eventual log
    messages. The container listens on port 5000, which is mapped to the host’s port
    8069\. The container will be removed after you close it (`--rm`). Just open `http://localhost:8069`
    on your preferred browser, and you will see the utility’s interface (*Figure 9**.1*).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我指定了一个本地的 `UserData` 目录，位于当前目录下，该目录会挂载到容器中作为 `/app/UserData` 卷（`-v` 选项表示卷）。该命令将容器命名为
    `openbullet2`（`--name`）并以交互模式运行（`-it`），这种模式适合让你观察日志消息。容器监听 5000 端口，并映射到主机的 8069
    端口。容器在关闭后会被移除（`--rm`）。只需在你喜欢的浏览器中打开 `http://localhost:8069`，就能看到该工具的界面（*图 9.1*）。
- en: '![Figure 9.1 – OpenBullet2’s initial screen](img/B19657_figure_09.01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – OpenBullet2 的初始界面](img/B19657_figure_09.01.jpg)'
- en: Figure 9.1 – OpenBullet2’s initial screen
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – OpenBullet2 的初始界面
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'While conducting the tests with OpenBullet2, I wasted a reasonable amount of
    time trying to understand why my attacks were not working. I’m not sure whether
    it was some bug with the version I used. The truth is that the following helped
    me fix it and put the utility to work as expected. You are good to skip this note
    and keep reading the rest of the section, but if at some stage you face errors
    such as `UserData` local directory. You’ll realize that the tool creates several
    files and directories. The only one that’s important at this moment is `Environment.ini`.
    Check its permissions and grant write permission if it doesn’t have it yet. Edit
    it and change the `WORDLIST TYPE` Default block to look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 OpenBullet2 进行测试时，我浪费了不少时间试图理解为什么我的攻击没有成功。我不确定是否是我使用的版本出现了某些 Bug。事实上，以下内容帮助我解决了这个问题，让这个工具如预期般工作。你可以跳过这一段，继续阅读接下来的部分，但如果在某个阶段你遇到了类似
    `UserData` 本地目录的错误，你会发现该工具会创建多个文件和目录。此时唯一重要的文件是 `Environment.ini`。检查它的权限，如果没有写权限，就授予它写权限。编辑该文件，将
    `WORDLIST TYPE` 默认块修改为如下所示：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we are doing here is instructing OpenBullet2 to use a colon (`:`) as a
    field separator, as well as to name the left part of such a colon `USERNAME` and
    the right part `PASSWORD`. This shouldn’t be the case, but it made a tremendous
    change to my environment. Save the file and run the container again as you did
    the first time. Now continue reading.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的，是指示 OpenBullet2 使用冒号（`:`）作为字段分隔符，并将冒号左边部分命名为 `USERNAME`，右边部分命名为 `PASSWORD`。原本不应这样做，但这对我的环境产生了巨大变化。保存文件后，像第一次一样重新启动容器。现在继续阅读。
- en: When you click on the flag, other flags and languages are presented. When this
    chapter was being written, a total of twelve languages were available! After clicking
    on your preferred language/flag, the license will be presented, and you just need
    to accept it. Also, the first time the application is running, an initial setup
    is necessary (*Figure 9**.2*).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击旗帜时，会展示其他旗帜和语言。在写这章内容时，共有十二种语言可供选择！点击你首选的语言/旗帜后，会出现许可协议，你只需接受即可。此外，第一次运行应用程序时，需要进行初始设置（*图
    9.2*）。
- en: '![Figure 9.2 – The initial setup](img/B19657_figure_09.02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 初始设置](img/B19657_figure_09.02.jpg)'
- en: Figure 9.2 – The initial setup
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 初始设置
- en: We are setting it up to run locally. Then, just click on the corresponding button.
    You also have the option to set OpenBullet2 to run on a remote host. After selecting
    the option, the setup will be finished. You will see the dashboard, which shows
    an interesting number of options and general usage statistics, including CPU,
    memory, and network consumption. Do not waste too much time on the screen shown
    in *Figure 9**.2*, as we must focus on the attack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置它以便本地运行。然后，只需点击相应的按钮。你还可以选择将 OpenBullet2 设置为在远程主机上运行。选择该选项后，设置将完成。你将看到仪表板，显示了许多有趣的选项和一般使用统计数据，包括
    CPU、内存和网络消耗。不要在*图 9**.2*所示的屏幕上浪费太多时间，因为我们必须专注于攻击。
- en: Creating a configuration and attacking
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建配置并进行攻击
- en: 'We will start the attack by creating a configuration. Follow this sequence:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建配置来开始攻击。按照以下顺序进行：
- en: Click on **Configs** on the left pane bar.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧面板上的**Configs**。
- en: On the new screen, click on **New**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新屏幕上，点击**New**。
- en: This will take you to a form where you can enter some metadata such as the config’s
    author, its name, and a graphical image located in a file or URL. This is the
    metadata part of the configuration. The other options are **Readme**, **Stacker**,
    **LoliCode**, **Settings**, and **C# Code**. It’s important to note that you can
    put C# code as part of the configuration. It will be executed by OpenBullet2 as
    part of the attack. When starting, the application logs a warning message to notify
    you that you shouldn’t run it as administrator or root due to the fact that binary
    code will be executed, and such code can bypass your host system’s security controls.
    *Figure 9**.3* shows OpenBullet2’s dashboard.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将带你进入一个表单，在其中你可以输入一些元数据，如配置的作者、名称，以及存储在文件或 URL 中的图像。这是配置的元数据部分。其他选项包括**Readme**、**Stacker**、**LoliCode**、**设置**和**C#
    代码**。值得注意的是，你可以将 C# 代码作为配置的一部分。它将由 OpenBullet2 执行，作为攻击的一部分。启动时，应用程序会记录一条警告信息，通知你不要以管理员或
    root 身份运行它，因为二进制代码将被执行，而此类代码可以绕过主机系统的安全控制。*图 9**.3*显示了 OpenBullet2 的仪表板。
- en: '![Figure 9.3 – The OpenBullet2 dashboard Screen](img/B19657_figure_09.03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – OpenBullet2 仪表板屏幕](img/B19657_figure_09.03.jpg)'
- en: Figure 9.3 – The OpenBullet2 dashboard Screen
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – OpenBullet2 仪表板屏幕
- en: The next figure shows the config’s metadata screen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图展示了配置的元数据屏幕。
- en: '![Figure 9.4 – The metadata part of the configuration](img/B19657_figure_09.04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 配置的元数据部分](img/B19657_figure_09.04.jpg)'
- en: Figure 9.4 – The metadata part of the configuration
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 配置的元数据部分
- en: Just write a name for the configuration itself and an author name. Leave the
    rest as its defaults. *Figure 9**.5* shows the warning message when you start
    the application.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需为配置本身写一个名称和作者名称。将其余部分保留为默认设置。*图 9**.5*显示了启动应用程序时的警告信息。
- en: '![Figure 9.5 – The startup warning message](img/B19657_figure_09.05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 启动警告信息](img/B19657_figure_09.05.jpg)'
- en: Figure 9.5 – The startup warning message
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 启动警告信息
- en: 'Before continuing with the configuration, we need to recall that both OpenBullet2
    and the API are running as containers. This means that they have received IP addresses
    belonging to Docker’s bridge network. The IP segment may change according to the
    Docker engine version and the system you are running, so you need to check which
    addresses were assigned to them. The host usually picks the first address of the
    block. In my case, which looks like this:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续配置之前，我们需要回顾一下 OpenBullet2 和 API 都是作为容器运行的。这意味着它们已经获得了属于 Docker 桥接网络的 IP 地址。IP
    段可能会根据 Docker 引擎版本和你正在运行的系统而变化，因此你需要检查它们被分配的地址。主机通常会选择该块的第一个地址。在我的情况下，像这样：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: $ docker inspect -f \
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ docker inspect -f \
- en: '''{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'' credential_api'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'' credential_api'
- en: 172.17.0.3). Let’s get back to our process.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 172.17.0.3）。让我们回到我们的流程。
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you want to create some text to describe what it is about, which is useful
    when more people are using the same instance, you can go to the **Readme** section
    and write some instructions there. Now click on **Stacker**. There, we can tell
    OpenBullet2 how the attack must be carried out. You will see that the stack is
    currently empty.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想创建一些文字来描述它的内容，当更多的人使用相同实例时，这会很有用，你可以进入**Readme**部分并在那里写一些说明。现在点击**Stacker**。在这里，我们可以告诉
    OpenBullet2 攻击应如何进行。你会看到当前堆栈为空。
- en: Click on the green plus sign to create a new stack config. This will open the
    **Add** **block** window.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色加号以创建一个新的堆栈配置。这将打开**添加** **块**窗口。
- en: Click on **Requests** | **Http** | **Http Request** (*Figure 9**.6*).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Requests** | **Http** | **Http Request** (*图 9**.6*)。
- en: '![Figure 9.6 – Inserting an HTTP request block to the stack config](img/B19657_figure_09.06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 将 HTTP 请求块插入堆栈配置](img/B19657_figure_09.06.jpg)'
- en: Figure 9.6 – Inserting an HTTP request block to the stack config
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 将 HTTP 请求块插入堆栈配置
- en: 'You are back to the stack config screen where all of the request’s details
    can be edited. We’ll have to change the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会回到堆栈配置屏幕，在这里你可以编辑请求的所有细节。我们需要更改以下内容：
- en: Set `URL` to `http://172.17.0.2:5000/login` (recall that the API’s endpoint
    is `/login`).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `URL` 设置为 `http://172.17.0.2:5000/login`（记住 API 的端点是 `/login`）。
- en: Change the `POST`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改 `POST`。
- en: 'Under `Content-Type: application/json`.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `Content-Type: application/json` 下。'
- en: 'Under **Content**, type what you want to send as the request’s body. It will
    consist of a simple JSON structure:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Content** 下，输入你希望作为请求主体发送的内容。它将包含一个简单的 JSON 结构：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `<input.USERNAME>` and `<input.PASSWORD>` parts will be replaced by lines
    in the `credentials.txt` file that we will create later.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<input.USERNAME>` 和 `<input.PASSWORD>` 部分将被我们稍后创建的 `credentials.txt` 文件中的行替换。'
- en: When reading a wordlist (you’ll see this later on), OpenBullet2 will iteratively
    pick each line of the `credentials.txt` file and consider the left part of the
    colon as `input.USERNAME` and the right part as `input.PASSWORD`. The dynamically
    built JSON string will then be sent to the API endpoint as login information.
    This will provide you with something like *Figure 9**.7*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读单词列表时（稍后你会看到这个），OpenBullet2 会逐行处理 `credentials.txt` 文件，每次把冒号左边的部分当作 `input.USERNAME`，右边的部分当作
    `input.PASSWORD`。动态构建的 JSON 字符串将作为登录信息发送到 API 端点。这将为你提供类似 *图 9**.7* 的内容。
- en: '![Figure 9.7 – Configuring the attack HTTP request](img/B19657_figure_09.07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 配置攻击 HTTP 请求](img/B19657_figure_09.07.jpg)'
- en: Figure 9.7 – Configuring the attack HTTP request
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 配置攻击 HTTP 请求
- en: We must analyze what the API is sending us as a response. Hence, we need to
    add another block. Click on the green plus sign again to add a new block. You
    won’t see it at first. Type **key** into the search bar and press **Search**.
    Select the **Keycheck** block (*Figure 9**.8*).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须分析 API 返回的响应。因此，我们需要添加另一个块。再次点击绿色的加号以添加新块。一开始你可能看不见它。输入 **key** 到搜索栏并点击
    **搜索**。选择 **Keycheck** 块 (*图 9**.8*)。
- en: '![Figure 9.8 – Adding a Keycheck control block](img/B19657_figure_09.08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 添加 Keycheck 控制块](img/B19657_figure_09.08.jpg)'
- en: Figure 9.8 – Adding a Keycheck control block
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 添加 Keycheck 控制块
- en: 'You will be sent back to the stack config screen. Do this to finish the request
    config:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你将返回到堆栈配置屏幕。执行以下操作以完成请求配置：
- en: Click on the other green plus sign that is available under the **Keychains:**
    string.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击位于 **Keychains:** 字符串下方的另一个绿色加号。
- en: Make sure that **Result Status** is set as **SUCCESS**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 **Result Status** 设置为 **SUCCESS**。
- en: Click on the **+String** button. This will open a few text boxes.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **+String** 按钮，这将打开几个文本框。
- en: Select **Contains** on the combo box and type **Login successful** in the textbox
    right beside it.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉框中选择 **Contains**，并在旁边的文本框中输入 **Login successful**。
- en: 'Repeat *steps 1* to *4* but with the following changes:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 1* 到 *4*，但做以下更改：
- en: For `Invalid credentials`.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `无效的凭证`。
- en: You will see something like *Figure 9**.9*.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到类似 *图 9**.9* 的内容。
- en: '![Figure 9.9 – Configuring the expected successful and failed responses.](img/B19657_figure_09.09.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 配置期望的成功和失败响应。](img/B19657_figure_09.09.jpg)'
- en: Figure 9.9 – Configuring the expected successful and failed responses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 配置期望的成功和失败响应。
- en: 'Save the config using the `credentials.txt` and insert the following contents.
    For your convenience, this file can be downloaded from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `credentials.txt` 保存配置，并插入以下内容。为方便起见，你可以从 [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/credential_stuffing/credentials.txt)
    下载此文件：
- en: '[PRE9]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will put actual credentials that, in our case, are hardcoded into the API’s
    application among other useless values. Back to the utility’s interface, do the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入实际的凭证，在我们的例子中，它们是硬编码在 API 应用程序中的，以及其他一些无用的值。回到工具的界面，执行以下操作：
- en: Click on **Wordlists** on the left pane.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧窗格中的 **Wordlists**。
- en: On this new screen, click on **+Add**. This will open a new window.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新页面中，点击**+添加（+Add）**。这将打开一个新窗口。
- en: Change **My Wordlist** to **Credentials**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**我的字典文件（My Wordlist）**改为**凭证（Credentials）**。
- en: Click on the `credentials.txt` file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`credentials.txt`文件。
- en: Click on the **Upload** button.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**上传（Upload）**按钮。
- en: Your wordlist-adding screen will look like *Figure 9**.10*.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的字典文件添加界面将显示为*图 9.10*。
- en: '![Figure 9.10 – Adding a wordlist](img/B19657_figure_09.10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 添加字典文件](img/B19657_figure_09.10.jpg)'
- en: Figure 9.10 – Adding a wordlist
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 添加字典文件
- en: You will be taken back to the wordlists screen, and you’ll see the one you just
    added with the number of parsed lines (five). The next step we need to follow
    is to create a job to combine the configuration and the wordlist to actually send
    packets to the API. Click on **Jobs** on the left pane. On this screen, click
    on the green **+New** button to add a job. Click on the **Multi Run** button.
    At this stage, it’s important for you to know that you can leverage proxy serves
    to split the requests. OpenBullet2 comes with an empty **Default** proxy group.
    You can go to the **Proxies** area and either manually add their URLs or import
    them, either via URLs or text files. We won’t use proxies in our example.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将返回字典文件页面，看到刚刚添加的字典文件，并且显示已解析的行数（五行）。接下来的步骤是创建一个任务，将配置与字典文件结合，实际向 API 发送数据包。点击左侧面板的**任务（Jobs）**。在这个界面中，点击绿色的**+新建（+New）**按钮添加一个任务。点击**多次运行（Multi
    Run）**按钮。在此阶段，了解你可以利用代理服务器来拆分请求是非常重要的。OpenBullet2 配备了一个空的**默认（Default）**代理组。你可以进入**代理（Proxies）**区域，手动添加代理
    URL 或导入它们，可以通过 URL 或文本文件导入。在我们的示例中，我们不会使用代理。
- en: Click on the **Select Config** button. This will open a window showing all configs
    you have saved. As we only save the one we just created, click on it and push
    **Select** (*Figure 9**.11*).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**选择配置（Select Config）**按钮。这将打开一个窗口，显示你保存的所有配置。由于我们只保存了刚创建的配置，点击它并点击**选择（Select）**（*图
    9.11*）。
- en: '![Figure 9.11 – Selecting the config to be part of the job](img/B19657_figure_09.11.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 选择要作为任务一部分的配置](img/B19657_figure_09.11.jpg)'
- en: Figure 9.11 – Selecting the config to be part of the job
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 选择要作为任务一部分的配置
- en: After selecting it, you will be back to the job definition screen that’s now
    updated with the selected config. Click on the **Select wordlist** button located
    on the right of this screen. This will open another window will all the saved
    wordlists you have. As you have only added a single wordlist, it will be the only
    one showing up. Observe that, once you select the wordlist you’d like to add to
    the job, its contents will be displayed on the bottom part of this window. This
    is good to do a final visual check and attest whether they are as expected. Click
    on the green **Select** button (*Figure 9**.12*).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件后，你将返回到更新后的任务定义页面，页面上已更新为选择的配置。点击此界面右侧的**选择字典文件（Select wordlist）**按钮。这将打开另一个窗口，显示你保存的所有字典文件。由于你只添加了一个字典文件，它将是唯一显示的。观察到，一旦选择了要添加到任务中的字典文件，它的内容将在窗口底部显示出来。这对于做最终的视觉检查和确认文件内容是否如预期非常有用。点击绿色的**选择（Select）**按钮（*图
    9.12*）。
- en: '![Figure 9.12 – Adding a wordlist to the job](img/B19657_figure_09.12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 将字典文件添加到任务](img/B19657_figure_09.12.jpg)'
- en: Figure 9.12 – Adding a wordlist to the job
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 将字典文件添加到任务
- en: We are back to the job definition screen. Scroll down the screen a little bit
    until you see the green **Create Job** button. Push it. If you have done something
    wrong with the job, you can change the job definition by clicking on the corresponding
    button. Otherwise, you can shoot the job with the **Start** button. Do it! As
    our wordlist is small and we are running everything locally, the job will finish
    quickly. All valid credentials (**Hits**) are located under the control buttons.
    **Fails** and skipped lines also have their stats lines (*Figure 9**.13*).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们回到了任务定义页面。稍微向下滚动，直到看到绿色的**创建任务（Create Job）**按钮。点击它。如果你在任务中做错了什么，可以通过点击相应按钮更改任务定义。否则，你可以通过**开始（Start）**按钮启动任务。做吧！由于我们的字典文件很小，并且所有操作都在本地进行，任务将很快完成。所有有效的凭证（**命中（Hits）**）会显示在控制按钮下方。**失败（Fails）**和跳过的行也会有它们的统计信息行（*图
    9.13*）。
- en: '![Figure 9.13 – The results after running an attack job; valid credentials
    are shown in green](img/B19657_figure_09.13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 运行攻击任务后的结果；有效的凭证以绿色显示](img/B19657_figure_09.13.jpg)'
- en: Figure 9.13 – The results after running an attack job; valid credentials are
    shown in green
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 运行攻击任务后的结果；有效的凭证以绿色显示
- en: Now that this lab is complete, let’s learn more about other important topics.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实验已经完成，让我们学习更多其他重要的主题。
- en: Other features and security recommendations
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他功能和安全建议
- en: OpenBullet2 has many other features that can be useful depending on the pentesting
    scenario you are facing. It suffered a revamp since the initial version and now
    has the web client option, which is quite handy when the testing system is not
    Windows. By the way, OpenBullet was initially designed and built as a .NET application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBullet2 还有许多其他功能，可以根据你面临的渗透测试场景发挥作用。自初版以来，它经历了改版，现在有了网页客户端选项，当测试系统不是 Windows
    时非常方便。顺便提一下，OpenBullet 最初是作为一个 .NET 应用程序设计和构建的。
- en: To get protected against credential stuffing, APIs should apply MFA. Rate limiting
    adds another protection layer since it reduces the impact of automated tools (such
    as OpenBullet2) carrying out too many login attempts in a specific timeframe.
    Finally, anomaly detection solutions, especially nowadays with the rich feature
    sets enabled by **Artificial Intelligence** (**AI**) and ML, are worth considering
    because they can track and analyze multiple different types of evidence at the
    same time, such as unusual login patterns, multiple failures from different geographic
    locations (something that can occur when you apply proxies), and notification
    of sysadmins based on some thresholds. In the next section, we will explore data
    scraping.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止凭证填充攻击，API 应该应用多因素认证（MFA）。速率限制提供了另一层保护，因为它能减少自动化工具（如 OpenBullet2）在特定时间范围内进行过多登录尝试的影响。最后，异常检测解决方案，尤其是在如今由**人工智能**（**AI**）和机器学习（ML）提供的丰富功能支持下，值得考虑，因为它们可以同时追踪和分析多种不同类型的证据，例如异常登录模式、来自不同地理位置的多次失败尝试（当使用代理时可能会发生这种情况），以及根据一些阈值通知系统管理员。在下一部分，我们将探讨数据抓取。
- en: Data scraping
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据抓取
- en: Data scraping consists of extracting data from websites or APIs in an automated
    way, usually without proper authorization. It’s not always criminal though. You
    can be conducting research and need to aggregate publicly available data; this
    is legitimate. Nonetheless, it becomes a real problem when the target is private
    or sensitive data. APIs handling data exchanges between multiple systems may be
    particularly vulnerable to this threat since they can expose structured data using
    machine-readable formats, which makes the automated extraction even easier. With
    the large adoption of APIs, a part of which is driven by cloud providers, the
    attack surface has dramatically increased.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抓取是指通过自动化方式从网站或 API 中提取数据，通常是在没有适当授权的情况下进行的。不过，这并不总是犯罪行为。你可能正在进行研究并需要聚合公开的数据；这种行为是合法的。然而，当目标是私人或敏感数据时，这就成为了一个真正的问题。处理多个系统之间数据交换的
    API 可能特别容易受到这种威胁，因为它们可能会以机器可读格式公开结构化数据，这使得自动提取变得更加容易。随着 API 的广泛采用，部分由云服务提供商推动，这种攻击面已经大大增加。
- en: 'Pentesters apply several tools and techniques to achieve success with this.
    The tools can vary from simple code written in Python or **Golang** to more sophisticated
    frameworks such as Scrapy, which we will exemplify in this section. Scrapy can
    handle very large data masses at once. Another notable example is **Selenium**,
    which is normally used to scrape dynamic content rendered by client-side JavaScript.
    The behavior is pretty much the same: these tools send requests to the API endpoints
    simulating human beings. These tools can be configured to adapt to different specificities
    presented by some endpoints, such as pagination, tokenization, rate limiting,
    and more. Being as adaptable and as human as this makes it easier for such tools
    to bypass some security countermeasures. One common evasion technique is switching
    source IP addresses (which can be accomplished with botnets) or employing proxy
    servers.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员使用多种工具和技术来实现这一目标。这些工具可以从简单的 Python 代码或**Golang**到更复杂的框架，如 Scrapy，后者将在本节中进行示例。Scrapy
    可以一次处理非常大的数据集。另一个值得注意的例子是**Selenium**，它通常用于抓取由客户端 JavaScript 渲染的动态内容。其行为基本相同：这些工具通过模拟人类向
    API 端点发送请求。这些工具可以被配置以适应某些端点所呈现的不同特性，例如分页、令牌化、速率限制等。因为它们如此适应性强且像人类一样，这使得这些工具更容易绕过一些安全防护措施。一种常见的规避技术是切换源
    IP 地址（可以通过僵尸网络实现）或使用代理服务器。
- en: Unauthorized data scraping can be extremely damaging for companies and organizations.
    They can lead to sensitive data thefts and/or leaks. Things such as user profiles,
    private datasets, financial records, intellectual property information, health
    records, or scholarly history are some examples of possible targets. Aside from
    financial and reputational damage, enterprises and their representatives can face
    legal outcomes, depending on the proportion of the leak and the nature of the
    leaked data. This can include trials and even imprisonment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 未经授权的数据抓取可能对公司和组织造成极大的损害。它们可能导致敏感数据的窃取和/或泄露。用户配置文件、私人数据集、财务记录、知识产权信息、健康记录或学术历史等内容都可能成为攻击的目标。除了财务和声誉损失外，企业及其代表可能会因泄露的数据比例和泄露数据的性质而面临法律后果。这可能包括审判甚至监禁。
- en: In the next sub-sections, you’ll create and run a dummy target API and write
    some code to attack it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，您将创建并运行一个虚拟的目标API，并编写一些攻击代码。
- en: Raising the dummy target
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升虚拟目标
- en: 'To practice data scraping, we will use the following GraphQL dummy API as a
    target. For your convenience, this code can be downloaded from [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习数据抓取，我们将使用以下GraphQL虚拟API作为目标。为了方便您，可以从[https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/api_scraping.py)下载此代码：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Observe that the API establishes a basic authentication mechanism through a
    pair of credentials (`admin` and `password`). When they are successfully sent
    by the client, a JWT is created and sent back. The only available endpoint (`/graphql`)
    only works when a valid JWT is presented by the client (enforced by the `@jwt_required()`
    decorator). The data itself is the user database. It’s our target.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，API通过一对凭证（`admin`和`password`）建立了基本的身份验证机制。当客户端成功发送它们时，将创建并返回一个JWT。唯一可用的端点（`/graphql`）仅在客户端提交有效JWT时才起作用（由`@jwt_required()`装饰器强制执行）。数据本身是用户数据库。这是我们的目标。
- en: 'To run the code, you’ll need to install a few other Python modules. To be safe,
    simply type the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，您需要安装几个其他Python模块。为了安全起见，只需键入以下内容：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You are good to put the API to run. Now, let’s focus on the attacking code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您已准备好运行API。现在，让我们专注于攻击代码。
- en: Putting the attack to work
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让攻击生效
- en: 'First, you must install Scrapy with `pip`. Then, create a project and enter
    its directory with the following commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须使用`pip`安装Scrapy。然后，使用以下命令创建一个项目并进入其目录：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since we need to authenticate first, part of the code is dedicated to performing
    multiple authentication attempts until a valid credential pair is found. There’s
    a class named `BruteForcespider`. Everything starts with the `start_requests()`
    method. This is specified by Scrapy’s spider definition (which will be explained
    later on), and it iterates through the hardcoded credential pairs. Every time
    a request is sent, the code calls the `parse_login()` method to analyze the result.
    When the token is present in a result, it means that the authentication was successful.
    So, the code executes the GraphQL query to request the user database. Finally,
    the `parse_users()` method is invoked to print the gathered data. The `bruteforce_spider.py`
    code can be found at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要首先进行身份验证，代码的一部分专门用于执行多个身份验证尝试，直到找到有效的凭据对为止。有一个名为`BruteForcespider`的类。一切都始于`start_requests()`方法。这是由Scrapy的爬虫定义指定的（稍后将对其进行解释），它会遍历硬编码的凭据对。每次发送请求时，代码都会调用`parse_login()`方法来分析结果。当结果中出现令牌时，这意味着身份验证成功。因此，代码执行GraphQL查询以请求用户数据库。最后，调用`parse_users()`方法以打印收集到的数据。可以在[https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/data_scraping/bruteforce_spider.py)找到`bruteforce_spider.py`代码。
- en: 'Before we can run the code, we must create a Scrapy project. This is accomplished
    with the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行代码之前，我们必须创建一个Scrapy项目。以下是完成这一任务的步骤：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When created, the `graphqlscraper` project is represented by a directory where
    several other files are inserted as well:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时，`graphqlscraper`项目由一个目录表示，其中还插入了几个其他文件：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code is located inside the `spiders` subdirectory. To run it, type the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码位于 `spiders` 子目录中。要运行它，请键入以下命令：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This instructs Scrapy to start a crawler whose class can be found inside the
    `bruteforce_spider.py` file. The output is sent to `users.json`. After a few seconds,
    you should receive the chatty output of Scrapy:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 Scrapy 启动一个爬虫，其类可以在 `bruteforce_spider.py` 文件中找到。输出被发送到 `users.json`。几秒钟后，你应该会收到
    Scrapy 的详细输出：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: $ more graphqlscraper/spiders/users.json
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: $ more graphqlscraper/spiders/users.json
- en: '['
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '{"ID": "1", "Name": "Alice", "Email": "alice@example.com"},'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '{"ID": "1", "Name": "Alice", "Email": "alice@example.com"},'
- en: '{"ID": "2", "Name": "Bob", "Email": "bob@example.com"},'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '{"ID": "2", "Name": "Bob", "Email": "bob@example.com"},'
- en: '{"ID": "3", "Name": "Charlie", "Email": "charlie@example.com"}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '{"ID": "3", "Name": "Charlie", "Email": "charlie@example.com"}'
- en: ']'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: $ curl http://localhost:5000/api/user/1
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl http://localhost:5000/api/user/1
- en: '{'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"id": 1,'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"id": 1,'
- en: '"name": "Alice",'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"name": "Alice",'
- en: '"email": "alice@example.com",'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"email": "alice@example.com",'
- en: '"role": "user"'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"role": "user"'
- en: 'admin_secret) password to provide special access, we can manipulate the role
    parameter with a single request in Python and make *Alice* an administrator (this
    code can be downloaded from https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_role.py):'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: admin_secret) 密码提供特殊访问权限，我们可以通过 Python 发出一个请求来操作角色参数，将 *Alice* 设置为管理员（此代码可以从
    https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter09/parameter_tampering/manipulate_role.py
    下载）：
- en: '[PRE18]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '{'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "User role updated"'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message": "用户角色已更新"'
- en: '}'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE20]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ curl http://localhost:5000/api/user/1
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl http://localhost:5000/api/user/1
- en: '{'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"id": 1,'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"id": 1,'
- en: '"name": "Alice",'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"name": "Alice",'
- en: '"email": "alice@example.com",'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"email": "alice@example.com",'
- en: '"role": "admin"'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"role": "admin"'
- en: '/transaction one deals with financial information. To retrieve some data, we
    need to provide the transaction ID. We might infer the numerical sequence (how
    about 1?):'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /transaction 一笔交易涉及金融信息。为了检索一些数据，我们需要提供交易 ID。我们可以推测数值顺序（比如 1？）：
- en: '[PRE21]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: import requests
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import requests
- en: data = {
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: data = {
- en: '''transaction_id'': ''1'','
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''transaction_id'': ''1'','
- en: '''status'': ''completed'','
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''status'': ''completed'','
- en: '''auth'': ''admin_secret'''
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''auth'': ''admin_secret'''
- en: '}'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: response = requests.post(
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = requests.post(
- en: '''http://localhost:5000/api/admin/update_status'', data=data'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''http://localhost:5000/api/admin/update_status'', data=data'
- en: )
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: print(response.json())
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(response.json())
- en: '[PRE22]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '{'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "Transaction status updated"'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message": "交易状态已更新"'
- en: '}'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE23]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: $ curl http://localhost:5000/api/transaction/1
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl http://localhost:5000/api/transaction/1
- en: '{'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"id": 1,'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"id": 1,'
- en: '"user_id": 1,'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"user_id": 1,'
- en: '"amount": 100,'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"amount": 100,'
- en: '"status": "completed"'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"status": "completed"'
- en: '/admin/update_status endpoint without providing the corresponding password:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /admin/update_status 端点未提供相应的密码：
- en: '[PRE25]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: import requests
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import requests
- en: data = {
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: data = {
- en: '''auth'': ''admin_secret'''
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''auth'': ''admin_secret'''
- en: '}'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: response = requests.post(
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = requests.post(
- en: '''http://localhost:5000/api/admin/update_status'', data=data'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''http://localhost:5000/api/admin/update_status'', data=data'
- en: )
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: print(response.json())
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(response.json())
- en: '[PRE27]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '{'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"super_secret": "This is top secret data!"'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"super_secret": "这是机密数据！"'
- en: '}'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: $ safety scan --target .
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: $ safety scan --target .
- en: Please login or register Safety CLI (free forever) to scan and secure your projects
    with Safety
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请登录或注册 Safety CLI（永久免费）以扫描并保护你的项目
- en: '(R)egister for a free account in 30 seconds, or (L)ogin with an existing account
    to continue (R/L): R'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (R)egister 免费帐户或 (L)ogin 登录现有帐户继续（R/L）：R
- en: Redirecting your browser to register for a free account. Once registered, return
    here to start using Safety.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正在将你的浏览器重定向到注册页面以获取免费帐户。注册后，返回此处开始使用 Safety。
- en: 'If the browser does not automatically open in 5 seconds, copy and paste this
    url into your browser:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器在 5 秒内没有自动打开，请将此 URL 复制并粘贴到浏览器中：
- en: <<<A dynamic URL is presented here.>>>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <<<这里是动态 URL。>>>
- en: '[=   ] waiting for browser authenticationupdate.go:85: cannot change mount
    namespace according to change mount (/var/lib/snapd/hostfs/usr/local/share/doc
    /usr/local/share/doc none bind,ro 0 0): cannot open directory "/usr/local/share":
    permission denied'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[=   ] 等待浏览器认证 update.go:85: 无法根据更改挂载命名空间更改挂载（/var/lib/snapd/hostfs/usr/local/share/doc
    /usr/local/share/doc none bind,ro 0 0）：无法打开目录 "/usr/local/share"：权限被拒绝'
- en: '[  ==] waiting for browser authenticationGtk-Message: 22:45:48.735: Not loading
    module "atk-bridge": The functionality is provided by GTK natively. Please try
    to not load it.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[  ==] 等待浏览器认证 Gtk-Message: 22:45:48.735: 未加载模块 "atk-bridge"：该功能由 GTK 原生提供。请尝试不要加载它。'
- en: Successfully registered address@domain.com
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 成功注册 address@domain.com
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Part 5: API Security Best Practices'
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分：API 安全最佳实践
- en: This is the final part of the book. You have been learning how to discover,
    get information on, and attack APIs in different scenarios. Throughout the previous
    parts, vulnerable code has been presented to you with exploitable points in RESTful
    and GraphQL APIs. In this part, you will understand that a reasonable portion
    of security problems with APIs originate from bad coding practices. Knowing best
    practices is vital for securing APIs in a more appropriate way. When a pentester
    gets more acquainted with how the API code was written and which parts were ignored
    or forgotten by the developers, this can definitely help in the invasion journey.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一部分。你已经学习了如何在不同的场景中发现、获取信息并攻击 APIs。在前面的章节中，我们向你展示了具有漏洞的代码，包含可被利用的点，涉及
    RESTful 和 GraphQL APIs。在这一部分，你将理解到，API 安全问题的一部分原因来源于糟糕的编码实践。了解最佳实践对于以更恰当的方式保护
    API 至关重要。当渗透测试人员更加熟悉 API 代码是如何编写的，以及哪些部分被开发人员忽略或遗忘时，这无疑会在入侵过程中提供帮助。
- en: 'This section contains the following chapter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 10*](B19657_10.xhtml#_idTextAnchor153), *Secure Coding Practices
    for APIs*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 10 章*](B19657_10.xhtml#_idTextAnchor153)，*API 的安全编码实践*'
