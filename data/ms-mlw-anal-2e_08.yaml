- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Handling Exploits and Shellcode
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理漏洞利用和 shellcode
- en: At this stage, we are already aware of the different types of malware. What
    is common among most of them is that they are standalone and can be executed on
    their own once they reach the targeted system. However, this is not always the
    case, and some of them are only designed to work properly with the help of targeted
    legitimate applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经了解了不同类型的恶意软件。大多数恶意软件的共同点是它们是独立的，一旦进入目标系统便能自行执行。然而，并非所有情况都如此，其中一些恶意软件设计时需要借助目标合法应用程序才能正常工作。
- en: In our everyday life, we interact with multiple software products that serve
    various purposes, from showing us pictures of cats to managing nuclear power plants.
    Thus, there is a specific category of threats that aim to leverage vulnerabilities
    hidden in such software to achieve their purposes, whether it is to penetrate
    the system, escalate privileges, or crash the target application or system to
    disrupt some important process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们日常生活中，我们与多种软件产品交互，它们的功能各异，从展示猫咪图片到管理核电站。因此，有一个特定类别的威胁，旨在利用这些软件中隐藏的漏洞来实现它们的目的，无论是渗透系统、提升特权，还是崩溃目标应用程序或系统，从而破坏一些重要的进程。
- en: 'In this chapter, we will be talking about exploits and learning how to analyze
    them. To that end, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论漏洞利用以及如何分析它们。为此，我们将涵盖以下主题：
- en: Getting familiar with vulnerabilities and exploits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉漏洞和漏洞利用
- en: Cracking the shellcode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解 shellcode
- en: Exploring bypasses for exploit mitigation technologies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索绕过漏洞利用缓解技术
- en: Analyzing Microsoft Office exploits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 Microsoft Office 漏洞利用
- en: Studying malicious PDFs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究恶意 PDF 文件
- en: Getting familiar with vulnerabilities and exploits
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉漏洞和漏洞利用
- en: In this section, we will cover what major categories of vulnerabilities and
    exploits exist and how they are related to each other. We will explain how an
    attacker can take advantage of a bug (or multiple bugs) to take control of the
    application (or maybe the whole system) by performing unauthorized actions in
    its context.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍存在的主要漏洞和漏洞利用类别，以及它们之间的关系。我们将解释攻击者如何利用一个或多个漏洞，在应用程序（甚至整个系统）上下文中执行未经授权的操作，从而控制应用程序（或整个系统）。
- en: Types of vulnerabilities
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞的类型
- en: A vulnerability is a bug or weakness inside an application that can be exploited
    or abused by an attacker to perform unauthorized actions. There are various types
    of vulnerabilities, most of which are caused by insecure coding practices and
    mistakes. You should pay attention when processing any input controlled by the
    end user, including environment variables and dependency modules. In this section,
    we will explore the most common cases and learn how attackers can leverage them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞是指应用程序内部的错误或弱点，攻击者可以利用这些漏洞执行未经授权的操作。漏洞有多种类型，大多数是由于不安全的编码实践和错误引起的。你应该在处理任何由终端用户控制的输入时特别小心，包括环境变量和依赖模块。在本节中，我们将探讨最常见的漏洞类型，并了解攻击者如何利用它们。
- en: The stack overflow vulnerability
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈溢出漏洞
- en: The **stack overflow** vulnerability is one of the most common vulnerabilities
    and the one that is generally addressed first by exploit mitigation technologies.
    Its risk has been reduced in recent years thanks to new improvements such as the
    introduction of the **Data** **Execution Prevention/No Execute** (**DEP/NX**)
    technique, which will be covered in greater detail in the *Exploring bypasses
    for exploit mitigation technologies* section. However, under certain circumstances,
    it can still be successfully exploited or at least used to perform a **Denial
    of Service** (**DoS**) attack.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈溢出**漏洞是最常见的漏洞之一，也是漏洞利用缓解技术通常首先解决的漏洞。近年来，由于引入了**数据执行保护/不可执行**（**DEP/NX**）技术，其风险已经得到了降低，相关内容将在《探索绕过漏洞利用缓解技术》一节中详细讨论。然而，在某些情况下，它仍然可以被成功利用，或者至少被用来执行**拒绝服务**（**DoS**）攻击。'
- en: 'Let’s take a look at the following simple application written in C:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下用 C 语言编写的简单应用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you know, the space for the `Buffer[80]` variable (as any local variable)
    is allocated on the stack, followed by the EBP register’s value, which is pushed
    at the beginning of the function prologue, and the return address:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`Buffer[80]` 变量的空间（就像任何局部变量一样）是分配在栈上的，紧接着是 EBP 寄存器的值，它会在函数序言的开始时被压入栈中，之后是返回地址：
- en: '![Figure 8.1 – Local variable representations in the stack'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 栈中的局部变量表示]'
- en: '](img/Figure_8.1_B18500.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B18500.jpg)'
- en: Figure 8.1 – Local variable representations in the stack
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 栈中局部变量的表示
- en: 'So, by simply passing an argument to this application that’s longer than 80
    bytes, the attacker can overwrite all the buffer space, as well as the EBP and
    the return address. It can take control of the address from which this application
    will continue executing after the vulnerable function finishes. The following
    diagram demonstrates overwriting `Buffer[80]` and the return address with shellcode:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过简单地向该应用程序传递一个超过 80 字节的参数，攻击者可以覆盖所有的缓冲区空间，以及 EBP 和返回地址。这可以控制该应用程序在脆弱函数执行完毕后继续执行的地址。以下图示演示了如何用
    shellcode 覆盖 `Buffer[80]` 和返回地址：
- en: '![Figure 8.2 – Overwriting Buﬀer[80] and the return address with shellcode'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 用 shellcode 覆盖 Buﬀer[80] 和返回地址'
- en: '](img/Figure_8.2_B18500.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B18500.jpg)'
- en: Figure 8.2 – Overwriting Buﬀer[80] and the return address with shellcode
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 用 shellcode 覆盖 Buﬀer[80] 和返回地址
- en: This is the most basic stack overflow vulnerability. Now, let’s look at other
    common types of vulnerabilities, such as **heap overflow**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本的栈溢出漏洞。现在，让我们来看看其他常见的漏洞类型，比如 **堆溢出**。
- en: Heap overflow vulnerabilities
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆溢出漏洞
- en: 'In this case, instead of using the stack, the affected variable would be stored
    in a dynamically allocated space in memory called the `malloc`, `HeapAlloc`, or
    other similar APIs. Windows supports two types of heaps: the default one and the
    private (that is, dynamic) one(s); all of them follow the `_HEAP` structure. The
    default heap’s address is stored in the `PEB` structure in the `ProcessHeap` field
    and can be obtained by calling the `GetProcessHeap` API; private ones are returned
    by APIs such as `HeapCreate` when they are created. All heap addresses (including
    the default one) are stored in a list that’s pointed to by the `ProcessHeaps`
    field of `PEB`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，受影响的变量将不会存储在栈中，而是存储在内存中的动态分配空间中，称为 `malloc`、`HeapAlloc` 或其他类似的 API。Windows
    支持两种类型的堆：默认堆和私有堆（即动态堆）；它们都遵循 `_HEAP` 结构。默认堆的地址存储在 `PEB` 结构中的 `ProcessHeap` 字段，并可以通过调用
    `GetProcessHeap` API 获取；私有堆则通过如 `HeapCreate` 等 API 返回。所有堆地址（包括默认堆）都存储在一个由 `PEB`
    中的 `ProcessHeaps` 字段指向的列表中。
- en: 'Unlike the stack, the heap doesn’t store return addresses to make it easily
    exploitable, but there are other ways to abuse it. To understand them, first,
    we need to learn some basics about the heap structure. The data that’s used by
    the application is stored in `_HEAP_SEGMENT` structure and are pointed to in the
    `_HEAP` structure. All heap chunks contain a header (the `_HEAP_ENTRY` structure)
    and the actual data. However, when the chunk is stored as freed, following the
    `_HEAP_ENTRY` structure, it contains a linked list structure, `_LIST_ENTRY`, that
    interconnects free chunks. This structure consists of pointers to the previous
    free chunk (the `BLink` field) and the next free chunk (the `FLink` field); the
    first and the last free chunks in a list are pointed to by the `FreeList` field
    of the `_HEAP` structure. When the system needs to remove a freed chunk from this
    list (for example, when the chunk is allocated again or as part of the chunk consolidation
    process), **unlinking** will take place. It involves writing the next item’s address
    in the previous item’s next entry, and the previous item’s address in the next
    item’s previous entry to remove the chunk from a list. The corresponding code
    will look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与栈不同，堆并不存储返回地址，因此不易被利用，但也有其他方式可以滥用它。要理解这些，我们首先需要了解堆结构的一些基础知识。应用程序使用的数据存储在 `_HEAP_SEGMENT`
    结构中，并通过 `_HEAP` 结构进行引用。所有堆块都包含一个头部（即 `_HEAP_ENTRY` 结构）和实际数据。然而，当堆块被标记为已释放时，在 `_HEAP_ENTRY`
    结构之后，它会包含一个链表结构，`_LIST_ENTRY`，用于将空闲堆块连接起来。该结构包括指向前一个空闲堆块（`BLink` 字段）和下一个空闲堆块（`FLink`
    字段）的指针；链表中的第一个和最后一个空闲堆块由 `_HEAP` 结构中的 `FreeList` 字段指向。当系统需要从该链表中移除一个已释放的堆块时（例如，当该块重新分配或在块合并过程中），将会发生**解除链接**操作。此操作涉及将下一个项的地址写入前一个项的下一个项，并将前一个项的地址写入下一个项的前一个项，从而将该块从链表中移除。相应的代码如下：
- en: '![Figure 8.3 – Sample code for the unlinking process'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 解除链接过程的示例代码'
- en: '](img/Figure_8.3_B18500.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B18500.jpg)'
- en: Figure 8.3 – Sample code for the unlinking process
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 解除链接过程的示例代码
- en: By overflowing the variable stored on the heap, the attacker may be able to
    overwrite the `FLink` and `BLink` values of the adjacent chunk, which would make
    it possible to write anything at any address during the unlinking step, as shown
    in the preceding screenshot. For example, this can be used to overwrite the address
    of some existing function that’s guaranteed to be executed with an address of
    the shellcode to achieve its execution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过溢出堆上存储的变量，攻击者可能会覆盖相邻块的`FLink`和`BLink`值，这将使得在解除链接步骤中，可以在任何地址写入任何内容，如前面的截图所示。例如，这可以用来覆盖某个已存在函数的地址，该函数保证会在
    shellcode 地址处执行，从而实现其执行。
- en: Multiple mitigations have been introduced over time to combat this technique.
    Starting from Windows XP SP2, because of additional checks being introduced, attackers
    had to switch from abusing `FreeList` to the `Lookaside` list for a similar purpose.
    Starting from Windows Vista, among other changes, the `Lookaside` list was replaced
    with a `Encoding` field value, forcing attackers to explore different techniques
    such as overwriting the `_HEAP` structure. In Windows 8, Microsoft engineers introduced
    additional checks and limitations to fight this approach – and this battle is
    still ongoing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，已经引入了多种缓解措施来应对这一技术。从 Windows XP SP2 开始，由于引入了额外的检查，攻击者不得不从滥用`FreeList`转向滥用`Lookaside`列表以实现类似目的。从
    Windows Vista 开始，除了其他更改外，`Lookaside`列表被替换为`Encoding`字段值，迫使攻击者探索不同的技术，如覆盖`_HEAP`结构。在
    Windows 8 中，微软工程师引入了额外的检查和限制来对抗这一方法——这场斗争仍在继续。
- en: The use-after-free vulnerability
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用后释放漏洞
- en: This type of vulnerability is still widely used, despite all the exploit mitigations
    that were introduced in the later versions of Windows. These vulnerabilities are
    common in scripting languages such as JavaScript in browsers or PDF files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Windows 的后续版本中引入了所有的漏洞利用缓解措施，这种类型的漏洞仍然被广泛使用。这些漏洞在浏览器中的 JavaScript 或 PDF
    文件等脚本语言中很常见。
- en: 'This vulnerability occurs when an object (a structure in memory, which we will
    cover in detail in the next chapter) is still being referenced after it has been
    freed. Imagine that the code looks something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象（内存中的一个结构，我们将在下一章详细介绍）在被释放后仍然被引用时，就会发生这种漏洞。假设代码看起来像这样：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, `Buf` contains the address of the `IsAdmin` function,
    which was executed later, after the whole `Buf` variable was freed in memory.
    Do you think `address_to_a_func` will still be pointing to `IsAdmin`? Maybe, but
    if this area was reallocated in memory with another variable controlled by the
    attacker, they can set the value of `address_to_a_func` to the address of their
    choice. As a result, this could allow the attacker to execute their shellcode
    and take control of the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Buf`包含了`IsAdmin`函数的地址，该函数会在整个`Buf`变量在内存中被释放后执行。你认为`address_to_a_func`仍然会指向`IsAdmin`吗？也许会，但如果该区域在内存中被重新分配，并且由攻击者控制的另一个变量占用，它们可以将`address_to_a_func`的值设置为他们选择的地址。结果，这可能允许攻击者执行他们的
    shellcode 并控制系统。
- en: In `vtable` arrays. When a `vtable` array is overwritten and any function inside
    this table is called, the attackers can redirect the execution to their shellcode.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vtable`数组中。当`vtable`数组被覆盖并且其中任何函数被调用时，攻击者可以将执行重定向到他们的 shellcode。
- en: Integer overflow vulnerabilities
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数溢出漏洞
- en: As we know, integer values can take 1, 2, 4, or 8 bytes. Regardless of how much
    size was granted to store them, there are always some numbers that are big enough
    to not fit there. The integer overflow vulnerability happens when the attacker
    is allowed to introduce a number outside of the range supported by the data unit
    intended to store it. An example would be making a byte-sized variable storing
    an unsigned integer, `256` (`100000000b`), which will result in storing `0` (`00000000b`)
    as only the last 8 bits would fit into a byte. This may lead to unexpected behavior
    in the program in favor of the attacker, such as allocating a buffer whose length
    is 0 and then writing the data outside of its scope.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，整数值可以占用 1、2、4 或 8 字节。无论为存储它们分配了多少空间，总有一些数字太大，无法适应存储单元的范围。整数溢出漏洞发生在攻击者能够引入一个超出数据单元范围的数字时，这个数据单元本应存储该数字。例如，将一个字节大小的变量用来存储无符号整数`256`（`100000000b`），这将导致存储`0`（`00000000b`），因为只有最后
    8 位能适应一个字节。这可能导致程序出现意外行为，进而有利于攻击者，比如分配一个长度为 0 的缓冲区，然后在其作用域之外写入数据。
- en: Logical vulnerabilities
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑漏洞
- en: A logical vulnerability is a vulnerability that doesn’t require memory corruption
    to be executed. Instead, it abuses the application logic to perform unintended
    actions. A good example of this is *CVE-2010-2729 (MS10-061)*, named **Windows
    Print Spooler Service Vulnerability**, which is used by the Stuxnet malware. Let’s
    dig deeper into how it works.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑漏洞是指不需要内存损坏即可执行的漏洞。相反，它滥用应用程序逻辑以执行意外操作。一个很好的例子是*CVE-2010-2729（MS10-061）*，被称为**Windows
    打印池服务漏洞**，被 Stuxnet 恶意软件使用。让我们深入了解其工作原理。
- en: Windows printing APIs allow the user to choose the directory that they wish
    to copy the file to be printed to. So, with an API named `GetSpoolFileHandle`,
    the attacker can get the file handle of the newly created file on the target machine
    and then easily write any data there with the `WriteFile` (or similar) API. A
    vulnerability like this one targets the application logic, which allows the attacker
    to choose the directory they wish and provides them with a file handle to overwrite
    this file with any data they want.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 打印 API 允许用户选择他们希望将要打印的文件复制到的目录。因此，使用名为`GetSpoolFileHandle`的 API，攻击者可以获取目标机器上新创建文件的文件句柄，然后轻松地使用`WriteFile`（或类似）API在那里写入任何数据。这类漏洞针对应用程序逻辑，允许攻击者选择他们希望的目录，并提供文件句柄以覆盖此文件并写入他们想要的任何数据。
- en: Different logical vulnerabilities are possible, and there is no specific format
    for them. This is why there is no universal mitigation for these types of vulnerabilities.
    However, they are still relatively rare compared to memory corruption ones as
    they are harder to find and not all of them lead to arbitrary code execution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的逻辑漏洞是可能的，它们没有特定的格式。这就是为什么这些类型的漏洞没有通用的缓解措施的原因。然而，与内存损坏漏洞相比，它们仍然相对罕见，因为它们更难发现，并且并非所有漏洞都会导致任意代码执行。
- en: There are other types of vulnerabilities out there, but the types that we have
    just covered are a cornerstone of other types of vulnerabilities you may witness.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的漏洞，但刚刚介绍的这些类型是您可能会遇到的其他类型漏洞的基石。
- en: Now that we have covered how the attacker can force the application to execute
    its code, let’s take a look at how this code is written and what challenges the
    attacker faces when writing it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了攻击者如何强制应用程序执行其代码，让我们看看这段代码是如何编写的以及攻击者在编写时面临的挑战。
- en: Types of exploits
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用类型
- en: 'Generally speaking, an exploit is a piece of code or data that takes advantage
    of a bug in software to perform an unintended behavior. There are several ways
    exploits can be classified. First of all, apart from the vulnerability that they
    target, when we talk about exploits, it is vitally important to figure out the
    actual result of the action being performed. Here are some of the most common
    types:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，利用是利用软件中的漏洞执行意外行为的一段代码或数据。利用可以按多种方式分类。首先，除了它们所针对的漏洞之外，当我们谈论利用时，弄清楚正在执行的动作的实际结果至关重要。以下是一些最常见的类型：
- en: '**Denial of Service** (**DoS**): Here, the exploit aims to crash either an
    application or the whole system to disrupt its normal operation.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝服务**（**DoS**）：在这里，利用的目标是崩溃应用程序或整个系统，以破坏其正常操作。'
- en: '**Privilege escalation**: In this case, the main purpose of the exploit is
    to elevate privileges to give the attacker greater abilities, such as access to
    more sensitive information.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升**：在这种情况下，利用的主要目的是提升权限，以赋予攻击者更大的能力，比如访问更敏感的信息。'
- en: '**Unauthorized data access**: This group is sometimes merged with the privilege
    escalation category, from which it differs mainly in scope and vector. Here, the
    attacker gets access to sensitive information that’s unavailable in a normal situation
    with permissions set up. Unlike the previous category, the attacker can’t perform
    arbitrary actions with different privileges, and the privileges that are used
    are not necessarily higher in this case – they may be associated with a different
    user of a similar access level.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经授权的数据访问**：这一组有时与权限提升类别合并，但在范围和向量上有所不同。在这里，攻击者可以访问未经授权的敏感信息，这些信息在正常情况下，根据权限设置，是无法获得的。与前一类别不同，攻击者在这种情况下不能使用不同权限执行任意操作，并且所使用的权限不一定更高
    - 它们可能与具有类似访问级别的不同用户相关联。'
- en: '**Arbitrary Code Execution** (**ACE**): Probably the most powerful and dangerous
    group, it allows the attacker to execute arbitrary code and perform pretty much
    any action. This code is generally referred to as shellcode and will be covered
    in greater detail in the next section. When the code is being executed remotely
    over the network, we are talking about **Remote Code Execution** (**RCE**).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任意代码执行**（**ACE**）：可能是最强大且最危险的一类，它允许攻击者执行任意代码并几乎执行任何操作。这段代码通常称为 shellcode，接下来会更详细地介绍。当代码通过网络远程执行时，我们所说的就是**远程代码执行**（**RCE**）。'
- en: 'Depending on the location where the exploit communicates with the targeted
    software, it is possible to distinguish between the following groups:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据漏洞利用与目标软件的通信位置，可以将其分为以下几类：
- en: '**Local exploits**: Here, exploits are executed on the machine, so the attacker
    should have already established access to it. Common examples include exploits
    with DoS or privilege escalation functionality.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地漏洞利用**：在这里，漏洞是在目标机器上执行的，因此攻击者应该已经建立了对该机器的访问权限。常见的例子包括具有 DoS 或权限提升功能的漏洞。'
- en: '**Remote exploits**: This group of exploits targets remote machines, which
    means they can be executed without prior access to the targeted system. A common
    example is RCE exploits granting this access, but remote DoS exploits are also
    pretty common.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程漏洞利用**：这一类漏洞针对远程机器，这意味着它们可以在没有预先访问目标系统的情况下执行。一个常见的例子是 RCE 漏洞，这种漏洞会授予这种访问权限，但远程
    DoS 漏洞也非常常见。'
- en: Finally, if the exploit targets a vulnerability that hasn’t been officially
    addressed and fixed yet, it is known as a **zero-day exploit**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果漏洞利用针对的是一个尚未正式解决和修复的漏洞，那么它被称为**零日漏洞**。
- en: Now, it is time to deep dive into various aspects of shellcode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，深入探讨 shellcode 的各个方面。
- en: Cracking the shellcode
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解 shellcode
- en: In this section, we will take a look at the code that gets executed by the attacker
    during vulnerability exploitation. This code gets executed in very special conditions
    without headers and known memory addresses. Let’s learn what shellcode is and
    how it’s written for Linux (Intel and ARM processors) and, later, the Windows
    operating system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看攻击者在利用漏洞时执行的代码。这段代码在没有头文件和已知内存地址的特殊条件下执行。让我们了解什么是 shellcode，以及如何为
    Linux（Intel 和 ARM 处理器）编写 shellcode，稍后还会介绍 Windows 操作系统。
- en: What’s shellcode?
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 shellcode？
- en: Shellcode is a list of carefully crafted instructions that can be executed once
    code has been injected into a running application. Due to most of the exploit’s
    circumstances, the shellcode must be position-independent code (which means it
    doesn’t need to run in a specific place in memory or require a base relocation
    table to fix its addresses). Shellcode also has to operate without an executable
    header or a system loader. For some exploits, it can’t include certain bytes (especially
    null for the overflows of the string-type buffers).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 是一组精心设计的指令，一旦代码被注入到正在运行的应用程序中，就可以执行。由于大多数漏洞的情况，shellcode 必须是位置独立的代码（意味着它不需要在内存中的特定位置运行，也不需要基址重定位表来修复其地址）。Shellcode
    还必须在没有可执行头文件或系统加载器的情况下操作。对于某些漏洞利用，shellcode 不能包含某些字节（特别是字符串类型缓冲区溢出时的空字节）。
- en: Now, let’s take a look at what shellcode looks like in Windows and Linux.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Windows 和 Linux 中的 shellcode 长什么样。
- en: Linux shellcode in x86-64
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 下的 x86-64 架构 shellcode
- en: 'Linux shellcode is generally arranged much simpler than Windows shellcode.
    Once the program counter register is pointing to the shellcode, the shellcode
    can execute consecutive system calls to spawn a shell, listen on a port, or connect
    back to the attacker with minimal effort (check out [*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188),
    *Dissecting Linux and IoT Malware*, for more information about system calls in
    Linux). The main challenges that attackers face are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 下的 shellcode 通常比 Windows 下的 shellcode 更简单排列。一旦程序计数器寄存器指向 shellcode，shellcode
    就可以连续执行系统调用，来生成一个 shell、监听一个端口，或与攻击者建立连接，几乎不需要任何努力（关于 Linux 中系统调用的更多信息，可以查看[*第
    11 章*](B18500_11.xhtml#_idTextAnchor1188)，*解剖 Linux 和 IoT 恶意软件*）。攻击者面临的主要挑战如下：
- en: Getting the absolute address of the shellcode (to be able to access data)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 shellcode 的绝对地址（以便能够访问数据）
- en: Removing any null bytes from the shellcode (optional)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 shellcode 中移除任何空字节（可选）
- en: Now, let’s learn how it is possible to overcome these challenges. After this,
    we will look at different types of shellcode.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何克服这些挑战。之后，我们将探讨不同类型的 shellcode。
- en: Getting the absolute address
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取绝对地址
- en: This is a relatively easy task. Here, the shellcode abuses the `call` instruction,
    which saves the absolute return address in the stack (which the shellcode can
    get using the `pop` instruction).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项相对简单的任务。这里，shellcode 滥用 `call` 指令，它将绝对返回地址保存在栈中（shellcode 可以通过 `pop` 指令获取该地址）。
- en: 'An example of this is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的一个例子如下：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After getting the absolute address, the shellcode can get the address of any
    data inside the shellcode, like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取绝对地址后，shellcode 可以获取其中任何数据的地址，如下所示：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another common way to get the absolute address is by using the `fstenv` FPU
    instruction. This instruction saves some parameters related to the FPU for debugging
    purposes, including the absolute address of the last executed FPU instruction.
    This instruction can be used like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的获取绝对地址的方法是使用 `fstenv` FPU 指令。该指令保存一些与 FPU 相关的调试参数，包括最后执行的 FPU 指令的绝对地址。可以像这样使用此指令：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the shellcode was able to obtain the absolute address of the
    last executed FPU instruction, `fldz`, or in this case the address of `_start`,
    which can help in obtaining the address of any required data or a string in the
    shellcode.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，shellcode 成功地获取了最后执行的 FPU 指令 `fldz` 的绝对地址，或者在这个例子中是 `_start` 的地址，这有助于获取
    shellcode 中任何所需数据或字符串的地址。
- en: Null-free shellcode
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无空字节的 shellcode
- en: Null-free shellcode is a type of shellcode that has to avoid any null byte to
    be able to fit a null-terminated string buffer. The authors of this shellcode
    have to change the way they write their code. Let’s take a look at an example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无空字节的 shellcode 是一种必须避免任何空字节以适应空终止字符串缓冲区的 shellcode。编写这种 shellcode 的作者必须改变他们编写代码的方式。让我们来看一个例子。
- en: 'For the call/pop approach that we described earlier, they will be assembled
    into the following bytes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前描述的 call/pop 方法，它们将被组装成以下字节：
- en: '![Figure 8.4 – call/pop in OllyDbg'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 在 OllyDbg 中的 call/pop'
- en: '](img/Figure_8.4_B18500.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B18500.jpg)'
- en: Figure 8.4 – call/pop in OllyDbg
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 在 OllyDbg 中的 call/pop
- en: 'As you can see, because of the relative addresses the call instruction uses,
    it produced 4 null bytes. For the shellcode authors to handle this, they need
    the relative address to be negative. It could work in a case like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于调用指令使用了相对地址，它产生了 4 个空字节。为了处理这种情况，shellcode 的编写者需要让相对地址为负数。像这样的情况可以正常工作：
- en: '![Figure 8.5 – call/pop in OllyDbg with no null bytes'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 在 OllyDbg 中的 call/pop，没有空字节'
- en: '](img/Figure_8.5_B18500.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B18500.jpg)'
- en: Figure 8.5 – call/pop in OllyDbg with no null bytes
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 在 OllyDbg 中的 call/pop，没有空字节
- en: 'Here are some other examples of the changes the malware authors can make to
    avoid null bytes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些恶意软件作者为避免空字节所做的其他修改示例：
- en: '![](img/Table_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_01.jpg)'
- en: As you can see, it’s not very hard to do this in shellcode. You will notice
    that most of the shellcode from different exploits (or even the shellcode in Metasploit)
    is null-free by design, even if the exploit doesn’t necessarily require it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 shellcode 中执行这个并不难。你会发现，来自不同漏洞利用的绝大多数 shellcode（甚至是 Metasploit 中的 shellcode）都经过设计避免了空字节，即使漏洞利用本身不一定需要。
- en: Local shell shellcode
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地 shell shellcode
- en: 'Let’s start with a simple example that spawns a shell:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，来启动一个 shell：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s take a closer look at this code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码：
- en: First, it executes the `execve` system call to launch a process, which in this
    case will be `/bin/sh`. This represents the shell.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它执行 `execve` 系统调用来启动一个进程，在这个例子中是 `/bin/sh`，即 shell。
- en: 'The `execve` system call’s prototype looks like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`execve` 系统调用的原型如下所示：'
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It sets the filename in `ebx` with `/bin/sh` by using the call/pop technique
    to get the absolute address.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过使用 call/pop 技术获取绝对地址，将文件名 `/bin/sh` 设置到 `ebx` 中。
- en: No additional command-line arguments need to be specified in this case, so `ecx`
    is set to zero (`xor`, `ecx`, and `ecx` to avoid the null byte).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下不需要指定额外的命令行参数，所以 `ecx` 被设置为零（`xor`，`ecx`，`ecx` 以避免空字节）。
- en: 'After the shell terminates, the shellcode executes the `exit` system call,
    which is defined like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 shell 终止后，shellcode 执行 `exit` 系统调用，其定义如下：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It sets the status to zero in `ebx` as the program exits normally.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将状态设置为零，在程序正常退出时将 `ebx` 设为零。
- en: 'In this example, you have seen how shellcode can give attackers a shell by
    launching `/bin/sh`. For the x64 version, there are a few differences:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你已经看到 shellcode 如何通过启动 `/bin/sh` 来为攻击者提供一个 shell。对于 x64 版本，有一些不同之处：
- en: '`int 0x80` is replaced by a special Intel instruction, `syscall`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int 0x80` 被一个特殊的 Intel 指令 `syscall` 替代。'
- en: The `execve` system call ID has changed to 0x3b (59) and `exit` has changed
    to 0x3c (60). To know what function each ID represents, check out the official
    Linux system calls table.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execve` 系统调用的 ID 已更改为 0x3b (59)，而 `exit` 的 ID 更改为 0x3c (60)。要知道每个 ID 代表什么功能，请查看官方的
    Linux 系统调用表。'
- en: It uses `rdi` for the first parameter, `rsi` for the next, and then `rdx`, `rcx`,
    `r8`, `r9`, and the rest in the stack.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `rdi` 作为第一个参数，`rsi` 作为下一个参数，接着是 `rdx`、`rcx`、`r8`、`r9`，其余的在栈中。
- en: 'The code will look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, there are no big differences between x86 and x64 when it comes
    to the shellcode. Now, let’s take a look at more advanced types of shellcode.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 shellcode 方面，x86 和 x64 之间并没有太大区别。现在，让我们看看更高级的 shellcode 类型。
- en: Reverse shell shellcode
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向 shell shellcode
- en: 'The reverse shell shellcode is one of the most widely used types of shellcode.
    This shellcode connects to the attacker and provides them with a shell on the
    remote system to gain full access to the remote machine. For this to happen, the
    shellcode needs to follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 shell shellcode 是最广泛使用的 shellcode 类型之一。这个 shellcode 会连接到攻击者，并在远程系统上为攻击者提供一个
    shell，以便完全访问远程机器。为实现这一目标，shellcode 需要按照以下步骤执行：
- en: '`socket`. Here is the definition of this function:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`。这是该函数的定义：'
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will usually see it being used like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会看到它这样使用：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, `AF_INET` represents most of the known internet protocols, including
    `IPPROTO_IP` for the IP protocol. `SOCK_STREAM` is used to represent TCP communication.
    From this system call, you can understand that this shellcode is communicating
    with the attacker through TCP. The assembly code looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AF_INET` 代表大多数已知的互联网协议，包括 `IPPROTO_IP`（即 IP 协议）。`SOCK_STREAM` 用于表示 TCP
    通信。从这个系统调用中，你可以理解这个 shellcode 正通过 TCP 与攻击者进行通信。汇编代码如下所示：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, the shellcode uses the `socketcall` system call (with ID 0x66). This
    system call represents many system calls, including `socket`, `connect`, `listen`,
    `bind`, and so on. In `ebx`, the shellcode sets the function it wants to execute
    from the `socketcall` list. Here is a snippet of the list of functions supported
    by `socketcall`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，shellcode 使用了 `socketcall` 系统调用（ID 为 0x66）。该系统调用表示多个系统调用，包括 `socket`、`connect`、`listen`、`bind`
    等。在 `ebx` 中，shellcode 设置要从 `socketcall` 列表中执行的函数。以下是 `socketcall` 支持的函数列表的一个片段：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The shellcode pushes the arguments to the stack and then sets `ecx` to point
    to the list of arguments, sets `ebx = 1` (`SYS_SOCKET`), sets the system call
    ID in `eax` (`socketcall`), and then executes the system call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode 将参数压入栈中，然后将 `ecx` 设置为指向参数列表，将 `ebx = 1`（即 `SYS_SOCKET`），将系统调用 ID 设置到
    `eax`（即 `socketcall`），接着执行系统调用。
- en: '`sockaddr_in` with the IP, port, and, again, `AF_INET`. Then, the shellcode
    executes the `connect` function from the `socketcall` list of functions. The prototype
    looks like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sockaddr_in` 包含 IP、端口，并且再次使用 `AF_INET`。接着，shellcode 执行 `socketcall` 函数列表中的
    `connect` 函数。其原型如下所示：'
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The assembly code will look as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码将如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`dup2` that overwrites the standard input, output, and error output with the
    socket one. Here is the assembly code for this step:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dup2` 会将标准输入、输出和错误输出重定向到 socket。以下是该步骤的汇编代码：'
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the shellcode overwrites `stdin (0)`, `stdout (1)`, and
    `stderr (2)` with `sockfd` (the socket handle) to redirect any input, output,
    and errors to the attacker, respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，shellcode 将 `stdin (0)`、`stdout (1)` 和 `stderr (2)` 替换为 `sockfd`（即 socket
    句柄），从而将任何输入、输出和错误分别重定向到攻击者。
- en: '`execve` call with `/bin/sh`, as we saw in the previous section.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们在上一节中看到的，`execve` 调用使用 `/bin/sh`。
- en: Now that you have seen more advanced shellcode, you can understand most of the
    well-known shellcode and the methodology behind them. For binding a shell or downloading
    and executing shellcode, the code is very similar, and it uses similar system
    calls and maybe one or two extra functions. You will need to check the definition
    of every system call and what arguments it takes before analyzing the shellcode
    based on that.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了更高级的 shellcode，你可以理解大多数知名的 shellcode 以及它们背后的方法论。对于绑定 shell 或下载并执行 shellcode，代码非常相似，且使用类似的系统调用，可能只有一两个额外的函数。在分析
    shellcode 时，你需要先了解每个系统调用的定义以及它需要的参数。
- en: That’s it for x86 (both 32-bit and 64-bit). Now, let’s take a quick look at
    ARM shellcoding and the differences between it and x86.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 x86（32 位和 64 位）的情况。现在，让我们简要看一下 ARM shellcoding 及其与 x86 之间的区别。
- en: Linux shellcode for ARM
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARM 的 Linux shellcode
- en: 'The shellcode on ARM systems is very similar to the shellcode that uses the
    x86 instruction set. It’s even easier for the shellcode authors to write in ARM
    as they don’t have to use the call/pop technique or `fstenv` to get the absolute
    address. In ARM assembly language, you can access the program counter register
    (`pc`) directly from the code, which makes this even simpler. Instead of `int
    0x80` or `syscall`, the shellcode uses `svc #0` or `svc #1` to execute a system
    function. An example of ARM shellcode for executing a local shell is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'ARM 系统上的 shellcode 与使用 x86 指令集的 shellcode 非常相似。实际上，ARM 上的 shellcode 编写起来更加简单，因为不需要使用
    call/pop 技术或 `fstenv` 来获取绝对地址。在 ARM 汇编语言中，你可以直接从代码中访问程序计数器寄存器 (`pc`)，这使得编写代码变得更为简单。与
    `int 0x80` 或 `syscall` 不同，ARM shellcode 使用 `svc #0` 或 `svc #1` 来执行系统函数。以下是一个用于执行本地
    shell 的 ARM shellcode 示例：'
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, the shellcode sets `r0` with the program counter (pc)
    + 12 to point to the `/bin/sh` string. Then, it sets the remaining arguments for
    the `execve` system call and calls the `svc` instruction to execute the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，shellcode 设置 `r0` 为程序计数器 (pc) + 12，指向 `/bin/sh` 字符串。然后，它设置 `execve`
    系统调用的其余参数，并调用 `svc` 指令来执行代码。
- en: Null-free shellcode
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无空值 shellcode
- en: ARM instructions are usually 32-bit instructions. However, many shellcodes switch
    to Thumb Mode, which sets the instructions to be 16 bits only and reduces the
    chances of having null bytes. For the shellcode to switch to Thumb Mode, it is
    common to use the `BX` or `BLX` instructions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 指令通常是 32 位指令。然而，许多 shellcode 会切换到 Thumb 模式，这会将指令设置为 16 位，从而减少了出现空字节的概率。为了让
    shellcode 切换到 Thumb 模式，通常会使用 `BX` 或 `BLX` 指令。
- en: 'After executing it, all instructions switch to the 16-bit mode, which reduces
    null bytes significantly. By using `svc #1` instead of `svc #0` and avoiding immediate
    null values and instructions that include null bytes, the shellcode can reach
    the null-free goal.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '执行后，所有指令都会切换到 16 位模式，这大大减少了空字节的出现。通过使用 `svc #1` 代替 `svc #0`，并避免使用包含空字节的立即数和指令，shellcode
    可以达到无空值的目标。'
- en: When analyzing ARM shellcode, make sure that you disassemble all the instructions
    after the mode switches to 16-bit rather than 32-bit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析 ARM shellcode 时，确保在模式切换到 16 位而非 32 位后，反汇编所有指令。
- en: Now that we have covered Linux shellcode for Intel and ARM processors, let’s
    take a look at Windows shellcode.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了适用于 Intel 和 ARM 处理器的 Linux shellcode，让我们来看一下 Windows shellcode。
- en: Windows shellcode
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows shellcode
- en: Windows shellcode is more complicated than its Linux counterpart. In Windows,
    you can’t directly use `sysenter` or interrupts like in Linux as the system function
    IDs change from one version to another. Windows provides interfaces to access
    their functionality in libraries, such as `kernel32.dll`. Windows shellcode has
    to find the base address of `kernel32.dll` and go through its export table to
    get the required APIs to implement their functionality. In terms of socket APIs,
    attackers may need to load additional DLLs using `LoadLibraryA`/`LoadLibraryExA`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Windows shellcode 比 Linux shellcode 更加复杂。在 Windows 中，你无法像在 Linux 中那样直接使用 `sysenter`
    或中断，因为系统函数 ID 会随版本变化。Windows 提供了接口来访问其库中的功能，例如 `kernel32.dll`。Windows shellcode
    必须找到 `kernel32.dll` 的基地址，并通过其导出表获取所需的 API 以实现其功能。在处理套接字 API 时，攻击者可能需要通过 `LoadLibraryA`/`LoadLibraryExA`
    加载额外的 DLL。
- en: 'Windows shellcode follows these steps to achieve its target:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Windows shellcode 按照以下步骤实现其目标：
- en: Get the absolute address (we covered this in the previous section).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取绝对地址（我们在前一部分已经讲解过）。
- en: Get the base address of `kernel32.dll`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `kernel32.dll` 的基地址。
- en: Get the required APIs from `kernel32.dll`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `kernel32.dll` 获取所需的 API。
- en: Execute the payload.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行有效载荷。
- en: Now that we’ve covered how shellcode gets its absolute address, let’s look at
    how it gets the base address of `kernel32.dll`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了 shellcode 如何获取绝对地址，接下来我们来看看它是如何获取 `kernel32.dll` 的基地址的。
- en: Getting the base address of kernel32.dll
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 `kernel32.dll` 的基地址
- en: '`kernel32.dll` is the main DLL that’s used by shellcode. It has APIs such as
    `LoadLibrary`, which allows you to load other libraries, and `GetProcAddress`,
    which gets the address of any API inside a library that’s loaded in memory.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernel32.dll` 是 shellcode 使用的主要 DLL。它包含像 `LoadLibrary` 这样的 API，用于加载其他库，还有
    `GetProcAddress`，可以获取加载到内存中的库中任意 API 的地址。'
- en: 'To access any API inside any DLL, the shellcode must get the address of `kernel32.dll`
    and parse its export table.When an application is being loaded into memory, the
    Windows OS loads its core libraries, such as `kernel32.dll` and `ntdll.dll`, and
    saves the addresses and other information about these libraries inside the `kernel32.dll`
    from the PEB as follows (for 32-bit systems):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问任何 DLL 中的任何 API，shellcode 必须获取 `kernel32.dll` 的地址并解析其导出表。当应用程序加载到内存中时，Windows
    操作系统会加载其核心库，如 `kernel32.dll` 和 `ntdll.dll`，并将这些库的地址及其他信息保存在 PEB 中的 `kernel32.dll`
    中，如下所示（对于 32 位系统）：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line gets the PEB address from the FS segment register (in x64, it
    will be the GS register and a different offset). Then, the second and the third
    lines get `PEB->LoaderData->InInitializationOrderModuleList`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行从 FS 段寄存器获取 PEB 地址（在 x64 中，它将是 GS 寄存器，并具有不同的偏移量）。然后，第二行和第三行获取 `PEB->LoaderData->InInitializationOrderModuleList`。
- en: '`InInitializationOrderModuleList` is a DLL that contains information about
    all the loaded modules (PE files) in memory (such as `kernel32.dll`, `ntdll.dll`,
    and the application itself), along with the base address, the filename, and other
    information.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`InInitializationOrderModuleList` 是一个 DLL，其中包含关于所有已加载模块（PE 文件）在内存中的信息（如 `kernel32.dll`、`ntdll.dll`
    和应用程序本身），以及基地址、文件名和其他信息。'
- en: The first entry that you will see in `InInitializationOrderModuleList` is `ntdll.dll`.
    To get `kernel32.dll`, the shellcode must go to the next item in the list. So,
    in the fourth line, the shellcode gets the next item while following the forward
    link (`ListEntry->FLink`). It gets the base address from the available information
    about the DLL in the fifth line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InInitializationOrderModuleList` 中，你将看到的第一个条目是 `ntdll.dll`。为了获取 `kernel32.dll`，shellcode
    必须转到列表中的下一个项。因此，在第四行，shellcode 在跟踪前向链接（`ListEntry->FLink`）时获取下一个项。它从第五行获得有关 DLL
    的可用信息来获取基地址。
- en: Getting the required APIs from kernel32.dll
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 kernel32.dll 获取所需的 API
- en: 'For the shellcode to be able to access the APIs of `kernel32.dll`, it should
    parse its export table. The export table consists of three arrays. The first array
    is `AddressOfNames`, which contains the names of the APIs inside the DLL file.
    The second array is `AddressOfFunctions`, which contains the **relative addresses**
    (**RVAs**) of all of these APIs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 shellcode 能够访问 `kernel32.dll` 的 API，它需要解析其导出表。导出表由三个数组组成。第一个数组是 `AddressOfNames`，其中包含
    DLL 文件中 API 的名称。第二个数组是 `AddressOfFunctions`，它包含所有这些 API 的**相对地址**（**RVAs**）：
- en: '![Figure 8.6 – Export table structure (the numbers are not real and have been
    provided as an example)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.6 – 导出表结构（数字不是真实的，仅作为示例）'
- en: '](img/Figure_8.6_B18500.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B18500.jpg)'
- en: Figure 8.6 – Export table structure (the numbers are not real and have been
    provided as an example)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 导出表结构（数字不是真实的，仅作为示例）
- en: However, the issue here is that these two arrays are aligned with a different
    alignment. For example, `GetProcAddress` could be in the third item in `AddressOfNames`,
    but it’s in the fifth item in `AddressOfFunctions`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里存在的问题是，这两个数组的对齐方式不同。例如，`GetProcAddress` 可能在 `AddressOfNames` 的第三项中，但它在
    `AddressOfFunctions` 的第五项中。
- en: 'To handle this issue, Windows created a third array named `AddressOfNameOrdinals`.
    This array has the same alignment as `AddressOfNames` and contains the index of
    every item in `AddressOfFunctions`. Note that `AddressOfFunctions` and `AddressOfNameOrdinals`
    have more items than `AddressOfNames` since not all APIs have names. The APIs
    without equivalent names are accessed using their ID (their index, in `AddressOfNameOrdinals`).
    The export table will look something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，Windows 创建了一个名为 `AddressOfNameOrdinals` 的第三个数组。该数组与 `AddressOfNames`
    对齐，并包含 `AddressOfFunctions` 中每个项的索引。请注意，`AddressOfFunctions` 和 `AddressOfNameOrdinals`
    比 `AddressOfNames` 多项，因为并非所有 API 都有名称。没有等效名称的 API 使用它们的 ID（即在 `AddressOfNameOrdinals`
    中的索引）进行访问。导出表看起来大致如下：
- en: '![Figure 8.7 – Export table parser (the winSRDF project)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 导出表解析器（winSRDF 项目）'
- en: '](img/Figure_8.7_B18500.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B18500.jpg)'
- en: Figure 8.7 – Export table parser (the winSRDF project)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 导出表解析器（winSRDF 项目）
- en: For the shellcode to get the addresses of its required APIs, it should search
    for the required API’s name in `AddressOfNames` and then take the index of it
    and search for that index in `AddressOfNameOrdinals` to find the equivalent index
    of this API in `AddressOfFunctions`. By doing this, it will be able to get the
    relative address of that API. The shellcode adds them to the base address of `kernel32.dll`
    so that it has the full address to this API. In most cases, instead of matching
    the API names against strings that it would need to hardcode within itself, the
    shellcode generally uses its hashes (more information can be found in [*Chapter
    6*](B18500_06.xhtml#_idTextAnchor554), *Bypassing Anti-Reverse Engineering Techniques*).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 shellcode 获取其所需 API 的地址，它应该在 `AddressOfNames` 中搜索所需 API 的名称，然后取出其索引，并在 `AddressOfNameOrdinals`
    中搜索该索引，以找到在 `AddressOfFunctions` 中该 API 对应的索引。通过这种方式，它将能够获取该 API 的相对地址。shellcode
    将这些地址与 `kernel32.dll` 的基地址相加，从而得到该 API 的完整地址。在大多数情况下，shellcode 通常不将 API 名称与它需要硬编码的字符串进行匹配，而是使用其哈希值（更多信息请参见
    [*第6章*](B18500_06.xhtml#_idTextAnchor554)，*绕过反向工程技术*）。
- en: The download and execute shellcode
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载并执行的 shellcode
- en: 'This shellcode uses an API located in `urlmon.dll` called `URLDownloadToFileA`.
    As its name suggests, it downloads a file from a given URL and saves it to the
    hard disk when it’s provided with the required path. The definition of this API
    is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该 shellcode 使用了位于 `urlmon.dll` 中的一个 API，名为 `URLDownloadToFileA`。顾名思义，它从给定的 URL
    下载文件并将其保存在硬盘中，当它提供了所需的路径时。此 API 的定义如下：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Only `szURL` and `szFilename` are required. The remaining arguments are mostly
    set to null. After the file is downloaded, the shellcode executes this file using
    `CreateProcessA`, `WinExec`, or `ShellExecute`. The C code for this may look as
    follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要 `szURL` 和 `szFilename`。其余的参数通常设置为 null。文件下载完成后，shellcode 会使用 `CreateProcessA`、`WinExec`
    或 `ShellExecute` 执行该文件。对应的 C 代码可能如下所示：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the payload is very simple and yet very effective in executing
    the second stage of the attack, which could be the backdoor that maintains persistence
    and can communicate to the attacker and exfiltrate valuable information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，payload 非常简单，却非常有效地执行了攻击的第二阶段，这可能是一个后门，用于维持持久性，并与攻击者通信，窃取有价值的信息。
- en: Static and dynamic analysis of exploits
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞的静态与动态分析
- en: Now that we have learned about what exploits look like and how they work, let’s
    summarize some practical tips and tricks for their analysis.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了漏洞的样子以及它们的工作原理，接下来总结一些分析漏洞时的实用技巧和窍门。
- en: Analysis workflow
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析工作流程
- en: 'Firstly, you need to carefully collect any prior knowledge: what environment
    the exploit was found in, whether it is already known what software was targeted
    and its version, and whether the exploit triggered successfully there. All this
    information will allow you to properly emulate the testing environment and successfully
    reproduce the expected behavior, which is very helpful for dynamic analysis.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要仔细收集任何先前的知识：漏洞是在哪种环境中发现的，是否已经知道了被攻击的软件及其版本，以及漏洞是否已经成功触发。所有这些信息将帮助你正确模拟测试环境，并成功重现预期的行为，这对于动态分析非常有帮助。
- en: Secondly, it is important to confirm how it interacts with the targeted application.
    Usually, exploits are delivered through the expected input channel (whether it
    is a listening socket, a web form or URI, or maybe a malformed document, a configuration
    file, or a JavaScript script), but other overlooked options are also possible
    (for example, environment variables and dependency modules). The next step here
    is to use this information to successfully reproduce the exploitation process
    and identify the indicators that can confirm it. Examples include the target application
    crashing in a particular way or performing particular actions that can be seen
    using suitable system monitors (for example, the ones that keep track of file,
    registry, or network operations or accessed APIs). If shellcode is involved, its
    analysis may give valuable information about the expected after-exploitation behavior.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，确认攻击载荷如何与目标应用程序交互也很重要。通常，攻击载荷通过预期的输入通道传递（无论是监听的套接字、Web表单或URI，还是可能是格式不正确的文档、配置文件或JavaScript脚本），但也可能有其他被忽视的选项（例如，环境变量和依赖模块）。此时，下一步是使用这些信息成功重现攻击过程，并识别可以确认攻击的指示器。例如，目标应用程序可能会以某种特定方式崩溃，或执行特定的操作，可以通过适当的系统监控工具看到（例如，监控文件、注册表或网络操作或访问的API）。如果涉及Shellcode，其分析可能会提供有关预期攻击后行为的有价值信息。
- en: After this, you need to identify the targeted vulnerability. The MITRE Corporation
    maintains a list of all publicly known vulnerabilities by assigning the corresponding
    **Common Vulnerabilities and Exposures** (**CVE**) identifiers to them so that
    they can easily be referenced (for example, CVE-2018-9206). Sometimes, it may
    be already known from antivirus detection or publications, but it is always advisable
    to confirm it in any case.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你需要识别目标漏洞。MITRE公司通过为所有公开已知的漏洞分配相应的**常见漏洞和暴露**（**CVE**）标识符，来维护一个漏洞列表，便于参考（例如，CVE-2018-9206）。有时，可能已经通过杀毒软件检测或公开发布知道该漏洞，但无论如何，最好进行确认。
- en: Check for unique strings first as they may give you a clue about the parts of
    the targeted software it interacts with. Unlike most other types of malware, static
    analysis may not be enough in this case. Since exploits work closely with the
    targeted software, they should be analyzed in their context, which in many cases
    requires dynamic analysis.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查独特的字符串，因为它们可能会给你提供关于目标软件交互部分的线索。与大多数其他类型的恶意软件不同，静态分析在这种情况下可能不够。由于攻击载荷与目标软件密切合作，因此需要在其上下文中进行分析，这在许多情况下需要动态分析。
- en: Here, you need to intercept the moment the exploit is delivered but hasn’t been
    processed yet using a debugger of preference. After this, there are multiple ways
    the analysis can be continued. One approach is to carefully go through the functions
    that are responsible for it being processed at a high level (without stepping
    into each function) and monitor the moment when it triggers. Once this happens,
    it becomes possible to narrow down the searching area and focus on the sub-functions
    of the identified function. Then, the engineer can repeat this process up until
    the moment the bug is found.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要使用自己偏好的调试器拦截攻击载荷的交付时刻，但此时载荷尚未被处理。之后，可以通过多种方式继续分析。一种方法是仔细检查负责处理该载荷的高层函数（无需逐个进入每个函数），并监视触发时刻。一旦触发，就有可能缩小搜索范围，集中精力分析已识别函数的子函数。然后，工程师可以重复此过程，直到找到漏洞为止。
- en: Another way to do this is to search for suspicious entries in the exploit itself
    first (such as corrupted fields, big binary blocks with high entropy, long lines
    with hex symbols, and so on) and monitor how the targeted software processes them.
    If shellcode is involved, it is possible to patch it with either breakpoint or
    infinite loop instructions at its beginning `(\xCC` and `\xEB\xFE`, respectively),
    then perform steps to reproduce the exploitation, wait until the inserted instructions
    get executed, and check the stack trace to see what functions have been called
    to reach this point.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是先在攻击载荷中搜索可疑条目（如损坏的字段、具有高熵的大二进制块、包含十六进制符号的长行等），并监视目标软件如何处理它们。如果涉及到Shellcode，可以在其开头用断点或无限循环指令修补（分别为`(\xCC`和`\xEB\xFE`），然后执行重现攻击的步骤，等待插入的指令执行，并检查堆栈跟踪，以查看哪些函数被调用以达到这一点。
- en: Overall, it is generally recommended to stick to the virtualized environment
    or emulation for dynamic analysis since in the case of exploits, it is much more
    probable that something may go wrong, and execution control will be lost. Therefore,
    it is convenient to be able to restore the previous debugging and environmental
    state.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，通常建议在虚拟化环境或仿真环境中进行动态分析，因为在漏洞利用的情况下，发生错误并失去执行控制的可能性更大。因此，能够恢复先前的调试和环境状态是非常方便的。
- en: These techniques are universal and can be applied to pretty much any type of
    exploit. Regardless of whether the engineer has to analyze browser exploits (often
    written in JavaScript) or some local privilege escalation code, the difference
    will mainly be in the setup for the testing environment.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术是通用的，可以应用于几乎所有类型的漏洞利用。无论工程师是否需要分析浏览器漏洞（通常是用JavaScript编写的）或本地权限提升代码，区别主要在于测试环境的设置。
- en: Shellcode analysis
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shellcode分析
- en: If you need to analyze the binary shellcode, you can use a debugger for the
    targeted architecture and platform (such as OllyDbg for 32-bit Windows) by copying
    the hexadecimal representation of the shellcode and using the binary paste option.
    It is also possible to use tools such as **unicorn**, **libemu** (a small emulator
    library for x86 instructions), or the **Pokas x86 Emulator**, which is a part
    of the **pySRDF** project, to emulate shellcode. Other great tools useful for
    dynamic analysis are **scdbg** and **qltool** (part of the **qiling** framework).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要分析二进制shellcode，您可以使用适用于目标架构和平台的调试器（例如32位Windows的OllyDbg），通过复制shellcode的十六进制表示并使用二进制粘贴选项来进行分析。还可以使用**unicorn**、**libemu**（一个小型x86指令仿真库）或**Pokas
    x86 Emulator**等工具，这些工具是**pySRDF**项目的一部分，用于仿真shellcode。其他有用的动态分析工具包括**scdbg**和**qltool**（**qiling**框架的一部分）。
- en: 'Another popular solution is to convert it into an executable file. After this,
    you can analyze it both statically and dynamically, just like any usual malware
    sample. One option would be to use the `shellcode2exe.py` script, but unfortunately,
    one of its core dependencies is no longer supported, so it may be hard to set
    it up. Another option would be to compile the executable manually by copying and
    pasting the shellcode into the corresponding template:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的解决方案是将其转换为可执行文件。之后，您可以像分析任何常见的恶意软件样本一样，静态和动态分析它。一种选择是使用`shellcode2exe.py`脚本，但不幸的是，它的一个核心依赖不再受支持，因此可能难以设置。另一种选择是通过将shellcode复制并粘贴到相应的模板中，手动编译可执行文件：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The execution flag may need to be added to the data section to make the shellcode
    executable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要将执行标志添加到数据段中，以使shellcode可执行。
- en: Finally, it is possible to just open any executable in the debugger and copy
    and paste the shellcode over the existing code. For example, in x64dbg, it can
    be done by right-clicking and going to **Binary** | **Paste (Ignore Size)**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以直接在调试器中打开任何可执行文件，然后将shellcode粘贴到现有代码中。例如，在x64dbg中，可以通过右键单击并选择**Binary**
    | **Paste (Ignore Size)**来完成。
- en: For the ROP chain to be analyzed, you need to get access to the targeted application
    and the system so that the actual instructions can be resolved dynamically there.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析ROP链，您需要访问目标应用程序和系统，以便在那里动态解析实际指令。
- en: Exploring bypasses for exploit mitigation technologies
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索绕过漏洞利用缓解技术
- en: Since the same types of vulnerabilities kept appearing, despite all the awareness
    and training for software developers on secure coding, new ways to reduce their
    impact and make them unusable for remote code execution have been introduced.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于即使在对软件开发人员进行安全编码培训和意识提升后，同样类型的漏洞仍然不断出现，因此已经引入了新的方法来减少这些漏洞的影响并使其无法用于远程代码执行。
- en: In particular, multiple exploit mitigation technologies were developed at various
    levels to make it hard to impossible for the attackers to successfully execute
    their shellcode. Let’s take a look at the most well-known mitigations that have
    been created for this purpose.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，各种级别的多种漏洞利用缓解技术已经被开发出来，使攻击者很难甚至不可能成功执行他们的shellcode。我们来看看为此目的创建的一些最著名的缓解措施。
- en: Data execution prevention (DEP/NX)
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据执行防护（DEP/NX）
- en: Data execution prevention is one of the earliest techniques that was introduced
    to protect against exploits and shellcode. The idea behind it is to stop the execution
    inside any memory page that doesn’t have `EXECUTE` permission. This technique
    can be supported by hardware that raises an exception once shellcode gets executed
    in the stack or in the heap (or any place in memory that doesn’t have this permission).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数据执行防护（DEP）是最早被提出用于防止漏洞和shellcode攻击的技术之一。其背后的理念是阻止在任何没有`EXECUTE`权限的内存页内执行代码。此技术可以通过硬件支持，一旦shellcode在栈或堆（或任何没有此权限的内存位置）中执行，就会引发异常。
- en: This technology didn’t completely stop the attackers from executing their payload
    and taking advantage of memory corruption vulnerabilities. They invented a new
    technique to bypass DEP/NX called **return-oriented programming** (**ROP**).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术并未完全阻止攻击者执行他们的有效载荷并利用内存损坏漏洞。他们发明了一种新技术来绕过DEP/NX，称为**面向返回的编程**（**ROP**）。
- en: Return-oriented programming
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向返回的编程
- en: 'The main idea behind ROP is that rather than setting the return address so
    that it points to the shellcode, attackers can set the return address to redirect
    the execution to some existing code inside the program or any of its modules and
    chain instructions to reproduce a shellcode. The small snippets of misused code
    will look like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ROP的主要思路是，攻击者不直接设置返回地址指向shellcode，而是将返回地址设置为重定向执行到程序内部或其任何模块中的现有代码，并通过链式指令重现shellcode。这些被误用的小段代码大致如下：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For example, on Windows, the attacker can try to redirect the execution to the
    `VirtualProtect` API to change permissions for the part of the stack (or heap)
    that the shellcode is in and execute the shellcode. Alternatively, it is possible
    to use combinations such as `VirtualAlloc` and `memcpy` or `WriteProcessMemory`,
    `HeapAlloc` and any memory copy API, or the `SetProcessDEPPolicy` and `NtSetInformationProcess`
    APIs to disable DEP.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Windows上，攻击者可以尝试将执行重定向到`VirtualProtect` API，改变栈（或堆）中shellcode所在部分的权限，并执行该shellcode。或者，可以使用`VirtualAlloc`和`memcpy`，或`WriteProcessMemory`、`HeapAlloc`及任何内存复制API，或`SetProcessDEPPolicy`和`NtSetInformationProcess`等API来禁用DEP。
- en: 'The trick here is to use the **Import Address Table** (**IAT**) of a module
    to get the address of any of these APIs so that the attacker can redirect the
    execution to the beginning of this API. In the ROP chain, the attacker places
    all the arguments that are required for each of these APIs, followed by a return
    to the API they want to execute. An example of this is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是使用模块的**导入地址表**（**IAT**）来获取这些API的地址，从而攻击者可以将执行重定向到该API的开头。在ROP链中，攻击者将所有这些API所需的参数放置好，接着返回到他们希望执行的API。下面是一个例子：
- en: '![Figure 8.8 – The ROP chain for the CVE-2018-6892 exploit'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.8 – CVE-2018-6892漏洞的ROP链'
- en: '](img/Figure_8.8_B18500.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B18500.jpg)'
- en: Figure 8.8 – The ROP chain for the CVE-2018-6892 exploit
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – CVE-2018-6892漏洞的ROP链
- en: Some ROP chains can execute the required payload without the need to return
    to the shellcode. There are automated tools that help the attacker search for
    these small code gadgets and construct the valid ROP chain. One of these tools
    is `mona.py`, which is a plugin for the Immunity Debugger.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一些ROP链可以在不返回shellcode的情况下执行所需的有效载荷。有一些自动化工具帮助攻击者搜索这些小型代码片段，并构造有效的ROP链。`mona.py`就是其中一个工具，它是Immunity
    Debugger的插件。
- en: As you can see, DEP alone doesn’t stop the attackers from executing their shellcode.
    However, along with **address space layout randomization** (**ASLR**), these two
    mitigation techniques make it hard for the attacker to successfully execute the
    payload. Let’s take a look at how ASLR works.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，仅有DEP并不能阻止攻击者执行他们的shellcode。然而，结合**地址空间布局随机化**（**ASLR**）这两种防御技术，使得攻击者很难成功执行有效载荷。让我们来看一下ASLR是如何工作的。
- en: Address space layout randomization
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址空间布局随机化
- en: ASLR is a mitigation technique that is used by multiple operating systems, including
    Windows and Linux. The idea behind it is to randomize addresses where the application
    and the DLLs are loaded in the process memory. Instead of using predefined `ImageBase`
    values as base addresses, the system uses random addresses to make it very hard
    for the attackers to construct their ROP chains, which generally rely on the static
    addresses of instructions that comprise it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ASLR 是一种缓解技术，被多个操作系统使用，包括 Windows 和 Linux。其背后的想法是随机化应用程序和 DLL 在进程内存中的加载地址。系统不再使用预定义的
    `ImageBase` 值作为基址，而是使用随机地址，这使得攻击者很难构造他们的 ROP 链，因为这些链通常依赖于组成它的指令的静态地址。
- en: Now, let’s take a look at some common ways to bypass it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些常见的绕过方式。
- en: DEP and partial ASLR
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DEP 和部分 ASLR
- en: For ASLR to be effective, it is required to have the application and all its
    libraries compiled with an ASLR enabling flag, such as `-fstack-protector` or
    `-pie -fPIE` for the GCC compiler, which isn’t always possible. If there is at
    least one module that doesn’t support ASLR, it becomes possible for the attacker
    to find the required ROP gadgets there. This is especially true for tools that
    have lots of plugins written by third parties or applications that use lots of
    different libraries. While the base address of `kernel32.dll` is still randomized
    (so that the attacker can’t directly return to an API inside), it can easily be
    accessed from the import table of the loaded non-ASLR module(s).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 ASLR 生效，要求应用程序及其所有库在编译时启用 ASLR 标志，例如 GCC 编译器的 `-fstack-protector` 或 `-pie
    -fPIE`，但这并非总是可能的。如果至少有一个模块不支持 ASLR，攻击者就有可能在该模块中找到所需的 ROP 工具。这对于有大量由第三方编写的插件的工具或使用多个不同库的应用程序尤其如此。虽然
    `kernel32.dll` 的基址仍然是随机化的（因此攻击者不能直接返回到 API 内部），但它可以通过已加载的非 ASLR 模块的导入表轻松访问。
- en: DEP and full ASLR – partial ROP and chaining multiple vulnerabilities
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DEP 和完整的 ASLR – 部分 ROP 和多重漏洞链
- en: In cases where all the libraries support ASLR, writing an exploit is much harder.
    The known technique for this is chaining multiple vulnerabilities. For example,
    one vulnerability will be responsible for information disclosure and another for
    memory corruption. The information disclosure vulnerability could leak an address
    of a module that helps reconstruct the ROP chain based on that address. The exploit
    could contain an ROP chain comprised of just RVAs (relative addresses without
    the base address values) and exploit the information disclosure vulnerability
    on the fly to leak the address and reconstruct the ROP chain to execute the shellcode.
    This type of exploit is more common in scripting languages, for example, targeting
    vulnerabilities that are exploited using JavaScript. Using the power of this scripting
    language, the attacker can construct the ROP chain on the target machine.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有库都支持 ASLR 的情况下，编写利用代码会变得更加困难。已知的技术是将多个漏洞链在一起。例如，一个漏洞负责信息泄露，另一个漏洞负责内存损坏。信息泄露漏洞可能会泄露一个模块的地址，帮助基于该地址重建
    ROP 链。利用代码可能包含一个仅由 RVA（相对地址，不包含基地址值）组成的 ROP 链，并实时利用信息泄露漏洞泄露地址，从而重建 ROP 链并执行 shellcode。这种类型的利用在脚本语言中更为常见，例如，利用
    JavaScript 攻击漏洞。利用这种脚本语言的强大功能，攻击者可以在目标机器上构造 ROP 链。
- en: 'An example of this could be the local privilege escalation vulnerability known
    as *CVE-2019-0859* in `win32k.sys`. The attacker uses a known technique for modern
    versions of Windows (this works on Windows 7, 8, and 10) called the `HMValidateHandle`
    technique. It uses an `HMValidateHandle` function that’s called by the `IsMenu`
    API, which is implemented in `user32.dll`. Given a handle of a window that has
    been created, this function returns the address of its memory object in the kernel
    memory, resulting in an information disclosure that could help in designing the
    exploit, as shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是被称为 *CVE-2019-0859* 的本地特权提升漏洞，存在于 `win32k.sys` 中。攻击者利用一种已知的现代 Windows
    版本（适用于 Windows 7、8 和 10）技术，称为 `HMValidateHandle` 技术。它使用一个由 `IsMenu` API 调用的 `HMValidateHandle`
    函数，该函数在 `user32.dll` 中实现。给定一个已经创建的窗口句柄，该函数返回其在内核内存中的内存对象地址，从而导致信息泄露，这可以帮助设计利用代码，如下所示的屏幕截图所示：
- en: '![Figure 8.9 – Kernel memory address leak using the HMValidateHandle technique'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.9 – 使用 HMValidateHandle 技术泄漏内核内存地址'
- en: '](img/Figure_8.9_B18500.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9_B18500.jpg)'
- en: Figure 8.9 – Kernel memory address leak using the HMValidateHandle technique
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 使用 HMValidateHandle 技术的内核内存地址泄露
- en: This technique works pretty well with stack-based overflow vulnerabilities.
    But for heap overflows or use-after-free, a new problem arises, which is that
    the location of the shellcode in the memory is unknown. In stack-based overflows,
    the shellcode resides in the stack, and it’s pointed to by the `esp` register,
    but in heap overflows, it is harder to predict where the shellcode will be. In
    this case, another technique called **heap spraying** is commonly used.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在基于栈的溢出漏洞中效果很好。但对于堆溢出或使用后释放漏洞，出现了一个新问题，那就是 shellcode 在内存中的位置未知。在基于栈的溢出中，shellcode
    存储在栈中，并由 `esp` 寄存器指向，但在堆溢出中，更难预测 shellcode 将位于何处。在这种情况下，通常使用另一种技术，称为 **堆喷射**。
- en: Full ASLR – the heap spraying technique
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全 ASLR – 堆喷射技术
- en: 'The idea behind this technique is to make multiple addresses lead to the shellcode
    by filling the memory of the application with lots of copies of it, which will
    lead to it being executed with a very high probability. The main problem here
    is guaranteeing that these addresses point to the start of it and not to the middle.
    This can be achieved by using some sort of shellcode padding. The most famous
    example involves having a huge amount of `nop` bytes (called **nop slide**, **nop
    sled**, or **nop ramp**), or any instructions that don’t have any major effect
    before the shellcode:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的原理是通过在应用程序的内存中填充大量的 shellcode 副本，使得多个地址指向同一 shellcode，从而以非常高的概率执行它。这里的主要问题是确保这些地址指向
    shellcode 的开始位置，而不是中间位置。通过使用某种 shellcode 填充技术可以实现这一点。最著名的例子是使用大量的 `nop` 字节（称为**nop
    滑梯**、**nop 漫游**或**nop 坡道**），或者任何没有重大效果的指令，放在 shellcode 前面：
- en: '![Figure 8.10 – The heap spray technique'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10 – 堆喷射技术'
- en: '](img/Figure_8.10_B18500.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B18500.jpg)'
- en: Figure 8.10 – The heap spray technique
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 堆喷射技术
- en: As you can see, the attacker used the `0x0a0a0a0a` address to point to its shellcode.
    Because of the heap spraying technique, this address, which has a relatively high
    probability, may point to the `nop` instructions in one of the shellcode blocks,
    which will later lead to the shellcode starting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，攻击者使用了 `0x0a0a0a0a` 地址来指向其 shellcode。由于堆喷射技术的存在，这个具有相对高概率的地址可能指向 shellcode
    块中的 `nop` 指令，进而启动 shellcode。
- en: DEP and full ASLR – JIT spraying
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DEP 和完全 ASLR – JIT 喷射
- en: This technique is very similar to heap spraying, with the only difference being
    that block allocation is caused by abusing a `EXECUTE` permissions as they are
    supposed to store generated assembly instructions. This way, DEP can be bypassed
    together with ASLR.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与堆喷射非常相似，唯一的区别是块分配是通过滥用 `EXECUTE` 权限来引起的，因为这些权限本应存储生成的汇编指令。通过这种方式，DEP 可以与
    ASLR 一起绕过。
- en: Other mitigation technologies
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他防护技术
- en: 'Several other mitigation techniques have been introduced to protect against
    exploitation. We will just mention a few of them:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止被利用，已经引入了几种其他的防护技术。我们这里只提及其中的一些：
- en: '`ret` instruction. This technique makes it harder for the attackers to use
    stack overflow vulnerabilities to modify the return address as this value is unknown
    to them. However, there are multiple bypasses for it, and one of them is overwriting
    the SEH address and forcing an exception to happen before the GS cookie is checked.
    Overwriting the SEH address is very effective and led to other mitigations being
    introduced for it.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ret` 指令。这种技术使得攻击者更难通过栈溢出漏洞修改返回地址，因为这个值对他们来说是未知的。然而，这种方法有多种绕过方式，其中之一是覆盖 SEH
    地址，并在 GS cookie 被检查之前强制触发异常。覆盖 SEH 地址是非常有效的，这也导致了引入其他防护措施来应对这一问题。'
- en: '**Structured Exception Handling Overwrite Protection** (**SEHOP**): This mitigation
    technique performs additional security checks to make sure that the SEH chain
    hasn’t been corrupted.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化异常处理覆盖保护** (**SEHOP**)：这种防护技术会执行额外的安全检查，以确保 SEH 链没有被破坏。'
- en: '**SafeSEH**: This mitigation directly protects the applications from memory
    corruptions that overwrite SEH addresses. In this case, the SEH addresses are
    no longer stored in the stack and instead are referenced in the PE header in a
    separate data directory that includes all the SEH addresses for all the application’s
    functions.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SafeSEH**：这种防护措施直接保护应用程序免受覆盖 SEH 地址的内存破坏。在这种情况下，SEH 地址不再存储在栈中，而是被引用于 PE 头中的一个单独的数据目录，该目录包含所有应用程序函数的
    SEH 地址。'
- en: That’s it for the most common mitigations. Now, let’s talk about other types
    of exploits.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是最常见的缓解措施。现在，让我们讨论其他类型的漏洞。
- en: Analyzing Microsoft Office exploits
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Microsoft Office 漏洞
- en: While Microsoft Office is mainly associated with Windows by many people, it
    has also supported the macOS operating system for several decades. In addition,
    the file formats used by it are also understood by various other suites, such
    as Apache OpenOffice and LibreOffice. In this section, we will look at vulnerabilities
    that can be exploited by malformed documents to perform malicious actions and
    learn how to analyze them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微软 Office 主要与 Windows 操作系统相关联，但它也已经支持 macOS 操作系统几十年了。此外，其他各种办公软件套件，如 Apache
    OpenOffice 和 LibreOffice，也能识别它使用的文件格式。在本节中，我们将研究恶意文档利用漏洞进行恶意操作，并学习如何分析这些漏洞。
- en: File structures
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构
- en: The first thing that should be clear when analyzing any exploit is how the files
    associated with them are structured. Let’s take a look at the most common file
    formats associated with Microsoft Office that are used by attackers to store and
    execute malicious code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析任何利用时，首先要清楚的是与这些漏洞相关的文件如何结构化。让我们看看攻击者常用的一些与 Microsoft Office 相关的文件格式，这些文件格式被用来存储和执行恶意代码。
- en: Compound file binary format
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合文件二进制格式
- en: This is probably the most well-known file format that can be found in documents
    associated with various older and newer Microsoft Office products, such as `.doc`
    (Microsoft Word), `.xls` (Microsoft Excel), `.ppt` (Microsoft PowerPoint), and
    others. Once completely proprietary, it was later released to the public and now,
    its specification can be found online. Let’s go through some of the most important
    parts of it in terms of malware analysis.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最著名的文件格式，可以在与各种旧版和新版 Microsoft Office 产品相关的文档中找到，例如 `.doc`（Microsoft Word）、`.xls`（Microsoft
    Excel）、`.ppt`（Microsoft PowerPoint）等。曾经完全是专有格式，后来发布给公众，现在它的规范可以在网上找到。让我们通过一些最重要的部分，来分析它在恶意软件分析中的应用。
- en: 'The **Compound File Binary** (**CFB**) format, also known as **OLE2**, provides
    a filesystem-like structure for storing application-specific streams of data in
    sectors:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**复合文件二进制**（**CFB**）格式，也称为 **OLE2**，提供了一种类文件系统的结构，用于在扇区中存储特定应用的数据流：'
- en: '![Figure 8.11 – OLE2 header parsed'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – OLE2 头部解析'
- en: '](img/Figure_8.11_B18500.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B18500.jpg)'
- en: Figure 8.11 – OLE2 header parsed
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – OLE2 头部解析
- en: 'Here is the structure of its header, which is stored at the beginning of the
    first sector:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其头部结构，存储在第一个扇区的开始处：
- en: '`\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1` (where the first 4 bytes in hex format resemble
    a `DOCFILE` string)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1`（其中前四个字节的十六进制格式类似于 `DOCFILE` 字符串）'
- en: '**Header CLSID** (**16 bytes**): Unused class ID; must be zero'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Header CLSID**（**16 字节**）：未使用的类 ID；必须为零'
- en: '**Minor version** (**2 bytes**): Always 0x003E for major versions 3 and 4 of
    this format'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minor version**（**2 字节**）：对于主版本 3 和 4，这个值始终为 0x003E'
- en: '**Major version** (**2 bytes**): Main version number, can be either 0x0003
    or 0x0004'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Major version**（**2 字节**）：主版本号，可以是 0x0003 或 0x0004'
- en: '**Byte order** (**2 bytes**): Always 0xFFFE and represents little-endian order'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Byte order**（**2 字节**）：始终为 0xFFFE，表示小端字节序'
- en: '**Sector shift** (**2 bytes**): The sector size as a power of 2, 0x0009 for
    major version 3 (2^9 = 512 bytes) or 0x000C for major version 4 (2^12 = 4,096
    bytes)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sector shift**（**2 字节**）：作为 2 的幂次方的扇区大小，对于主版本 3 为 0x0009（2^9 = 512 字节），对于主版本
    4 为 0x000C（2^12 = 4,096 字节）'
- en: '**Mini sector shift** (**2 bytes**): Always 0x0006 and represents the sector
    size of the mini stream (2^6 = 64 bytes)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mini sector shift**（**2 字节**）：始终为 0x0006，表示迷你流的扇区大小（2^6 = 64 字节）'
- en: '**Reserved** (**6 bytes**): Must be set to zero'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reserved**（**6 字节**）：必须设置为零'
- en: '**Number of directory sectors** (**4 bytes**): Represents the number of **Directory**
    sectors, always zero for major version 3 (not supported)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Number of directory sectors**（**4 字节**）：表示 **目录** 扇区的数量，对于主版本 3 始终为零（不支持）'
- en: '**Number of FAT sectors** (**4 bytes**): Number of FAT sectors'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Number of FAT sectors**（**4 字节**）：FAT 扇区的数量'
- en: '**First directory sector location** (**4 bytes**): Represents the starting
    sector number for the directory stream'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**First directory sector location**（**4 字节**）：表示目录流的起始扇区号'
- en: '**Transaction signature number** (**4 bytes**): Stores a sequence number for
    the transactions in files supporting them or zero otherwise'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transaction signature number**（**4 字节**）：存储支持事务的文件中的事务序列号，或其他情况下为零'
- en: '**Mini stream cutoff size** (**4 bytes**): Always 0x00001000, this represents
    the maximum size of the user-defined data stream associated with the MiniFAT data'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mini 流截止大小**（**4 字节**）：始终为 0x00001000，表示与 MiniFAT 数据关联的用户定义数据流的最大大小'
- en: '**First MiniFAT sector location** (**4 bytes**): Stores the starting sector
    number for the MiniFAT sectors'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个 MiniFAT 扇区位置**（**4 字节**）：存储 MiniFAT 扇区的起始扇区号'
- en: '**Number of MiniFAT sectors** (**4 bytes**): Is used to store several MiniFAT
    sectors'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MiniFAT 扇区数量**（**4 字节**）：用于存储多个 MiniFAT 扇区'
- en: '**First DIFAT sector location** (**4 bytes**): Starting sector number for the
    DIFAT data'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个 DIFAT 扇区位置**（**4 字节**）：DIFAT 数据的起始扇区号'
- en: '**Number of DIFAT sectors** (**4 bytes**): Stores several DIFAT sectors'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DIFAT 扇区数量**（**4 字节**）：存储多个 DIFAT 扇区'
- en: '**DIFAT** (**436 bytes**): An array of integers (4 bytes each) representing
    the first 109 locations of FAT sectors:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DIFAT**（**436 字节**）：一个整数数组（每个 4 字节），表示 FAT 扇区的前 109 个位置：'
- en: '![Figure 8.12 – DIFAT array mentioning only one FAT sector with an ID of 0x2D'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – DIFAT 数组仅提到一个 ID 为 0x2D 的 FAT 扇区'
- en: '](img/Figure_8.12_B18500.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B18500.jpg)'
- en: Figure 8.12 – DIFAT array mentioning only one FAT sector with an ID of 0x2D
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – DIFAT 数组仅提到一个 ID 为 0x2D 的 FAT 扇区
- en: 'As you can see, it is possible to allocate memory using the usual sectors and
    mini stream that operates with sectors of smaller sizes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可以使用常规的扇区和操作小尺寸扇区的 mini 流来分配内存：
- en: '**File Allocation Table** (**FAT**): This is the main space allocator. Each
    stream is represented by a sector chain, where each entry contains the ID of the
    next sector up until the chain terminator. This chain information is stored in
    dedicated **FAT sectors**:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件分配表**（**FAT**）：这是主要的空间分配器。每个流由一个扇区链表示，其中每个条目包含下一个扇区的 ID，直到链终止符。这个链信息存储在专用的
    **FAT 扇区**中：'
- en: '![Figure 8.13 – FAT sector storing information about sector chains'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13 – FAT 扇区存储关于扇区链的信息'
- en: '](img/Figure_8.13_B18500.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B18500.jpg)'
- en: Figure 8.13 – FAT sector storing information about sector chains
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – FAT 扇区存储关于扇区链的信息
- en: '**MiniFAT**: This is the allocator for the mini stream and small user-defined
    data:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MiniFAT**：这是 mini 流和小型用户定义数据的分配器：'
- en: '![Figure 8.14 – MiniFAT sectors storing information about mini stream chains'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – MiniFAT 扇区存储关于 mini 流链的信息'
- en: '](img/Figure_8.14_B18500.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B18500.jpg)'
- en: Figure 8.14 – MiniFAT sectors storing information about mini stream chains
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – MiniFAT 扇区存储关于 mini 流链的信息
- en: 'As we mentioned previously, for each sector in a chain, the ID of the next
    sector is stored up until the last one that contains the `ENDOFCHAIN` (`0xFFFFFFFE`)
    value, and the header takes up a single usual sector with its values padded according
    to the sector’s size if necessary:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于链中的每个扇区，都会存储下一个扇区的 ID，直到最后一个包含 `ENDOFCHAIN`（`0xFFFFFFFE`）值的扇区，头部占用一个常规扇区，并根据扇区大小填充其值（如果需要）：
- en: '![Figure 8.15 – Example of the sector chain following the header'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.15 – 头部后续扇区链的示例'
- en: '](img/Figure_8.15_B18500.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B18500.jpg)'
- en: Figure 8.15 – Example of the sector chain following the header
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 头部后续扇区链的示例
- en: 'There are several other auxiliary storage types, including the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个其他辅助存储类型，包括以下内容：
- en: '**Double-Indirect File Allocation Table** (**DIFAT**): Stores the locations
    of FAT sectors (explained previously)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双重间接文件分配表**（**DIFAT**）：存储 FAT 扇区的位置（前面已解释）'
- en: '**Directory**: Stores metadata for storage and stream objects'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：存储存储和流对象的元数据'
- en: 'Here, stream and storage objects are used in a similar way to files and directories
    in typical filesystems:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，流和存储对象的使用方式类似于典型文件系统中的文件和目录：
- en: '![Figure 8.16 – Multiple streams within a single storage object'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16 – 单个存储对象中的多个流'
- en: '](img/Figure_8.16_B18500.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B18500.jpg)'
- en: Figure 8.16 – Multiple streams within a single storage object
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 单个存储对象中的多个流
- en: 'The root directory will be the first entry in the first sector of the directory
    chain; it behaves as both a stream and a storage object. It contains a pointer
    to the first sector that stores the mini stream:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录将是目录链中第一个扇区的第一个条目；它既作为流又作为存储对象。它包含指向存储 mini 流的第一个扇区的指针：
- en: '![Figure 8.17 – Root directory'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.17 – 根目录'
- en: '](img/Figure_8.17_B18500.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B18500.jpg)'
- en: Figure 8.17 – Root directory
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 根目录
- en: In `.xls` files, the main `Workbook` stream follows the `.doc` files, the `WordDocument`
    stream should start with the **FIB** structure.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.xls` 文件中，`Workbook` 主要流遵循 `.doc` 文件，`WordDocument` 流应以 **FIB** 结构开头。
- en: Knowing how the files are structured allows reverse engineers to identify anomalies
    that can lead to unexpected behavior.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 知道文件结构如何允许逆向工程师识别可能导致意外行为的异常。
- en: Now, let’s focus on **Rich Text Format** (**RTF**) documents.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于 **富文本格式**（**RTF**）文档。
- en: Rich Text Format
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 富文本格式
- en: RTF is another proprietary Microsoft format with a published specification that
    can be used to create documents. Originally, its syntax was influenced by the
    **TeX** language, which was mostly developed by Donald Knuth as it was intended
    to be cross-platform. The first reader and writer were released with the Microsoft
    Word product for Macintosh computers. Unlike the other document formats we’ve
    described, it is human-readable in usual text editors, without any preprocessing
    required.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: RTF 是另一种专有的微软格式，具有公开的规范，可用于创建文档。最初其语法受 **TeX** 语言影响，这是由唐纳德·克努斯开发的跨平台语言。第一版的阅读器和写入器与微软
    Word 产品一同发布，适用于 Macintosh 计算机。与我们描述的其他文档格式不同，它在通常的文本编辑器中是人类可读的，无需任何预处理。
- en: 'Apart from the actual text, all RTF documents are implemented using the following
    elements:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际文本外，所有 RTF 文档都使用以下元素实现：
- en: '`\rtfN`: The starting control word that can be found at the beginning of any
    RTF document, where `N` represents the major format version (currently, this is
    1).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\rtfN`: 可在任何 RTF 文档开头找到的起始控制词，其中 `N` 表示主要格式版本（当前为 1）。'
- en: Important Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is worth mentioning that if the `fN` part of it is not enforced, the RTF
    document will be considered valid by MS Office, even if it is absent or replaced
    with something else.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，如果 `fN` 的部分未强制执行，RTF 文档将被 MS Office 视为有效，即使其不存在或替换为其他内容。
- en: '`\ansi`: One of the supported character sets that follows `\rtfN`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\ansi`: 在 `\rtfN` 之后的受支持字符集之一。'
- en: '`\fonttbl`: The control word for introducing the font table group.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\fonttbl`: 引入字体表组的控制词。'
- en: '`\pard`: Resets to the default paragraph properties.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\pard`: 重置为默认段落属性。'
- en: '`\par`: Specifies the new paragraph (or the end of the current paragraph).'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\par`: 指定新段落（或当前段落的结束）。'
- en: '**Delimiters**: Marks the end of an RTF control word. There are three types
    of delimiters in total:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分隔符**: 标志着 RTF 控制词的结束。总共有三种类型的分隔符：'
- en: '**Spaces**: Treated as part of the control word'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空格**: 视为控制词的一部分。'
- en: '**Non-alphanumeric symbols**: Terminates the control word, but is not part
    of it'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非字母数字符号**: 终止控制词，但不包括在其中。'
- en: '**A digit with an optional hyphen (to specify minus)**: Indicates the numeric
    parameter; either positive or negative'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带可选连字符的数字（用于指定负数）**: 表示数值参数；可以是正数或负数。'
- en: '**Control symbols**: These symbols include a backslash, followed by a non-alphabetic
    character. These are treated in the same way as control words.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制符号**: 这些符号包括反斜杠，后跟非字母字符。这些与控制词处理方式相同。'
- en: '**Groups**: Groups consist of text and control words or symbols that specify
    the associated attributes, all surrounded by curly brackets.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**: 组由文本和控制词或指定相关属性的符号组成，所有这些都被大括号包围。'
- en: 'The embedded executable payloads are commonly stored in the following areas:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式可执行负载通常存储在以下区域：
- en: 'The `\objdata` argument of the `\object` control word. The data can be of various
    data formats and specified using the `\objclass` control word. The following are
    some example formats:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\object` 控制词的 `\objdata` 参数。数据可以是各种数据格式，并使用 `\objclass` 控制词指定。以下是一些示例格式：'
- en: OLE2 (for example, Word.Document.8)
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OLE2（例如，Word.Document.8）
- en: OOXML
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOXML
- en: PDF
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF
- en: The `\datastore` block’s content.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\datastore` 块的内容。'
- en: 'The document’s overlay (the area after the markdown):'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档覆盖区域（在 markdown 后的区域）：
- en: '![Figure 8.18 – Malicious executable stored in the document’s overlay'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – 存储在文档覆盖区域中的恶意可执行文件'
- en: '](img/Figure_8.18_B18500.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B18500.jpg)'
- en: Figure 8.18 – Malicious executable stored in the document’s overlay
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 存储在文档覆盖区域中的恶意可执行文件
- en: Apart from that, the remote malicious payload can be accessed using the `\objautlink`
    control word. In addition, `\objupdate` is commonly used to reload the object
    without the user’s interaction to achieve code execution.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，远程恶意负载可以通过 `\objautlink` 控制词访问。此外，`\objupdate` 常用于重新加载对象，无需用户交互即可实现代码执行。
- en: 'In terms of obfuscation, multiple techniques exist for this, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就混淆而言，存在多种技术，如下所示：
- en: Inserting `{\object}` entries in the middle of the data
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据中间插入`{\object}`条目
- en: Inserting multiple excessive `\bin[num]` entries
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入多个过多的`\bin[num]`条目
- en: 'Adding spaces between digits in the objects’ data:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象数据中添加空格：
- en: '![Figure 8.19 – Malware using excessive \bin control words'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 使用过多的\bin控制字的恶意软件'
- en: '](img/Figure_8.19_B18500.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B18500.jpg)'
- en: Figure 8.19 – Malware using excessive \bin control words
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 使用过多的\bin控制字的恶意软件
- en: Now, let’s talk about threats that follow the **Office Open XML** (**OOXML**)
    format.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论遵循**Office Open XML**（**OOXML**）格式的威胁。
- en: Office Open XML format
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Office Open XML格式
- en: OOXML format is associated with newer Microsoft Office products and is implemented
    in files with extensions that end with *x*, such as `.docx`, `.xlsx`, and `.pptx`.
    At the time of writing, this is the default format used by modern versions of
    Office.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: OOXML格式与较新的Microsoft Office产品相关联，并实现在扩展名为*x*的文件中，如`.docx`、`.xlsx`和`.pptx`。在撰写本文时，这是现代Office版本使用的默认格式。
- en: In this case, all information is stored in **Open Packaging Convention** (**OPC**)
    packages, which are ZIP archives that follow a particular structure and store
    XML and other data, as well as the relationships between them.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有信息都存储在**Open Packaging Convention**（**OPC**）包中，这些包是遵循特定结构并存储XML和其他数据及其之间关系的ZIP存档。
- en: 'Here is its basic structure:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其基本结构：
- en: '`[Content_Types].xml`: This file can be found in any document and stores MIME-type
    information for various parts of the package.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Content_Types].xml`：此文件可以在任何文档中找到，并为包的各个部分存储MIME类型信息。'
- en: '`_rels`: This directory contains relationships between files within the package.
    All files that have relationships will have a file here with the same name and
    a `.rels` extension appended to it. In addition, it also contains a separate `.rels`
    XML file for storing package relationships.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_rels`：此目录包含包内文件之间的关系。所有具有关系的文件都会在此处有一个同名并以`.rels`扩展名结尾的文件。此外，它还包含一个单独的`.rels`
    XML文件，用于存储包关系。'
- en: '`docProps`: This contains several XML files describing certain properties associated
    with the document – for example, `core.xml` for core properties (such as the creator
    or various dates) and `app.xml` for the number of pages, characters, and so on.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docProps`：此处包含几个描述与文档相关的特定属性的XML文件 - 例如，`core.xml`用于核心属性（如创建者或各种日期），`app.xml`用于页面数、字符数等。'
- en: '`<document_type_specific_directory>`: This directory contains the actual document
    data. Its name depends on the target application. The following are some examples:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<特定文档类型的目录>`：此目录包含实际的文档数据。其名称取决于目标应用程序。以下是一些示例：'
- en: '`word` for Microsoft Word: The main information is stored in the `document.xml`
    file.'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word`代表Microsoft Word：主要信息存储在`document.xml`文件中。'
- en: '`xl` for Microsoft Excel: In this case, the main file will be `workbook.xml`.'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xl`代表Microsoft Excel：在这种情况下，主文件将是`workbook.xml`。'
- en: '`ppt` for Microsoft PowerPoint: Here, the main information is located in the
    `presentation.xml` file.'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ppt`代表Microsoft PowerPoint：这里，主要信息位于`presentation.xml`文件中。'
- en: Now that we’ve become familiar with the common document formats, it is time
    to learn how to analyze malware that utilizes them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了常见的文档格式，是时候学习如何分析利用它们的恶意软件了。
- en: Static and dynamic analysis of MS Office exploits
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MS Office漏洞的静态和动态分析
- en: In this section, we are going to learn how malicious Microsoft Office documents
    can be analyzed. Here, we will focus on malware-exploiting vulnerabilities. Macro
    threats will be covered in [*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106),
    *Scripts and Macros – Reversing, Deobfuscation, and Debugging,* as they aren’t
    classed as exploits from a technical standpoint.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何分析恶意Microsoft Office文档。在这里，我们将专注于利用漏洞的恶意软件。宏威胁将在[*第10章*](B18500_10.xhtml#_idTextAnchor1106)，*脚本和宏
    - 反向工程，解混淆和调试*中进行讨论，因为从技术角度来看，它们并不被分类为漏洞利用。
- en: Static analysis
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'There are quite a few tools that allow analysts to look inside original Microsoft
    Office formats, as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具允许分析员查看原始Microsoft Office格式，如下所示：
- en: '**oletools**: A unique set of several powerful tools that allow an analyst
    to analyze all common documents associated with Microsoft Office products. The
    following are some examples:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oletools**：一套独特的强大工具，允许分析人员分析与Microsoft Office产品相关的所有常见文档。以下是一些示例：'
- en: '**olebrowse**: A pretty basic GUI tool that allows you to browse CFB documents'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**olebrowse**: 一个相当基础的GUI工具，允许你浏览CFB文档'
- en: '**oledir**: Displays directory entries within CFB files'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oledir**: 显示CFB文件中的目录条目'
- en: '**olemap**: Shows all sectors present in the document, including the header'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**olemap**: 显示文档中存在的所有扇区，包括头部'
- en: '**oleobj**: Allows you to extract embedded objects from CFB files'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oleobj**: 允许你从CFB文件中提取嵌入的对象'
- en: '**rtfobj**: Pretty much the same functionality as in case of oleobj, but this
    time for RTF documents'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rtfobj**: 几乎与oleobj相同的功能，但这次是针对RTF文档'
- en: '**oledump**: This powerful tool gives valuable insight into streams that are
    present in the document and features dumping and decompression options as well.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oledump**: 这个强大的工具能够提供有关文档中流的宝贵信息，并提供转储和解压选项。'
- en: '**rtfdump**: Another tool by the same author, this time aiming to facilitate
    the analysis of RTF documents.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rtfdump**: 另一个由同一作者开发的工具，旨在帮助分析RTF文档。'
- en: '**OfficeMalScanner**: Features several heuristics to search for and analyze
    shellcode entries, as well as encrypted MZ-PE files. For RTF files, it has a dedicated
    **RTFScan** tool.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OfficeMalScanner**: 提供多种启发式分析方法，能够搜索和分析shellcode条目，以及加密的MZ-PE文件。对于RTF文件，它有一个专用的**RTFScan**工具。'
- en: Regarding the newer Open XML-based files (such as `.docx`, `.xlsx`, and `.pptx`),
    **officedissector**, a parser library written in Python that was designed for
    securely analyzing OOXML files, can be used to automate certain tasks. But overall,
    once unzipped, they can always be analyzed in your favorite text editor with XML
    highlighting. Similarly, as we have already mentioned, RTF files don’t necessarily
    require any specific software and can be analyzed in pretty much any text editor.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 关于较新的基于Open XML的文件（如`.docx`、`.xlsx`和`.pptx`），可以使用**officedissector**，这是一个用Python编写的解析库，专为安全分析OOXML文件而设计，能够自动化某些任务。但总体而言，一旦解压，它们总是可以用你喜欢的文本编辑器进行XML高亮分析。类似地，正如我们之前提到的，RTF文件不一定需要任何特定软件，几乎可以在任何文本编辑器中分析。
- en: When performing static analysis, it generally makes sense to extract macros
    first if they’re present, as well as check for the presence of other non-exploit-related
    techniques, such as DDE or PowerPoint actions (their analysis will be covered
    in [*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106), *Scripts and Macros – Reversing,
    Deobfuscation, and Debugging*). Then, you need to check whether any URLs or high-entropy
    blobs are present as they may indicate the presence of shellcode. Only after this
    does it make sense to dig into anomalies in the document structure that may indicate
    the presence of an exploit.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行静态分析时，通常最好先提取宏（如果存在的话），并检查是否存在其他非漏洞相关的技术，例如DDE或PowerPoint操作（这些分析会在[*第10章*](B18500_10.xhtml#_idTextAnchor1106)中讲解，*脚本与宏—逆向分析、去混淆和调试*）。然后，需要检查是否存在任何URL或高熵二进制块，因为它们可能表明存在shellcode。只有在这一点之后，才有意义深入挖掘文档结构中的异常，这些异常可能表明存在漏洞。
- en: Dynamic analysis
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态分析
- en: 'Dynamic analysis of these types of exploits can be performed in two stages:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型漏洞的动态分析可以分为两个阶段：
- en: '**High-level**: At this stage, you must reproduce, and thus confirm, the malicious
    behavior. Usually, it involves the following steps:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级分析**: 在这一阶段，你必须重现并确认恶意行为。通常包括以下步骤：'
- en: '**Figure out the actual exploit payload**: Generally, this part can be done
    during the static analysis stage. Otherwise, it is possible to set up various
    behavioral analysis tools (filesystem, registry, process, and network monitors)
    and search for suspicious entries once the exploit is supposed to trigger during
    the next step.'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找出实际的漏洞载荷**: 通常，这部分可以在静态分析阶段完成。否则，可以设置各种行为分析工具（文件系统、注册表、进程和网络监控器），并在漏洞触发的下一步中寻找可疑条目。'
- en: '**Identify the product version(s) vulnerable to it**: If the vulnerability
    has been publicly disclosed, in most cases, it contains confirmed versions of
    targeted products. Otherwise, it is possible to install multiple versions of it
    in separate VM snapshots so that you can find at least one that allows you to
    reliably reproduce the exploit being triggered.'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定受此漏洞影响的产品版本**: 如果漏洞已经公开，通常会包含已确认的受影响版本。否则，可以在不同的虚拟机快照中安装多个版本，以便找到至少一个能可靠重现漏洞触发的版本。'
- en: '**Low-level**: In many cases, this stage is not required as we already know
    what the exploit is supposed to do and what products are affected. However, if
    we need to verify the vulnerability’s CVE number or handle zero-day vulnerabilities,
    it may be required to figure out exactly what bug has been exploited.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级**: 在许多情况下，这个阶段并不需要，因为我们已经知道漏洞应该做什么以及哪些产品受到影响。然而，如果我们需要验证漏洞的 CVE 编号或处理零日漏洞，可能需要弄清楚到底是哪个
    bug 被利用了。'
- en: Once we can reliably reproduce the exploit being triggered, we can attach it
    to the targeted module of the corresponding Microsoft Office product and keep
    debugging it until we see the payload being triggered. Then, we can intercept
    this moment and dive deep into how it works.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够可靠地重现触发的漏洞，我们可以将其附加到相应 Microsoft Office 产品的目标模块，并继续调试，直到我们看到负载被触发。然后，我们可以拦截这一时刻，深入研究它是如何工作的。
- en: Studying malicious PDFs
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究恶意 PDF
- en: The **Portable Document Format** (**PDF**) was developed by Adobe in the 90s
    for uniformly presenting documents, regardless of the application software or
    operating system used. Originally proprietary, it was released as an open standard
    in 2008\. Unfortunately, due to its popularity, multiple attackers misuse it to
    deliver their malicious payloads. Let’s see how they work and how they can be
    analyzed.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**便携式文档格式**（**PDF**）是由 Adobe 在 90 年代开发的，目的是统一地呈现文档，无论使用什么应用软件或操作系统。最初是专有的，2008
    年发布为开放标准。不幸的是，由于其流行，多个攻击者滥用它来传递恶意负载。让我们看看它们是如何工作的以及如何分析它们。'
- en: File structure
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构
- en: 'A PDF is a tree file that consists of objects that implement one of eight data
    types:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: PDF 是一个树形文件，由实现八种数据类型之一的对象组成：
- en: '`Null object`: Represents a lack of data.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空对象`: 表示缺少数据。'
- en: '`Boolean values`: Classic true/false values.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔值`: 经典的真/假值。'
- en: '`Numbers`: Both integer and real values.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数字`: 包括整数和实数值。'
- en: '`Names`: These values can be recognized by a forward slash at the beginning.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`: 这些值可以通过前面的斜杠来识别。'
- en: '`Strings`: Surrounded by parentheses.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符串`: 用圆括号括起来。'
- en: '`Arrays`: Enclosed within square brackets.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`: 用方括号括起来。'
- en: '`Dictionaries`: In this case, double curly brackets are used.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字典`: 在这种情况下，使用双大括号。'
- en: '`Streams`: These are the main data storage blocks, and they support binary
    data. Streams can be compressed to reduce the size of the associated data.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`流`: 这些是主要的数据存储块，支持二进制数据。流可以被压缩以减少相关数据的大小。'
- en: Apart from this, it is possible to use comments with the help of the percentage
    (`%`) sign.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还可以借助百分号（`%`）符号使用注释。
- en: All complex data objects (such as images or JavaScript entries) are stored using
    basic data types. In many cases, objects will have the corresponding dictionary
    mentioning the data type with the actual data stored in a stream.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 所有复杂的数据对象（如图像或 JavaScript 条目）都使用基本数据类型存储。在许多情况下，对象会有相应的字典，字典中会提到数据类型，并且实际数据存储在流中。
- en: 'PDF documents generally start with the `%PDF` signature, followed by the format
    version number (for example, 1.7) separated by a dash. However, because the PDF
    documents are read from the end, this is not guaranteed, and different PDF viewers
    allow a different number of arbitrary bytes to be placed in front of this signature
    (in most cases, at least `1000`):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: PDF 文档通常以 `%PDF` 签名开始，后跟格式版本号（例如，1.7），中间用连字符分隔。然而，由于 PDF 文档是从末尾读取的，因此不能保证这一点，不同的
    PDF 查看器允许在签名前插入不同数量的任意字节（在大多数情况下，至少为`1000`个字节）：
- en: '![Figure 8.20 – Arbitrary bytes in front of the %PDF signature of a valid document'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.20 – 有效文档的 %PDF 签名前的任意字节'
- en: '](img/Figure_8.20_B18500.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B18500.jpg)'
- en: Figure 8.20 – Arbitrary bytes in front of the %PDF signature of a valid document
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 有效文档的 %PDF 签名前的任意字节
- en: 'Multiple keywords can define the boundaries and types of the data objects,
    as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多个关键字定义数据对象的边界和类型，如下所示：
- en: '`%PDF` signature):'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%PDF` 签名）：'
- en: '![Figure 8.21 – The xref table in the PDF document'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.21 – PDF 文档中的 xref 表'
- en: '](img/Figure_8.21_B18500.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.21_B18500.jpg)'
- en: Figure 8.21 – The xref table in the PDF document
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – PDF 文档中的 xref 表
- en: Another less common option is a **cross-reference stream**, which serves the
    same purpose.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太常见的选项是**交叉引用流**，它起着相同的作用。
- en: '`obj` keyword is prepended by the object number and its generation number (this
    can be increased when the file is updated later), all separated by spaces:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 关键字由对象编号及其生成编号（在文件更新时可以增加）组成，所有内容用空格分隔：'
- en: '![Figure 8.22 – Example of the object in PDF document'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.22 – PDF 文档中对象的示例'
- en: '](img/Figure_8.22_B18500.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.22_B18500.jpg)'
- en: Figure 8.22 – Example of the object in PDF document
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22 – PDF 文档中对象的示例
- en: '**stream/endstream**: This can be used to define the streams that store the
    actual data.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stream/endstream**：可用于定义存储实际数据的流。'
- en: '`startxref` keyword specifying the offset of the index table and the *%%EOF*
    marker.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startxref` 关键字指定索引表的偏移量和 *%%EOF* 标记。'
- en: 'The following are the most common entries that might be of interest to analysts
    when they’re analyzing malicious PDFs:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是分析恶意 PDF 时，分析人员可能感兴趣的最常见条目：
- en: '`/Type`: This defines the type of the associated object data, The following
    are some examples:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Type`：定义相关对象数据的类型。以下是一些示例：'
- en: '`/ObjStm`: The object stream is a complex data type that can be used to store
    multiple objects. Usually, it is accompanied by several other entries, such as
    `/N` for defining the number of embedded objects and `/First` for defining the
    offset of the first object inside it. The first line of the stream defines the
    numbers and offsets of embedded objects, all separated by spaces.'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ObjStm`：对象流是一种复杂的数据类型，可用于存储多个对象。通常，它伴随有其他几个条目，例如 `/N` 用于定义嵌入对象的数量，`/First`
    用于定义第一个对象的偏移量。流的第一行定义了嵌入对象的编号和偏移量，所有内容由空格分隔。'
- en: '`/Action`: This describes the action to perform. There are different types,
    as follows:'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Action`：描述要执行的动作。其类型如下：'
- en: '`/Launch`: Defines the launch action to execute an application specified using
    the `/F` value and its parameters using the `/P` value.'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Launch`：定义执行指定应用程序的启动动作，应用程序通过 `/F` 值指定，其参数通过 `/P` 值指定。'
- en: '`/URI`: Defines the URI action to resolve the specified URI.'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/URI`：定义 URI 操作以解析指定的 URI。'
- en: '`/JavaScript`: Executes a specified piece of JavaScript, `/JS`, which defines
    a text string or a stream containing a JavaScript block that should be executed
    once the action (rendition or JavaScript) triggers.'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/JavaScript`：执行指定的 JavaScript 片段，`/JS` 定义了一个文本字符串或一个包含 JavaScript 代码块的流，该代码块将在动作（呈现或
    JavaScript）触发后执行。'
- en: '`/Rendition`: Can be used to execute JavaScript as well. The same `/JS` name
    can be used to specify it.'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Rendition`：也可用于执行 JavaScript。可以使用相同的 `/JS` 名称来指定它。'
- en: '`/SubmitForm`: Sends data to the specified address. The URL is provided in
    the `/F` entry and might be used in phishing documents.'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/SubmitForm`：将数据发送到指定的地址。URL 在 `/F` 条目中提供，并可能在钓鱼文档中使用。'
- en: '`/EmbeddedFiles`: This can be used to store an auxiliary file, such as a malicious
    payload.'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/EmbeddedFiles`：可用于存储辅助文件，例如恶意载荷。'
- en: '`/Catalog`: This is the root of the object hierarchy. It defines references
    to other objects, as follows:'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Catalog`：这是对象层次结构的根。它定义了对其他对象的引用，如下所示：'
- en: '`/Names`: An optional document name dictionary. It allows you to refer to some
    objects by names rather than by references – for example, using `/JavaScript`
    or `/EmbeddedFiles` mappings.'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Names`：一个可选的文档名称字典。它允许通过名称而不是引用来引用一些对象——例如，使用 `/JavaScript` 或 `/EmbeddedFiles`
    映射。'
- en: '`/OpenAction`: This specifies the destination to display (generally, this isn’t
    relevant for malware analysis purposes) or an action to perform once the document
    has been opened (see the previous list).'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/OpenAction`：指定打开文档后要显示的目标（通常，这对于恶意软件分析无关紧要）或执行的动作（参见前面的列表）。'
- en: '`/AA`: This specifies additional actions associated with trigger events.'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/AA`：指定与触发事件相关的附加动作。'
- en: '`/XF`: This specifies an XML-based form. It can contain embedded JavaScript
    code.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/XF`：指定基于 XML 的表单。它可以包含嵌入的 JavaScript 代码。'
- en: '`/Filter`: This entry defines the decoding filter(s) to be applied to the associated
    stream so that the data becomes readable. `/FFilter` can be used in the stream’s
    external file. For some of them, optional parameters can be specified using `/DecodeParms`
    (or `/FDecodeParms`, respectively). Multiple filters can be cascaded if necessary.
    There are two main categories of filters: compression filters and ASCII filters.
    Here are some examples that are commonly used in malware:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Filter`：该条目定义了要应用于相关流的解码过滤器，以使数据变得可读。`/FFilter` 可用于流的外部文件。对于某些过滤器，可以使用 `/DecodeParms`（或
    `/FDecodeParms`）指定可选参数。如果需要，可以级联多个过滤器。过滤器主要分为两类：压缩过滤器和 ASCII 过滤器。以下是一些常见的恶意软件中使用的例子：'
- en: '`/FlateDecode`: Probably the most common way to compress text and binary data,
    this utilizes the `zlib/deflate` algorithm:'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/FlateDecode`：可能是最常见的压缩文本和二进制数据的方式，它使用 `zlib/deflate` 算法：'
- en: '![Figure 8.23 – The /FlateDecode filter used in a PDF document'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.23 – PDF 文档中使用的 /FlateDecode 过滤器'
- en: '](img/Figure_8.23_B18500.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.23_B18500.jpg)'
- en: Figure 8.23 – The /FlateDecode filter used in a PDF document
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – PDF 文档中使用的 /FlateDecode 过滤器
- en: '`/LZWDecode`: In this case, the LZW compression algorithm is used instead.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/LZWDecode`: 在这种情况下，使用 LZW 压缩算法。'
- en: '`/RunLengthDecode`: Here, the data is encoded using the **Run-Length Encoding**
    (**RLE**) algorithm.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/RunLengthDecode`: 在这里，数据使用 **游程编码**（**RLE**）算法进行编码。'
- en: '`/ASCIIHexDecode`: Data is encoded using hexadecimal representation in ASCII.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ASCIIHexDecode`: 数据使用 ASCII 中的十六进制表示法进行编码。'
- en: '`/ASCII85Decode`: Another way to encode binary data, in this case using ASCII85
    (also known as Base85) encoding.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ASCII85Decode`: 另一种编码二进制数据的方式，在这种情况下，使用 ASCII85（也称为 Base85）编码。'
- en: '`/Encrypt`: An entry in the file trailer dictionary that specifies that this
    document is password protected. The entries in the corresponding object specify
    the way this is done:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Encrypt`: 文件尾部字典中的一个条目，指定该文档受密码保护。相应对象中的条目指定了保护的方式：'
- en: '`/O`: This entry defines the owner-encrypted document. Generally, it is used
    for DRM purposes.'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/O`: 该条目定义了所有者加密文档。通常用于 DRM（数字版权管理）目的。'
- en: '`/U`: This is associated with the so-called user-encrypted document and it
    is usually used for confidentiality. Malware authors may use it to bypass security
    checks and then give the victim a password to open it.'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/U`: 与所谓的用户加密文档相关联，通常用于保密。恶意软件作者可能会利用它绕过安全检查，然后给受害者提供密码以打开文件。'
- en: It is worth mentioning that in the modern specification, it is possible to replace
    parts of these names (or even the whole name) with `#XX` hexadecimal representations.
    So, `/URI` can become `/#55RI` or even `/#55#52#49`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在现代规范中，可以使用 `#XX` 十六进制表示法替换这些名称的部分（甚至是整个名称）。因此，`/URI` 可以变成 `/#55RI`，甚至是
    `/#55#52#49`。
- en: Some entries may reference other objects using the letter *R*. For example,
    `/Length 15 0 R` means that the actual length value is stored in a separate object,
    15, in generation 0\. When the file is updated, a new object with the incremented
    generation number is added.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一些条目可能会引用其他对象，使用字母 *R*。例如，`/Length 15 0 R` 表示实际的长度值存储在一个单独的对象中，即 15，在第 0 代。当文件更新时，会添加一个带有递增代号的新对象。
- en: Static and dynamic analysis of PDF files
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PDF 文件的静态与动态分析
- en: Now, it is time to learn how malicious PDF files can be analyzed. In this section,
    we will cover various tools that can assist with the analysis and give some guidelines
    on when and how they should be used.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习如何分析恶意 PDF 文件了。在本节中，我们将介绍一些可以帮助分析的工具，并提供有关何时以及如何使用它们的指南。
- en: Static analysis
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'In many cases, static analysis can answer pretty much any question that an
    engineer has when analyzing these types of samples. Multiple dedicated open source
    tools can make this process pretty straightforward. Let’s explore some of the
    most popular ones:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，静态分析几乎可以回答工程师在分析这些样本时遇到的任何问题。多种专用开源工具可以使这一过程变得相当简单。让我们来看看其中一些最流行的工具：
- en: '`-a`: Displays stats for the PDF sample'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`: 显示 PDF 样本的统计信息'
- en: '`-O`: Parses `/ObjStm` objects'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O`: 解析 `/ObjStm` 对象'
- en: '`-k`: Searches for the name of interest'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-k`: 搜索感兴趣的名称'
- en: '`-d`: Dumps the object specified using the `-o` argument'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`: 使用 `-o` 参数指定的对象进行转储'
- en: '`-w`: Raw output'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`: 原始输出'
- en: '`-f`: Passes an object through decoders'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`: 通过解码器传递对象'
- en: '**peepdf**: Another tool in the arsenal of malware analysts, this provides
    various useful commands that aim to identify, extract, decode, and beautify extracted
    data.*   **PDFStreamDumper**: This Windows tool combines multiple features into
    one comprehensive GUI and provides rich functionality that’s required when analyzing
    malicious PDF documents. It is strongly focused on extracting and processing various
    types of payload hidden in streams and supports multiple encoding algorithms,
    including less common ones:![Figure 8.24 – The PDFStreamDumper tool'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**peepdf**: 这是恶意软件分析人员工具箱中的另一个工具，提供多种有用的命令，旨在识别、提取、解码和美化提取的数据。* **PDFStreamDumper**:
    这款 Windows 工具将多个功能结合在一个全面的 GUI 中，并提供在分析恶意 PDF 文档时所需的丰富功能。它重点关注从流中提取和处理各种类型的有效载荷，并支持多种编码算法，包括一些较少见的编码算法。![图
    8.24 – PDFStreamDumper 工具'
- en: '](img/Figure_8.24_B18500.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.24_B18500.jpg)'
- en: Figure 8.24 – The PDFStreamDumper tool
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 – PDFStreamDumper 工具
- en: '**malpdfobj**: The authors of this tool took a slightly different approach
    in that the tool generates a JSON containing all the extracted and decoded information
    from the malicious PDF to make it more visible. This way it can be easily parsed
    using a scripting language of preference if necessary.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**malpdfobj**：该工具的作者采用了一种略有不同的方法，工具会生成一个包含所有从恶意PDF中提取和解码信息的JSON，使其更为可见。这样，如果需要，它可以通过脚本语言轻松解析。'
- en: Apart from these, multiple tools and libraries can facilitate analysis by parsing
    a PDF’s structure, decrypting documents, or decoding streams. This includes **qpdf**,
    **PyPDF2**, and **origami**.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，多种工具和库可以通过解析PDF结构、解密文档或解码流来促进分析。这些工具包括**qpdf**、**PyPDF2**和**origami**。
- en: When performing static analysis for malicious PDF files, it usually makes sense
    to start by listing the actions as well as the different types of objects. Pay
    particular attention to the suspicious entries we listed previously. Decode all
    the encoded streams to see what’s inside as they may contain malicious modules.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在对恶意PDF文件进行静态分析时，通常可以从列出操作和不同类型的对象开始。特别注意我们之前列出的可疑条目。解码所有编码的流，看看里面有什么，因为它们可能包含恶意模块。
- en: If the JavaScript object has been extracted, follow the recommendations for
    both static and dynamic analysis that have been provided in [*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106),
    *Scripts and Macros – Reversing, Deobfuscation, and Debugging*. In many cases,
    the exploit functionality is implemented using this language. ActionScript is
    much less common nowadays as Flash Player has been discontinued.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JavaScript对象已经被提取，请参考[*第10章*](B18500_10.xhtml#_idTextAnchor1106)，*脚本和宏 - 逆向工程、去混淆与调试*中提供的静态和动态分析的建议。在很多情况下，漏洞功能是通过此语言实现的。ActionScript现在已经不那么常见，因为Flash
    Player已被停止支持。
- en: Dynamic analysis
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态分析
- en: 'In terms of dynamic analysis, the same steps that were taken for Microsoft
    Office exploits can be followed:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分析方面，可以遵循对Microsoft Office漏洞所采取的相同步骤：
- en: Figure out which payload has been exploited.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弄清楚被利用的有效载荷是什么。
- en: Identify the product version(s) vulnerable to it.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定易受攻击的产品版本。
- en: Open the document using the candidate product and use behavior analysis tools
    to confirm that it triggers.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用候选产品打开文档，并使用行为分析工具确认它是否触发漏洞。
- en: Find a place in the code of the vulnerable product where you can trigger the
    exploit.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在易受攻击产品的代码中找到触发漏洞的地方。
- en: If the actual exploit body is written in some other language (such as JavaScript),
    it might be more convenient to debug parts of it separately while emulating the
    environment that’s required for the exploit to work. This will also be covered
    in [*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106), *Scripts and Macros – Reversing,
    Deobfuscation, and Debugging*.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实际的漏洞主体是用其他语言（如JavaScript）编写的，那么可能更方便将其中的一部分单独调试，同时模拟漏洞所需的环境。这部分内容也将在[*第10章*](B18500_10.xhtml#_idTextAnchor1106)，*脚本和宏
    - 逆向工程、去混淆与调试*中进行讲解。
- en: Summary
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we became familiar with various types of vulnerabilities, the
    exploits that target them, and different techniques that aim to battle them. Then,
    we learned about shellcode, how it is different for different platforms, and how
    it can be analyzed.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们熟悉了各种类型的漏洞、针对它们的攻击方式以及旨在应对这些漏洞的不同技术。然后，我们学习了Shellcode，它如何在不同平台上有所不同，以及如何分析它。
- en: Finally, we covered other common types of exploits that are used nowadays in
    the wild – that is, malicious PDF and Microsoft Office documents – and explained
    how to examine them. With this knowledge, you can gauge the attacker’s mindset
    and understand the logic behind various techniques that can be used to compromise
    the target system.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了当前在野外常见的其他类型的漏洞攻击——即恶意的PDF和Microsoft Office文档，并解释了如何检查它们。有了这些知识，你可以判断攻击者的思维方式，并理解可以用来破坏目标系统的各种技术背后的逻辑。
- en: In [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946), *Reversing Bytecode Languages
    – .NET, Java, and More*, we will learn how to handle malware that’s been written
    using bytecode languages, what challenges the engineer may face during the analysis,
    and how to deal with them.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18500_09.xhtml#_idTextAnchor946)，*逆向字节码语言 - .NET、Java及更多*中，我们将学习如何处理使用字节码语言编写的恶意软件，工程师在分析过程中可能遇到的挑战，以及如何应对这些挑战。
