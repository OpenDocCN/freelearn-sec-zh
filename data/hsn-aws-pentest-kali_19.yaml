- en: Targeting Other Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对其他服务
- en: AWS offers a wide variety of services and they are constantly updating those
    services, along with releasing new ones. There are so many that it would be impossible
    to cover them all in this book, but this chapter aims to cover a few less mainstream
    services and how they can be abused for our benefit as an attacker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了各种各样的服务，并且不断更新这些服务，同时发布新的服务。这本书不可能覆盖所有这些服务，但本章旨在介绍一些不太主流的服务以及它们如何被滥用以使我们作为攻击者受益。
- en: It is important to note that every single AWS service has the potential for
    some sort of exploitation when looking at it like an attacker, and that just because
    it is not covered in this book, it doesn't mean you shouldn't investigate it.
    There are a variety of security problems that can arise in every service, so the
    best thing to do is to look at a service and determine how it would be used in
    the real world, then look for common mistakes, insecure defaults, or just bad
    practices that are followed to benefit yourself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，每个AWS服务都有可能存在某种利用方式，当将其视为攻击者时，这本书没有涵盖的服务并不意味着您不应该调查它。每项服务都可能出现各种安全问题，因此最好的做法是查看服务并确定它在现实世界中的使用方式，然后寻找常见的错误、不安全的默认设置或者只是为了使自己受益而遵循的不良实践。
- en: The four different services we will look at in this chapter include Route 53,
    a scalable DNS/domain management service; **Simple Email Service** (**SES**),
    a managed email service; CloudFormation, an infrastructure-as-code service; and
    **Elastic Container Registry** (**ECR**), a managed Docker container registry.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍的四种不同服务包括Route 53，一个可扩展的DNS/域管理服务；**简单邮件服务**（**SES**），一个托管的电子邮件服务；CloudFormation，一个基础设施即代码服务；以及**弹性容器注册表**（**ECR**），一个托管的Docker容器注册表。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Route 53
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Route 53
- en: SES
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SES
- en: CloudFormation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation
- en: ECR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECR
- en: Route 53
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Route 53
- en: Route 53 is a great service to spend some time looking at for a few different
    reasons. The main reason would be reconnaissance, as it allows us to associate
    IPs and host names and discover domains and sub-domains, which is what we are
    going to cover here. It is also a very fruitful service for some more malicious
    attacks that we aren't going to be going into in-depth because they are not useful
    to us as penetration testers, but we will cover them at the end to make you aware
    of what a real malicious hacker might try and do once gaining access.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Route 53是一个很好的服务，有几个不同的原因值得花时间研究。主要原因是侦察，因为它允许我们关联IP和主机名，并发现域和子域，这就是我们要在这里介绍的内容。它也是一项非常有成效的服务，用于一些更恶意的攻击，我们不会深入讨论，因为它们对于我们作为渗透测试人员来说没有用处，但我们会在最后介绍它们，以让您意识到一旦获得访问权限，真正的恶意黑客可能会尝试做些什么。
- en: Hosted zones
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管区域
- en: 'The first thing we will want to do is get a list of hosted zones in Route 53\.
    We can gather this information with the following AWS CLI command (we can leave
    the `--region` argument out for Route 53):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是获取Route 53中托管区域的列表。我们可以使用以下AWS CLI命令收集这些信息（我们可以在Route 53中省略`--region`参数）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should look something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, we found one public hosted zone (we can see that `"PrivateZone"` is set
    to `false`), and that it has five record sets created in it (because `"ResourceRecordSetCount"`
    is `5`). Next, we can use the `ListResourceRecordSets` command to check out what
    records have been set for the `"test.com"` hosted zone:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们发现了一个公共托管区域（我们可以看到“PrivateZone”设置为“false”），并且在其中创建了五个记录集（因为“ResourceRecordSetCount”为“5”）。接下来，我们可以使用`ListResourceRecordSets`命令来查看为“test.com”托管区域设置了哪些记录：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The response will likely be somewhat long, depending on how many record sets
    there are. It should include a list of `"ResourceRecordSets"` that have a name,
    type, **Time-To-Live** (**TTL**), and a list of resource records. These records
    can be any sort of DNS record, such as A records, **C****anonical Name** (**CNAME**)
    records, and **Mail Exchanger **(MX) record. This list of record sets can be compared
    against known IP addresses from something like EC2, so that you can discover the
    hostname associated with certain servers you can access, or even discover unknown
    IPs, domains, and subdomains.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 响应可能会相当长，取决于有多少记录集。它应该包括一个“ResourceRecordSets”列表，其中包括名称、类型、**生存时间**（**TTL**）和资源记录列表。这些记录可以是任何类型的DNS记录，例如A记录、**规范名称**（**CNAME**）记录和**邮件交换器**（MX）记录。这些记录集列表可以与来自EC2之类的已知IP地址进行比较，以便您可以发现与您可以访问的某些服务器相关的主机名，甚至发现未知的IP、域和子域。
- en: This is useful because many web servers won't load correctly when visiting the
    server's IP address directly, as it requires the hostname, which we can use Route
    53 to figure out and resolve correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为许多Web服务器在直接访问服务器的IP地址时无法正确加载，因为它需要主机名，我们可以使用Route 53来找出并正确解析。
- en: This is also useful when looking at private hosted zones in Route 53 to help
    you discover what hosts and IPs are available to you on the internal network side
    of things, once you have gained access.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这在查看Route 53中的私有托管区域时也很有用，可以帮助您发现内部网络中可用的主机和IP，一旦获得访问权限。
- en: There are many malicious attacks that can take place in Route 53, so it is important
    that access to this service is highly restricted. These kinds of attacks will
    likely not be used in penetration tests, but it is good to be aware of for your
    and your client's security. The simplest attack would be to just change the IP
    addresses associated with A records, so any user who visits the domain (such as
    `test.com`), gets directed to your own attacker IP address, where you could then
    try phishing or a variety of other attacks. The same attack could work for CNAME
    records as well, by just pointing a subdomain of your target to your own attacker
    hosted web site. There are endless possibilities when you are in control of a
    website's DNS records, but be careful not to mess them up and cause a large issue
    for the AWS environment you are testing against.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Route 53中可能发生许多恶意攻击，因此重要的是对这项服务的访问进行严格限制。这些类型的攻击可能不会在渗透测试中使用，但对于你和你的客户的安全来说，了解这些攻击是很重要的。最简单的攻击可能就是改变与A记录相关的IP地址，这样任何访问该域的用户（例如`test.com`）都会被重定向到你自己的攻击者IP地址，然后你可以尝试网络钓鱼或其他各种攻击。相同的攻击也可以适用于CNAME记录，只需将你目标的子域指向你自己的攻击者托管的网站。当你控制一个网站的DNS记录时，可能有无穷无尽的可能性，但要小心不要搞砸并对你正在测试的AWS环境造成严重问题。
- en: Domains
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域名
- en: Route 53 supports registering new domains for a variety of TLDs. As an attacker,
    you could theoretically use the target AWS account to register a new domain, then
    transfer that domain to another provider for management, where you could essentially
    have a throwaway website for whatever you want. This would likely never be performed
    during a penetration test and would only be used for malicious purposes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Route 53支持注册各种顶级域的新域名。作为攻击者，你理论上可以使用目标AWS账户注册一个新域名，然后将该域名转移到另一个提供商进行管理，在那里你可以为任何你想要的东西创建一个一次性网站。这可能永远不会在渗透测试期间执行，只会用于恶意目的。
- en: Resolvers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器
- en: Route 53 DNS resolvers can be used to route DNS queries between different networks
    and VPCs that are in use. As an attacker, this may provide us with insight into
    other networks that are not hosted within AWS or possibly services within VPCs,
    but generally any actual attacks against these services would be for malicious
    use only and not what we would want as a penetration tester.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Route 53 DNS解析器可用于在使用中的不同网络和VPC之间路由DNS查询。作为攻击者，这可能为我们提供有关未在AWS中托管的其他网络或可能在VPC内的服务的见解，但通常对这些服务的实际攻击只会用于恶意目的，而不是我们作为渗透测试人员所希望的。
- en: Simple Email Service (SES)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单电子邮件服务（SES）
- en: SES is a small, but useful service that allows the management of sending and
    receiving emails from domains and email accounts that you own, but as an attacker
    with access to SES, we can use this service for information gathering and social
    engineering. Depending on your compromised users' access to SES and the associated
    setup for the different verified domains/email accounts that are registered, it
    can allow for some serious phishing and social engineering against both employees
    and clients of our target company.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SES是一个小巧但实用的服务，允许管理从你拥有的域和电子邮件账户发送和接收电子邮件，但作为拥有SES访问权限的攻击者，我们可以利用这项服务进行信息收集和社会工程。根据你受损用户对SES的访问权限以及已注册的不同验证域/电子邮件账户的相关设置，它可以允许对我们目标公司的员工和客户进行一些严重的网络钓鱼和社会工程。
- en: Phishing
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络钓鱼
- en: 'We''re going to assume the account we compromised has full access to SES so
    that we can go over all of the attacks, but that may need to be adjusted, depending
    on what kind of access you find yourself with in a real-life scenario. The first
    thing we will want to do is look for verified domains and/or email address. These
    may be isolated to a single region or separated between a few different regions,
    so it is important to check each region when running these API calls. We can discover
    these verified domains/email addresses for the `us-west-2` region by running the
    following AWS CLI command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们受损的账户对SES拥有完全访问权限，以便我们可以进行所有攻击，但根据你在现实场景中发现的访问权限的类型，可能需要进行调整。我们首先要做的是查找已验证的域和/或电子邮件地址。这些可能被隔离到单个区域或在几个不同的区域之间分开，因此在运行这些API调用时检查每个区域是很重要的。我们可以通过运行以下AWS
    CLI命令来发现这些已验证的域/电子邮件地址，以获取`us-west-2`区域的信息：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will contain both domains and email addresses that have been added
    to that region, regardless of their status. A domain/email addresses status states
    whether it is verified, pending verification, failed verification, and so on,
    and a domain/email address must be verified before it can be used with the rest
    of the features that SES offers. This is to confirm that the person setting it
    up owns whatever it is that they are signing up. The output of that command should
    look something like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将包含已添加到该区域的域和电子邮件地址，无论它们的状态如何。域/电子邮件地址的状态表示它是否已验证、待验证、验证失败等等，域/电子邮件地址必须在可以与SES提供的其他功能一起使用之前进行验证。这是为了确认设置它的人拥有他们正在注册的东西。该命令的输出应该类似于以下内容：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If an email address is set up and verified through SES, then that means it alone
    can be used for email sending/receiving, but if an entire domain gets set up and
    verified, that means any email address across any subdomain of that domain can
    be used. This means that if `test.com` is set up and verified, emails could be
    sent from `admin@test.com`, `admin@subdomain.test.com`, `test@test.com`, or any
    other variation ([https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html)).
    This is what we like to see as attackers, because we can really customize our
    phishing attack with that flexibility. This information can be helpful because
    we might be able to discover emails/domains that we were not aware of before,
    making it much easier to formulate a phishing attack that looks realistic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过SES设置和验证了电子邮件地址，那么它就可以单独用于发送/接收电子邮件，但是如果设置和验证了整个域，那么该域的任何子域中的任何电子邮件地址都可以使用。这意味着如果`test.com`被设置和验证，可以从`admin@test.com`、`admin@subdomain.test.com`、`test@test.com`或任何其他变体发送电子邮件。这是攻击者喜欢看到的，因为我们可以根据需要定制我们的网络钓鱼攻击。这些信息可能很有帮助，因为我们可能能够发现以前不知道的电子邮件/域，从而更容易制定看起来真实的网络钓鱼攻击。
- en: 'Next, once we have found a domain and/or email address that has been verified,
    we will want to make sure that email sending is enabled in that same region. We
    can check this with the following AWS CLI command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一旦我们找到了已验证的域名和/或电子邮件地址，我们将希望确保在同一区域中启用了电子邮件发送。我们可以使用以下AWS CLI命令检查：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should return `True` or `False`, depending on whether email sending is
    enabled or disabled in the `us-west-2` region. If sending is disabled, there are
    no other regions with verified domains/email accounts, and we have the `"ses:UpdateAccountSendingEnabled"`
    permission, we can use that permission to re-enable sending to allow us to perform
    our phishing attack. The following command will do just that:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回`True`或`False`，取决于`us-west-2`区域是否启用了电子邮件发送。如果发送被禁用，没有其他已验证域名/电子邮件帐户的区域，并且我们具有`"ses:UpdateAccountSendingEnabled"`权限，我们可以使用该权限重新启用发送，以便执行我们的网络钓鱼攻击。以下命令将实现这一点：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Be careful when running this in someone else's environment, though, because
    sending may be disabled for a very specific reason and enabling it again could
    cause unknown problems. If this command was successful, the AWS CLI won't respond
    with anything; otherwise, you will see an error that explains what the problem
    was.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在他人的环境中运行此命令时要小心，因为可能出于非常特定的原因禁用了发送，再次启用可能会导致未知问题。如果此命令成功，AWS CLI不会做出任何响应；否则，您将看到一个解释问题的错误。
- en: 'Next, we will want to confirm that the domain/email address in this region
    is verified, which can be done with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确认该区域中的域名/电子邮件地址是否已验证，可以使用以下命令完成：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should receive a response back that indicates whether `"admin@example.com"`
    and `"test.com"` are verified. That should look like the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该收到一个响应，指示`"admin@example.com"`和`"test.com"`是否已验证。输出应该如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, `"test.com"` is still pending verification, so we cannot use
    it for sending out emails, but `admin@example.com` has been successfully verified.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`"test.com"`仍在等待验证，因此我们不能用它发送电子邮件，但`admin@example.com`已成功验证。
- en: 'So, we have found an identity that has been successfully verified in a region
    with sending enabled; now we need to check the identity policy of it. We can do
    this with the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经找到了在启用发送的区域中成功验证的身份；现在我们需要检查其身份策略。我们可以使用以下命令完成：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If an empty list of policy names comes back, then that means no policy has
    been applied to this identity and that means good news for us, because there are
    no restrictions on the use of this identity. If there is a policy applied, its
    name will show up in the response, which means we then need to follow up with
    a `GetIdentityPolicies` command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回一个空的策略名称列表，那么这意味着没有策略应用于此身份，这对我们来说是个好消息，因为对于此身份的使用没有限制。如果应用了策略，其名称将显示在响应中，这意味着我们需要跟进使用`GetIdentityPolicies`命令：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should return a JSON document that specifies who can do what with the
    identity we specified (`admin@example.com`). Like we have seen in the past, this
    JSON policy will be returned to us as an escaped string within another JSON object.
    That policy should look something like this (after converting it from an escaped
    string in to a real JSON object for easier viewing):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回一个JSON文档，指定了我们指定的身份(`admin@example.com`)可以做什么。就像我们过去看到的那样，这个JSON策略将作为一个转义字符串返回给我们，放在另一个JSON对象中。该策略应该看起来像这样（将其从转义字符串转换为真正的JSON对象以便更容易查看）：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This shows us that the IAM user with the  `"arn:aws:iam::000000000000:user/ExampleAdmin"` ARN is
    the only entity that can use the `admin@example.com` email to send emails. This
    is an example of a scenario where we need to escalate our permissions by modifying
    this policy, because even if we have the `"ses:SendEmail"` permission, this policy
    is preventing us from using it (because we are assuming that we are not the `ExampleAdmin`
    IAM user).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明，具有`"arn:aws:iam::000000000000:user/ExampleAdmin"` ARN的IAM用户是唯一可以使用`admin@example.com`发送电子邮件的实体。这是一个我们需要通过修改此策略来提升我们权限的情况的示例，因为即使我们具有`"ses:SendEmail"`权限，该策略也阻止我们使用它（因为我们假设我们不是`ExampleAdmin`
    IAM用户）。
- en: 'To make this happen, we need to modify that policy to add our own user as a
    trusted principal. To add ourselves in, we just need to change the value of the
    Principal | AWS key to an array, where we then add our own user''s ARN in as a
    trusted principal. After we do that, the policy should look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要修改该策略，将我们自己的用户添加为受信任的主体。为了添加我们自己，我们只需要将Principal | AWS的值更改为一个数组，然后将我们自己的用户的ARN添加为受信任的主体。这样做之后，策略应该如下所示：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this policy, we have granted access to the `"CompromisedUser"` IAM user,
    which we are assuming is the user we have compromised in a pentest. Another option
    would to allow access to your own AWS account, because SES identity policies support
    cross-account email sending, so you wouldn't even need credentials for the target
    account after you add the ARN of your other account ([https://aws.amazon.com/about-aws/whats-new/2015/07/amazon-ses-now-supports-cross-account-sending/](https://aws.amazon.com/about-aws/whats-new/2015/07/amazon-ses-now-supports-cross-account-sending/)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此策略中，我们已授予`"CompromisedUser"`IAM用户访问权限，我们假设这是我们在渗透测试中受到影响的用户。另一个选择是允许访问您自己的AWS帐户，因为SES身份策略支持跨帐户发送电子邮件，因此在添加您其他帐户的ARN后，您甚至不需要目标帐户的凭据。
- en: 'We can update this policy by using the SES `PutIdentityPolicy` API:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SES `PutIdentityPolicy` API更新此策略。
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ses-policy-document.json` file includes the JSON we previously added our
    compromised user trust to. There should be no output if the update was successful;
    otherwise, an error will explain what happened.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ses-policy-document.json`文件包括我们之前添加的受损用户信任的JSON。如果更新成功，将不会有任何输出；否则，错误将解释发生了什么。'
- en: If that was successful, then we have essentially escalated our SES identity
    permissions by adding ourselves as a trusted entity. Now that the policy allows
    us to send emails and we have the `ses:SendEmail` permission, we are almost ready
    to get to phishing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，那么我们基本上通过将自己添加为受信任的实体来提升了我们的SES身份权限。现在策略允许我们发送电子邮件，并且我们有`ses:SendEmail`权限，我们几乎准备好进行钓鱼了。
- en: The one last thing that we need to think about is whether the current account
    is still in the SES sandbox. There currently isn't a great way to determine this
    from the AWS CLI without just attempting to send an email, but if you have AWS
    web console access, then you will be able to find this information out. The SES
    sandbox restricts sending emails to any email account/domain that is outside your
    list of verified email accounts/domains. Normally, you are only able to send emails
    from verified email accounts/domains in SES, but if your account is still in the
    SES sandbox, then you can only send emails from and to verified email accounts/domains.
    This means that, in our demo account, if it was still in the SES sandbox, we could
    only send emails from `admin@example.com` to `admin@example.com`. This restriction
    must be manually requested to be lifted, so if you encounter an account that is
    using SES, you are likely to find they are already out of the SES sandbox for
    their own business needs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一件事是当前帐户是否仍在SES沙箱中。目前还没有一个很好的方法可以在AWS CLI中确定这一点，而不是尝试发送电子邮件，但如果您有AWS
    Web控制台访问权限，那么您将能够找到这些信息。SES沙箱限制发送电子邮件到您已验证的电子邮件帐户/域之外的任何电子邮件帐户/域。通常，您只能从SES中的已验证电子邮件帐户/域发送电子邮件，但如果您的帐户仍在SES沙箱中，那么您只能从已验证的电子邮件帐户/域发送电子邮件，并且只能发送到已验证的电子邮件帐户/域。这意味着，在我们的演示帐户中，如果它仍然在SES沙箱中，我们只能从`admin@example.com`发送电子邮件到`admin@example.com`。必须手动请求解除此限制，因此如果您遇到正在使用SES的帐户，很可能会发现他们已经出于自己的业务需求而脱离了SES沙箱。
- en: If you find an account that is still in the SES sandbox but has a verified domain
    identity, that means you can still send emails from any email account at that
    domain to any email account at that domain, which means you can likely still abuse
    this access for internal phishing of employees.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现一个仍然在SES沙箱中但已经验证了域身份的帐户，这意味着您仍然可以从该域的任何电子邮件帐户发送电子邮件到该域的任何电子邮件帐户，这意味着您可能仍然可以滥用这种访问权限来对员工进行内部钓鱼攻击。
- en: 'If you have AWS web console access with your compromised account, you can check
    for sandbox access by visiting the Sending Statistics page of the SES console.
    You''ll want to check each region you find a verified identity in, just in case
    one region is still in the sandbox, but another isn''t. If the account is still
    in the sandbox, you will see the message in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用受损的帐户访问AWS Web控制台，可以通过访问SES控制台的发送统计页面来检查沙箱访问权限。您需要检查您发现已验证身份的每个区域，以防一个区域仍然在沙箱中，而另一个区域不在。如果帐户仍然在沙箱中，您将在以下截图中看到以下消息：
- en: '![](img/b7df4642-48dd-4555-9868-db947bf04b0a.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7df4642-48dd-4555-9868-db947bf04b0a.png)'
- en: The AWS account in this screenshot is still restricted to the sandbox in us-west-2
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图中的AWS帐户仍受限于us-west-2的沙箱
- en: 'When you''re ready to start sending off your phishing emails, it is worth checking
    out any email templates that the target might have saved in their SES configuration.
    This could give you an idea on the format that this email account usually uses
    when sending emails out, as well as what type of content is usually sent out.
    You won''t always find templates saved in SES, but when you do, they can be very
    useful. We can find any existing templates with the `ListTemplates` API:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备开始发送钓鱼邮件时，值得查看目标可能在其SES配置中保存的任何电子邮件模板。这可以让您了解此电子邮件帐户通常在发送电子邮件时使用的格式，以及通常发送的内容类型。您并不总是会在SES中找到保存的模板，但当您找到时，它们可能非常有用。我们可以使用`ListTemplates`
    API查找任何现有模板：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we can use the `GetTemplate` API to review the content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`GetTemplate` API来查看内容：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, we can build our phishing email around a template that looks promising.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以围绕一个看起来有希望的模板构建我们的钓鱼邮件。
- en: 'When all of that is said and done, we can finally use the SES `SendEmail` API
    to send off our phishing emails. For more information on setting up the CLI to
    send an email, refer to this guide in the SES documentation: [https://docs.aws.amazon.com/cli/latest/reference/ses/send-email.html](https://docs.aws.amazon.com/cli/latest/reference/ses/send-email.html).
    Now we have successfully sent out phishing emails from legitimate domains, using
    legitimate templates, which are near guaranteed to trick some end users/employees
    into disclosing sensitive information.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些都说完了，我们最终可以使用SES `SendEmail` API发送我们的网络钓鱼邮件。有关设置CLI发送电子邮件的更多信息，请参阅SES文档中的指南：[https://docs.aws.amazon.com/cli/latest/reference/ses/send-email.html](https://docs.aws.amazon.com/cli/latest/reference/ses/send-email.html)。现在，我们已经成功从合法域名发送了网络钓鱼邮件，使用了合法的模板，几乎可以肯定地欺骗一些最终用户/员工透露敏感信息。
- en: Other attacks
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他攻击
- en: Even if we can't use the SES `SendEmail` API or we don't want to attract unwanted
    attention from a defender, we can still abuse SES for phishing if they are using
    email templates. We can use the SES `UpdateTemplate` API to update the text/HTML
    of an email template that is already created in SES. As an attacker, we can use
    this to basically establish backdoor phishing emails. Let's say Example Co. uses
    SES templates to send out marketing emails. We, as the attacker, can go in and
    modify that specific template, where we could insert malicious links and content.
    Then, every time `Example Co.` sends out their marketing emails, our malicious
    links and content will be included, increasing the chances of our attack working
    by a large amount.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们无法使用SES `SendEmail` API，或者我们不想吸引防御者的注意，如果他们使用电子邮件模板，我们仍然可以滥用SES进行网络钓鱼。我们可以使用SES
    `UpdateTemplate` API来更新SES中已创建的电子邮件模板的文本/HTML。作为攻击者，我们可以利用这一点基本上建立后门网络钓鱼电子邮件。假设Example
    Co.使用SES模板发送营销电子邮件。作为攻击者，我们可以进入并修改特定模板，插入恶意链接和内容。然后，每当`Example Co.`发送他们的营销电子邮件时，我们的恶意链接和内容将被包含在内，大大增加我们的攻击成功的几率。
- en: Another attack that could be performed would be to set up a receipt rule that
    determines what happens with incoming emails to those verified emails/domains.
    By using the SES `CreateReceiptRule` API, we could set up a receipt rule that
    sends all incoming messages to our own S3 bucket in our attacker account, where
    we could then read for sensitive contents, or a variety of other options supported
    by receipt rules, such as triggering Lambda functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以执行的另一个攻击是设置一个收据规则，确定对已验证的电子邮件/域名的传入电子邮件的处理方式。通过使用SES `CreateReceiptRule` API，我们可以设置一个收据规则，将所有传入的消息发送到我们攻击者帐户中的自己的S3存储桶，然后我们可以读取敏感内容，或者使用收据规则支持的其他选项，如触发Lambda函数。
- en: Attacking all of CloudFormation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击所有CloudFormation
- en: CloudFormation is an extremely useful service that has been maturing quite a
    bit recently. It essentially lets you write code that is then translated into
    AWS resources, allowing you to easily spin up and down your resources and track
    those resources from a central location. CloudFormation seems to suffer from some
    of the same issues regular source code does, including hardcoded secrets, overly
    permissive deployments, and more, which we will cover here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation是一个非常有用的服务，最近已经成熟了很多。它基本上让你编写代码，然后将其转换为AWS资源，使您可以轻松地启动和关闭资源，并从一个中央位置跟踪这些资源。CloudFormation似乎遇到了一些常规源代码的问题，包括硬编码的秘密，过度宽松的部署等，我们将在这里进行介绍。
- en: 'There are many things to look at when pentesting CloudFormation. The following
    list is what we will cover in this section:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试CloudFormation时有很多要注意的事情。以下列表是我们将在本节中涵盖的内容：
- en: Stack parameters
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈参数
- en: Stack output values
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈输出值
- en: Stack termination protection
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈终止保护
- en: Deleted stacks
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已删除的堆栈
- en: Stack exports
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈导出
- en: Stack templates
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈模板
- en: Passed roles
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的角色
- en: For this section, we have spun up a simple LAMP stack, based off the simple
    LAMP stack CloudFormation sample template, but with a few modifications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，我们已经启动了一个简单的LAMP堆栈，基于简单的LAMP堆栈CloudFormation示例模板，但进行了一些修改。
- en: 'The first thing we are going to want to do is use the CloudFormation `DescribeStacks` API
    to gather some information on the stacks across each region. Again, these APIs
    are per-region, so they may need to be run across each region to ensure that all
    stacks are discovered. We can do this by running the following AWS CLI command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是使用CloudFormation `DescribeStacks` API来收集每个区域的堆栈信息。同样，这些API是按区域划分的，因此可能需要在每个区域运行它们，以确保发现所有的堆栈。我们可以通过运行以下AWS
    CLI命令来实现这一点：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The nice thing about this command is that it will return multiple things we
    want to look at for each stack.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的好处是它将为每个堆栈返回我们想要查看的多个内容。
- en: Parameters
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: The first interesting piece of information we will want to inspect is what is
    stored under `"Parameters"`. Available parameters are defined in the stacks template,
    then the values are passed in when using that template to create a new stack.
    The names and values of these parameters are stored along with the associated
    stack and show up under the `"Parameters"` key of the `DescribeStacks` API call
    response.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一条有趣信息是存储在“Parameters”下的内容。可用参数在堆栈模板中定义，然后在使用该模板创建新堆栈时传递值。这些参数的名称和值与关联的堆栈一起存储，并显示在“Parameters”键下的DescribeStacks
    API调用响应中。
- en: We are hoping to find some sensitive information being passed in to parameters,
    where we could then use it to gain further access to the environment. If best
    practices are being followed, then we ideally should not be able to find any sensitive
    information in the values of the parameters for a stack, but we have found that
    best practices aren't always followed and that certain sensitive values will sneak
    by occasionally. Best practice is to use the `NoEcho` property when defining a
    parameter in a CloudFormation template, which prevents the value passed to that
    parameter from being echoed back to anyone running the `DescribeStacks` API call.
    If `NoEcho` is used and set to `true`, then that parameter will still show up
    under `Parameters` when describing stacks, but its value will be censored with
    a few `"*"` characters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望找到一些敏感信息被传递到参数中，然后我们可以使用它来进一步访问环境。如果遵循最佳实践，那么理想情况下我们不应该能够在堆栈的参数值中找到任何敏感信息，但我们发现最佳实践并不总是被遵循，某些敏感值偶尔会被漏掉。最佳实践是在定义CloudFormation模板中的参数时使用`NoEcho`属性，这可以防止传递给该参数的值被回显给运行`DescribeStacks`
    API调用的任何人。如果使用`NoEcho`并将其设置为`true`，那么在描述堆栈时该参数仍将显示在`Parameters`下，但其值将被用几个`“*”`字符进行屏蔽。
- en: 'For the stack we created for this demo, the following parameters are returned:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们为此演示创建的堆栈，返回以下参数：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are a few different things we can take away from this information. Some
    basic information gathering lets us see that there is an SSH key named `"MySSHKey"`
    being used, SSH access is allowed from `"0.0.0.0/0"`, there is a database named
    `"CustomerDatabase"`, and there is an EC2 instance of the `"t2.small"` type. In
    addition to all of that, we see a few database passwords and a database username.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中我们可以得出一些不同的东西。一些基本的信息收集让我们看到有一个名为`“MySSHKey”`的SSH密钥正在使用，允许从`“0.0.0.0/0”`进行SSH访问，有一个名为`“CustomerDatabase”`的数据库，以及一个`“t2.small”`类型的EC2实例。除此之外，我们还看到一些数据库密码和数据库用户名。
- en: We can see that `"DBUser"` has a value of `"****"`, which likely means that
    the `DBUser` parameter had `"NoEcho"` set to `true`, so that its value would be
    censored when trying to read from it. It is also possible that the value of `DBUser`
    is actually `"****"`, but that can be confirmed easily by checking out the template
    for the stack, where we can review the constraints and properties set for the
    `DBUser` parameter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`“DBUser”`的值为`“****”`，这很可能意味着`DBUser`参数已经将`“NoEcho”`设置为`true`，因此在尝试从中读取时其值将被屏蔽。`DBUser`的值也可能是`“****”`，但可以通过查看堆栈的模板来轻松确认这一点，我们可以在那里审查为`DBUser`参数设置的约束和属性。
- en: Due to `cleartext` values being under `"DBPassword"` and `"DBRootPassword"`,
    we know that whoever designed this CloudFormation template made a few mistakes.
    They forgot to set `"NoEcho"` for those two parameters, so the `cleartext` passwords
    are returned anytime anyone describes the current stack. This is good for us attackers,
    because now we have the `cleartext` password for the regular database user and
    the root database user for a database. We can analyse the template again to find
    where this database might be or how we can access it, but we will get there in
    a little bit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`“DBPassword”`和`“DBRootPassword”`下的`明文`值，我们知道设计这个CloudFormation模板的人犯了一些错误。他们忘记为这两个参数设置`“NoEcho”`，因此每当有人描述当前堆栈时，`明文`密码都会被返回。这对我们攻击者来说是好事，因为现在我们有了常规数据库用户和数据库根用户的`明文`密码。我们可以再次分析模板，找出这个数据库可能在哪里或者我们如何访问它，但我们稍后会到达那里。
- en: Beyond the `cleartext` passwords, we also see that `"SSHLocation"` is set to
    `"0.0.0.0/0"`, which we can assume means some server was set up to allow SSH access
    from that IP range, which means that anyone on the internet can access the SSH
    server, because `0.0.0.0/0` is a representation of all IPv4 addresses that exist.
    That is good information for us as well, because maybe we will be able to exploit
    some out-of-date SSH software on the server to gain access or something like that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`明文`密码之外，我们还看到`“SSHLocation”`被设置为`“0.0.0.0/0”`，我们可以假设这意味着某个服务器被设置为允许来自该IP范围的SSH访问，这意味着任何人都可以访问SSH服务器，因为`0.0.0.0/0`代表所有存在的IPv4地址。这对我们来说也是有用的信息，因为也许我们将能够利用服务器上过时的SSH软件来获取访问权限或类似的东西。
- en: Output values
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出值
- en: 'Next, we will want to check out the values under `"Outputs"` when we described
    the CloudFormation stacks earlier. We are looking at something essentially the
    same as what was in `"Parameters"`, but these values are ones that were generated
    during the creation of the stack. Again, we want to look for sensitive information.
    There may not be any output values for some stacks, so there won''t be anything
    to look at for this part of the demo if that is the case you have run into. In
    our demo, this is what showed up under the `Outputs` section of our stack when
    describing it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要检查在之前描述CloudFormation堆栈时在`“Outputs”`下的值。我们正在查看与`“Parameters”`中基本相同的东西，但这些值是在堆栈创建过程中生成的。同样，我们要寻找敏感信息。对于某些堆栈可能没有输出值，因此如果遇到这种情况，我们在演示的这部分中就没有什么可看的了。在我们的演示中，当我们描述它时，这是显示在堆栈的`Outputs`部分下的内容：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see, there isn''t anything *too* sensitive in here, but it does give
    us the public endpoint of an EC2 instance that was likely created during the creation
    of the stack. Given the `"SSHLocation"` parameter being set to `0.0.0.0/0`, we
    should likely find an open SSH port (`22`) on this server. We can use `nmap` to
    run a service scan to (`-sV`) verify this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里没有太敏感的东西，但它确实给了我们一个EC2实例的公共端点，很可能是在创建堆栈时创建的。鉴于`“SSHLocation”`参数被设置为`0.0.0.0/0`，我们很可能会在这台服务器上找到一个开放的SSH端口（`22`）。我们可以使用`nmap`运行服务扫描（`-sV`）来验证这一点：
- en: '![](img/91e1c7a2-d9ea-45cd-b312-41f4989f5af2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91e1c7a2-d9ea-45cd-b312-41f4989f5af2.png)'
- en: Port 22 is found to be open and running OpenSSH version 7.4
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 22端口被发现是开放的，并且运行着OpenSSH版本7.4
- en: We have verified that there is an open SSH port on that server, like we expected.
    Just by looking at the output values of this CloudFormation stack, we were able
    to identify the public endpoint of this EC2 instance, which has port `22` `open`,
    running an SSH server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经验证了服务器上有一个开放的SSH端口，就像我们预期的那样。仅通过查看CloudFormation堆栈的输出值，我们就能够识别出这个EC2实例的公共端点，该端点的端口“22”是“开放”的，运行着一个SSH服务器。
- en: It is possible for the output values to include sensitive information, such
    as credentials or API keys. An example of this might be when a template needs
    to create a new IAM user along with a set of access keys for that user. Those
    access keys would then likely be shown in the output values of the stack, as there
    needs to be some way for a user to access them after creating the stack ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-accesskey](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-accesskey)).
    Those keys might be able to grant us further access to the environment in hopes
    of escalating privileges higher than we already have.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出值可能包含敏感信息，例如凭据或API密钥。例如，当模板需要为新的IAM用户创建一组访问密钥时，这可能会发生。然后，这些访问密钥可能会显示在堆栈的输出值中，因为在创建堆栈后，用户需要某种方式来访问它们（https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-accesskey）。这些密钥可能会使我们能够进一步访问环境，以期提升我们已有的权限。
- en: Bonus – discovering the values of NoEcho parameters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励-发现NoEcho参数的值
- en: Like we discussed earlier, using the `NoEcho` property on a parameter prevents
    its value from being shown when using the DescribeStacks API so that sensitive
    values aren't exposed to any user who can make that API call. Sometimes (most
    of the time), values with the `"NoEcho"` property set to `true` would be useful
    to us as attackers, because often they would be passwords or API keys. All is
    not lost, though, because with the right permissions, you can uncover the values
    that were used for those parameters to deploy CloudFormation stacks that exist
    in the account.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，使用参数上的“NoEcho”属性可以防止在使用DescribeStacks API时显示其值，以便敏感值不会暴露给可以调用该API的任何用户。有时（大多数情况下），具有“NoEcho”属性设置为“true”的值对我们作为攻击者可能是有用的，因为通常它们可能是密码或API密钥。但并非一无所获，因为在拥有适当权限的情况下，您可以揭示用于部署账户中存在的CloudFormation堆栈的那些参数的值。
- en: To do this, you are required to have the `cloudformation:UpdateStack` permission
    at the minimum. If we wanted to uncover the `NoEcho` parameter `DBUser` from our
    previously mentioned demo stack, we would first download the template for that
    stack with the `GetTemplate` API command. If we didn't have the `GetTemplate`
    permissions, we could create our own template, but that would effectively delete
    every resource that the stack created, and we did not include in our custom template,
    so we won't be covering that.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您至少需要具有“cloudformation:UpdateStack”权限。如果我们想要从先前提到的演示堆栈中揭示“NoEcho”参数“DBUser”，我们首先需要使用“GetTemplate”API命令下载该堆栈的模板。如果我们没有“GetTemplate”权限，我们可以创建自己的模板，但这实际上会删除堆栈创建的每个资源，而我们没有包含在自定义模板中，因此我们不会涉及到这一点。
- en: 'Save the template to `template.json` in your current directory, then just like
    the previous section, create `params.json` with the following data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将模板保存到当前目录中的“template.json”中，然后就像前一节一样，创建包含以下数据的“params.json”：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is so that we can update the template of the stack without modifying the
    values of parameters that were already passed in, including `"DBUser"`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以更新堆栈的模板，而不修改已传递的参数的值，包括“DBUser”。
- en: 'Then all that needs to be done is to remove the `"NoEcho"` property on the
    `DBUser` parameter or set it to `false`. At this point, if we try to update the
    stack, we''ll likely receive this message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要做的就是删除“DBUser”参数上的“NoEcho”属性，或将其设置为“false”。此时，如果我们尝试更新堆栈，我们可能会收到以下消息：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is because CloudFormation is not recognizing the removal/change of the
    `"NoEcho"` parameter for `DBUser`. The easiest thing to do would be to just change
    some string somewhere in the template. Make sure it won''t cause any problems,
    such as adding a space to a comment in some code or something like that. Make
    sure not to insert it into some configuration that would cause any problems when
    redeploying that resource. Then, we can run the same command as before to update
    the stack with this new template:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为CloudFormation没有识别“NoEcho”参数对“DBUser”的删除/更改。最简单的方法就是在模板的某个地方更改一些字符串。确保不会引起任何问题，比如在某些代码的注释中添加一个空格之类的。确保不要将其插入到某些配置中，这样在重新部署资源时不会引起任何问题。然后，我们可以运行与之前相同的命令来使用这个新模板更新堆栈：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, once the stack is done updating, we should be able to DescribeStacks again
    and have access to the uncensored value that was previously input when the stack
    was created:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦堆栈更新完成，我们应该能够再次描述堆栈，并且可以访问之前在创建堆栈时输入的未经审查的值：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see from this partial output from running DescribeStacks, the value
    of `"DBUser"` has been unmasked and it shows us that it is set to the value of
    `"admin"`. We did all of that and discovered that secret value without causing
    any disruption to the environment either, so that is a win-win for us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行DescribeStacks的部分输出中可以看出，“DBUser”的值已经被解除掩码，并且显示它被设置为“admin”的值。我们做到了所有这些，并且在不对环境造成任何干扰的情况下发现了秘密值，所以这对我们来说是双赢的。
- en: Termination protection
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止保护
- en: 'Termination protection is a setting that can be enabled that blocks a CloudFormation
    stack from being deleted. To delete a stack with termination protection enabled,
    you would first need to disable it, then try to delete the stack, which requires
    a different set of permissions that you might not have. It''s generally a best
    practice to enable termination protection on CloudFormation stacks, so although
    it doesn''t directly affect us as attackers (unless we are trying to delete everything),
    it is good to check each stack for termination protection and note it as a potential
    misconfiguration in the environment. To check this value, we still use the `DescribeStacks`
    API, but it requires that we name the stacks specifically in the API call. Our
    demo stack is named `Test-Lamp-Stack`, so to determine the termination protection
    setting for that stack, we could run the following AWS CLI command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 终止保护是一种可以启用的设置，它阻止CloudFormation堆栈被删除。要删除启用了终止保护的堆栈，您首先需要禁用它，然后尝试删除堆栈，这需要一组不同的权限，您可能没有这些权限。通常最好在CloudFormation堆栈上启用终止保护，因此，尽管它不会直接影响我们作为攻击者（除非我们试图删除所有内容），但检查每个堆栈的终止保护并将其作为环境中的潜在错误配置是很好的做法。要检查此值，我们仍然使用`DescribeStacks`
    API，但它要求我们在API调用中明确命名堆栈。我们的演示堆栈名为`Test-Lamp-Stack`，因此要确定该堆栈的终止保护设置，我们可以运行以下AWS
    CLI命令：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The results should be like what we have seen previously, but they will include
    the `EnableTerminationProtection` key, which is set to `true` or `false`, which
    specifies whether termination protection is enabled or not.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该与我们之前看到的类似，但它们将包括`EnableTerminationProtection`键，该键设置为`true`或`false`，指定了是否启用了终止保护。
- en: Deleted stacks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除的堆栈
- en: 'CloudFormation also allows you to inspect stacks that have been deleted, but
    it is a little bit of a different process on the CLI. From the AWS web console
    CloudFormation stacks page, there is a drop-down box that allows you to show all
    deleted stacks, like what is shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation还允许您检查已删除的堆栈，但在CLI上的过程有点不同。从AWS Web控制台CloudFormation堆栈页面，有一个下拉框，允许您显示所有已删除的堆栈，就像下面的截图所示：
- en: '![](img/f3304abb-0eb9-4acf-922e-32450f27eb84.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3304abb-0eb9-4acf-922e-32450f27eb84.png)'
- en: Listing deleted CloudFormation stacks on the AWS web console
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS Web控制台上列出已删除的CloudFormation堆栈
- en: 'From the CLI, we first need to run the CloudFormation `ListStacks` command,
    which looks like this using the AWS CLI:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从CLI，我们首先需要运行CloudFormation `ListStacks`命令，使用AWS CLI看起来像这样：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command will provide similar output to the `DescribeStacks` command, but
    it is a little less verbose. The `ListStacks` command also includes deleted CloudFormation
    stacks, which can be identified by looking at the StackStatus key for a particular
    stack, where the value will be `DELETE_COMPLETE`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将提供与`DescribeStacks`命令类似的输出，但它不太冗长。`ListStacks`命令还包括已删除的CloudFormation堆栈，可以通过查看特定堆栈的StackStatus键来识别，其中值将为`DELETE_COMPLETE`。
- en: 'To get more details on deleted stacks, we must then explicitly pass them into
    the `DescribeStacks` command. Unlike active stacks, deleted stacks cannot be referred
    to by their name, only their unique stack ID. A unique stack ID is just the value
    under the `"StackId"` key of the output from `ListStacks`. It will be an ARN,
    formatted similarly to this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关已删除堆栈的更多详细信息，我们必须明确地将它们传递到`DescribeStacks`命令中。与活动堆栈不同，已删除的堆栈不能通过它们的名称引用，只能通过它们的唯一堆栈ID引用。唯一的堆栈ID只是`ListStacks`输出中`"StackId"`键下的值。它将是一个类似于这样格式的ARN：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then run the `DescribeStacks` command and pass that value into the `--stack-name`
    parameter, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行`DescribeStacks`命令，并将该值传递给`--stack-name`参数，就像这样：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The output of that command should look familiar, where we can now review the
    parameter values and output values associated with that deleted stack. It is important
    to check deleted stacks for secrets for many reasons, one being that the reason
    that stack was deleted could be because a developer made a mistake that accidentally
    exposed sensitive information or something along those lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出应该看起来很熟悉，我们现在可以查看与已删除堆栈相关联的参数值和输出值。检查已删除的堆栈是否包含秘密信息非常重要，其中一个原因是，删除堆栈的原因可能是开发人员犯了错误，意外地暴露了敏感信息或类似情况。
- en: Exports
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出
- en: 'CloudFormation exports allow you to share output values between different stacks
    without having to worry about referencing those other stacks. Any value that is
    exported will also be stored under `"outputs"` of the stack that exported it,
    so if you review the output values of every active and deleted stacks, you will
    have already viewed the exports. It might be useful to look at the aggregated
    list of exports though, to see what kind of information is available to each stack.
    This might make it easier to learn more about the target environment and/or use
    cases of the CloudFormation stacks. To retrieve this data, we can use the `ListExports`
    command from the AWS CLI:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation导出允许您在不必担心引用其他堆栈的情况下共享输出值。任何导出的值也将存储在导出它的堆栈的`"outputs"`下，因此，如果您查看每个活动和已删除堆栈的输出值，您已经查看了导出。查看聚合导出列表可能会有所帮助，以查看每个堆栈可用的信息类型。这可能会更容易了解目标环境和/或CloudFormation堆栈的用例。要检索这些数据，我们可以使用AWS
    CLI的`ListExports`命令：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output will tell you the name and value of each export and what stack exported
    it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将告诉您每个导出的名称和值以及导出它的堆栈。
- en: Templates
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Now we want to look at the actual templates that were used to create the CloudFormation
    stacks that we see. We can do this with the CloudFormation `GetTemplate` command.
    This command works like the `DescribeStacks` command, where we can pass in a template
    name to the `--stack-name` parameter to retrieve the template for that specific
    stack. It also works the same in the way that, if you are looking to retrieve
    the template of a deleted stack, you need to specify the unique stack ID instead
    of the name. To get the template of our demo stack, we can run the following AWS
    CLI command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想查看用于创建我们看到的CloudFormation堆栈的实际模板。我们可以使用CloudFormation `GetTemplate`命令来实现这一点。此命令的工作方式类似于`DescribeStacks`命令，我们可以将模板名称传递给`--stack-name`参数，以检索该特定堆栈的模板。如果要检索已删除堆栈的模板，也需要指定唯一的堆栈ID而不是名称。要获取我们的演示堆栈的模板，我们可以运行以下AWS
    CLI命令：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The response should include the JSON/YAML template that was used to create the
    stack we named.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应包括用于创建我们命名的堆栈的JSON/YAML模板。
- en: Now there are a few things we can do, but manual inspection of the template
    is the most effective. Before we start manual inspection though, it might be useful
    to run a security scanner against the template itself to try and discover any
    security risks in the assets specified in it. Some of the tools created for this
    purpose are meant to be set up and used in **Continuous Integration** (**CI**)/**Continuous
    Deployment** (**CD**) environments, such as `"cfripper"` by Skyscanner ([https://github.com/Skyscanner/cfripper/](https://github.com/Skyscanner/cfripper/)).
    For this example, we'll use `"cfn_nag"` by Stelligent ([https://github.com/stelligent/cfn_nag](https://github.com/stelligent/cfn_nag)),
    which can also be run against individual files/directories containing CloudFormation
    templates. These tools generally won't catch everything, but they can be a big
    help in identifying certain insecure configurations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以做一些事情，但手动检查模板是最有效的。在开始手动检查之前，对模板本身运行安全扫描可能是有用的，以尝试发现其中指定的资产中的任何安全风险。为此创建的一些工具旨在在**持续集成**（**CI**）/
    **持续部署**（**CD**）环境中设置和使用，例如Skyscanner的“cfripper”（[https://github.com/Skyscanner/cfripper/](https://github.com/Skyscanner/cfripper/)）。在此示例中，我们将使用Stelligent的“cfn_nag”（[https://github.com/stelligent/cfn_nag](https://github.com/stelligent/cfn_nag)），它也可以针对包含CloudFormation模板的单个文件/目录运行。这些工具通常不会捕捉所有内容，但它们可以帮助识别某些不安全的配置。
- en: 'To use `cfn_nag` (at the time of writing, this may change as the tool updates),
    we will assume we have Ruby 2.2.x installed, so we can install the `cfn_nag` gem
    with the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`cfn_nag`（在撰写本文时，这可能会随着工具的更新而改变），我们将假设已安装Ruby 2.2.x，因此我们可以使用以下命令安装`cfn_nag`
    gem：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can save the template we retrieved from the AWS API to a file, such
    as `template.json` or `template.yaml`, depending on the type of template you have.
    For our demo, we saved it to `template.json`, so we can run the following command
    to scan the template:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将从AWS API检索到的模板保存到文件中，例如`template.json`或`template.yaml`，具体取决于您的模板类型。对于我们的演示，我们将其保存到`template.json`，因此我们可以运行以下命令来扫描模板：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output should look something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![](img/a11cae28-0155-45b8-a8db-b01b880f804b.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a11cae28-0155-45b8-a8db-b01b880f804b.png)'
- en: The results of scanning our CloudFormation template with cfn_nag
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cfn_nag扫描我们的CloudFormation模板的结果
- en: The output shows that the template we scanned output `1` failure and `2` warnings.
    All three are associated with `"WebServerSecurityGroup"` and its inbound/outbound
    rule sets. The two warnings are about overly permissive inbound rules allowed
    through that security group, but if that security group is also defining the SSH
    inbound rules, then it makes sense that those two warnings showed up. This is
    because we know that inbound access to SSH is allowed from the `0.0.0.0/0` range ,
    which is not a `/32` IP range, and that it means the world is allowed access.
    Even with that information, it is still worth checking out manually.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，我们扫描的模板输出了`1`个失败和`2`个警告。所有三个都与“WebServerSecurityGroup”及其入站/出站规则集相关联。两个警告是关于允许通过该安全组的入站规则过于宽松，但如果该安全组还定义了SSH入站规则，那么这两个警告出现是有道理的。这是因为我们知道允许从`0.0.0.0/0`范围访问SSH入站，这不是`/32`
    IP范围，这意味着允许世界访问。即使有了这些信息，手动检查仍然是值得的。
- en: The failure that `cfn_nag` reported will likely be irrelevant until we find
    a way to compromise the EC2 instance behind the security group—then we will start
    caring about what outbound access rules are set up. Given that no rules are specified
    (according to `cfn_nag`), that means all outbound internet access is allowed and
    that we won't need to worry about it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`cfn_nag`报告的失败可能在找到一种妥协EC2实例的方法之前是无关紧要的，然后我们将开始关心设置了什么出站访问规则。鉴于`cfn_nag`没有指定规则，这意味着允许所有出站互联网访问，我们不需要担心。'
- en: After scanning the template, it is most likely time for manual inspection. Manual
    inspection will provide us with a lot of information about the resources the template
    sets up and it is possible we could find other sensitive information stored throughout.
    After opening the template in our favorite text editor, we can browse through
    with a few things in mind. We should check out the parameters again to see whether
    there are any hardcoded sensitive default values, but also because we can possibly
    get a description of exactly what that parameter is.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描模板后，很可能是时候进行手动检查了。手动检查将为我们提供有关模板设置的资源的大量信息，可能会发现存储在其中的其他敏感信息。在我们喜爱的文本编辑器中打开模板后，我们可以考虑一些事情。我们应该再次检查参数，看看是否有任何硬编码的敏感默认值，但也因为我们可能可以得到有关该参数的确切描述。
- en: Like we expected earlier, looking at the `"SSHLocation"` parameter, we can see
    that there is a description that says the IP address range that can be used to
    SSH to the EC2 instances. Our guess earlier was correct, but this is a good way
    to confirm those kinds of things. The `"Default"` key contains the `"0.0.0.0/0"` value, which
    means that the stack we have been looking at is using the default value for the `"SSHLocation"`
    parameter. Maybe we can find default passwords or IP addresses hardcoded into
    the templates in some situations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前预期的那样，查看`"SSHLocation"`参数，我们可以看到有一个描述，说明可以用于SSH到EC2实例的IP地址范围。我们之前的猜测是正确的，但这是确认这类事情的好方法。`"Default"`键包含`"0.0.0.0/0"`值，这意味着我们一直在查看的堆栈正在使用`"SSHLocation"`参数的默认值。也许我们可以在某些情况下在模板中找到默认密码或IP地址的硬编码。
- en: Next, we will want to check out the resources defined in this template. In here,
    there are all kinds of possibilities of things we could encounter. One example
    of this would be startup scripts for EC2 instances that are created. We can read
    through those looking for anything sensitive, while gaining knowledge about the
    setup/architecture of the environment that this stack has deployed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要检查此模板中定义的资源。在这里，有各种可能遇到的事情。其中一个例子是为创建的EC2实例启动脚本。我们可以阅读这些内容，寻找任何敏感信息，同时了解这个堆栈部署的环境的设置/架构。
- en: 'The template that we used for our stack has a few setup scripts that seem to
    set up a MySQL database and a PHP web server. Ideally, we gain access to one or
    both of those, so we can scroll down to the `"WebServerSecurityGroup"` that `cfn_nag`
    flagged previously, and we see the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于堆栈的模板有一些设置脚本，似乎是设置了一个MySQL数据库和一个PHP Web服务器。理想情况下，我们可以访问其中一个或两个，因此我们可以滚动到之前`cfn_nag`标记的`"WebServerSecurityGroup"`，我们看到以下内容：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This tells us that the web server security group allows inbound access to port
    `80` from any IP address (`0.0.0.0/0`) and inbound access to port `22` from the
    `"SSHLocation"` parameter, which we know was also set to `0.0.0.0/0`. Now we can
    go back to the output values that we checked out earlier for this stack to get
    the hostname of the server again, where we now know port `80` is open. If we navigate
    to that URL ([http://ec2-34-221-86-204.us-west-2.compute.amazonaws.com/](http://ec2-34-221-86-204.us-west-2.compute.amazonaws.com/))
    in our browser, we are presented with the following page:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们Web服务器安全组允许从任何IP地址（`0.0.0.0/0`）对端口`80`进行入站访问，并允许从`"SSHLocation"`参数对端口`22`进行入站访问，我们知道`"SSHLocation"`参数也设置为`0.0.0.0/0`。现在我们可以回到之前检查这个堆栈的输出值，再次获取服务器的主机名，现在我们知道端口`80`是开放的。如果我们在浏览器中导航到该URL（[http://ec2-34-221-86-204.us-west-2.compute.amazonaws.com/](http://ec2-34-221-86-204.us-west-2.compute.amazonaws.com/)），我们将看到以下页面：
- en: '![](img/3613329d-d857-41a2-bf26-7bde19fd1f85.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3613329d-d857-41a2-bf26-7bde19fd1f85.png)'
- en: The web server hosted on the EC2 instance deployed by the CloudFormation stack
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由CloudFormation堆栈部署的EC2实例上托管的Web服务器
- en: Beyond what we have just done, CloudFormation templates can be inspected to
    determine the setup of the various resources that the stack deployed, which could
    help us to identify resources, misconfigurations, hardcoded secrets, and more,
    all without the requirement of having AWS permissions that grant access to those
    actual resources.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚做的事情之外，CloudFormation模板可以被检查以确定堆栈部署的各种资源的设置，这可以帮助我们识别资源、错误配置、硬编码的秘密等，而无需具有授予对这些实际资源访问权限的AWS权限。
- en: Passed roles
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过的角色
- en: When a CloudFormation stack is created, there is the option to pass an IAM role
    to it for the deployment process. If a role is passed, the stack will be created
    using that role, but if a role is not passed, then CloudFormation just uses the
    current user privileges to deploy the stack. This opens the possibility of privilege
    escalation through stacks that have already been passed roles when they were created.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CloudFormation堆栈时，有一个选项可以为其传递IAM角色进行部署过程。如果传递了角色，则将使用该角色创建堆栈，但如果没有传递角色，则CloudFormation将只使用当前用户的权限来部署堆栈。这打开了通过已经在创建时传递了角色的堆栈进行权限提升的可能性。
- en: Let's say that a user we compromised has `"cloudformation:*"` permissions, but
    not `"iam:PassRole"`. This means that we cannot escalate our privileges by creating
    a new stack and passing it a role with higher privileges than what we have (because
    that requires the `"iam:PassRole"` permission), but it does mean that we can modify
    existing stacks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被入侵的用户具有`"cloudformation:*"`权限，但没有`"iam:PassRole"`权限。这意味着我们无法通过创建一个新的堆栈并传递给它比我们拥有的更高权限的角色来提升我们的权限（因为这需要`"iam:PassRole"`权限），但这意味着我们可以修改现有的堆栈。
- en: To determine which, if any, CloudFormation stacks have had roles passed to them,
    we can go back to the output from the `DescribeStacks` command. If a stack has
    the `"RoleARN"` key with the value of an IAM role's ARN, then that stack has been
    passed a role. If that key does not show up, then that stack was not passed a
    role when it was created. The demo stack we created was passed a role.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定是否有CloudFormation堆栈已经传递了角色，我们可以回到`DescribeStacks`命令的输出。如果一个堆栈具有`"RoleARN"`键，并且其值是IAM角色的ARN，则该堆栈已经传递了一个角色。如果该键没有显示，则在创建时该堆栈没有传递角色。我们创建的演示堆栈已经传递了一个角色。
- en: Now, if we have the necessary IAM permissions, we could use the IAM API to figure
    out what permissions the role passed to that stack has, but if we don't, we can
    infer based off a few different things. First, the name of the role could be a
    small hint, such as if it includes `"EC2FullAccessForCloudFormation"`, it is safe
    to assume the role has full access to EC2\. The more reliable, but not necessarily
    complete, set of permissions can be assumed based on what resources the stack
    deployed. If a certain stack deployed an EC2 instance, created a security group
    for it, created an S3 bucket, and set up an RDS database, it would be safe to
    assume that the role has access to do all of those things. In our case, that's
    more access to the AWS APIs than just `"cloudformation:*"`, so we could abuse
    that stack to gain further access to the environment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有必要的IAM权限，我们可以使用IAM API来确定传递给该堆栈的角色具有哪些权限，但如果没有，我们可以根据一些不同的事情进行推断。首先，角色的名称可能是一个小提示，比如如果它包括`"EC2FullAccessForCloudFormation"`，那么可以安全地假设该角色对EC2具有完全访问权限。更可靠但不一定完整的权限集可以根据堆栈部署的资源进行推断。如果某个堆栈部署了一个EC2实例，为其创建了安全组，创建了一个S3存储桶，并设置了一个RDS数据库，那么可以安全地假设该角色有权执行所有这些操作。在我们的情况下，这比`"cloudformation:*"`更多地访问了AWS
    API，因此我们可以滥用该堆栈来进一步访问环境。
- en: 'There are a few ways we can check that, including just looking at the raw CloudFormation
    template we looked at earlier, or we can use the `DescribeStackResources` command
    to list out what resources were created by that stack, then make our access assumptions
    from there. This can be done by running the following command from the AWS CLI:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以检查，包括仅查看我们之前查看的原始CloudFormation模板，或者我们可以使用`DescribeStackResources`命令列出该堆栈创建的资源，然后从那里进行我们的访问假设。这可以通过从AWS
    CLI运行以下命令来完成：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output from our demo stack looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示堆栈的输出如下：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can see here that an EC2 instance and an EC2 security group were created,
    so we can assume the role attached to this stack at least has access to do those
    two things. To then take advantage of these permissions and escalate our own privileges,
    we can use the `UpdateStack` command. This allows us to update/change the template
    associated with the stack we are targeting, allowing us to add/remove resources
    to the list. To cause less of a disturbance in the environment, we could pull
    the existing template from the stack and then just add resources to it, to cause
    as little disruption as possible. This is because existing resources that have
    not been changed will not be modified, so we won't cause a denial of service.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里创建了一个EC2实例和一个EC2安全组，因此我们可以假设附加到该堆栈的角色至少具有执行这两项操作的权限。然后，为了利用这些权限并提升我们自己的权限，我们可以使用`UpdateStack`命令。这允许我们更新/更改与我们正在定位的堆栈相关联的模板，从而允许我们添加/删除资源到列表中。为了在环境中造成较小的干扰，我们可以从堆栈中提取现有模板，然后只向其中添加资源，以尽可能少地造成干扰。这是因为未更改的现有资源将不会被修改，因此我们不会造成拒绝服务。
- en: At this point, the next steps depend quite a bit on the situation. If you find
    out that a stack has IAM permissions, add some IAM resources to the template that
    allow you to escalate your access, or if you find out that a stack has EC2 permissions,
    like we did here, add a bunch of EC2 instances with your own SSH key or something
    like that. If we went ahead and added some more EC2 instances to our demo stack,
    we could possibly gain access to the internal side of the VPC that they are using
    for these resources, which then could possibly grant us further, more-privileged
    access to the environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，下一步取决于情况。如果发现某个堆栈具有IAM权限，可以向模板添加一些IAM资源，以允许您提升访问权限，或者如果发现某个堆栈具有EC2权限，就像我们在这里所做的那样，可以添加一堆带有您自己SSH密钥的EC2实例。如果我们继续向我们的演示堆栈添加一些EC2实例，可能会获得对它们用于这些资源的VPC内部的访问权限，然后可能会进一步授予我们对环境的更高特权访问。
- en: 'An example command to perform this attack might look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此攻击的示例命令可能如下所示：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `template.json` file would include your updated CloudFormation template
    and `params.json` would include something that instructs the stack to use all
    of the already supplied parameters, instead of new ones:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.json`文件将包括您更新的CloudFormation模板，`params.json`将包括一些指示堆栈使用所有已提供的参数而不是新参数的内容：'
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now the stack will update and create your new resources, and you will have successfully
    used the passed roles' permissions to perform an API action in AWS, effectively
    escalating your own privileges.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，堆栈将更新并创建您的新资源，您将成功地使用传递的角色权限在AWS中执行API操作，有效地提升了自己的权限。
- en: Elastic Container Registry (ECR)
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性容器注册表（ECR）
- en: ECR is described as a fully managed Docker container registry that makes it
    easy for developers to store, manage, and deploy Docker container images ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)).
    The permissions model that it uses can allow for some nasty misconfigurations
    if a repository isn't set up correctly, mainly because, by design, ECR repositories
    can be made public or shared with other accounts. This means that, even if we
    only have a small amount of access, a misconfigured repository could grant us
    large amounts of access to an environment, depending on what is stored in the
    Docker images it is hosting.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ECR被描述为一个完全托管的Docker容器注册表，使开发人员可以轻松存储、管理和部署Docker容器映像（[https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)）。它使用的权限模型可以允许一些令人讨厌的错误配置，如果存储库没有正确设置，主要是因为按设计，ECR存储库可以被设置为公共或与其他帐户共享。这意味着，即使我们只有少量访问权限，错误配置的存储库也可能根据其托管的Docker映像中存储的内容，向我们授予对环境的大量访问权限。
- en: 'If we are targeting public repositories in another account, then the main piece
    of information we need is the account ID of where the repositories are. There
    are a few ways of getting it. If you have credentials for the account you are
    targeting, the easiest way is to use the **Simple Token Service** (**STS**) `GetCallerIdentity`
    API, which will provide you with some information that includes your account ID.
    That command would look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在针对另一个账户中的公共仓库，那么我们需要的主要信息是仓库所在的账户ID。有几种获取它的方法。如果您拥有您正在针对的账户的凭据，最简单的方法是使用**Simple
    Token Service**（**STS**）`GetCallerIdentity` API，它将为您提供一些包括您的账户ID在内的信息。该命令将如下所示：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The problem with this is that it is logged to CloudTrail and clearly shows that
    you are trying to gather information about your user/the account you're in, which
    could raise some red flags for a defender. There are other methods as well, particularly
    based around research from Rhino Security Labs, where they released a script to
    enumerate a small amount of information about the current account without ever
    touching CloudTrail. This was done through verbose error messages that certain
    services disclose, and those services aren't supported by CloudTrail yet, so there
    was no record of the API call being made, but the user gathered some information,
    including the account ID ([https://rhinosecuritylabs.com/aws/aws-iam-enumeration-2-0-bypassing-cloudtrail-logging/](https://rhinosecuritylabs.com/aws/aws-iam-enumeration-2-0-bypassing-cloudtrail-logging/)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于它被记录到了CloudTrail中，并清楚地显示您正在尝试收集有关您的用户/您所在账户的信息，这可能会引起防御者的警觉。还有其他方法，特别是基于Rhino
    Security Labs的研究，他们发布了一个脚本来枚举有关当前账户的少量信息，而不会触及CloudTrail。这是通过某些服务披露的冗长错误消息来完成的，而这些服务尚不受CloudTrail支持，因此没有记录API调用的记录，但用户收集了一些信息，包括账户ID（[https://rhinosecuritylabs.com/aws/aws-iam-enumeration-2-0-bypassing-cloudtrail-logging/](https://rhinosecuritylabs.com/aws/aws-iam-enumeration-2-0-bypassing-cloudtrail-logging/)）。
- en: 'If you are targeting repositories in the account that you have compromised
    and are using those credentials for these API calls, then the account ID won''t
    matter, because it will default to the current account automatically in most cases.
    The first thing we will want to do is list out the repositories in the account.
    This can be done with the following command (if you are targeting a different
    account, pass the account ID in to the `--registry-id` argument):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在针对您已经入侵并使用这些凭据进行这些API调用的账户中的仓库，则账户ID将无关紧要，因为在大多数情况下它将自动默认为当前账户。我们首先要做的是列出账户中的仓库。这可以通过以下命令完成（如果您正在针对不同的账户，请将账户ID传递给`--registry-id`参数）：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should list out the repositories in the current region, including their
    ARN, registry ID, name, URL, and when they were created. Our example returned
    the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该列出当前区域中的仓库，包括它们的ARN、注册表ID、名称、URL以及创建时间。我们的示例返回了以下输出：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then fetch all of the images stored in that repository with the `ListImages`
    command. That will look something like this for the `example-repo` we found previously:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`ListImages`命令获取存储在该仓库中的所有镜像。对于我们之前找到的`example-repo`，它将看起来像这样：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This command will give us a list of images, including their digest and image
    tag:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将给我们一个镜像列表，包括它们的摘要和镜像标签：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can (hopefully) pull this image to our local machine and run it, so
    that we can see what''s inside. We can do this by running the following command
    (again, specify an external account ID in the `--registry-id` parameter if needed):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以（希望）将这个镜像拉到我们的本地机器并运行它，以便我们可以看到里面有什么。我们可以通过运行以下命令来完成这个操作（再次，如果需要，请在`--registry-id`参数中指定外部账户ID）：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The AWS command returns the required docker command to log you into the target
    registry, and the `$()` around it will automatically execute that command and
    log you in. You should see `Login Succeeded` printed to the console after running
    it. Next, we can use Docker to pull the image, now that we are authenticated with
    the repository:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: AWS命令返回所需的docker命令，以便将您登录到目标注册表，并且其中的`$()`将自动执行该命令并将您登录。运行后，您应该在控制台上看到`登录成功`的打印输出。接下来，我们可以使用Docker来拉取镜像，现在我们已经通过仓库进行了身份验证：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now the Docker image should get pulled and should be available if you run `docker
    images` to list the Docker images:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Docker镜像应该被拉取，并且如果您运行`docker images`来列出Docker镜像，它应该是可用的。
- en: '![](img/fb01c6a4-ae68-4a3d-ab65-c791365784b7.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb01c6a4-ae68-4a3d-ab65-c791365784b7.png)'
- en: Listing the example-repo Docker image after pulling it down
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其拉下来后，列出`example-repo` Docker镜像
- en: 'Next, we will want to run this image and drop ourselves into a bash shell within
    it, so then we can explore the filesystem and look for any goodies. We can do
    this with the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要运行这个镜像，并在其中的bash shell中放置自己，这样我们就可以探索文件系统并寻找任何好东西。我们可以通过以下方式来完成这个操作：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now our shell should switch from the local machine to the Docker container
    as the root user:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的shell应该从本地机器切换到Docker容器，作为root用户：
- en: '![](img/5ff3cb4e-29ca-4692-b0fd-11a27c8c55f9.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ff3cb4e-29ca-4692-b0fd-11a27c8c55f9.png)'
- en: Using the Docker run command to enter a bash shell in the container we are launching
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker运行命令进入我们正在启动的容器中的bash shell
- en: This is where you can employ your normal penetration testing techniques for
    searching around the operating system. You should be looking for things such as
    source code, configuration files, logs, environment files, or anything that sounds
    interesting, really.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以使用常规渗透测试技术搜索操作系统的地方。您应该寻找诸如源代码、配置文件、日志、环境文件或任何听起来有趣的东西。
- en: 'If any of those commands failed due to authorization issues, we could go ahead
    and check the policy associated with the repository we are targeting. This can
    be done with the `GetRepositoryPolicy` command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中任何命令由于授权问题而失败，我们可以继续检查我们所针对的仓库相关的策略。这可以通过`GetRepositoryPolicy`命令来完成：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The response will be an error if no policy has been created for the repository;
    otherwise, it will return a JSON policy document that specifies what AWS principals
    can execute what ECR commands against the repository. You might find that only
    certain accounts or users are able to access the repository, or you might find
    that anyone can access it (such as if the `"*"` principal is allowed).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未为存储库创建策略，则响应将是错误；否则，它将返回一个指定AWS主体可以针对存储库执行什么ECR命令的JSON策略文档。您可能会发现只有特定帐户或用户能够访问存储库，或者您可能会发现任何人都可以访问它（例如如果允许`"*"`主体）。
- en: If you have the correct push permissions to ECR, another attack worth trying
    would be to implant malware in one of the existing images, then push an update
    to the repository so that anyone who then uses that image will launch it with
    your malware running. Depending on the workflow the target uses behind the scenes,
    it may take a long time to discover this kind of backdoor in their images if done
    correctly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有正确的对ECR的推送权限，另一个值得尝试的攻击是在现有图像中植入恶意软件，然后推送更新到存储库，这样任何使用该图像的人都将启动带有您的恶意软件运行的图像。根据目标在幕后使用的工作流程，如果操作正确，可能需要很长时间才能发现其图像中的此类后门。
- en: If you are aware of applications/services being deployed with these Docker images,
    such as through Elastic Container Service (ECS), then it might be worth looking
    for vulnerabilities within the container that you might be able to externally
    exploit, to then gain access to those servers. To help with this, it might be
    useful to do static vulnerability analysis on the various containers using tools
    such as Anchore Engine ([https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine)),
    Clair ([https://github.com/coreos/clair](https://github.com/coreos/clair)), or
    any others of the many available online. The results from those scans could help
    you identify known vulnerabilities that you might be able to take advantage of.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道使用这些Docker图像部署的应用程序/服务，比如通过弹性容器服务（ECS），那么值得寻找您可能能够外部利用的容器内的漏洞，然后获得对这些服务器的访问权限。为了帮助解决这个问题，使用Anchore
    Engine（[https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine)）、Clair（[https://github.com/coreos/clair](https://github.com/coreos/clair)）或其他许多在线可用工具对各种容器进行静态漏洞分析可能会很有用。这些扫描的结果可以帮助您识别可能能够利用的已知漏洞。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When attacking an AWS environment, it is important to come up with a definitive
    list of what AWS services they are using, as it allows you to formulate your attack
    plan better. Along with that, it is important to look at the configuration and
    setup that is deployed across all of these services to find misconfigurations
    and features to abuse and hopefully chain together to gain full access to the
    environment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击AWS环境时，重要的是要列出他们正在使用的AWS服务的明确清单，因为这可以让您更好地制定攻击计划。除此之外，重要的是要查看部署在所有这些服务上的配置和设置，以找到错误配置和滥用的功能，并希望将它们链接在一起以获得对环境的完全访问权限。
- en: No service is too small to look at, as there are likely attack vectors across
    every single AWS service if you have the permissions to interact with them. This
    chapter aimed to show some attacks on some less common AWS servers (compared to
    EC2, S3, and so on), and attempted to show that many services have policy documents
    that handle permissions in one way or another, such as SES identity policies or
    ECR repository policies. These services can all be abused in similar ways with
    misconfigured policies or by updating them ourselves.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 没有服务太小，不值得关注，因为如果您有与它们交互的权限，那么可能在每个AWS服务中都存在攻击向量。本章旨在展示一些对一些不太常见的AWS服务器的攻击（与EC2、S3等相比），并试图表明许多服务都有处理权限的策略文档，比如SES身份策略或ECR存储库策略。这些服务都可以通过错误配置的策略或通过自己更新来滥用。
- en: In the next chapter, we will take a look CloudTrail, which is the AWS central
    API logging service. We will look at how to securely configure your trails and
    how to go about attacking them as a pentester for information gathering and to
    avoid being logged while trying to stay under the radar.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究CloudTrail，这是AWS的中央API日志记录服务。我们将看看如何安全地配置您的跟踪，并如何攻击它们作为渗透测试人员进行信息收集，并在试图保持低调时避免被记录。
