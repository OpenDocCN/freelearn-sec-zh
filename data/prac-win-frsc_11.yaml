- en: Chapter 11. Memory Forensics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 内存取证
- en: System memory is the working space of the operating system. The operating system
    uses memory to place the data that is needed to execute programs and the programs
    themselves. This is why acquiring the system memory is one of the steps that must
    be performed when applicable in digital forensics. Analyzing the memory may reveal
    the existence of a malicious process or program that has no traces in the machine
    hard disk. Memory also contains the opened network connections, which could include
    the connection of an attacker controlling the machine or stealing user data and
    information.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 系统内存是操作系统的工作空间。操作系统使用内存来存放执行程序所需的数据和程序本身。这就是为什么在数字取证中，获取系统内存是必须执行的步骤之一。分析内存可能揭示恶意进程或程序的存在，而这些程序在机器硬盘中没有任何痕迹。内存还包含了打开的网络连接，其中可能包括攻击者控制机器或窃取用户数据和信息的连接。
- en: In this chapter, we will briefly discuss the Windows memory structure, some
    techniques that are used by attackers to hide their malicious activities and existence,
    and the tools that are used to investigate memory dump.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将简要讨论Windows内存结构、攻击者用来隐藏恶意活动和存在的一些技术，以及用于调查内存转储的工具。
- en: Memory structure
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存结构
- en: Each process that runs in memory allocates space in memory to store its code
    and data. This space consists of memory pages. Each memory page is 4 KB in size
    in x86 systems. All the processes address their memory spaces with virtual addresses,
    which are translated into physical addresses by the system itself with no interaction
    by any process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行中的进程都会在内存中分配空间来存储其代码和数据。这个空间由内存页组成。在x86系统中，每个内存页的大小为4 KB。所有进程都通过虚拟地址来寻址其内存空间，系统会将虚拟地址转换为物理地址，且无需任何进程的干预。
- en: 'In modern operating systems, there are two categories of the running processes:
    processes run in user mode and others run in kernel mode. The difference between
    both modes is the level of access that is granted to the operating system. In
    the user mode, the processes can''t modify paging or access other processes''
    memory locations except some inter-process communications using Windows APIs.
    All the processes start in user mode, except the SYSTEM process.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代操作系统中，运行中的进程分为两类：一类是运行在用户模式下的进程，另一类是运行在内核模式下的进程。这两种模式的区别在于操作系统授予的访问权限级别。在用户模式下，进程不能修改分页或访问其他进程的内存位置，除非通过一些进程间通信使用Windows
    API。除SYSTEM进程外，所有进程都从用户模式开始运行。
- en: Kernel mode is used by the Windows kernel at system booting to set up memory
    space and paging. In some situations, such as executing the Windows API, the processor
    receives interrupt, which requires it to switch to kernel mode to execute the
    interrupt and then return back to the user mode.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式由Windows内核在系统启动时用于设置内存空间和分页。在某些情况下，例如执行Windows API时，处理器会接收到中断，这要求它切换到内核模式以执行该中断，然后再返回到用户模式。
- en: Memory acquisition
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存获取
- en: We discussed memory acquisition previously in volatile evidence acquisition
    in *Chapter 3* , *Volatile Data Collection*. However, we now need to highlight
    this in a modern Windows operating system, the different security controls which
    forbid processes to access the whole memory, and the step which is required by
    any acquisition tool to acquire the system memory. This may cause a system crash
    and the loss of system memory, or the whole hard disk in the case of active hard
    disk encryption.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第3章*《易失性数据收集》中曾讨论过内存获取。然而，现在我们需要在现代Windows操作系统中重点介绍这一点，包括禁止进程访问整个内存的不同安全控制措施，以及任何获取工具获取系统内存所需的步骤。这可能会导致系统崩溃和系统内存丢失，或者在活动硬盘加密的情况下丢失整个硬盘。
- en: So, modern digital forensics acquisition tools tend to install a driver first
    to the operating system and then use this driver to access the system memory,
    which will need higher privileges on the system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代数字取证获取工具通常会首先在操作系统中安装一个驱动程序，然后使用这个驱动程序来访问系统内存，这需要更高的系统权限。
- en: The sources of memory dump
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存转储的来源
- en: We can consider a memory dump during the incident response process as the main
    source for memory forensics. However, what if we have a powered off machine or,
    for any reason, we couldn't acquire the memory of the machine? The question here
    is do we have any other way to conduct memory forensics? Fortunately, we have
    a positive answer for this question in many situations. Let's see what they are.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将事件响应过程中的内存转储视为内存取证的主要来源。然而，如果我们有一台关闭的机器，或者因某些原因无法获取该机器的内存呢？这里的问题是，我们是否有其他方法进行内存取证？幸运的是，在许多情况下我们对这个问题有肯定的答案。让我们看看有哪些方法。
- en: Hibernation file
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 休眠文件
- en: Hibernation is a power option in most operating systems, including Windows OS.
    In this mode, the system copies the memory, which is volatile, to a single file
    named `hiberfil.sys`, which is located under the system root in the hard disk,
    which is non-volatile, and completely shuts down the machine. When the user turns
    the machine on again from hibernation, the system copies the contents of this
    file again to memory and resumes the execution of the previous processes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠是大多数操作系统中的一种电源选项，包括 Windows 操作系统。在此模式下，系统会将易失性的内存复制到一个名为`hiberfil.sys`的单一文件中，该文件位于硬盘的系统根目录下（硬盘是非易失性的），然后完全关闭计算机。当用户从休眠状态重新启动计算机时，系统会将该文件的内容再次复制到内存中，并恢复先前进程的执行。
- en: If the investigator has a forensic image of the victim's or suspect's hard disk,
    they can extract the hibernation file and conduct memory forensics on this file
    using the memory analysis tools that we will be discussing later in this chapter.
    The hibernation file will provide the investigator or the analyst with a memory
    image from specific time in the past that may contain traces to the malicious
    activities or important evidence related to the case under investigation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调查人员拥有受害人或嫌疑人的硬盘取证镜像，他们可以提取休眠文件，并使用本章稍后讨论的内存分析工具对该文件进行内存取证。休眠文件将为调查人员或分析员提供一个特定时间点的内存镜像，可能包含与恶意活动或与调查案件相关的重要证据。
- en: The filesystem's last modification time of the hibernation file will indicate
    the time when the hibernation was used in the system. Fortunately, the structure
    of the hibernation file is different but known, which makes it possible to convert
    it to a raw memory image in order to conduct analysis on it using the memory forensics
    tools. Although it contains most of the memory data, the hibernation file won't
    contain some data, such as the dynamically obtained network information using
    DHCP. We need to consider this during analysis.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠文件的文件系统最后修改时间将指示系统使用休眠时的时间。幸运的是，休眠文件的结构虽然不同，但已知，这使得它可以转换为原始内存镜像，以便使用内存取证工具进行分析。尽管它包含大部分内存数据，但休眠文件不会包含一些数据，例如通过
    DHCP 动态获取的网络信息。在分析时，我们需要考虑这一点。
- en: Crash dump
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 崩溃转储
- en: 'If the Windows system crashed, it is designed to store information about the
    system state at the time of the crash for future troubleshooting of the crash
    after recovering the system. Crashing the system was an old way to dump the memory
    to the crash dump file, which can be done using the NotMyFault tool from Sysinternals
    ([http://download.sysinternals.com/files/NotMyFault.zip](http://download.sysinternals.com/files/NotMyFault.zip)).
    However, better methods and tools are available nowadays. The crash dump file
    is named `MEMPRY.DMP` by default and is located under system root directly. The
    crash dump file can hold different data depending on the settings of the crash
    dumps, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Windows 系统崩溃，它会设计为存储崩溃时的系统状态信息，以便在系统恢复后进行故障排除。系统崩溃曾是通过崩溃转储文件来转储内存的一种旧方法，用户可以使用
    Sysinternals 的 NotMyFault 工具来完成这一操作（[http://download.sysinternals.com/files/NotMyFault.zip](http://download.sysinternals.com/files/NotMyFault.zip)）。然而，现在已有更好的方法和工具可用。崩溃转储文件默认命名为
    `MEMPRY.DMP`，并直接位于系统根目录下。崩溃转储文件可以根据崩溃转储的设置包含不同的数据，如下所示：
- en: '**Complete memory dump**: This contains the physical memory at the time of
    the crash with a 1 MB header. This type is not common because it has a large size
    especially for systems with a large memory.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整内存转储**：这包含崩溃时的物理内存以及一个 1MB 的头部信息。此类型不常见，因为它的大小较大，尤其是在内存较大的系统上。'
- en: '**Kernel memory dump**: This is when the system dumps the memory pages in the
    kernel mode only and ignores the pages in the user mode.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核内存转储**：这是系统仅在内核模式下转储内存页面，并忽略用户模式下的页面。'
- en: '**Small dump files**: These are small files that have a size of 64 KB in 32bit
    systems and 128 KB in 64bit systems. This contains information about running processes
    and loaded drivers in the system.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型转储文件**：这些是小文件，在32位系统中大小为64 KB，在64位系统中为128 KB。它包含有关系统中正在运行的进程和已加载的驱动程序的信息。'
- en: 'For the investigator to know which type of dump file is present in the case,
    they can determine this from the size of the file. They can also open the registry
    location of `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl`,
    under a value called **CrashDumpEnable**, which will be one of the following four
    values:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让调查人员了解案件中存在的转储文件类型，他们可以通过文件的大小来判断。他们还可以打开注册表位置`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl`，在名为**CrashDumpEnable**的值下，它将是以下四个值之一：
- en: '0: This is when debugging information is not written to a file'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: 这是调试信息未写入文件时的情况'
- en: '1: This is when the complete crash dump is written to a file'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 这是将完整的崩溃转储写入文件时的情况'
- en: '2: This is when the kernel memory dump is written to a file'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: 这是将内核内存转储写入文件时的情况'
- en: '3: This is when a small memory dump is written to a file'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3: 这是将小型内存转储写入文件时的情况'
- en: After extracting the crash dump file, the investigator can use the `dmp2bin.exe`
    tool from Moonsols to convert the dump.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 提取崩溃转储文件后，调查人员可以使用 Moonsols 的`dmp2bin.exe`工具转换转储文件。
- en: Page files
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面文件
- en: Paging is a memory management technique that works as a secondary storage for
    Windows memory. It speeds up the system by moving the least-used pages in memory
    to the hard drive in a file named `pagefile`. By applying such techniques, the
    user will have more memory space to use. When the user starts using the saved
    pages again, the system restores these pages to memory again. This can be noticed
    in small lagging while accessing some opened applications that haven't been used
    for some time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是一种内存管理技术，作为 Windows 内存的二级存储。它通过将最少使用的内存页面移动到硬盘上的名为`pagefile`的文件中，从而加速系统。当用户再次使用这些保存的页面时，系统会将这些页面恢复到内存中。这可以在访问一些长时间未使用的已打开应用程序时察觉到小的延迟。
- en: 'The page files on the hard drive can be up to 16 files, and not only under
    the root directory. To find out the locations of the page files from the registry,
    check `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Memory Management\ExistingPageFiles`
    and `PagingFiles`. Some memory acquisition tools, such as FTK imager can add the
    page file to memory image during live acquisition:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘上的页面文件最多可以有16个文件，且不仅仅位于根目录下。要从注册表中查找页面文件的位置，请检查`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Memory
    Management\ExistingPageFiles`和`PagingFiles`。一些内存采集工具，如 FTK imager，可以在实时采集期间将页面文件添加到内存镜像中：
- en: '![Page files](img/image_11_001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![页面文件](img/image_11_001.jpg)'
- en: 'Figure 1: FTK imager; adding page files during memory acquisition'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '图1: FTK imager；在内存采集过程中添加页面文件'
- en: Page files store unordered data, which make it more difficult for in-depth analysis.
    This means that string search in the page files may give some clues about the
    contents of the page files and the case under investigation, such as the IP, path,
    or the registry key. File carving also can be conducted in the page files in order
    to recover some related files. Scanning the page files for a malware signature
    may uncover malware running in memory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 页面文件存储无序的数据，这使得深入分析更加困难。这意味着在页面文件中进行字符串搜索可能会提供一些有关页面文件内容和正在调查案件的线索，例如 IP 地址、路径或注册表项。还可以在页面文件中进行文件雕刻，以恢复一些相关文件。扫描页面文件以查找恶意软件特征可能会发现内存中运行的恶意软件。
- en: Processes in memory
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的进程
- en: A process is an instance of a program that has been executed in the system.
    Each process in memory has a private isolated memory space. A process contains
    the execution code and the data that is required to complete the execution of
    the code, such as files, DLLs, and user input. All this data and code are located
    in a memory space allocated for this process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是系统中已执行程序的一个实例。内存中的每个进程都有一个私有的隔离内存空间。一个进程包含执行代码和完成代码执行所需的数据，如文件、DLL 和用户输入。所有这些数据和代码都位于为该进程分配的内存空间中。
- en: Many processes can be in the memory at the same time. All the processes are
    listed in one structure called `_EPROCESS` in the memory of the running Windows
    operating system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多进程可以同时存在于内存中。所有进程都在运行的 Windows 操作系统内存中列出一个名为`_EPROCESS`的结构。
- en: Each entry of the `_PROCESS` structure holds one process with its metadata;
    the process name, its executable path, parent process, start time, and in some
    cases, the exit time. The metadata can be used as an indication of the presence
    of malicious activity if the parent process of a well-known process is different.
    For example, the `lsass.exe` process has parent process of `Explorer.exe`, while
    its parent process should be `Wininit.exe`. We can assume here that this `lsass.exe`
    process is not the genuine `lsass.exe` process and it is trying to deceive the
    user by taking the name of a legitimate process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`_PROCESS`结构的每个条目都包含一个进程及其元数据；包括进程名称、可执行路径、父进程、启动时间，某些情况下，还包括退出时间。如果一个知名进程的父进程不同，则元数据可以作为恶意活动存在的指示。例如，`lsass.exe`进程的父进程是`Explorer.exe`，而它的父进程应该是`Wininit.exe`。在这里我们可以假设该`lsass.exe`进程并不是合法的`lsass.exe`进程，而是在通过假冒合法进程的名称来欺骗用户。'
- en: The `_EPROCESS` structure is similar to a double-linked list, each process points
    to the previous and the next process in a chain-like structure. This is used to
    circulate the processing time between different processes. The normal Windows
    command that is used to list the system processes uses the `EPROCESS` structure
    to read all the processes in a sequential way. So, if a malicious process was
    able to change the addresses in two processes before and after its location to
    point to each other, it won't be shown in the processes list. This is one way
    used by some malware samples to hide their existence. This technique is called **Direct
    Kernel Object Manipulation** or **DKOM**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`_EPROCESS`结构类似于双向链表，每个进程指向前一个和下一个进程，形成链状结构。它用于在不同进程之间循环处理时间。用于列出系统进程的常规Windows命令使用`EPROCESS`结构按顺序读取所有进程。因此，如果恶意进程能够修改前后两个进程的地址，使其指向对方，那么它将不会出现在进程列表中。这是一些恶意软件样本用来隐藏自己存在的方式。这个技术叫做**直接内核对象操作**（**DKOM**）。'
- en: To overcome this technique and because the `_EPROCESS` entry has a specific
    structure, instead of depending on the manipulated `EPROCESS` structure, we can
    carve the memory file for all the `_EPROCESS` entries by their signature. In this
    case, the carving tool won't go through `EPROCESS` sequentially and won't miss
    any hidden processes. This can also display some closed processes which were removed
    from `_EPROCESS` but their entries still exist in memory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种技术，并且由于`_EPROCESS`条目具有特定的结构，除了依赖被篡改的`EPROCESS`结构外，我们可以通过它们的签名对所有的`_EPROCESS`条目进行内存文件的切割。在这种情况下，切割工具不会按顺序遍历`EPROCESS`，也不会漏掉任何隐藏的进程。这也可以显示一些已被从`_EPROCESS`中移除的进程，尽管它们的条目仍然存在于内存中。
- en: Network connections in memory
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的网络连接
- en: Usually, networks are used by attackers to control the machine remotely, to
    send captured user information, or to receive new commands. Checking the network
    connections, which were opened in the system at the time of acquisition, would
    provide clues about the attack.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，攻击者利用网络来远程控制机器，发送捕获的用户信息，或接收新的命令。检查在获取时系统中打开的网络连接，可以提供关于攻击的线索。
- en: Network activities in general leave traces in memory. Investigating network
    connections could lead to discovery of a hidden connection created by rootkits.
    These connections can be hidden from normal listing tools in the same way that
    can be done with the processes. Carving for the network connection structure in
    memory can reveal such connections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 网络活动通常会在内存中留下痕迹。调查网络连接可能会发现由rootkit创建的隐藏连接。这些连接可以像隐藏进程一样，通过与正常的列出工具的方式进行隐藏。对内存中的网络连接结构进行切割可以揭示这些连接。
- en: Another technique to hide a connection is to inject code into a legitimate process
    to open a malicious connection, so we need to check all the connections in the
    memory file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种隐藏连接的技术是将代码注入到一个合法进程中，以打开一个恶意连接，因此我们需要检查内存文件中的所有连接。
- en: The DLL injection
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DLL注入
- en: '**DLL** or **Dynamic Link Libraries** are resources and functions that are
    shared among different processes running within the system. Some processes and
    programs require special external DLLs, which can be included with the program
    to run properly. As DLLs usually run within the processes in memory, they are
    usually targeted by the malware as a way to access and control other processes
    in memory. DLLs are loaded into the process with different ways:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**DLL** 或 **动态链接库** 是在系统内运行的不同进程之间共享的资源和功能。一些进程和程序需要特殊的外部 DLL，这些 DLL 可以与程序一起包含，以便程序能够正常运行。由于
    DLL 通常在进程内存中运行，它们通常成为恶意软件的目标，成为访问和控制其他进程内存的方式。DLL 通过不同的方式加载到进程中：'
- en: '**Dynamic linking**: This is when an executable has an **Import Address Table**
    (**IAT**), which describes the resources needed for this executable to load along
    with their addresses, which are loaded in the process memory space.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态链接**：这是指可执行文件具有**导入地址表**（**IAT**），该表描述了此可执行文件在加载时所需的资源及其地址，这些资源会被加载到进程的内存空间中。'
- en: '**Runtime Dynamic Linking**: Some DLLs may not be mentioned in the IAT, but
    are called out by the program itself during execution, by calling out one of the
    Windows functions such as `LoadLibrary`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时动态链接**：有些 DLL 可能没有在 IAT 中提到，但在程序执行期间通过调用 Windows 函数之一，如 `LoadLibrary`，由程序自身调用。'
- en: '**Injection**: DLLs can be injected into a process by different techniques.
    Let''s see what they are.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入**：DLL 可以通过不同的技术注入到进程中。我们来看一下它们是什么。'
- en: Remote DLL injection
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程 DLL 注入
- en: A malicious process allocates memory space in a legitimate process with read/write
    protection and writes the path to the malicious DLL in the legitimate process
    memory space. Then, the malicious process opens a remote thread to force open
    the DLL in the legitimate process and then removes the DLL path. In this way,
    the malicious process controls the legitimate one by the code in the DLL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意进程在合法进程中分配了具有读/写保护的内存空间，并将恶意 DLL 的路径写入合法进程的内存空间中。然后，恶意进程打开一个远程线程，强制在合法进程中打开
    DLL，并随后移除 DLL 路径。通过这种方式，恶意进程通过 DLL 中的代码控制合法进程。
- en: It won't be easy to detect this type of injection. We need to list all the DLLs
    loaded by the legitimate process and check the names, paths, and time of loading
    of all the DLLs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检测这种类型的注入并不容易。我们需要列出合法进程加载的所有 DLL，并检查所有 DLL 的名称、路径以及加载时间。
- en: Remote code injection
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程代码注入
- en: We follow the same steps of the Remote DLL injections, but instead of writing
    the path to the DLL in the hard drive, the malicious process injects the code
    directly to the allocated memory space. Here, the protection of the allocated
    memory space will be read/write and execute. This protection scheme, which isn't
    popular, is found a lot in memory that is used to detect this kind of injection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循与远程 DLL 注入相同的步骤，但不同的是，恶意进程将代码直接注入到分配的内存空间中，而不是将 DLL 的路径写入硬盘。这里，分配的内存空间的保护将是读/写和执行。这种保护方案虽然不常见，但在用于检测这种注入的内存中却经常出现。
- en: Reflective DLL injection
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射 DLL 注入
- en: The hybrid technique combines the previous two methods. The malicious process
    loads the DLL directly into the legitimate process's allocated memory space. In
    this way, DLL won't ever be written to the hard drive and won't go through the
    normal loading process, so it won't be found while listing the process's loaded
    DLLs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 混合技术结合了前两种方法。恶意进程将 DLL 直接加载到合法进程的分配内存空间中。通过这种方式，DLL 永远不会写入硬盘，也不会经过正常的加载过程，因此在列出进程加载的
    DLL 时，它不会被发现。
- en: API hooking
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 钩子
- en: Hooking is usually used by rootkits, forcing the kernel to hide all activities
    that are related to the malware and to intercept the user input in order to steal
    sensitive information from the user. This used to be achieved by manipulating
    the output of the API calls by the system kernel. This can be deceptive in live
    analysis during the incident-handling process. In depth analysis of the memory
    image acquired during the evidence acquisition of the infected system would making
    it much easier to detect such behavior. Hooking is done simply by redirecting
    the normal flow of one process execution to execute malicious code in another
    location in the memory, and then return back to complete the normal process code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Hooking 通常由 Rootkit 使用，强制内核隐藏所有与恶意软件相关的活动，并拦截用户输入，以窃取用户的敏感信息。这通常是通过操控系统内核的 API
    调用输出实现的。这在事件处理过程中的实时分析中可能会造成欺骗。在感染系统的证据获取过程中对内存镜像的深入分析，可以更容易地检测到这种行为。Hooking 通过将一个进程执行的正常流程重定向到内存中的另一个位置执行恶意代码，然后再返回以完成正常的进程代码来完成。
- en: Memory analysis
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分析
- en: After a successful memory acquisition process, the investigator will have a
    single dump file that contains the full memory. Fortunately, the structure of
    the memory can be parsed by many analysis programs, including volatility, which
    is the most famous memory analysis framework nowadays.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的内存获取过程之后，调查人员将获得一个包含完整内存的单一转储文件。幸运的是，内存的结构可以被许多分析程序解析，包括 Volatility，当前最著名的内存分析框架。
- en: The volatility framework
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Volatility 框架
- en: A free memory forensics framework can be downloaded from [http://www.volatilityfoundation.org](http://www.volatilityfoundation.org).
    This framework supports many versions of Windows, Mac, and Linux operating systems.
    An independent book called *Art of Memory Forensics* was released with volatility
    2.4\. It explains in detail different operating systems' artifacts in memory and
    how to extract and analyze them using the volatility framework. In this section,
    we will discuss the usage of volatility framework and how it detects the malicious
    activities in memory dump.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个免费的内存取证框架可以从 [http://www.volatilityfoundation.org](http://www.volatilityfoundation.org)
    下载。这个框架支持多个版本的 Windows、Mac 和 Linux 操作系统。与 Volatility 2.4 一同发布了一本独立的书籍《*内存取证艺术*》。它详细解释了不同操作系统在内存中的遗留物，并说明了如何使用
    Volatility 框架提取和分析这些遗留物。在本节中，我们将讨论 Volatility 框架的使用以及它如何检测内存转储中的恶意活动。
- en: Each operating system has a different memory structure. Volatility has the ability
    to understand different structures. Using this profile, volatility can understand
    the correct data structures of the image under investigation and apply the right
    analysis and parsing tools.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的内存结构都不同。Volatility 具有理解不同结构的能力。使用这个配置文件，Volatility 可以理解正在分析的镜像的正确数据结构，并应用正确的分析和解析工具。
- en: Volatility works with plugins, each plugin performs specific tasks with the
    memory dump file. You can add or write your own plugin and add it to your version.
    In the following sections, we will discuss some volatility plugins.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 与插件配合工作，每个插件执行内存转储文件的特定任务。你可以添加或编写自己的插件，并将其添加到你的版本中。在接下来的章节中，我们将讨论一些
    Volatility 插件。
- en: Volatility plugins
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Volatility 插件
- en: A complete list of volatility plugins can be found in the tool's documentation.
    Here, we will discuss some plugins which are usually used to discover the discussed
    malware techniques.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 插件的完整列表可以在工具的文档中找到。在这里，我们将讨论一些通常用于发现所讨论的恶意软件技术的插件。
- en: imagecopy
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: imagecopy
- en: In case the available memory file is a hibernation file or a crash dump file,
    volatility can convert this file to the raw format using the imagecopy plugin.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用的内存文件是休眠文件或崩溃转储文件，Volatility 可以使用 imagecopy 插件将该文件转换为原始格式。
- en: 'Usage: `vol.py -f <Hiber|DumpFile> --profile=<ImageProfile> imagecopy -O <OutputFile>`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：`vol.py -f <Hiber|DumpFile> --profile=<ImageProfile> imagecopy -O <OutputFile>`
- en: raw2dmp
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: raw2dmp
- en: In some situations, you need to convert the dumped raw memory file to the crash
    dump format in order to use it with other tools, such as WinDBG, the Windows debugger.
    In such cases, the raw2dmp plugin can do this job.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你需要将转储的原始内存文件转换为崩溃转储格式，以便与其他工具一起使用，例如 WinDBG，Windows 调试器。在这种情况下，raw2dmp
    插件可以完成此任务。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> raw2dmp -O <OutputFile>`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：`vol.py -f <ImageFile> --profile=<ImageProfile> raw2dmp -O <OutputFile>`
- en: imageprofile
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: imageprofile
- en: Before starting the analysis and in case you don't know the right image profile
    or don't know how to write it in a volatility command, you can run the imageinfo
    plugin against the image file and volatility will suggest the right profile to
    you. Imageinfo actually uses another plugin called **kdbgscan**, which scans a
    part of the NT kernel module for specific unique strings which identifies the
    image profile. The profile provided by one string, such as Win7SP0X86, and the
    profile which Volatility uses by default is WinXPSP2x86.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始分析之前，如果你不知道正确的映像配置文件或者不知道如何在volatility命令中写出它，你可以运行imageinfo插件来检查映像文件，volatility会建议正确的配置文件。Imageinfo实际上使用了另一个插件**kdbgscan**，该插件扫描NT内核模块的一部分，查找特定的唯一字符串，以识别映像配置文件。一个字符串（如Win7SP0X86）提供的配置文件，而Volatility默认使用的配置文件是WinXPSP2x86。
- en: 'Usage: `vol.py -f <ImageFile> imageinfo`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> imageinfo`
- en: pslist
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pslist
- en: This plugin lists the processes from the memory image file. It walks through
    the double-linked list in the `_EPROCESS` structure and prints all the processes
    in the list. It displays the process name, ID, offset, parent process ID, number
    of threads and handles, and timestamp of the start and end of the process. This
    plugin's output has the logical offset of each process in the `_EPROCESS` structure.
    If we need to view the physical offset, we can use the `-P` option. If there are
    hidden processes that were unlinked from the list, this plugin won't detect them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件列出内存映像文件中的进程。它遍历`_EPROCESS`结构中的双向链表并打印列表中的所有进程。它显示进程名称、ID、偏移量、父进程ID、线程和句柄的数量以及进程开始和结束的时间戳。该插件的输出包括每个进程在`_EPROCESS`结构中的逻辑偏移量。如果需要查看物理偏移量，可以使用`-P`选项。如果有从列表中取消链接的隐藏进程，该插件无法检测到它们。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> pslist -P <OptionalPhysicalOffset>`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> pslist -P <OptionalPhysicalOffset>`
- en: 'The following is the output of the preceding command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面命令的输出：
- en: '![pslist](img/image_11_002.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![pslist](img/image_11_002.jpg)'
- en: 'Figure 2: An example of running the pslist plugin'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：运行pslist插件的示例
- en: psscan
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: psscan
- en: This plugin lists the processes in the memory dump file by carving the dump
    for any process structure, and it doesn't consider the `EPROCESS` structure. It
    can get all the processes in the memory, including active, terminated, and hidden
    processes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件通过扫描内存转储文件中的任何进程结构，列出内存转储中的进程，它不考虑`EPROCESS`结构。它可以获取内存中的所有进程，包括活动的、已终止的和隐藏的进程。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> psscan`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> psscan`
- en: pstree
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pstree
- en: The pstree plugin lists the processes in a tree view, identifying the parent
    and child processes. It lists the process using the same method that is used by
    the pslist plugin, so it won't detect hidden or unlinked processes. The output
    is structured in levels to show the different levels of parenthood between processes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: pstree插件以树状视图列出进程，识别父进程和子进程。它使用与pslist插件相同的方法列出进程，因此无法检测隐藏或未链接的进程。输出按层次结构显示不同级别的父子关系。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> pstree`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> pstree`
- en: psxview
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: psxview
- en: The plugin psxview compares the results of different process-viewing techniques,
    for example, using pslist and psscan. This helps in detecting hidden and unlinked
    processes from one output window.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 插件psxview比较不同的进程查看技术的结果，例如，使用pslist和psscan。这有助于从一个输出窗口中检测隐藏和未链接的进程。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> psxview`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> psxview`
- en: 'The following is the output of the preceding command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面命令的输出：
- en: '![psxview](img/image_11_003.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![psxview](img/image_11_003.jpg)'
- en: 'Figure 3: An example of running psscan'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：运行psscan的示例
- en: getsids
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: getsids
- en: Each process has the privilege of the user who started it. The security identifier
    of the user, the SID, describes the user's privilege in the system. The process
    has a copy of the access token that is created for the user when they logged on
    to the system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有启动它的用户的权限。用户的安全标识符SID描述了该用户在系统中的权限。进程有一个为用户登录时创建的访问令牌副本。
- en: Use the getsids plugin and the process ID to provide the SID of the user who
    started the process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用getsids插件和进程ID，提供启动该进程的用户的SID。
- en: 'The SID can be mapped easily from the system registry along the following path:
    `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SID可以通过系统注册表轻松映射，路径如下：`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList`。
- en: It can also be extracted from the opened registry in memory, which will be discussed
    later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以从内存中打开的注册表中提取这些信息，稍后会讨论这一点。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> getsids -p <optionalPID>`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：`vol.py -f <ImageFile> --profile=<ImageProfile> getsids -p <optionalPID>`
- en: dlllist
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: dlllist
- en: This plugin lists all the DLLs that are called and added to the process using
    the normal way in the operating system. It shows all the DLLs for all the processes
    in memory. If the investigator used the `-p` option with specific PID, then in
    this case, this will list only the DLLs of that specific process.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件列出了所有通过操作系统中的常规方式调用并添加到进程中的DLL。它显示了内存中所有进程的所有DLL。如果调查人员使用了`-p`选项并指定了特定的PID，那么此时只会列出该特定进程的DLL。
- en: While addressing hidden of unlinked processes, we need to use the physical address
    of its structure in memory. So, if we need to list the DLLs of an unlinked or
    hidden process, we need to provide the plugin with the physical offset of the
    process in the psscan plugin output, with the `--offset= option`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理隐藏或未链接的进程时，我们需要使用其在内存中结构的物理地址。因此，如果我们需要列出未链接或隐藏进程的DLL，我们需要提供插件该进程在psscan插件输出中的物理偏移量，并使用`--offset=
    option`。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> dlllist -p <OptionalPID>
    --offset= <PhysicalOffsetOfTheProcessFromPsscan>`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：`vol.py -f <ImageFile> --profile=<ImageProfile> dlllist -p <OptionalPID>
    --offset= <PhysicalOffsetOfTheProcessFromPsscan>`
- en: handles
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: handles
- en: A process can have many handles to many objects in the operating system. Analysis
    of these handles can be difficult because of the huge number of handles for each
    process. However, this could play an important role in proving a theory about
    the incident. It could provide the investigator with proof that one process has
    requested a handle to access a specific file in the filesystem or to create a
    specific mutant used as a signature for specific malware.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以有许多指向操作系统中多个对象的句柄。由于每个进程的句柄数量巨大，分析这些句柄可能会很困难。然而，这在证明关于事件的理论时可能起到重要作用。它可以为调查人员提供证据，证明某个进程请求了一个句柄来访问文件系统中的特定文件，或创建一个特定的突变体，作为特定恶意软件的标识。
- en: Using the handles plugin in volatility, we can display all the plugins of one
    process by the process ID and choose which type of handles will be displayed in
    the results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Volatility中的handles插件，我们可以通过进程ID显示一个进程的所有插件，并选择在结果中显示哪种类型的句柄。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> handles -p <optionalPID>
    -t <OptionalHandleType>`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：`vol.py -f <ImageFile> --profile=<ImageProfile> handles -p <optionalPID>
    -t <OptionalHandleType>`
- en: filescan
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: filescan
- en: For any process to create or read a file, it needs to open this file first in
    memory. The volatility plugin, filescan, parses for the file object tag in memory
    and lists all the opened files or the files hidden from ordinary file-scanning
    tools by the rootkit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进程要创建或读取文件，首先需要在内存中打开该文件。Volatility插件filescan解析内存中的文件对象标签，列出所有打开的文件或被rootkit隐藏的文件，这些文件是普通文件扫描工具无法检测到的。
- en: This plugin will display the physical offset of the detected file object and
    the filename with the permissions on the file. Like the handles plugin, filescan
    will be useful in confirming the existence of specific malware by scanning for
    its specific files that are opened in memory. We can pipeline the output of this
    plugin with the `grep` command in Linux to filter on a specific filename.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件将显示检测到的文件对象的物理偏移量和文件名，并显示文件的权限。像handles插件一样，filescan插件对于通过扫描内存中打开的特定文件来确认特定恶意软件的存在非常有用。我们可以将此插件的输出与Linux中的`grep`命令管道结合使用，以过滤特定的文件名。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> filescan | grep "<FileName>"`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：`vol.py -f <ImageFile> --profile=<ImageProfile> filescan | grep "<FileName>"`
- en: procexedump
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: procexedump
- en: When an executable runs in system, a version of this executable is copied to
    memory. During analysis, we can dump the executable from memory in order to investigate
    the executable code, or fix the code and run it within a controlled environment,
    such as a sandbox. Volatility has the procexedump plugin to dump any process executable
    from memory. It must be provided with the process ID.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个可执行文件在系统中运行时，该可执行文件的一个版本会被复制到内存中。在分析过程中，我们可以从内存中转储该可执行文件，以便检查可执行代码，或者修复代码并在受控环境中运行，比如沙盒。Volatility具有procexedump插件，可以从内存中转储任何进程的可执行文件。必须提供该进程的ID。
- en: Another plugin that does the same thing, but dumps the slack space along with
    the executable, is procmemdump and this is used in the same way. This will be
    helpful if the malware is manipulating the PE header in order to deceive the dumping
    tools.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个执行相同功能的插件是 procmemdump，它还会将空闲空间与可执行文件一起转储出来，使用方法相同。如果恶意软件操纵 PE 头部以欺骗转储工具，这将非常有帮助。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> procexedump -p <PID>
    -D <OptionalOutputDir>`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> procexedump -p <PID> -D <OptionalOutputDir>`
- en: memdump
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: memdump
- en: When the process starts executing, it uses some space in memory to store its
    code and data that is required during execution. This area could contain important
    information about the malware, such as strings, code, file paths, contents of
    files, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程开始执行时，它会使用一些内存空间来存储在执行过程中所需的代码和数据。该区域可能包含关于恶意软件的重要信息，如字符串、代码、文件路径、文件内容等。
- en: Volatility can dump this whole area into a single file for further analysis.
    We can run this file against the Linux native command-Strings in order to extract
    all the strings in the file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 可以将整个区域转储到单个文件以供进一步分析。我们可以针对 Linux 原生命令-Strings 运行此文件，以提取文件中的所有字符串。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> procexedump -p <PID>
    -D <OutputDir>`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> procexedump -p <PID> -D <OutputDir>`
- en: 'The following is the output of the preceding command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令的输出：
- en: '![memdump](img/image_11_004.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![memdump](img/image_11_004.jpg)'
- en: 'Figure 4: Dumping malicious process for further analysis'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：转储恶意进程以进行进一步分析
- en: svcscan
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: svcscan
- en: Windows services are usually run in the background with higher privileges than
    other programs, which are run by system users. Some malware samples run as services
    to work in the background and to ensure the malware's existence in the system
    after reboot. Rootkits can manipulate the Windows native service-monitoring tools
    in order to hide some services. Volatility has a plugin called **svcscan**, which,
    besides listing the services by normal means, also parses the memory space that
    is owned by the `services.exe` process, searching for unique tags for services.
    This method will reveal any hidden process in memory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 服务通常以比其他程序更高的权限在后台运行，由系统用户运行。一些恶意软件样本以服务的形式运行，以便在系统重新启动后继续在后台工作，并确保恶意软件在系统中的存在。Rootkit
    可以操纵 Windows 本地服务监控工具，以隐藏某些服务。Volatility 有一个名为 **svcscan** 的插件，除了通过正常手段列出服务外，还解析由
    `services.exe` 进程拥有的内存空间，搜索服务的唯一标签。此方法将揭示内存中的任何隐藏进程。
- en: The output displays the process ID of each service, the service name, service
    display name, service type, and current status. It also shows the binary path
    for the registered service, which will be an `EXE` for user mode services and
    a driver name for services that run from kernel mode.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示每个服务的进程 ID、服务名称、服务显示名称、服务类型和当前状态。它还显示注册服务的二进制路径，这对于用户模式服务来说将是一个`EXE`，对于从内核模式运行的服务则是驱动程序名称。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> svcscan`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> svcscan`
- en: connections
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: connections
- en: As discussed earlier, network traces are very important while analyzing memory
    samples. Volatility has plugins to scan opened TCP connections in memory with
    different methods. The first plugin is connections, which displays the TCP connections
    as Windows tools would do. This lists the all the connections in a linked list
    structure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在分析内存样本时，网络跟踪非常重要。Volatility 具有插件以不同方法扫描内存中打开的 TCP 连接。第一个插件是 connections，显示的是
    Windows 工具所做的 TCP 连接，将所有连接列在链表结构中。
- en: This plugin only works with Windows XP and the Windows 2003 server, only x68
    or x64.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件仅适用于 Windows XP 和 Windows 2003 服务器，仅支持 x68 或 x64。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> connections -P <OptionalPhysicalOffset>`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> connections -P <OptionalPhysicalOffset>`
- en: connscan
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: connscan
- en: Just like the psscan plugin, connscan searches for connection object structure
    instead of listing all the connections in the linked list only. It will also list
    the terminated connections.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与 psscan 插件类似，connscan 不仅搜索连接对象结构，而不是仅列出链表中的所有连接。它还将列出已终止的连接。
- en: Some connections may have been fully or partially overwritten. So, we need to
    pay attention during analysis and compare the results with the normal connections
    plugin.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些连接可能已被完全或部分覆盖。因此，在分析过程中，我们需要注意并将结果与正常连接插件进行比较。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> connscan`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> connscan`
- en: sockets
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sockets
- en: Another plugin from volatility to network is sockets, which lists all the opened
    sockets on the system with any protocol. This lists the connection in the way
    that any Windows API would use for this purpose by walking though the sockets-linked
    list. This won't be able to find closed sockets or residuals from old sockets.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: volatility 还有一个网络插件，叫做 sockets，它会列出系统中所有已打开的套接字，不论协议如何。它以 Windows API 会使用的方式列出连接，通过遍历套接字链表来获取信息。这个插件无法找到已关闭的套接字或旧套接字的残留。
- en: This plugin only works with Windows XP and the Windows 2003 server, either x68
    or x64.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件仅适用于 Windows XP 和 Windows 2003 服务器，支持 x86 或 x64。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> sockets`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '使用方法: `vol.py -f <ImageFile> --profile=<ImageProfile> sockets`'
- en: sockscan
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sockscan
- en: Like the connscan plugin, sockscan searches for the socket structure in memory,
    which makes it possible to recover residual sockets that were previously opened.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 connscan 插件，sockscan 会在内存中搜索套接字结构，从而使恢复先前打开过的残留套接字成为可能。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> sockscan`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '使用方法: `vol.py -f <ImageFile> --profile=<ImageProfile> sockscan`'
- en: Netscan
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Netscan
- en: For memory dumped from Windows Vista and higher, both x68 and x64 systems, the
    netscan plugin checks network traces. This plugin finds TCP endpoints, TCP listeners,
    UDP endpoints, and UDP listeners. It distinguishes between IPv4 and IPv6, prints
    the local and remote IP, the local and remote port, and the time when the socket
    was bound or when the connection was established.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从 Windows Vista 及更高版本内存中提取的数据，无论是 x86 还是 x64 系统，netscan 插件会检查网络数据流。这个插件会查找
    TCP 端点、TCP 监听器、UDP 端点和 UDP 监听器。它能够区分 IPv4 和 IPv6，显示本地和远程 IP 地址，本地和远程端口，以及套接字绑定或连接建立的时间。
- en: Some fields could be missed, as netscan parses through the memory for tags of
    network data structure and views all the results in the same output.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 netscan 插件会在内存中解析网络数据结构的标记，并将所有结果视作同一输出，因此可能会遗漏某些字段。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> netscan`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '使用方法: `vol.py -f <ImageFile> --profile=<ImageProfile> netscan`'
- en: hivelist and printkey
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: hivelist 和 printkey
- en: The registry hives are opened in memory. To locate the hive files in memory,
    we can use the hivelist volatility plugin, which will list the addresses of the
    hive files in memory with virtual and physical addresses with the full path of
    the hive files on the hard drive.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表的配置单元已在内存中打开。为了在内存中定位配置单元文件，我们可以使用 hivelist volatility 插件，它会列出内存中配置单元文件的地址，包括虚拟地址和物理地址，以及硬盘上配置单元文件的完整路径。
- en: We can use the printkey plugin to display the subkeys, values, and data in one
    specific registry key. This will parse all the hives to locate the key that you
    want, and it may be located in more than one hive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 printkey 插件来显示某个特定注册表项下的子键、值和数据。该插件会解析所有配置单元，以定位所需的键，且该键可能位于多个配置单元中。
- en: If you want to limit the search to one hive, you can provide the virtual address
    to the plugin with the `-o` option.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将搜索限制在某个配置单元内，可以使用 `-o` 选项向插件提供虚拟地址。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> hivelist`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '使用方法: `vol.py -f <ImageFile> --profile=<ImageProfile> hivelist`'
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> printkey -o <OptionalVirtualOffsetOfTheHiveFile>
    -K "PathWithinTheregisty"`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '使用方法: `vol.py -f <ImageFile> --profile=<ImageProfile> printkey -o <OptionalVirtualOffsetOfTheHiveFile>
    -K "PathWithinTheregisty"`'
- en: malfind
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: malfind
- en: The malfind volatility plugin finds hidden injected code or DLLs that are based
    on the permissions granted for specific pages in memory. It detects DLLs or code
    injected in a suspicious way, for example, using the `CreateRemoteThread` or `LoadLibrary`
    functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: malfind volatility 插件可以发现隐藏的注入代码或 DLL，基于特定内存页所授予的权限。它能够检测以可疑方式注入的 DLL 或代码，例如，使用
    `CreateRemoteThread` 或 `LoadLibrary` 函数。
- en: The output of the malfind plugin disassembles the code in the detected area.
    This output could contain malicious code or an executable file that starts with
    an executable signature that starts with MZ.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: malfind 插件的输出会将检测到区域的代码反汇编。该输出可能包含恶意代码或以 MZ 开头的可执行文件。
- en: A copy of the identified memory segments can be extracted for further analysis
    using `-D` or `-dump-dir=<Dir>` and the extracted segment will be located under `<Dir>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 识别的内存段副本可以使用 `-D` 或 `-dump-dir=<Dir>` 提取进行进一步分析，提取的内存段将存储在 `<Dir>` 下。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> malfind -p <PID> -D
    <OptionalOutputDir>`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '使用方法: `vol.py -f <ImageFile> --profile=<ImageProfile> malfind -p <PID> -D <OptionalOutputDir>`'
- en: 'The following is the output of the preceding command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面命令的输出：
- en: '![malfind](img/image_11_005.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![malfind](img/image_11_005.jpg)'
- en: 'Figure 5: An example of malfind'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5: malfind 示例'
- en: In the preceding screenshot, an area of memory with the `0x00210000` base address
    and the `PAGE_EXECUTE_READWRITE` permissions in the `wininit.exe` process (ID `392`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，内存区域的基地址是`0x00210000`，在`wininit.exe`进程（ID `392`）中，具有`PAGE_EXECUTE_READWRITE`权限。
- en: vaddump
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: vaddump
- en: The **VAD** (**Virtual Address Descriptor**) is used in Windows memory to describe
    memory locations that are allocated by a process running in memory. Every time
    the process allocates new memory, a new VAD entry is created in what is called
    a VAD tree. Each VAD entry has a start and end, and it covers a specific area
    in the process memory space.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**VAD**（**虚拟地址描述符**）用于 Windows 内存中，描述由内存中运行的进程分配的内存位置。每当进程分配新的内存时，就会在所谓的 VAD
    树中创建一个新的 VAD 条目。每个 VAD 条目都有一个开始和结束，它覆盖进程内存空间中的特定区域。'
- en: The volatility framework has a plugin, vaddump, which can dump each VAD area
    separately if we are interested in only one VAD entry. This is usually helpful
    if code or DLL injection has occurred, where we can extract the VAD that contains
    the malicious code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: volatility 框架有一个插件 vaddump，它可以单独转储每个 VAD 区域，如果我们只对一个 VAD 条目感兴趣，这通常很有帮助。如果发生了代码或
    DLL 注入，我们可以提取包含恶意代码的 VAD。
- en: Each VAD has metadata, including a start and end. The vadinfo volatility plugin
    can provide more information about VADs in one process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 VAD 都有元数据，包括开始和结束。vadinfo volatility 插件可以提供有关单个进程中 VAD 的更多信息。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> vaddump -p <PID> -b
    <VADStartAddressInHex> -D <OutputDir>`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> vaddump -p <PID> -b <VADStartAddressInHex>
    -D <OutputDir>`
- en: apihooks
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: apihooks
- en: 'The apihooks volatility plugin detects hooks. It detects CALLs and JMPs to
    other locations in memory. The function being imported or exported begins with
    the following instructions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: apihooks volatility 插件检测钩子。它检测调用（CALL）和跳转（JMP）到内存中的其他位置。被导入或导出的函数以以下指令开始：
- en: CALL addr
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CALL addr
- en: JMP addr
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMP addr
- en: PUSH addr; RET
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUSH addr; RET
- en: MOV reg, addr; CALL reg
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOV reg, addr; CALL reg
- en: MOV reg, addr; JMP reg,
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOV reg, addr; JMP reg,
- en: If the plugin detects an addr outside of the process memory space, it reports
    a hook.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插件检测到一个地址超出了进程的内存空间，它会报告一个钩子。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> apihooks`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> apihooks`
- en: mftparser
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: mftparser
- en: The maftparser volatility plugin scans memory file for master file table MFT
    entries using the FILE or BAAD entry signature. This can list information from
    the `$FILE_NAME`, `$STANDARD_INFORMATION`, and `$DATA NTFS` attributes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: maftparser volatility 插件使用 FILE 或 BAAD 条目签名扫描内存文件中的主文件表（MFT）条目。它可以列出来自`$FILE_NAME`、`$STANDARD_INFORMATION`和`$DATA
    NTFS`属性的信息。
- en: The output of this plugin can be in text format by the `--output=text` option.
    It can also format the body, which is compatible with The Sleuth Kit 3 using the `--output=body`
    option.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件的输出可以通过`--output=text`选项以文本格式呈现。也可以通过`--output=body`选项将其格式化为兼容 The Sleuth
    Kit 3 的主体格式。
- en: In the case of a body file we can use the mactime tool to create one timeline
    of all the MFT activities in memory which will be useful in tracking activities
    by time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是一个主体文件，我们可以使用 mactime 工具创建一个时间轴，列出内存中所有 MFT 活动，这将有助于按时间跟踪活动。
- en: 'Usage: `vol.py -f <ImageFile> --profile=<ImageProfile> mftparser --output=<body|text>
    --output-file=<OutputFile>`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：`vol.py -f <ImageFile> --profile=<ImageProfile> mftparser --output=<body|text>
    --output-file=<OutputFile>`
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the importance of memory forensics in discovering
    malicious activities, briefly explained the memory structure, and went through
    volatility as one of the most-famous and effective memory forensics tools.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了内存取证在发现恶意活动中的重要性，简要解释了内存结构，并介绍了 volatility 作为最著名和有效的内存取证工具之一。
- en: In the next chapter, we will be discussing the network forensics tools and techniques
    in order to extract evidential data from any network dump.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论网络取证工具和技术，以便从任何网络转储中提取证据数据。
