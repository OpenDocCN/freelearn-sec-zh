# 第十一章：渗透测试 CMS-WordPress

CMS 代表内容管理系统-用于管理和修改数字内容的系统。它支持多个用户、作者和订阅者的协作。互联网上使用了许多 CMS，其中一些主要的是 WordPress、Joomla、PHPNuke 和**AEM（Adobe Experience Manager）**。在本章中，我们将研究一个著名的 CMS，WordPress。我们将看看如何对这个 CMS 进行渗透测试。

我们将在本章中涵盖以下主题：

+   WordPress 架构简介

+   使用 Metasploit 进行 WordPress 侦察和枚举

+   WordPress 的漏洞扫描

+   WordPress 利用

+   自定义 Metasploit 漏洞

# 技术要求

以下是本章的先决条件：

+   Metasploit 框架

+   安装的 WordPress CMS

+   配置了数据库服务器（建议使用 MySQL）

+   基本的 Linux 命令知识

# WordPress 简介

WordPress 是一个开源的 CMS，使用 PHP 作为前端，MySQL 作为后端。它主要用于博客，但也支持论坛、媒体库和在线商店。WordPress 由其创始人 Matt Mullenweg 和 Mike Little 于 2003 年 5 月 27 日发布。它还包括插件架构和模板系统。WordPress 插件架构允许用户扩展其网站或博客的功能和功能。截至 2019 年 2 月，WordPress.org 有 54,402 个免费插件和 1500 多个付费插件。WordPress 用户还可以自由创建和开发自己的自定义主题，只要他们遵循 WordPress 标准。

在查看 WordPress 枚举和利用之前，让我们首先了解 WordPress 运行的架构。

# WordPress 架构

WordPress 架构可以分为四个主要部分：

![](img/1056d453-80ca-47bc-8a3d-d62875c86981.png)

让我们看看各个部分：

+   **显示**：这包含对用户可见的 HTML、CSS 和 JavaScript 文件。

+   **主题/模板**：这包括表单、主题文件、不同的 WordPress 页面和部分，如评论、页眉、页脚和错误页面。

+   **WP-Engine**：这个引擎负责整个 CMS 的核心功能，例如 RSS 订阅、与数据库通信、设置、文件管理、媒体管理和缓存。

+   **WP-Backend**：这包括数据库、PHP 邮件程序 cron 作业和文件系统。

现在，让我们看看目录结构。

# 文件/目录结构

浏览 WordPress 目录将给我们一个文件/文件夹结构，如下截图所示：

![](img/c018ede2-5f94-4353-a2e3-b48d6dcd1588.png)

让我们快速浏览一下这些文件夹和文件。

# 基本文件夹

让我们把这称为根目录。该目录包含三个文件夹，即`wp-admin`、`wp-content`和`wp-includes`，以及一堆 PHP 文件，包括最重要的`wp-config.php`。

基本文件夹包含 WordPress 核心操作所需的所有其他 PHP 文件和类。

# wp-includes

wp-includes 文件夹包含所有其他 PHP 文件和类，这些文件和类由前端使用，并且由 WordPress 核心所需。

# wp-admin

该文件夹包含 WordPress 仪表板的文件，用于执行所有管理任务，如撰写帖子、审核评论以及安装插件和主题。只有注册用户才能访问仪表板。

# wp-content

`wp-content`文件夹包含所有用户上传的数据，并再次分为三个子文件夹：

+   `themes`

+   `plugins`

+   `uploads`

`themes`目录包含安装在我们的 WordPress 网站上的所有主题。默认情况下，WordPress 带有两个主题：Twenty Twelve 和 Twenty Thirteen。

同样，`plugins`文件夹用于存储安装在我们的 WordPress 网站上的所有插件。自从我们启动网站以来上传的所有图像（和其他媒体文件）将存储在`uploads`目录中。这些按日，月和年分类。

现在您对 WordPress 的架构和文件/目录结构有了基本的了解，让我们开始渗透测试。

# WordPress 侦察和枚举

在开始利用 WordPress 的任何插件/主题/核心漏洞之前，第一步是确认网站是否在 WordPress 上。至于检测 WordPress 本身，有各种方法可以检测 WordPress CMS 的安装：

+   在 HTML 页面源代码中搜索`wp-content`字符串。

+   查找`/wp-trackback.php`或`/wp-links-opml.php`文件名 - 在 WordPress 安装的情况下它们返回 XML。

+   您还可以尝试`/wp-admin/admin-ajax.php`和`/wp-login.php`。

+   查找静态文件，如`readme.html`和`/wp-includes/js/colorpicker.js`。

一旦确认网站正在运行 WordPress，下一步就是了解目标服务器上运行的 WordPress 版本。为了实现这一点，您需要知道可以检测其版本号的不同方法。为什么要版本号？因为根据安装在目标服务器上的 WordPress 版本，您可以测试可能公开或可能不公开的基于插件或 WordPress 核心的漏洞。

# 版本检测

每个 WordPress 安装都带有一个版本号。在最新的 WordPress 版本中，默认情况下隐藏了版本号，但我们仍然可以枚举版本。在本节中，您将学习一些识别正在运行的 WordPress 版本的方法。

一些最常见的侦察技术是`Readme.html`，meta generator，feed（RDF，Atom 和 RSS），插件和主题（JS 和 CSS ver）以及哈希匹配。

# Readme.html

这是最简单的技术。我们所要做的就是访问`readme.html`页面，它会在中心披露版本号。该文件的原始目的是向 CMS 的首次用户提供有关如何继续安装和使用 WordPress 的信息。一旦安装和设置完成，它应该被删除。在使用任何工具（包括 Metasploit）之前，始终检查 WordPress 安装的版本号，然后再执行任何形式的利用。

因此，请确保您知道您要进行渗透测试的版本。您可以在以下截图中看到`readme.html`的示例：

![](img/47c8a71e-5612-43b5-94ea-6eec443de1b7.png)

接下来，我们将看 meta generator。

# Meta generator

`generator`名称属性的元标记通常被描述为用于生成文档/网页的软件。确切的版本号在元标记的`content`属性中披露。基于 WordPress 的网站通常在其源代码中具有此标记，如下面的截图所示：

![](img/b6fe34bc-d909-4a69-9e73-e81b5c9a5f73.png)

接下来，我们将看到如何通过 JavaScript 和 CSS 文件获取版本。

# 通过 JavaScript 和 CSS 文件获取版本

找到版本号的另一种方法是查看以下文件的源代码。以下文件请求 JS 和 CSS 文件：

+   `wp-admin/install.php`

+   `wp-admin/upgrade.php`

+   `wp-login.php`

这些在其`ver`参数中披露了确切的版本号，如下面的截图所示：

![](img/aafbf7e7-e25a-4244-9ac6-0b2c6359a66b.png)

接下来，我们将看到如何通过 feed 获取版本。

# 通过 feed 获取版本

有时，版本信息也可能在网站的 feed 中披露。以下文件路径可用于披露版本信息：

+   `/index.php/feed/`

+   `/index.php/feed/rss/`

+   `/index.php/feed/rss2/`

+   `/index.php/comments/feed/`

+   `/index.php/feed/rdf/`（文件是本地下载的）

+   `/index.php/feed/atom/`

+   `/?feed=atom`

+   `/?feed=rss`

+   `/?feed=rss2`

+   `/?feed=rdf`

以下截图显示了通过 feeds 披露的版本信息：

![](img/043846de-e277-4b4c-a10c-bb59af500c6f.png)

接下来，我们将看一下 OPML。

# 使用大纲处理标记语言（OPML）

OPML 是大纲处理标记语言（*定义为*每个节点包含一组具有字符串值的命名属性的树*）。以下文件允许 WordPress 从其他网站导入链接，只要它们以 OPML 格式存在，但访问此文件也会披露版本信息（在 HTML 注释标签之间），如下截图所示：

```
/wp-links-opml.php
```

这可以在以下截图中看到：

![](img/acd12498-2ab0-49ba-882b-3874a991c629.png)

接下来，我们将看一下高级指纹识别。

# 唯一/高级指纹识别

这是另一种指纹识别 WordPress 确切版本的方法。顾名思义，这种技术非常独特。它是通过计算静态文件的哈希值，并将其与不同版本的 WordPress 发布中相同静态文件的哈希值进行比较来完成的。您可以通过执行以下命令来执行此操作：

![](img/c54f698d-13f1-42d6-9ba0-ba96b97f16c5.png)

要比较哈希值，请参阅以下 GitHub 存储库：[`github.com/philipjohn/exploit-scanner-hashes`](https://github.com/philipjohn/exploit-scanner-hashes)。

# 使用 Metasploit 进行 WordPress 侦察

Metasploit 有一个用于获取版本号的 WordPress 扫描器模块，`wordpress_scanner`。

让我们为此模块设置选项：

![](img/f98f065a-fd34-48b1-8a72-8398c6beb6b4.png)

一切准备就绪后，让我们运行它：

![](img/d9f00ebc-e06b-4eb0-8a18-9d6e4347162e.png)

这是一个非常简单的扫描程序，尝试使用先前提到的技术找到版本号。

既然我们有了版本号，您可以参考以下案例研究，了解如何枚举和利用 WordPress 的漏洞。给出的漏洞都有详细解释。

# 使用 Metasploit 进行 WordPress 枚举

以下是攻击面，您可以在枚举时专注的地方：

+   用户名

+   主题

+   插件

使用 Metasploit 模块`auxiliary/scanner/http/wordpress_login_enum`，按照以下步骤操作：

1.  您可以尝试暴力破解用户名，也可以枚举用户名：

![](img/a410ad68-667c-48f9-9d5d-d6ab51b0b52e.png)

1.  让我们设置选项，只枚举用户名并运行模块：

![](img/ad5d19e6-ebeb-478d-a1fd-7d49a6e50ce0.png)

1.  您现在可以尝试使用字典进行暴力破解。模块的默认选项使其能够执行暴力破解攻击：

![](img/880e5de1-ccee-4f47-84ad-d23ab23c885c.png)

1.  现在让我们设置选项。我们已经设置了从前面的枚举方法中找到的用户名：

![](img/3c9a8662-7c8e-48b5-b2a8-da48490f11cb.png)

1.  对于密码字典，使用`set PASS_FILE <file>`命令并运行模块：

![](img/535be82d-a179-4cda-a41d-324305d50f11.png)

在下一节中，我们将看一下漏洞评估扫描。

# WordPress 漏洞评估

Metasploit 没有可以执行漏洞评估扫描的模块。但是，您可以编写一个充当第三方工具（如 WPscan）包装器的 Metasploit 模块，用于漏洞评估扫描。

我们编写了一个自定义的 Metasploit 模块，执行时将运行 WPscan，解析输出并打印出来。虽然该模块只是一个粗糙的包装代码，但您可以根据需要进一步修改它。以下是自定义 Metasploit 模块的示例代码：

1.  我们将首先添加所需的库，如下所示：

```
require 'open3'
require 'fileutils'
require 'json'
require 'pp'
```

1.  然后，我们添加 Metasploit 的`Auxiliary`类：

```
class MetasploitModule < Msf::Auxiliary
 include Msf::Auxiliary::Report
```

1.  我们定义模块的信息部分：

```
def initialize
 super(
 'Name' => 'Metasploit WordPress Scanner (WPscan)',
 'Description' => 'Runs wpscan via Metasploit',
 'Author' => [ 'Harpreet Singh', 'Himanshu Sharma' ]
 )
```

1.  在这里，我们将添加模块的`options`部分，通过它我们可以为测试添加目标 URL：

```
register_options(
 [
     OptString.new('TARGET_URL', [true, 'The target URL to be scanned using wpscan'])
 ]
 )
 end
```

1.  接下来，我们定义`target_url`方法，该方法将存储用户选项`TARGET_URL`：

```
def target_url
 datastore['TARGET_URL']
end
```

1.  我们还定义了`find_wpscan_path`方法，该方法将在系统中查找`wpscan`文件：

```
def find_wpscan_path
 Rex::FileUtils.find_full_path("wpscan")
end
```

1.  接下来，我们添加辅助模块执行方法`run`，并检查系统中是否安装了`wpscan`：

```
def run
 wpscan = find_wpscan_path
 if wpscan.nil?
 print_error("Please install wpscan gem via: gem install wpscan")
 end
```

如果找到`wpscan`，模块将首先创建一个带有随机字符的临时文件：

```
tmp_file_name = Rex::Text.rand_text_alpha(10)
```

1.  以下是`wpscan`执行块。这里将使用用户选项创建一个`wpscan`进程：

```
cmd = [ wpscan, "--url", target_url, "-o", "#{tmp_file_name}", "-f", "json", "--force" ]
 ::IO.popen(cmd, "rb") do |fd|
     print_status("Running WPscan on #{target_url}")
     print_line("\t\t\t\t(This may take some time)\n")
     fd.each_line do |line|
         print_status("Output: #{line.strip}")
     end
 end
```

执行完成后，模块将读取包含`wpscan`输出的临时文件：

```
json = File.read("/tmp/#{tmp_file_name}")
```

1.  现在，我们添加将解析 JSON 输出的代码块：

```
obj = JSON.parse(json)
 i = 0
 print_line("\n")
 print_status("-------------------------------------")
 print_status("Looking for some Interesting Findings")
 print_status("-------------------------------------")
 obj = obj.compact
```

在这里，我们正在查找 JSON 输出中的`interesting_findings`数组。我们将使用此数组打印在 WordPress 目标站点中发现的漏洞的详细信息：

```

 while (i <= obj['interesting_findings'].length) do
     if obj['interesting_findings'][i]['type'] == 'headers' && !(obj['interesting_findings'][i].nil?)
         obj['interesting_findings'][i]['interesting_entries'].each { |x|                     print_good("Found Some Interesting Enteries via Header detection: #{x}")}
         i += 1
     elsif obj['interesting_findings'][i]['type'] == 'robots_txt' && (!obj['interesting_findings'][i].nil?)
         obj['interesting_findings'][i]['interesting_entries'].each { |x| print_good("Found Some Interesting Enteries via robots.txt: #{x}")}
         i += 1
     else
         break
     end
 end
```

1.  我们添加了检查 JSON 输出中的`version`数组并解析 WordPress 版本的代码块：

```
 print_line("\n")
 print_status("--------------------------------------")
 print_status("Looking for the WordPress version now")
 print_status("--------------------------------------")
 if !(obj['version'].nil?)
     print_good("Found WordPress version: " + obj['version']['number'] + " via " + obj['version']['found_by'])
 else
     print_error("Version not found")
 end
```

我们解析了`wpscan`发现的漏洞总数，并打印出来（包括引用和 CVE 链接）：

```
 print_status "#{obj['version']['vulnerabilities'].count} vulnerabilities identified:"
 obj['version']['vulnerabilities'].each do |x|
 print_error("\tTitle: #{x['title']}")
 print_line("\tFixed in: #{x['fixed_in']}")
 print_line("\tReferences:")
 x['references'].each do |ref|
 if ref[0].include?'cve'
     print_line("\t\t- https://cve.mitre.org/cgi-bin/cvename.cgi?name=#{ref[1][0]}")
 elsif ref[0].include?'url'
     ref[1].each do |e|
     print_line("\t\t- #{e}")
 end
 elsif ref[0].include?'wpvulndb'
     print_line("\t\t- https://wpvulndb.com/vulnerabilities/#{ref[1][0]}")
 end
 end
 print_line("\n")
 end
```

1.  我们添加了用于检查已安装主题的代码块，使用`wpscan`：

```
 print_line("\n")
 print_status("------------------------------------------")
 print_status("Checking for installed themes in WordPress")
 print_status("------------------------------------------")
 if !(obj['main_theme'].nil?)
     print_good("Theme found: " + "\"" + obj['main_theme']['slug'] + "\"" + " via " + obj['main_theme']['found_by'] + " with version: " + obj['main_theme']['version']['number'])
 else
     print_error("Theme not found")
 end
```

我们还添加了使用`wpscan`枚举已安装插件的代码块：

```
 print_line("\n")
 print_status("---------------------------------")
 print_status("Enumerating installed plugins now")
 print_status("---------------------------------")
 if !(obj['plugins'].nil?)
     obj['plugins'].each do |x|
     if !x[1]['version'].nil?
         print_good "Plugin Found: #{x[0]}"
         print_status "\tPlugin Installed Version: #{x[1]['version']['number']}"
         if x[1]['version']['number'] < x[1]['latest_version']
             print_warning "\tThe version is out of date, the latest version is #{x[1]['latest_version']}"
         elsif x[1]['version']['number'] == x[1]['latest_version']
             print_status "\tLatest Version: #{x[1]['version']['number']} (up to date)"
         else
             print_status "\tPlugin Location: #{x[1]['location']}"
         end 
    else
     print_good "Plugin Found: #{x[0]}, Version: No version found"
 end
```

1.  然后，我们添加了查找已安装插件中发现的漏洞并根据 CVE 和引用 URL（包括`exploit-db` URL）进行映射的代码块：

```
 if x[1]['vulnerabilities'].count > 0
     print_status "#{x[1]['vulnerabilities'].count} vulnerabilities identified:"
 x[1]['vulnerabilities'].each do |b|
     print_error("\tTitle: #{b['title']}")
     print_line("\tFixed in: #{b['fixed_in']}")
     print_line("\tReferences:")
     b['references'].each do |ref2|
     if ref2[0].include?'cve'
         print_line("\t\t- https://cve.mitre.org/cgi-bin/cvename.cgi?name=#{ref2[1][0]}")
     elsif ref2[0].include?'url'
         ref2[1].each do |f|
         print_line("\t\t- #{f}")
     end
 elsif ref2[0].include?'exploitdb'
     print_line("\t\t- https://www.exploit-db.com/exploits/#{ref2[1][0]}/")
 elsif ref2[0].include?'wpvulndb'
     print_line("\t\t- https://wpvulndb.com/vulnerabilities/#{ref2[1][0]}")
 end
 end
 print_line("\n")
 end

 end
 end
 else
     print_error "No plugin found\n"
 end
```

1.  一切都完成后，删除此模块创建的临时文件：

```
File.delete("/tmp/#{tmp_file_name}") if File.exist?("/tmp/#{tmp_file_name}")
 end
end
```

以下是 WPscan 辅助模块的完整代码：

```
require 'open3'
require 'fileutils'
require 'json'
require 'pp'
class MetasploitModule < Msf::Auxiliary
 include Msf::Auxiliary::Report

 def initialize
 super(
 'Name' => 'Metasploit WordPress Scanner (WPscan)',
 'Description' => 'Runs wpscan via Metasploit',
 'Author' => [ 'Harpreet Singh', 'Himanshu Sharma' ]
 )

 register_options(
 [
     OptString.new('TARGET_URL', [true, 'The target URL to be scanned using wpscan'])
 ]
 )
 end

 def target_url
     datastore['TARGET_URL']
 end

 def find_wpscan_path
     Rex::FileUtils.find_full_path("wpscan")
 end

 def run
     wpscan = find_wpscan_path
     if wpscan.nil?
         print_error("Please install wpscan gem via: gem install wpscan")
     end
     tmp_file_name = Rex::Text.rand_text_alpha(10)
     cmd = [ wpscan, "--url", target_url, "-o", "#{tmp_file_name}", "-f", "json", "--force" ]
     ::IO.popen(cmd, "rb") do |fd|
         print_status("Running WPscan on #{target_url}")
         print_line("\t\t\t\t(This may take some time)\n")
         fd.each_line do |line|
             print_status("Output: #{line.strip}")
         end
 end

 json = File.read("/tmp/#{tmp_file_name}")
 obj = JSON.parse(json)
 i = 0
 print_line("\n")
 print_status("-------------------------------------")
 print_status("Looking for some Interesting Findings")
 print_status("-------------------------------------")
 obj = obj.compact
 while (i <= obj['interesting_findings'].length) do
     if obj['interesting_findings'][i]['type'] == 'headers' && !(obj['interesting_findings'][i].nil?)
         obj['interesting_findings'][i]['interesting_entries'].each { |x| print_good("Found Some Interesting Enteries via Header detection: #{x}")}
         i += 1
     elsif obj['interesting_findings'][i]['type'] == 'robots_txt' && (!obj['interesting_findings'][i].nil?)
         obj['interesting_findings'][i]['interesting_entries'].each { |x| print_good("Found Some Interesting Enteries via robots.txt: #{x}")}
         i += 1
     else
         break
     end
 end

 print_line("\n")
 print_status("--------------------------------------")
 print_status("Looking for the WordPress version now")
 print_status("--------------------------------------")
 if !(obj['version'].nil?)
     print_good("Found WordPress version: " + obj['version']['number'] + " via " + obj['version']['found_by'])
 else
     print_error("Version not found")
 end
 print_status "#{obj['version']['vulnerabilities'].count} vulnerabilities identified:"
 obj['version']['vulnerabilities'].each do |x|
 print_error("\tTitle: #{x['title']}")
 print_line("\tFixed in: #{x['fixed_in']}")
 print_line("\tReferences:")
 x['references'].each do |ref|
 if ref[0].include?'cve'
     print_line("\t\t- https://cve.mitre.org/cgi-bin/cvename.cgi?name=#{ref[1][0]}")
 elsif ref[0].include?'url'
     ref[1].each do |e|
     print_line("\t\t- #{e}")
 end
 elsif ref[0].include?'wpvulndb'
     print_line("\t\t- https://wpvulndb.com/vulnerabilities/#{ref[1][0]}")
 end
 end
 print_line("\n")
 end
 print_line("\n")

 print_status("------------------------------------------")
 print_status("Checking for installed themes in WordPress")
 print_status("------------------------------------------")
 if !(obj['main_theme'].nil?)
     print_good("Theme found: " + "\"" + obj['main_theme']['slug'] + "\"" + " via " + obj['main_theme']['found_by'] + " with version: " + obj['main_theme']['version']['number'])
 else
     print_error("Theme not found")
 end
 print_line("\n")
 print_status("---------------------------------")
 print_status("Enumerating installed plugins now")
 print_status("---------------------------------")
 if !(obj['plugins'].nil?)
     obj['plugins'].each do |x|
 if !x[1]['version'].nil?
     print_good "Plugin Found: #{x[0]}"
     print_status "\tPlugin Installed Version: #{x[1]['version']['number']}"
     if x[1]['version']['number'] < x[1]['latest_version']
         print_warning "\tThe version is out of date, the latest version is #{x[1]['latest_version']}"
     elsif x[1]['version']['number'] == x[1]['latest_version']
         print_status "\tLatest Version: #{x[1]['version']['number']} (up to date)"
     else
         print_status "\tPlugin Location: #{x[1]['location']}"
     end 
 else
     print_good "Plugin Found: #{x[0]}, Version: No version found"
 end
 if x[1]['vulnerabilities'].count > 0
     print_status "#{x[1]['vulnerabilities'].count} vulnerabilities identified:"
 x[1]['vulnerabilities'].each do |b|
     print_error("\tTitle: #{b['title']}")
     print_line("\tFixed in: #{b['fixed_in']}")
     print_line("\tReferences:")
     b['references'].each do |ref2|
     if ref2[0].include?'cve'
         print_line("\t\t- https://cve.mitre.org/cgi-bin/cvename.cgi?name=#{ref2[1][0]}")
     elsif ref2[0].include?'url'
         ref2[1].each do |f|
             print_line("\t\t- #{f}")
         end
     elsif ref2[0].include?'exploitdb'
         print_line("\t\t- https://www.exploit-db.com/exploits/#{ref2[1][0]}/")
     elsif ref2[0].include?'wpvulndb'
         print_line("\t\t- https://wpvulndb.com/vulnerabilities/#{ref2[1][0]}")
     end
 end

 print_line("\n")
 end
 end
 end
 else
     print_error "No plugin found\n"
 end
 File.delete("/tmp/#{tmp_file_name}") if File.exist?("/tmp/#{tmp_file_name}")
 end
end
```

以下是运行我们刚创建的自定义模块的步骤：

1.  将模块复制到`<path_to_metasploit>/modules/auxiliary/scanner/wpscan.rb`并启动 Metasploit：

![](img/644d4153-ce63-42a6-a54b-f815a2cee11c.png)

1.  设置选项并运行模块：

![](img/9d4414cc-b40d-40a1-bd8e-dd7699618f12.png)

该模块还解析插件信息：

![](img/277f5e1e-edef-46f5-8528-6ab302a8446f.png)

该模块不会将信息保存在数据库中，因此如果您愿意，可以自定义它来执行。该模块的唯一目的是枚举插件、主题和 WordPress 版本，并查找漏洞。在下一节中，我们将介绍利用。

# WordPress 利用部分 1-WordPress 任意文件删除

现在您已经了解了如何识别 WordPress 版本，让我们详细了解一些利用 WordPress 的方法。我们还将讨论利用过程的工作原理。

我们首先来看一下*WordPress 任意文件删除*漏洞。此漏洞允许任何经过身份验证的用户从服务器上删除文件。攻击者可以利用这一点来执行命令。让我们看看这个利用是如何工作的以及如何实现命令执行。

以下屏幕截图显示了在我们的本地主机上运行的 WordPress 博客：

![](img/0ab04930-fc56-4664-af10-4b4a39aaa041.png)

漏洞实际上是一个二次文件删除，我们上传和编辑图像，然后将我们文件的路径放入元数据中。当图像被删除时，WordPress 调用 unlink 函数自动删除包含我们文件路径的元数据，因此文件也被删除。让我们看一下基本的漏洞流程。

# 漏洞流程和分析

我们将深入挖掘此漏洞的根本原因。看一下`wp-admin/post.php`文件的以下屏幕截图。在这里，未经过滤的输入来自用户并存储在`$newmeta`中：

![](img/aee3e993-ad6e-49ed-9c92-3e693964d7ca.png)

在`wp-includes/post.php`文件中，相同的输入被传递给`wp_update_attachment_metadata()`，以作为序列化值存储在数据库中，`meta_key`：

![](img/0b9b3840-f22c-458b-9d9e-dc515fe82c13.png)

当用户点击删除媒体按钮时，以下代码将要求从数据库中获取输入并将其存储在`$thumbfile`中。然后，调用 unlink 函数来删除指定的文件。缩略图链接元数据被删除，因为它包含了对`wp-config`的路径：

![](img/9d176a82-42bd-4132-9a70-39c6a17a9f36.png)

接下来，我们将使用 Metasploit 利用漏洞。

# 使用 Metasploit 利用漏洞

Metasploit 有一个内置的利用模块，可以删除服务器上的任意文件。我们将使用`wp-config`文件的示例，因为我们稍后将讨论如何使用此利用来将 shell 上传到服务器上：

1.  要使用该模块，我们在 msfconsole 中运行以下命令。

1.  使用`auxiliary/scanner/http/wp_arbitrary_file_deletion`：

![](img/d2bc9cb7-fbaa-453f-860a-5b6740bd759e.png)

如前面的截图所示，我们输入了 RHOST、WordPress 用户名和密码以及配置文件的路径。在运行利用之前，让我们也看一下我们的 WordPress 数据库的`wp_postmeta`表中当前的条目，如下截图所示：

![](img/53d389a6-a53a-41d0-a30b-303861c28093.png)

`wp-config.php`文件现在也存在于服务器上：

![](img/c71c4646-2b73-4088-8a97-5f8b7ae09e8a.png)

当执行模块时，Metasploit 会使用 WordPress 进行身份验证，并将`.gif`文件上传到服务器：

![](img/8295e6bb-88a1-44fa-aca8-787f83e9bf1d.png)

再次查看`wp_postmeta`表的条目，我们看到现在存在一个附件，并且附件的元数据以序列化格式存储。元数据包含文件名、宽度、高度和 EXIF 标头等详细信息：

![](img/8592b189-e21d-403a-ba7e-c39773d91c55.png)

接下来，利用将尝试编辑附件并将缩略图参数设置为我们要删除的文件的路径：

![](img/b1d6b1bc-00d6-47ad-98c8-a7a373467017.png)

这会得到一个`302`响应，我们被重定向回帖子页面：

![](img/30388210-f549-4906-b09f-e5cbed547012.png)

让我们看看在此请求之后数据库是如何更新的。再次查看`wp_postmeta`表，我们将看到已向序列化的`meta_value`列添加了两个新字符串。这些值是缩略图和配置文件的路径：

![](img/fdd2fb65-0ea0-41b4-b5d7-0643178b8b6b.png)

利用的下一步是删除已上传的附件，这将导致调用`unlink()`函数，从而删除配置文件：

![](img/9779c3d2-be73-4dc8-bf77-11eca91cd8f9.png)

接下来要考虑的问题是：**删除配置文件如何让我们在服务器上实现远程代码执行（RCE）**？

一旦`wp-config.php`文件被删除，WordPress 将重定向站点到`setup-config.php`，即默认的安装启动页面，如下截图所示：

![](img/622632d9-a1e2-4f15-aceb-dbad9613365a.png)

想法是在我们自己的服务器上创建一个数据库，并重新设置 WordPress 与我们自己的数据库：

以下截图显示了在我们自己的服务器上创建 MySQL 数据库的 SQL 命令。这个服务器需要被 WordPress 访问，所以我们必须确保 MySQL 正在运行并且允许远程登录：

![](img/695bfe68-4adb-457d-a9fc-dcf6478e2819.png)

现在，我们点击继续并提供数据库连接详细信息，如下所示：

![](img/f940bd9a-ec22-46c0-af9a-05884504e7d3.png)

完成后，下一步是创建 WordPress 用户进行登录：

![](img/c0cfd386-a692-4fdf-9780-25577512341b.png)

现在我们可以使用刚刚创建的 WordPress 用户登录。服务器上的 WordPress 实例现在已连接并配置为使用我们自己的数据库：

![](img/eef9d31c-ac40-4ba6-915c-6a58eee3bafc.png)

由于我们对 WordPress CMS 具有管理员访问权限，因此我们可以使用 Metasploit 模块在站点上上传 shell。可以使用以下利用方法来实现：

```
use exploit/unix/webapp/wp_admin_shell_upload
```

以下截图显示了前面命令的输出：

![](img/c0538732-e8c9-4f71-98d3-fae3a60d06dc.png)

让我们设置此利用要使用的选项，如下所示：

![](img/697f3f79-49d5-40b8-aabe-db873eac18b0.png)

现在，让我们执行该模块并等待魔法发生：

![](img/87e0f3c8-c573-40f6-aa19-eef1ebf98f1c.png)

现在我们在服务器上有 meterpreter 访问权限。因此，已实现 RCE：

![](img/211ab09b-0a74-4abb-9452-e7c2d101253e.png)

这是一个非常直接的利用。然后可以进一步破解哈希值以获得对管理员面板的访问权限，或者一旦获得明文密码，就可以使用 WordPress shell 上传模块在服务器上获取 meterpreter。在接下来的部分，我们将看一下 Google 地图插件中的未经身份验证的 SQL 注入。

# WordPress 利用第 2 部分-未经身份验证的 SQL 注入

让我们来看另一个 SQL 注入的案例，这是在 WordPress 谷歌地图插件中发现的。Metasploit 已经有一个内置的利用模块，可以从数据库中提取`wp_users`表：

```
auxiliary/admin/http/wp_google_maps_sqli
```

在运行模块之前，让我们看一下插件的源代码，并了解问题出在哪里。

# 漏洞流程和分析

查看`class.rest-api.php`的源代码，我们可以看到用户输入作为名为`fields`的`get`参数传递到`explode`函数中。`explode`函数用于*按指定字符串拆分字符串为多个部分*：

![](img/7896c1b7-2d14-47cf-b6e6-710917affa92.png)

然后，输入存储在`$imploded`变量中，使用`implode()`组合后直接传递到`SELECT`查询中，如下截图所示：

![](img/2d450d07-01af-473d-af5f-69ae07fe2f80.png)

在这里，`$imploded`变量是注入点。这个漏洞也可以利用 Metasploit 模块来利用。

# 使用 Metasploit 利用漏洞

对目标运行利用程序将给我们显示存储在`wp_users`表中的数据，如下所示：

![](img/5f63e3b9-aa74-4a75-8f06-91ea0173e857.png)

接下来，我们将看一下 WordPress 利用的第三部分和最后一部分。

# WordPress 利用第 3 部分-WordPress 5.0.0 远程代码执行

在本节中，我们将看一下 RCE 漏洞，这个漏洞存在于 WordPress 版本 5.0.0 及以下。这个利用链两个不同的漏洞来实现代码执行（路径遍历和本地文件包含）。Metasploit 已经有一个针对这个漏洞的模块。

# 漏洞流程和分析

第一个漏洞是 CVE-2019-8942，它覆盖了`post`元数据条目：

![](img/79575cd5-bfee-4f91-88ba-54b9b2e272ff.png)

未经过消毒的用户输入然后传递到`wp_update_post()`，它不检查不允许的`post`元数据字段：

![](img/05675fe4-d972-464d-bfc8-899e7e590d49.png)

攻击者可以覆盖`_wp_attached_file`的 post 元数据键为他们的恶意文件。在这一点上，我们已经利用了 CVE-2019-8942。现在我们已经控制了在 post 元数据条目中可以覆盖的内容，让我们利用下一个漏洞 CVE-2019-8943，即路径遍历漏洞。利用这个漏洞，我们可以将我们上传的恶意文件的路径从先前利用的漏洞（CVE-2019-8942）更改为我们选择的路径以实现 RCE。

`wp_crop_image()`函数调用`get_attached_file()`函数时没有进行任何文件路径验证。因此，在服务器上上传的恶意图片文件将在调用`wp_crop_image()`函数时传递给`get_attached_file()`函数（在裁剪图片时）：

![](img/420d959f-dc5a-44f6-a353-c12ee2807714.png)

我们可以利用这个漏洞来改变我们上传的恶意文件的路径，并将裁剪后的图片保存在默认主题目录中，即`wp-content/themes/<default_theme>/<cropped-image>.jpg`：

![](img/c977730a-ad7d-4fbd-b74f-391c42dfdf80.png)

正如我们在上面的截图中所看到的，恶意图片被保存在默认主题文件夹中。现在我们的恶意图片已经就位，我们可以请求帖子，以便我们的 PHP 有效负载得到执行，从而实现 RCE。

# 使用 Metasploit 利用漏洞

可以使用以下命令在 Metasploit 控制台中选择模块：

```
use exploit/multi/http/wp_crop_rce
```

以下截图显示了上述命令的输出：

![](img/e9b86a32-cf35-4d2c-991a-09e693695a93.png)

我们设置了如下截图中所示的必需选项。我们将需要 WordPress 博客上的低权限帐户，因为此漏洞需要身份验证以及上传和编辑媒体的权限：

![](img/f8e38b91-b9c5-498c-b172-8108bf3dfc80.png)

利用发生在几个步骤中。Metasploit 模块的第一步是检查提供的`targeturi`是否正确：

![](img/31153afb-0ed7-4a44-9ae1-90e84cef11a5.png)

得到 200 的 HTTP 响应代码后，确认了`targeturi`路径：

![](img/5b78206a-09db-4e1c-a9ea-e4207e9b9fc8.png)

模块继续下一步——身份验证。在此步骤中，模块使用的用户名和密码将被使用。在与 WordPress 网站进行身份验证时，模块还请求重定向到一个不存在的页面：

![](img/ddfa5732-c0c0-4d37-934a-11ae67e1fccd.png)

HTTP 响应将重定向（302）到一个不存在的页面。这样做是为了从服务器获取会话 cookie。在此步骤之后的一切都是使用这些 cookie 完成的：

![](img/af2d092a-076a-4d86-b548-40da3ec12963.png)

让我们确认数据库状态：

![](img/fd522b3e-4e20-4737-a891-f1552e0b3160.png)

现在会话已从服务器检索到，在下一步中，该模块请求`media-new.php`页面。该页面负责将媒体上传到 WordPress 网站：

![](img/7b2c026a-c212-4aa9-80bb-45c770f1c9ac.png)

这里的目标是上传一个嵌入了我们有效载荷的图像：

![](img/3640ee55-5e04-4fc6-b3c8-890c7eecb754.png)

然后，该模块上传了嵌入了我们的有效载荷的图像：

![](img/bca11c05-baf5-487c-a6a2-36d58b4bd234.png)

正如我们在前面的截图中看到的，嵌入在图像中的有效载荷是`<?=`$_GET[0]`;?>`。我们使用这样一个压缩的有效载荷的原因是因为我们剩下的空间不多，用于执行有效载荷。另外，请注意，有效载荷嵌入在两个不同的地方——扫描标头后面和 EXIF 元数据中。嵌入两次的原因是为了确保有效载荷被执行。

WordPress 支持两种用于 PHP 的图像编辑扩展：**GD** **Library**和**Imagick**。GD Library 压缩图像并去除所有 EXIF 元数据。Imagick 不会去除任何 EXIF 元数据。这就是为什么该模块将有效载荷嵌入图像两次的原因。

上传时的路径和 POST 元数据存储在数据库中：

![](img/45360bc1-ee8b-40b9-a631-ce2f8835da76.png)

一旦恶意图像上传，响应中会分配一个 ID 给图像，并显示其完整路径：

![](img/1ef665c6-bf8f-4c54-929c-c3cc18bdea92.png)

该模块检查 WordPress 网站是否容易受到 CVE-2019-8942 和 CVE-2019-8943 的攻击。它通过以下步骤来实现：

1.  通过查询所有附件来确认图像是否已上传或不。 

1.  它确保恶意图像以 400 x 300 的大小保存。（这将有助于进行虚假裁剪时。）

1.  它获取了更新的`wp_nonce`和编辑恶意图像时的更新文件名。

1.  它检查图像的 POST 元数据条目是否可以从`.jpg`被覆盖为`.jpg?/x`。如果更改了，就表明 WordPress 网站容易受到 CVE-2019-8942 的攻击。

1.  它裁剪图像（这里是一个虚假的裁剪）来检查 WordPress 网站是否容易受到 CVE-2019-8943 的攻击，即路径遍历漏洞。

1.  一旦模块确认了漏洞，它通过将 POST 元数据从`.jpg`覆盖为`.jpg?/../../../../themes/#{@current_theme}/#`{`@shell_name`}来利用 CVE-2019-8942：

![](img/cd0c3186-7084-48ba-81fb-483fc174f2e2.png)

以下截图显示了`meta_value`列的更新值：

![](img/57c237e9-7099-4975-9039-1d5cf665dacb.png)

我们还可以在以下截图中看到，默认模板已更改为`cropped-zAdFmXvBCk.jpg`：

![](img/39360439-d3c9-4306-a03c-afa9d9bf9514.png)

然后，模块请求带有帖子 ID 的默认模板，并附加`0`参数以执行 RCE 的命令：

![](img/191b9e8b-b961-4cd0-9264-bc37f3921191.png)

命令的输出如下：

![](img/dd4e6f35-a083-4f0d-8016-78723ce829a0.png)

接下来，模块会执行以下操作：

1.  它确认系统中是否存在 Base64 程序。

1.  它将 PHP meterpreter 转换为 Base64，并使用`echo <base64_of _PHP_meterpreter> | base64 -d > shell.php`将其上传到服务器。

1.  它请求上传的 PHP shell 以获得 meterpreter 访问。

1.  以下截图显示了 Base64 编码的 meterpreter 代码被写入 PHP 文件：

![](img/6e6c0812-0bc1-470a-bc29-36b8cf4bf95d.png)

以下截图显示了从服务器成功建立的 meterpreter 连接：

![](img/123bf68c-e1e1-4d7c-be49-0e7ad0a273d5.png)

在下一节中，我们将定制 Metasploit 利用。

# 走出舒适区-定制 Metasploit 利用

对于我们在上一节中使用的 Metasploit 模块`exploit/multi/http/wp_crop_rce`，我们需要设置模块的用户名和密码才能使其工作。但是如果在认证时有 reCAPTCHA 呢？模块肯定会失败，因为模块无法绕过获取会话 cookie 的方法：

1.  让我们修改模块，使其也能与`COOKIE`数据存储一起使用：

![](img/ca7611b4-1b44-4b37-bf25-d9e214b9c3f8.png)

我们可以在以下截图中看到更新后的模块选项：

![](img/9d1b52a6-91b5-4726-a056-ebd8c6ff167a.png)

1.  让我们为`COOKIE`数据存储定义一个函数：

![](img/88b328c9-81f5-457f-bd52-48f1e13990c2.png)

1.  我们还需要根据响应代码验证 cookie。因此，让我们定义一个`validate_cookie()`函数；这将使用 200 的 HTTP 响应代码验证 cookie：

![](img/e980a39e-1194-4140-8b9f-85ed97c37b86.png)

1.  现在，在`exploit()`函数中，让我们包括一个`fail-safe fail_with()`方法，以确保如果用户名或密码缺失，利用将会失败。如果 cookie 也没有设置，也会这样做：

![](img/d97fd41b-955d-4a59-a6e6-9321257efaf2.png)

1.  如果用户名和密码缺失，模块将尝试使用`COOKIE`。让我们更新模块并为其设置`COOKIE`选项：

![](img/0dd59fcf-afc4-4779-8b16-931841056b1b.png)

1.  现在，让我们运行模块，看魔术发生：

![](img/17ee4fc4-c9e4-4fdb-8ecb-ea27cd51970b.png)

我们已经使用`COOKIE`得到了 meterpreter！

# 摘要

在本章中，我们首先讨论了 WordPress 的架构，然后是目录结构。接下来，我们学习了如何对 WordPress 进行手动和自动化的侦察。之后，我们看了一些利用的例子，并逐步手动和使用 Metasploit 模块进行了整个利用过程的演示。

在下一章中，我们将学习如何对基于 Joomla 的**内容管理系统**（**CMS**）进行渗透测试。

# 问题

1.  所有版本的 WordPress 的侦察步骤都一样吗？

1.  我找到了一个`wp-admin`目录，但目录本身是不可访问的。在这种情况下我该怎么办？

1.  WordPress 可以免费下载吗？

# 进一步阅读

以下链接可用于了解更多有关 WordPress 的利用方法和最新发布的漏洞：

+   [`wpvulndb.com/`](https://wpvulndb.com/)

+   [`wpsites.net/wordpress-tips/3-most-common-ways-wordpress-sites-are-exploited/`](https://wpsites.net/wordpress-tips/3-most-common-ways-wordpress-sites-are-exploited/)

+   [`www.exploit-db.com/docs/english/45556-wordpress-penetration-testing-using-wpscan-and-metasploit.pdf?rss`](https://www.exploit-db.com/docs/english/45556-wordpress-penetration-testing-using-wpscan-and-metasploit.pdf?rss)
