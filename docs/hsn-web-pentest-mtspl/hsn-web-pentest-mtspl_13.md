# 第十三章：渗透测试 CMS - Drupal

在上一章中，我们解释了如何对 Joomla 网站进行渗透测试。WordPress、Joomla 和 Drupal 之间存在相当大的差异，特别是在安全性和架构方面。在本章中，我们将学习有关 Drupal、其架构以及如何测试基于 Drupal 的网站的内容。

在本章中，我们将涵盖以下主题：

+   Drupal 及其架构简介

+   Drupal 侦察和枚举

+   使用 droopescan 进行 Drupal 漏洞扫描

+   利用 Drupal

# 技术要求

对于本章，您将需要以下内容：

+   一些 PHP 知识

+   对 Metasploit Framework 的基础了解

+   了解基本的 Linux 命令，如`grep`和`ag`

+   对 Burp Suite 的基础了解

# Drupal 及其架构简介

Drupal 是一个用 PHP 编写的免费开源**内容管理系统**（**CMS**）。它最初是由**Dries Buytaert**作为留言板编写的，但在 2001 年成为一个开源项目。尽管与其他 CMS 相比，Drupal 被认为使用起来有点棘手，但它确实提供了内置的 API 来促进自定义模块的开发。

# Drupal 的架构

描述 Drupal 架构的一般方法是将其分为四个主要部分，如下图所示：

![](img/d71d78c6-8415-43a1-96b9-6626a2d3383a.png)

要了解架构，首先让我们了解 Drupal 的组件。Drupal 的组件列在这里：

+   **主题**：主题是定义 Drupal 网站用户界面的文件集合。这些文件包含用 PHP、HTML 和 JavaScript 编写的代码。

+   **模块**：模块是事件驱动的代码文件，可用于扩展 Drupal 的功能。一些模块是已知的核心模块，由 Drupal 开发团队维护，因为它们是 Drupal 运行的重要部分。

+   **核心 API**：Drupal 的核心是用于与内容和其他模块通信的 API。这些 API 包括以下内容：

+   **数据库 API**：这允许开发人员轻松更新/修改数据库中的数据。

+   **缓存 API**：此 API 存储页面响应，以便浏览器不必在每次请求时重新渲染页面。

+   **会话处理 API**：这可以跟踪网站上不同用户及其活动。

+   **数据库**：这是存储所有数据的地方。Drupal 支持不同类型的数据库，如 MySQL、Postgres 和 SQLite。

现在我们对 Drupal 的架构有了基本了解，让我们接下来看目录结构。

# 目录结构

Drupal 具有以下目录结构：

+   **核心**：这包括默认 Drupal 安装使用的文件。

+   **模块**：安装在 Drupal 中的所有自定义模块都存储在这里。

+   **配置文件**：此文件夹存储安装配置文件。安装配置文件包含有关预安装模块、主题和给定 Drupal 站点配置的信息。

+   **网站**：如果 Drupal 与多个站点一起使用，则包含特定于站点的模块。

+   **主题**：基础主题和所有其他自定义主题都存储在此目录中。

+   **供应商**：此目录包含 Drupal 使用的后端库，如 Symfony。

默认 Drupal 安装的目录结构如下截图所示：

![](img/d1bf7a31-cca4-4596-b2a0-156a89a49364.png)

现在我们对 Drupal 的基础知识和目录结构有了了解，让我们继续下一个主题：Drupal 侦察和枚举。

# Drupal 侦察和枚举

正如我们在前几章中所讨论的，侦察和枚举是任何渗透测试的关键步骤。在本节中，我们将看一些可用于识别 Drupal 安装和已安装版本的方法。

# 通过 README.txt 进行检测

这是最简单和最基本的技术。我们只需要访问`README.txt`页面，就会看到一行文字，上面写着“保护文件和目录免受窥视”：

![](img/1abf36c4-7030-48a4-8185-c8ea7708e7cf.png)

这将表明该实例确实是 Drupal 实例。

# 通过元标记检测

具有`name`属性为`"Generator"`的元标记标识用于生成文档/网页的软件。版本号在元标记的`content`属性中公开：

![](img/49ec88ea-884d-491e-bee6-457eafafb59c.png)

基于 Drupal 的网站通常在其源代码中有这个标签。

# 通过服务器标头检测

如果服务器响应中存在以下标头之一，也可以识别 Drupal：

+   **X-Generator HTTP 标头**：这标识了 Drupal 网站。

+   **X-Drupal-Cache 标头**：这个标头由 Drupal 的缓存使用。如果标头值为**X-Drupal-Cache: MISS**，这意味着页面不是从缓存显示中提供的，如果你看到**X-Drupal-Cache: HIT**，这意味着页面是从缓存中提供的。

+   **X-Drupal-Dynamic-Cache 标头**：该动态缓存用于加载动态内容（缓存页面），但不包括个性化部分。

+   **过期：1978 年 11 月 19 日**。

以下屏幕截图显示了服务器响应中的这些标头：

![](img/7fdeff02-29d4-4706-8798-5a9a6dcc56e3.png)

Drupal 版本 8+引入了动态缓存标头`X-Drupal-Dynamic-Cache`，不适用于 Drupal 版本 7 或更早版本。

# 通过 CHANGELOG.txt 检测

有时，`CHANGELOG.txt`文件也会公开版本号。该文件可以在这里找到：

```
/CHANGELOG.txt 
/core/CHANGELOG.txt
```

我们可以浏览`/CHANGELOG.txt`或`/core/CHANGELOG.txt`来识别已安装的 Drupal 版本：

![](img/99bfdd0d-92f0-4fe8-a16b-0a58bee864d6.png)

在某些情况下，我们可能找不到`CHANGELOG.txt`文件。在这种情况下，我们可以尝试本节中提到的其他检测技术。

# 通过 install.php 检测

尽管建议在安装后删除`install.php`文件，但开发人员经常将其留在服务器上。它可以用于找到 Drupal 安装的版本号：

![](img/432fa7c9-6292-4c5a-834b-ab42cc1158fc.png)

此方法仅适用于 Drupal 版本 8.x。

这些检测技术只能确定站点是否安装了 Drupal 以及使用的版本。它不会找到 Drupal 中安装的插件、主题和模块。要识别插件、主题和模块，我们需要枚举它们。我们需要枚举插件、主题和模块，因为这些是攻击者可以利用的入口点，以控制 Drupal 站点。作为渗透测试人员，我们需要找到有漏洞的插件、主题和模块（已安装的版本）并报告它们。

# 插件、主题和模块枚举

现在几乎所有在线可用的开源工具都使用了一种非常常见的技术来枚举 Drupal 插件、主题和模块。要进行枚举，我们只需在`themes/`、`plugins/`和`modules/`目录中寻找以下文件：

```
/README.txt 
/LICENSE.txt 
/CHANGELOG.txt
```

`README.txt`文件提供了插件、主题和模块的版本。它甚至还公开了 Drupal 版本号。`LICENSE.txt`文件包括 GNU**通用公共许可证（GPL）**许可证。如果`plugins/`、`themes/`或`modules/`目录中有这个文件，这意味着特定的插件、主题或模块已安装。`CHANGELOG.txt`文件公开了已安装的插件、主题或模块的版本号。

模块名称可以从`README.txt`文件或 URL 本身中找到，如下面的屏幕截图所示：

![](img/f08b6880-a5dc-459e-810f-8966663d79d9.png)

在枚举方面，我们可以编写自己的 Metasploit 包装模块，或者使用第三方开源工具 droopescan。要编写自己的包装器，我们可以按照上一章第八章中所做的进行。我们现在将继续使用 droopescan 进行漏洞扫描。

# 使用 droopescan 进行 Drupal 漏洞扫描

没有 Metasploit 模块可以对 Drupal 进行漏洞扫描。因此，我们需要使用第三方工具，如 droopescan，来帮助我们发现 Drupal 中的漏洞。droopescan 可以从[`github.com/droope/droopescan`](https://github.com/droope/droopescan)下载：

1.  让我们使用以下命令克隆 droopescan 的 Git 存储库进行安装：

```
git clone https://github.com/droope/droopescan
```

以下是先前命令的输出截图：

![](img/11fd5fe7-a373-405b-ac8c-eb972a52afe8.png)

1.  在运行 droopescan 之前，我们仍然需要安装必要的 Python 模块，可以使用以下命令完成：

```
pip install -r requirements.txt
```

1.  在系统上安装了所有软件包后，我们可以通过执行以下命令来测试安装 droopescan：

```
./droopescan
```

1.  如果在执行 droopescan 时出现错误，我们也可以使用以下命令来执行它：

```
python droopescan
```

1.  安装 droopescan 后，我们可以执行以下命令对 Drupal 进行漏洞扫描：

```
./droopescan scan drupal -u <URL>
```

以下是先前命令的输出截图：

![](img/f166934c-7acd-40ff-9eea-7305462df76c.png)

droopescan 是一个基于插件的扫描器，用于识别多个 CMS 中的漏洞，但主要是 Drupal。droopescan 使用预先构建的单词列表，并通过暴力破解来检测模块、主题和插件。因此，这完全取决于我们的单词列表有多好。我们也可以找到其他基于 Drupal 的漏洞扫描器，用于识别 Drupal 中的漏洞。唯一的区别是它们所使用的语言（为了效率）和单词列表。

当我们在 Drupal CMS 中发现漏洞后，我们可以继续寻找它们的公开利用程序。其中最著名的漏洞之一是 Drupalgeddon。在接下来的部分中，我们将介绍 Drupalgeddon2 漏洞，并学习如何利用它。

# 利用 Drupal

在利用 Drupal 时，以下是我们需要牢记的攻击向量：

+   为了进行暴力破解攻击，枚举 Drupal 用户。

+   通过猜测密码利用 Drupal 的破损认证

+   利用插件、主题或模块进行任意文件泄露和上传、持久性**跨站脚本**（**XSS**）等

+   利用 Drupal 核心组件进行 SQL 注入和**远程代码执行**（**RCE**）

对于不同版本的 Drupal，可以使用不同的公开利用程序。有时，我们可以使用公开利用程序访问 Drupal 站点，而其他时候我们必须更改利用程序使其生效。了解利用程序并在后期执行它总是一个好的实践。现在让我们先专注于 Drupalgeddon2 的公开利用程序。

# 利用 Drupal 使用 Drupalgeddon2

2018 年 3 月 28 日，Drupal 发布了一份公告，强调了 Drupal 各个版本中的 RCE 漏洞。后来这个漏洞被重新命名为 Drupalgeddon2。Drupal 6 版本引入了 Form API，用于在表单渲染期间修改数据，在 Drupal 7 中，这被泛化为**可渲染数组**。可渲染数组以键值结构包含元数据，并在渲染过程中使用：

```
[ 
'#type' => 'email', 
'#title => '<em> Email Address</em>', 
'#prefix' => '<div>', 
'#suffix' => '</div>' 
] 
```

现在让我们了解一下基于表单的漏洞。

# 了解 Drupalgeddon 漏洞

Drupalgeddon 漏洞与特定注册表单有关。此表单在所有 Drupal 安装中都可用，并且可以在没有任何身份验证的情况下访问。在此表单中，电子邮件字段允许用户输入未经过处理的输入，这允许攻击者将数组注入到表单数组结构中（作为`email`字段的值）。以下属性可用于利用此漏洞：

+   `#post_render`

+   `#lazy_builder`

+   `#pre_render`

+   `#access_callback`

Metasploit 的利用模块使用`#post_render`属性将有效载荷注入到`mail`数组中，大致如下所示：

```
[ mail[#post_render][]': 'exec', // Function to be used for RCE mail[#type]': 'markup', 'mail[#markup]': 'whoami' // Command ] 
```

在渲染时，将调用`exec()`函数，该函数将执行`whoami`命令并返回输出。现在让我们继续看看这个利用程序的实际操作。

以下代码可以在`/core/lib/Drupal/Core/Render/Renderer.php`中找到：

![](img/be660a7c-1d53-487f-853c-d05648a9997d.png)

`/core/modules/file/src/Element/ManagedFile.php`如下所示：

![](img/a5a0017f-828c-48f1-ac59-72b9ddabcd1b.png)

我们可以看到表单值使用斜杠进行分解，然后使用`NestedArray::getValue()`函数来获取值。根据返回的数据，渲染结果。在这种情况下，`$form["user_picture"]["widget"][0]`变成了`user_picture/widget/0`。我们可以输入我们自己的路径到所需的元素。在帐户注册表单中，有`mail`和`name`参数。`name`参数过滤用户数据，但`email`参数不会。我们可以将此参数转换为数组，并提交以`#`开头的行作为键。

返回到`/core/lib/Drupal/Core/Render/Renderer.php`，我们看到`#post_render`属性将`#children`元素并将其传递给`call_user_func()`函数，如下所示：

![](img/6ce011fc-841b-4398-995c-ef246f48e348.png)

这是来自 PHP 手册的：

![](img/677cb687-a188-4d27-83ef-8ce9b2514175.png)

如果我们传递`call_user_func(system,id)`，它将被执行为`system(id)`。因此，我们需要将`#post_render`定义为`exec()`，并将`#children`定义为我们要传递给`exec()`的值：

```
[ 
mail[#post_render][]': printf, 
mail[#type]': 'markup', 
'mail[#children]': testing123 
] 
```

另一种方法是使用`#markup`元素，该元素由互联网上提供的其他漏洞利用所使用。

# 使用 Metasploit 利用 Drupalgeddon2

还有一个 Metasploit 模块可用于利用 Drupalgeddon2 漏洞，我们可以通过在 msfconsole 中执行以下命令来使用它：

```
use exploit/unix/webapp/drupal_drupalgeddon2
```

现在，执行以下步骤来利用漏洞：

1.  要查看选项，我们运行`show options`，如下所示：

![](img/dd93cd7f-20c2-4ae7-8caa-036106f54951.png)

1.  接下来，设置`rhosts`和`rport`的选项，如下截图所示：

![](img/4a43b16c-906d-41e6-be30-5d7a22b4bf6d.png)

1.  当利用程序运行时，首先通过向`/`发出请求来查找响应标头或元标记中的 Drupal 版本来进行指纹识别，如下所示：

![](img/1140cab0-4235-4607-bb13-fdc91999c4ed.png)

1.  接下来，通过调用`CHANGELOG.txt`并查找`SA-CORE-2018-002`补丁来执行补丁级别检查，如下所示：

![](img/e744cbc6-c914-498d-ae85-65c49566d635.png)

完成前两个步骤后，利用程序通过简单调用`printf`函数来确认 RCE 的存在并打印响应中的值：

![](img/973be9fe-dbff-4f6c-a5c4-efc109b40f0f.png)

在上述截图中，我们使用了`testing123`字符串。如果服务器响应`testing123`，则服务器存在 Drupalgeddon2 漏洞：

![](img/06e70d9a-93fd-4c93-8e8b-4655ae043bdc.png)

使用 PHP 的`passthru()`函数来确认 RCE 以执行`id`、`whoami`和`uname -a`命令：

![](img/5090a9af-6328-4612-9102-01a5a2b2fc59.png)

服务器将响应返回给执行的命令，如下所示：

![](img/1c624e12-a14a-42fd-90d2-ae84db657c13.png)

1.  最后一步是发送 PHP meterpreter 有效载荷，如下所示，将其注入并在内存中执行：

![](img/53499d94-19c2-4618-b0dc-9d398321ebd9.png)

成功执行后，我们将在终端中打开一个 meterpreter 会话：

![](img/7ad41191-f982-420a-8449-4710ee434b3a.png)

现在，让我们看另一个 Drupal 漏洞的例子，并尝试理解它是如何工作的。

# RESTful Web Services 漏洞 - unserialize()

2019 年 2 月，CVE-2019-6340 发布，披露了 Drupal 的 RESTful web 服务模块中的一个漏洞。这个漏洞可以被利用来执行 RCE。只有当 Drupal 安装了所有的 web 服务（**HAL**，**Serialization**，**RESTful Web Services**和**HTTP Basic Authentication**，如下面的截图所示）时，才可能发生 RCE：

![](img/28e062fc-3526-4c96-ac10-737f7e4bee1c.png)

RESTful Web Services 模块使用 REST API 与 Drupal 通信，可以对网站资源执行更新、读取和写入等操作。它依赖于序列化模块对发送到 API 和从 API 接收的数据进行序列化。Drupal 8 核心使用**Hypertext Application Language**（**HAL**）模块，在启用时使用 HAL 对实体进行序列化。我们可以通过使用`GET`方法请求节点并带上`_format=hal_json`参数来检查 Drupal 服务器是否启用了这些 web 服务，如下面的截图所示：

![](img/e721e86a-a4ee-4f2f-85b4-df93db8c2299.png)

如果安装了模块，我们将得到一个基于 JSON 的响应，如下所示：

![](img/1d2ac192-34b1-4eca-bdfb-97413a18184c.png)

如果服务器没有 web 服务模块，我们将收到`406`（`不可接受`）的 HTTP 代码错误：

![](img/1a9fa8b6-f200-4f68-8191-8c3265b97bdb.png)

这个漏洞存在是因为`LinkItem`类接受未经过处理的用户输入，并将其传递给`unserialize()`函数：

![](img/b8d2ce64-296d-4e26-a1f5-3a7b359837e5.png)

从下面的截图中可以看到，根据`unserialize()`函数的 PHP 手册，当使用`unserialize()`时，我们不应该让不受信任的用户输入传递给这个函数：

![](img/e9d74ccb-6fff-40b8-907d-f2654f0b8e97.png)

为了利用这个漏洞，需要满足**三个**条件：

+   应用程序应该有一个我们可以控制的`unserialize()`函数。

+   应用程序必须有一个实现 PHP 魔术方法（`destruct()`或`wakeup()`）的类，执行危险语句。

+   需要有一个序列化的有效负载，使用应用程序中加载的类。

从前面的截图中，我们可以确认我们可以控制`$value['options']`表单实体。为了检查魔术方法，让我们使用以下命令在源代码中搜索`destruct()`函数：

```
ag __destruct | grep guzzlehttp
```

下面的截图显示了前面命令的输出：

![](img/08e86e24-974d-4070-98be-bfe6d28f49aa.png) **注意**：在执行上述命令之前，您必须安装`ag`包。

在上面的截图中，我们排除了`guzzlehttp`，因为 Guzzle 被 Drupal 8 用作 PHP HTTP 客户端和用于构建 RESTful web 服务客户端的框架。

从查看`FnStream.php`文件（参考上面的截图）中，我们可以看到`__destruct()`魔术方法调用了`call_user_func()`函数，如下面的截图所示：

![](img/5387edda-be4c-4204-98f4-5b18a8a9e62a.png)

`call_user_func()`是一个非常危险的函数，特别是当传递多个参数时。我们可以使用这个函数来执行函数注入攻击：

![](img/d881b08a-7212-47d7-b563-931509ee6ddb.png)

根据 OWASP 的说法，函数注入攻击包括将客户端的函数名称插入或**注入**到应用程序中。成功的函数注入利用可以执行任何内置或用户定义的函数。函数注入攻击是一种注入攻击类型，其中任意函数名称，有时带有参数，被注入到应用程序中并执行。如果参数被传递到注入的函数，这将导致 RCE。

根据 Drupal API 文档，`LinkItem` 类用于实现 `link` 字段类型：

![](img/13a4dcde-1e0f-4148-a7ad-be1fc1c8d976.png)

我们知道 `LinkItem` 类将未经过处理的用户输入传递给 `unserialize()` 函数，但要调用此类，我们需要首先调用一个实体。实体将是特定实体类型的一个实例，例如评论、分类术语或用户配置文件，或者是一组实例，例如博客文章、文章或产品。我们需要找到一个被 `LinkItem` 用于导航的实体。让我们使用以下命令在源代码中搜索实体：

```
ag LinkItem | grep Entity
```

以下屏幕截图显示了前述命令的输出：

![](img/7bccca3c-e951-4a7d-bb8f-50780360ece6.png)

从前面的屏幕截图中可以看到，`LinkItem` 用于导航到 `MenuLinkContent.php` 和 `Shortcut.php` 实体，并且从 `Shortcut.php` 文件中可以看到，快捷方式实体正在创建一个 `link` 属性：

![](img/90eb533f-940f-4f5d-8317-2f814f4095d0.png)

要触发 `unserialize()` 函数，我们需要将我们迄今为止解释的所有元素对齐在一起：

```
{ "link": [ { "value": "link", "options": "<SERIALIZED_PAYLOAD>" } ], "_links": { "type": { "href": "localhost/rest/type/shortcut/default" } } } 
```

现在我们已经满足了三个条件中的两个，唯一剩下的就是创建我们的序列化有效负载。有各种方法可以创建序列化有效负载，但我们将使用一个名为**PHP 通用小工具链**（**PHPGGC**）的库来为 Guzzle 创建一个序列化有效负载。要使用 `phpggc` 生成序列化有效负载，我们使用以下命令：

```
./phpggc <gadget chain> <function> <command> --json
```

以下屏幕截图显示了前述命令的输出：

![](img/f1b16264-0f54-4cdb-8b9c-e8acf296f33b.png)

在前述屏幕截图中生成的 JSON 序列化有效负载将调用 `system()` 函数并运行 `id` 命令。我们将以以下 URL 格式使用 `GET/POST/PUT` 方法提交整个有效负载：`localhost/node/1?_format=hal_json`

服务器将执行 `id` 命令并返回我们在此处显示的输出：

![](img/e99611e3-3515-4e8a-87c2-7e3d72f64152.png)

我们已成功实现了 RCE，但问题仍然存在：为什么序列化有效负载有效？要回答这个问题，我们需要了解一般序列化数据的外观，并了解序列化格式。

# 理解序列化

为了基本了解 `serialize()` 函数，让我们看一下以下 PHP 代码片段：

![](img/6bc0db63-b4d7-453f-b13a-f8437195ddf1.png)

在前面的代码中，我们初始化了一个名为 `my_array` 的数组，其中包含以下元素：

+   `my_array[0] = "Harpreet"`

+   `my_array[1] = "Himanshu"`

然后我们使用 `serialize()` 函数为数组生成序列化数据。如下屏幕截图所示，序列化数据流如下：

![](img/6f514979-d1e7-4650-a6e2-feae11be981f.png)

其他常用的 PHP 序列化格式包括：

+   `a`：数组

+   `b`：布尔值

+   `i`：整数

+   `d`：双精度

+   `O`: 通用对象

+   `r`：对象引用

+   `s`：字符串

+   `C`：自定义对象

Metasploit 还针对此漏洞内置了一个利用程序。查看利用程序的源代码，我们注意到它使用的有效负载几乎与 PHPGCC 生成的有效负载相同：

![](img/5dfc91eb-4d83-46d3-b7fb-145af8c686a3.png)

唯一的区别是命令及其长度根据我们通过利用选项给出的输入动态设置。

正如我们在下面的截图中所看到的（在这里我们调用`__destruct()`函数），要在`call_user_func()`中执行函数注入，我们必须控制`_fn_close`方法，以便危险函数（如`system()`、`passthru()`和`eval()`）可以轻松地作为第一个参数传递给`call_user_func()`：

![](img/ea3ce84e-d2e6-4f59-831b-6b207d8dc051.png)

要控制`_fn_close`方法，我们必须查看构造函数（`__construct()`）：

![](img/dccd4d87-9547-458a-8991-9e695d07cffa.png)

从上面的截图中可以看出，`$methods`数组作为参数传递给构造函数。`__construct()`函数将通过循环遍历`$methods`数组来创建函数，然后在`_fn_`字符串之前添加。如果`$methods`数组中有一个`close`字符串，该字符串将被添加上`_fn_`，从而形成`_fn_close`方法。现在，让我们看看`$methods`数组中的元素：

![](img/c0298697-61c6-426b-b948-32420e3352f7.png)

从上面的截图中可以清楚地看到`$methods`数组中有一个值为`close`的元素。现在我们知道如何控制`_fn_close`方法，接下来，我们必须找到一种方法将危险函数和要执行的命令传递给`_fn_close`。为此，我们必须创建一个**POP 链**。

# 什么是 POP 链？

在内存损坏漏洞（如缓冲区溢出和格式字符串）中，如果存在内存防御措施，如**数据执行防护**（**DEP**）和**地址空间布局随机化**（**ASLR**），则可以使用代码重用技术，如**返回到 libc**（**ret2libc**）和**返回导向编程**（**ROP**）来绕过这些防御措施。代码重用技术在基于 PHP 的 Web 应用程序的情况下也是可行的，这些应用程序使用对象的概念。可以利用对象属性进行利用的一种代码重用技术是**基于属性的编程（POP）**。

POP 链是一种利用 Web 应用程序中对象注入漏洞的利用方法，利用能够任意修改被注入到给定 Web 应用程序中的对象的属性的能力。然后可以相应地操纵受害应用程序的数据和控制流。

创建一个 POP 链，序列化的负载使用`GuzzleHttp`的`HandlerStack`类：

![](img/b863d5af-a05a-4373-9aee-26ab0e7d1bfc.png)

我们将我们的命令传递给`handler`方法，将危险函数传递给`stack[]`方法，如下图所示：

![](img/d2cd4c36-ebe9-4e5b-a78d-75dfe3b18823.png)

一旦析构函数被调用（在对象销毁时会自动调用），`_fn_close`方法的属性将被传递给`call_user_func()`，并执行`system(id)`：

![](img/130a43e7-9a43-42bf-8dcd-d80855746173.png)

接下来，我们将反序列化负载。

# 反序列化负载

为了更清楚地理解负载，我们可以对其进行反序列化并使用`var_dump`。根据 PHP 手册，`var_dump`显示关于一个或多个表达式的结构化信息（包括类型和值）。`var_dump`会递归地探索数组和对象，并缩进显示结构。我们也可以使用`print_r()`函数执行相同的操作：

![](img/1e4e11bb-a571-4201-ad87-ca29d6df17ec.png)

由于我们使用基于`GuzzleHttp`客户端的负载，我们需要安装 Guzzle。我们可以使用以下 PHP 代码对其进行反序列化：

```
<?php
require __DIR__ . '/vendor/autoload.php';
$obj= unserialize(json_decode(file_get_contents("./payload.txt")));
var_dump($obj);
?>
```

运行代码将给我们以下输出：

```
object(GuzzleHttp\Psr7\FnStream)#3 (2) {["methods":"GuzzleHttp\Psr7\FnStream":private]=>array(1) {["close"]=>array(2) {[0]=>object(GuzzleHttp\HandlerStack)#2 (3) {["handler":"GuzzleHttp\HandlerStack" :private]=>string(1) "id"["stack":"GuzzleHttp\HandlerStack":private]=>array(1) {[0]=>array(1) {[0]=>string(4) "system"}}["cached":"GuzzleHttp\HandlerStack" :private]=>bool(false)}[1]=>string(7) "resolve"}}["_fn_close"]=>array(2) {[0]=>object(GuzzleHttp\HandlerStack)#2 (3) {["handler":"GuzzleHttp\HandlerStack" :private]=>string(1) "id"["stack":"GuzzleHttp\HandlerStack":private]=>array(1) {[0]=>array(1) {[0]=>string(4) "system"}}["cached":"GuzzleHttp\HandlerStack" :private]=>bool(false)}[1]=>string(7) "resolve"}
```

当执行时，会导致`system()`函数执行传递给该函数的命令，并将输出返回给我们。

# 通过 Metasploit 使用 unserialize()利用 RESTful Web Services RCE

现在我们了解了序列化的概念以及如何对有效载荷进行序列化，让我们使用 Metasploit 的`exploit`模块来利用这个漏洞。执行以下命令来使用`exploit`模块：

```
use exploit/unix/webapp/drupal_restws_unserialize
```

以下截图显示了前述命令的输出：

![](img/53af4093-02c2-4f7e-a999-34476b2a707d.png)

然后我们设置选项并运行利用。运行 Metasploit 模块后，我们会观察到它首先通过询问`CHANGELOG.txt`来查找**SA-CORE-2019-003**补丁来执行补丁级别检查。执行`id`命令以确认 Drupal 安装上的 RCE，如下所示：

![](img/a8a4bfbc-a4ce-4363-8680-084c41f9b7b3.png)

成功利用后，服务器将返回`id`命令的输出，如下所示：

![](img/1623bd94-efad-4951-90f7-103f4d0f8ddd.png)

然后，PHP meterpreter 代码被序列化并发送到服务器，一个 meterpreter 会话在我们的 Metasploit 中打开，如下所示：

![](img/2339fefb-69b9-4c2e-9ab8-47141bf4dcce.png)

我们通过利用 RESTful Web Services 模块获得了对 Drupal 服务器的访问。

# 摘要

我们从讨论 Drupal 的架构和目录结构开始了本章。然后，我们学习了如何手动和自动执行 Drupal 的侦察。之后，我们看了两个利用的例子，并逐步介绍了整个利用过程。

在下一章中，我们将看一下对 JBoss 服务器的枚举和利用。

# 问题

1.  相同的漏洞可以用来利用不同版本的 Drupal 吗？

1.  我们需要在本地安装 Drupal 来利用远程 Drupal 网站吗？

1.  RESTful API Web Services 利用不起作用-我们能做些什么？

1.  我们可以访问 Drupal 管理员帐户-我们如何在服务器上实现 RCE？

1.  我们在 Drupal 网站上发现了一个`.swp`文件-这可以用于利用吗？

# 进一步阅读

+   Drupal 8 的架构：[`www.drupal.org/docs/8/modules/entity-browser/architecture`](https://www.drupal.org/docs/8/modules/entity-browser/architecture)

+   Drupal 8 RCE 的深入研究：[`www.ambionics.io/blog/drupal8-rce`](https://www.ambionics.io/blog/drupal8-rce)
