# 第十五章：渗透测试 CloudTrail

AWS CloudTrail 被描述为一项 AWS 服务，可帮助您启用 AWS 账户的治理、合规性、运营和风险审计（[`docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html`](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html)），基本上被宣传为 AWS 账户中 API 活动的中央日志来源。CloudTrail 在某种意义上是一项始终开启的服务，因为它会将读/写 API 操作记录到最近 90 天的日志的不可变存档中，称为 CloudTrail 事件历史。我们将在本章的*侦察*部分更深入地了解事件历史。

在本章中，我们将研究 CloudTrail 及其为勤勉的 AWS 用户提供的功能。我们还将从渗透测试人员的角度来看待它，涵盖如何审计目标账户中的 CloudTrail 最佳实践，以及如何通过 CloudTrail 对环境进行侦察，如何绕过 CloudTrail 服务以避开监视，以及如何破坏已经存在的任何日志记录机制。这些主题对我们的客户很有益，因为它们可以帮助他们了解环境中的盲点；然而，它们也可以帮助我们发现更多关于攻击目标的信息，而不一定需要直接对他们使用的每个服务进行 API 调用。

在本章中，我们将涵盖以下主题：

+   设置、最佳实践和审计

+   侦察

+   绕过日志记录

+   破坏跟踪

# 关于 CloudTrail 的更多信息

尽管 CloudTrail 旨在成为 AWS 账户的中央日志来源，但它的构建方式使一些不良风险暴露在新的 AWS 服务开发中。AWS 的团队正在创建一个新服务，必须创建与他们的服务集成的 CloudTrail，以允许其 API 调用记录到 CloudTrail。此外，由于 AWS 推出新服务和功能的速度很快，有许多服务发布时没有任何对 CloudTrail 的支持。可以在这里找到该列表：[`docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html`](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html)。在本章后面，我们将深入探讨滥用不受支持的服务对我们作为攻击者的优势，因为任何不记录到 CloudTrail 的 API 调用对我们作为攻击者来说都是有利的。

CloudTrail 并不是 AWS 账户中日志记录的唯一选项。它汇总了大多数 AWS 服务的日志，但一些服务也提供了它们自己特定类型的日志记录。这些类型的日志包括 S3 存储桶访问日志、弹性负载均衡器访问日志、CloudWatch 日志、VPC 流量日志等。这些其他类型的日志存在是因为它们不像 CloudTrail 那样记录 API 活动，而是记录其他类型的活动，这些活动可能会有用。

在开始 CloudTrail 渗透测试之前，我们将看看如何设置它。

# 设置、最佳实践和审计

在这一部分，我们将介绍如何设置一个新的 CloudTrail 跟踪，遵循所有推荐的最有效/安全设置的最佳实践。我们将展示使用 AWS Web 控制台的设置步骤，但我们所做的一切也可以通过 AWS CLI 实现，我们将通过 CLI 审计 CloudTrail。

# 设置

让我们开始设置 CloudTrail，按照以下步骤进行：

1.  我们要做的第一件事是导航到 AWS Web 控制台中的 CloudTrail 服务，并在主页面上单击“创建跟踪”按钮：

![](img/53723408-3f16-4c43-8543-57f5ba0b8904.png)

图 1：在 CloudTrail 服务页面上找到“创建跟踪”按钮的位置

1.  我们将命名我们的跟踪为`ExampleTrail`，然后页面上呈现给我们的下一个选项是我们将要查看的第一个最佳实践。该选项询问我们是否想要将此跟踪应用于所有区域，最佳实践建议我们选择是，将我的跟踪应用于所有区域。这是因为 CloudTrail 可以基于每个区域运行，所以理论上您需要为每个现有的区域创建一个跟踪。有了这个选项，我们可以创建一个单一的跟踪，监视每个区域的 API 活动，因此我们将始终了解我们的环境，无论活动发生在哪里。

1.  接下来是“管理事件”部分，我们将选择“全部”。在 AWS 中有两种类型的事件：管理事件和数据事件，其中管理事件基本上是在与 AWS 交互时使用的高级 API，而数据事件可以被视为与 AWS 账户内资源进行交互。数据事件的一个示例是`s3:GetObject`事件，这将是有人访问 S3 中的对象。我们希望确保所有 API 活动都被记录下来，因此应该选择“全部”来记录管理事件。

1.  之后，我们现在处于“数据事件”部分。记录数据事件会增加一些成本，因此记录所有读取和写入数据活动可能并不总是正确的决定。此外，如果您只使用单个帐户进行跟踪，并使用一个 S3 存储桶来存储日志，那么通过记录所有 S3 数据事件，实质上您将记录 CloudTrail 正在将日志写入其日志存储桶。因此，出于这个原因，我们将在数据事件下添加一个单独的 S3 存储桶，这将是我们在上一章中创建的`bucket-for-lambda-pentesting`。在数据事件部分的 Lambda 选项卡下，我们将启用“记录所有当前和未来的调用”，以便我们可以监视所有 Lambda 函数的调用活动：

![](img/001dfc21-54b9-4d46-b5a0-2216456f278a.png)

图 2：我们新跟踪的当前配置

1.  在存储位置部分，我们将选择“是”以创建一个新的 S3 存储桶，因为我们还没有设置存储日志的存储桶。我们将把它命名为`example-for-cloudtrail-logs`，然后我们将点击“高级”链接，以展开更多我们想要启用的选项。

1.  日志文件前缀可以填写或留空，因为这只是为了将一些内容添加到 CloudTrail 日志的路径中，以便更容易识别/分离，如果您有多种类型的日志写入到单个存储桶中。

1.  我们将选择“是”以使用 SSE-KMS 加密日志文件。

1.  我们还没有设置 KMS 密钥，因此我们也将选择“是”或“创建新的 KMS 密钥”，并将其命名为`CloudTrail-Encryption-Key`。这将确保我们所有的 CloudTrail 日志文件在存储在 S3 中时都被加密，如果需要，它还为我们提供了管理权限的能力，以确定谁可以/不能解密这些日志文件，以获得更精细的权限模型：

![](img/32503746-96cb-40e5-83bc-047e3629c393.png)

图 3：我们新跟踪的其余配置

1.  接下来，我们将选择“是”以启用日志文件验证，这告诉 CloudTrail 在日志旁边也写入摘要文件到 S3 存储桶中，然后可以用来确定自 CloudTrail 将其交付到 S3 存储桶以来，我们的日志文件是否被篡改。这对于确保我们在账户中有一个可信赖的、完整的 API 活动记录非常重要。

1.  对于最后一个选项“为每个日志文件交付发送 SNS 通知”，我们暂时选择“否”。CloudTrail 日志经常被写入，这可能会导致发送许多 SNS 通知，因此如果您对这些通知感兴趣，最好采取一种策略性的方法来解决这个问题。

1.  现在我们可以完成并点击右下角的“创建”来创建我们的新跟踪。

现在迹象将被创建和启用，此时它将立即开始发送日志文件和摘要到您的 S3 存储桶，以便读取、验证、导出等。

出于组织原因，您可能需要创建多个迹象，例如一个记录管理事件，一个记录数据事件。通常建议将这些日志发送到另一个账户，因为这样它们将与账户分开，在发生妥协时它们可能会更安全。

# 审计

现在我们已经完成了设置新的 CloudTrail 迹象的过程，我们可以离开 AWS Web 控制台，转到 AWS CLI，我们将现在介绍如何审计 CloudTrail 以确保遵循所有最佳实践。

首先，我们将要查看目标账户中是否有任何活动的迹象。我们可以使用 CloudTrail 的`DescribeTrails` API 来实现这一点，该 API 允许我们查看所有 AWS 区域中的迹象，即使它们是由账户的组织管理的。命令将看起来像这样：

```
 aws cloudtrail describe-trails --include-shadow-trails 
```

`--include-shadow-trails`标志允许我们查看其他区域/我们组织的迹象。不会显示的唯一迹象是针对命令运行的区域之外的特定区域迹象，因此可能存在一些 CloudTrail 日志记录，您只需要找到它。这仍然是一个不好的设置，因为这些日志没有扩展到每个区域。该命令的输出将给我们大部分我们感兴趣的信息。

我们希望确保 CloudTrail 日志记录扩展到所有区域，我们可以通过查看我们正在查看的特定迹象的`IsMultiRegionalTrail`键来确定。它应该设置为 true。如果没有，那么这是需要纠正的事情。一个多区域迹象比每个区域一个迹象更有意义，原因有很多，尤其是因为随着新的 AWS 区域的发布，您需要为它们创建迹象，而多区域迹象将在添加它们时自动覆盖它们。

然后我们要确保`IncludeGlobalServiceEvents`设置为`true`，因为这样可以使迹象记录非特定区域的 AWS 服务的 API 活动，例如全局的 IAM。如果禁用了这个设置，我们将错过很多重要的活动。之后，我们要确保`LogFileValidationEnabled`设置为`true`，以便可以检测和验证日志的删除和修改。然后我们将寻找`KmsKeyId`键，如果存在，将是用于加密日志文件的 KMS 密钥的 ARN，如果不存在，则意味着日志文件没有使用 SSE-KMS 进行加密。如果尚未存在，这是另一个应该添加的设置。

如果我们想确定数据事件是否已启用，我们可以首先通过查看`HasCustomEventSelectors`键来确认它是否设置为`true`。如果是`true`，我们将想要调用在创建迹象的区域中调用`GetEventSelectors` API 来查看已指定了什么。我们创建的`ExampleTrail`是在`us-east-1`区域创建的，因此我们将运行以下命令来查看事件选择器：

```
aws cloudtrail get-event-selectors --trail-name ExampleTrail --region us-east-1 
```

该 API 调用返回了以下数据：

```
{
    "TrailARN": "arn:aws:cloudtrail:us-east-1:000000000000:trail/ExampleTrail",
    "EventSelectors": [
        {
            "ReadWriteType": "All",
            "IncludeManagementEvents": true,
            "DataResources": [
                {
                    "Type": "AWS::S3::Object",
                    "Values": [
                        "arn:aws:s3:::bucket-for-lambda-pentesting/"
                    ]
                },
                {
                    "Type": "AWS::Lambda::Function",
                    "Values": [
                        "arn:aws:lambda"
                    ]
                }
            ]
        }
    ]
}
```

不同事件选择器的值告诉我们这条迹象记录了哪些类型的事件。我们可以看到`ReadWriteType`设置为`All`，这意味着我们记录了读和写事件，而不仅仅是其中的一个。我们还可以看到`IncludeManagementEvents`设置为`true`，这意味着迹象正在记录我们想要的管理事件。在`DataResources`下，我们可以看到 S3 对象日志记录已启用，ARN 为`arn:aws:s3:::bucket-for-lambda-pentesting/`，但没有其他的，并且 Lambda 函数调用日志已启用，ARN 中包含`arn:aws:lambda`的函数，这意味着所有 Lambda 函数。

理想情况下，读写事件应该被记录，管理事件应该被记录，所有 S3 存储桶/ Lambda 函数应该被记录，但这可能并不总是可能的。

现在我们已经检查了跟踪的配置，我们需要确保它已启用并记录日志！我们可以使用与跟踪创建在同一区域的`GetTrailStatus` API 来实现这一点：

```
aws cloudtrail get-trail-status --name ExampleTrail --region us-east-1 
```

它将返回以下类似的输出：

```
{
    "IsLogging": true,
    "LatestDeliveryTime": 1546030831.039,
    "StartLoggingTime": 1546027671.808,
    "LatestDigestDeliveryTime": 1546030996.935,
    "LatestDeliveryAttemptTime": "2018-12-28T21:00:31Z",
    "LatestNotificationAttemptTime": "",
    "LatestNotificationAttemptSucceeded": "",
    "LatestDeliveryAttemptSucceeded": "2018-12-28T21:00:31Z",
    "TimeLoggingStarted": "2018-12-28T20:07:51Z",
    "TimeLoggingStopped": ""
}
```

最重要的事情是查看`IsLogging`键是否设置为`true`。如果设置为`false`，那么意味着该跟踪已被禁用，我们刚刚检查的所有配置都无关紧要，因为它实际上并没有记录任何内容。

此外，我们可以查看`LatestDeliveryAttemptTime`和`LatestDeliveryAttemptSucceeded`键，以确保日志被正确传送。如果日志被传送，那么这两个值应该是相同的。如果不是，那么就有一些问题阻止了 CloudTrail 将这些日志传送到 S3。

这基本上总结了 CloudTrail 设置和最佳实践的基础知识，但是通过为跟踪使用 KMS 加密密钥创建自定义策略，并修改 S3 存储桶策略以进一步限制对日志的访问、防止日志被删除等，可以更深入和安全地进行设置。

# 侦察

现在我们将转变方向，讨论 CloudTrail 如何帮助我们作为攻击者。它可以帮助我们进行侦察和信息收集。

您可能无法总是妥协于具有必要的 S3 读取权限并具有使用最初使用的 KMS 密钥加密数据的访问权限的用户。如果您没有这两个权限，那么您将无法读取日志文件。甚至可能存在其他限制，使您难以做到这一点。为了解决这个问题，我们可以使用我们的`cloudtrail:LookupEvents`权限与 CloudTrail 事件历史记录进行交互。CloudTrail 事件历史记录是通过 CloudTrail API 提供的一个始终可用的、不可变的读/写管理事件记录。这些日志可以通过使用`LookupEvents` API 或访问 AWS Web 控制台中的事件历史记录页面来获取：

![](img/f1fc9b2c-1d15-4ec4-bf04-9374ebd25f70.png)

图 4：在 AWS Web 控制台中查找 CloudTrail 事件历史记录的位置

由于 CloudTrail 事件历史记录是不可变的，并且与 S3 分开，因此它对于防御者和攻击者都是一个有用的工具。作为防御者，如果发生了什么事情，您的 CloudTrail 日志被修改或删除，您可以恢复它们，CloudTrail 事件历史记录可能是一个有用的地方，以找出在那段时间内发生了什么（如果是在过去 90 天内）。作为攻击者，我们可以使用它来收集有关目标环境的信息，而无需访问 S3 或 KMS。

由于事件历史记录中存储的日志数量以及下载这些日志所需的极其缓慢的 API 调用，要在没有某种过滤器的情况下审查大量信息可能会很困难。由于这可能归因于您应该使用真实的跟踪而不仅仅是事件历史记录，CloudTrail `LookupEvents` API 一次只返回 50 个事件，并且速率限制为每秒一次。在大型环境中，这意味着即使只是过去一天的所有日志，下载所有日志可能需要大量时间。这给我们留下了两个选择：一个是等待下载并尽可能多地获取，但由于可能涉及的大量时间，这并不推荐。第二个选择是在下载之前检查和过滤日志，这样就会减少等待的日志数量。

通过查看事件历史中的不同事件，我们可以收集大量信息。在大规模上，我们可以确定哪些用户/服务是活跃的，以及他们进行了什么样的活动，我们可以了解他们在 AWS 中的习惯。这对我们有帮助，因为我们可以在攻击中使用这些知识。这样，我们可以通过不做任何可能在账户中不寻常的事情来保持低调。通过 AWS Web 控制台，我们已经选择了在本章前面设置 trail 时生成的 CloudTrail `CreateTrail`事件。Web 控制台将信息聚合成一个易于查看的格式，但我们可以点击“查看事件”按钮来查看请求的原始 JSON。该 JSON 看起来像下面这样：

```
{
    "eventVersion": "1.06",
    "userIdentity": {
        "type": "IAMUser",
        "principalId": "AIDARACQ1TW2RMLLAQFTX",
        "arn": "arn:aws:iam::000000000000:user/TestUser",
        "accountId": "000000000000",
        "accessKeyId": "ASIAQA94XB3P0PRUSFZ2",
        "userName": "TestUser",
        "sessionContext": {
            "attributes": {
                "creationDate": "2018-12-28T18:49:59Z",
                "mfaAuthenticated": "true"
            }
        },
        "invokedBy": "signin.amazonaws.com"
    },
    "eventTime": "2018-12-28T20:07:51Z",
    "eventSource": "cloudtrail.amazonaws.com",
    "eventName": "CreateTrail",
    "awsRegion": "us-east-1",
    "sourceIPAddress": "1.1.1.1",
    "userAgent": "signin.amazonaws.com",
    "requestParameters": {
        "name": "ExampleTrail",
        "s3BucketName": "example-for-cloudtrail-logs",
        "s3KeyPrefix": "",
        "includeGlobalServiceEvents": true,
        "isMultiRegionTrail": true,
        "enableLogFileValidation": true,
        "kmsKeyId": "arn:aws:kms:us-east-1:000000000000:key/4a9238p0-r4j7-103i-44hv-l457396t3s9t",
        "isOrganizationTrail": false
    },
    "responseElements": {
        "name": "ExampleTrail",
        "s3BucketName": "example-for-cloudtrail-logs",
        "s3KeyPrefix": "",
        "includeGlobalServiceEvents": true,
        "isMultiRegionTrail": true,
        "trailARN": "arn:aws:cloudtrail:us-east-1:000000000000:trail/ExampleTrail",
        "logFileValidationEnabled": true,
        "kmsKeyId": "arn:aws:kms:us-east-1:000000000000:key/4a9238p0-r4j7-103i-44hv-l457396t3s9t",
        "isOrganizationTrail": false
    },
    "requestID": "a27t225a-4598-0031-3829-e5h130432279",
    "eventID": "173ii438-1g59-2815-ei8j-w24091jk3p88",
    "readOnly": false,
    "eventType": "AwsApiCall",
    "managementEvent": true,
    "recipientAccountId": "000000000000"
}
```

甚至仅从这一个事件中，我们就可以收集到关于用户和环境的大量信息。我们可以看到的第一件事是，这个 API 调用是由一个 IAM 用户进行的，还有用户 ID、ARN、账户 ID、使用的访问密钥 ID、用户名以及他们是否进行了 MFA 身份验证的列表。此外，`invokedBy`键的值为`signin.amazonaws.com`，这告诉我们他们在执行此操作时已经登录到 AWS Web 控制台，而不是使用 CLI。然后我们可以看到有关请求本身的信息，包括事件是什么，该事件是为哪个服务发生的，事件发生的时间，以及请求中包含的一些参数。之后，我们可以看到 API 在响应中返回的参数，这些参数告诉我们一些关于新创建的 CloudTrail trail 的信息。

我们忽略的两个最重要的事情包括请求的来源 IP 地址和请求使用的用户代理。IP 地址将告诉我们呼叫来自何处，并且在更大的样本集中可能允许我们确定用户的工作地点，办公室的 IP 地址等。例如，如果我们看到多个用户在工作时间（上午 9 点至下午 5 点）从同一个 IP 地址发起，那么可以安全地假设他们都在办公室或者在使用 AWS API 时都在 VPN 上。然后我们知道，如果其中一个用户开始从我们以前没有见过的外部 IP 地址发起请求，那将是奇怪的，因此我们可以围绕这一点制定我们的攻击计划，试图避免这种情况。

用户代理也是一样的。在前面的示例事件中，用户代理是`signin.amazonaws.com`，这是在使用 AWS Web 控制台时出现的用户代理。如果我们看一个不同的事件，比如当我们使用 AWS CLI 中的`GetEventSelectors` API 时，我们可以看到用户代理更加具体：

```
{
    "eventVersion": "1.06",
    "userIdentity": {
        "type": "IAMUser",
        "principalId": "AIDARACQ1TW2RMLLAQFTX",
        "arn": "arn:aws:iam::000000000000:user/TestUser",
        "accountId": "000000000000",
        "accessKeyId": "AKIAFGVRRHYEFLLDHVVEA",
        "userName": "TestUser"
    },
    "eventTime": "2018-12-28T20:57:17Z",
    "eventSource": "cloudtrail.amazonaws.com",
    "eventName": "GetEventSelectors",
    "awsRegion": "us-east-1",
    "sourceIPAddress": "1.1.1.1",
    "userAgent": "aws-cli/1.16.81 Python/3.7.0 Windows/10 botocore/1.12.71",
    "requestParameters": {
        "trailName": "ExampleTrail"
    },
    "responseElements": null,
    "requestID": "f391ba17-519x-423r-8b1t-16488a26b02p",
    "eventID": "562b2177-1ra0-2561-fjm0-3f1app6ac375",
    "readOnly": true,
    "eventType": "AwsApiCall",
    "managementEvent": true,
    "recipientAccountId": "000000000000"
}
```

这个请求的用户代理设置为`aws-cli/1.16.81 Python/3.7.0 Windows/10 botocore/1.12.71`，这为我们提供了关于用户使用的系统的大量信息。我们可以看到他们使用了 AWS CLI 的 1.16.81 版本，使用的是 Python 3.7.0 版本，在 Windows 10 上，并且使用了 botocore 库的 1.12.71 版本。这些信息本身就让我们了解到可能在我们目标公司使用的系统，同时也让我们能够收集环境中已知用户代理的列表。有了这个列表，我们可以伪装自己的用户代理，使其看起来像一个已知的用户代理，这样我们在 API 请求中就不会显得异常。

通过查看 CloudTrail 日志/事件历史，您可以做很多事情，包括我们之前进行的少量信息收集。您还可以根据对这些服务的 API 调用来确定账户中正在使用的 AWS 服务，并且可能发现有关账户中特定资源的有用信息。例如，假设您没有`ec2:DescribeInstances`权限，但您有`ec2:ModifyInstance`权限。理论上，您将无法获取 EC2 实例的列表，然后使用`ec2:ModifyInstance`API，因为您没有访问权限，但您可以查看 CloudTrail 日志，查找过去有人与 EC2 实例交互的事件。该事件可能包括实例 ID 和可能对您在发现环境中的资产有帮助的其他信息。

事件历史并不是查找这些信息的唯一地方，因为如果您具有必要的 S3 和 KMS 权限，您可以直接从它们交付的 S3 存储桶中下载日志，这比事件历史 API 的输出更快、更容易解析。但要小心不要触发任何警报，因为该存储桶内的活动可能正在被监视，从中下载文件的一系列请求可能会对防御者看起来可疑。

# 绕过日志记录

现在我们将绕过 CloudTrail 来发现您已经获得访问权限的账户的信息。第一种方法使用 CloudTrail 不支持的服务来收集基本账户信息，第二种方法使用其中一些信息来枚举账户中的 IAM 资源，而不会在目标账户中生成 CloudTrail 日志。

# 攻击者和防御者的不受支持的 CloudTrail 服务

正如我们在本章前面提到的，CloudTrail 并不记录所有内容，包括许多完全不受支持的服务。同样，不受支持服务的列表可以在这里找到：[`docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html`](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html)。这意味着我们对这些服务的 API 调用将不会被 CloudTrail 记录在任何地方（包括事件历史！）。其中一些服务对我们作为攻击者可能非常有利，因此如果您攻破了某个用户并发现他们可以访问其中任何服务，那么值得检查，因为您可以保持低调并获得巨大利益。另一个关于不受支持的 CloudTrail 服务的重要一点是，这意味着您无法为这些 API 操作创建 CloudWatch 事件规则，这意味着您无法立即响应这些服务中发生的事件。

作为攻击者，如果我们正在寻找计算资源，我们可以滥用一些不同的未记录服务。在撰写本文时，AppStream 2.0、Amplify 和 Cloud9 都以某种方式为我们提供了对托管的 EC2 服务器的访问权限。这意味着我们可以启动服务器并与其交互，而不会被记录。

作为防御者，重要的是确保除非必要，否则没有用户可以访问这些服务。如果需要提供对任何未记录服务的访问权限，那么利用服务可能提供的任何内置日志，并利用 IAM 提供的其他一些功能来监视此访问。如果您下载 IAM 凭证报告，您可以通过查看`access_key_1_last_used_service`和`access_key_2_last_used_service`列来查看服务最近是否被访问，那些未记录的服务仍然会显示出来。要获取 IAM 凭证报告，您可以运行以下命令：

```
aws iam get-credential-report 
```

另一个选择是使用 IAM 的`GenerateServiceLastAccessedDetails`和`GetServiceLastAccessDetails`API 来确定用户何时/是否访问了某个服务，包括 CloudTrail 未记录的服务。为此，我们可以首先运行生成命令来生成报告：

```
aws iam generate-service-last-accessed-details --arn arn:aws:iam::000000000000:user/TestUser 
```

ARN 参数的值必须是 IAM 资源的 ARN，包括用户、组、角色和托管策略。这个 API 命令应该会返回一个`JobId`给你。然后我们可以使用那个 ID 来获取报告：

```
aws iam get-service-last-accessed-details --job-id frt7ll81-9002-4371-0829-35t1927k30w2 
```

该命令的响应将包括有关资源是否已经对某个服务进行了身份验证以及上次身份验证发生的时间的信息。这些 API 不会告诉你正在进行的确切活动，但至少可以检查谁正在尝试访问这些服务。

这些 API 还有助于检测未记录的 CloudTrail 服务用于账户枚举。Wired 公司发布了一篇关于 Rhino Security Labs 研究的文章，该研究涉及一种方法，基本上允许攻击者使用密钥收集少量 AWS 账户信息，而不会被 CloudTrail 记录（https://www.wired.com/story/aws-honeytoken-hackers-avoid/）。这项研究之所以如此重要，是因为有许多金丝雀令牌服务依赖于 CloudTrail，在密钥被泄露时发出警报。金丝雀令牌通常放置在环境中的某个地方，并设置为在使用时触发警报，这将表明攻击者在环境中并找到了这些令牌。对于 AWS，金丝雀令牌提供商通常依赖于 CloudTrail 来发出这些警报，但 Rhino Security Labs 表明可以绕过这些警报，并确定 AWS 密钥是否为金丝雀令牌，同时保持低调。

当时发现，一些最受欢迎的 AWS 金丝雀令牌提供商使用单个账户生成这些密钥，或者在指示它们正在被用作金丝雀令牌的用户中包含识别信息。这些信息可以通过从不受支持的 CloudTrail 服务返回的冗长错误消息中暴露出来，从而允许攻击者根据账户 ID 或用户名/路径来识别 AWS 密钥是否为金丝雀令牌，而不会触发密钥本来应该触发的警报。Atlassian 的`SpaceCrab`项目就是这种攻击的一个受害者。

最初，默认的`SpaceCrab`设置将 IAM 用户的路径设置为`/SpaceCrab/`。然后，攻击者可以针对不受支持的 CloudTrail 服务运行 AWS CLI 命令，用户的 ARN 将在错误消息中被披露。ARN 包括用户的路径，因此很明显这些密钥是由`SpaceCrab`创建的金丝雀令牌。以下是在运行 AppStream `DescribeFleets`命令时返回的示例错误消息：

![](img/c581e8bf-a547-4728-a25b-5454b0553d85.png)

图 5：IAM 用户路径包含 SpaceCrab，透露了它们是金丝雀令牌

该问题已报告给 Atlassian 并得到解决。问题也报告给了 AWS 本身，但被拒绝，因为他们不认为 ARN 是敏感信息。这是正确的，但用户不应该能够在不生成任何日志的情况下获取这些信息。

AWS Amplify 是另一个在 CloudTrail 中不受支持的较新的服务，它输出类似的冗长错误消息。在尝试运行`ListApps`命令而没有正确权限时返回了以下消息：

```
An error occurred (AccessDeniedException) when calling the ListApps operation: User: arn:aws:iam::000000000000:user/TestUser is not authorized to perform: amplify:ListApps on resource: arn:aws:amplify:us-west-2:000000000000:apps/* 
```

如果 AWS 服务输出类似的错误消息，并且有一些 CloudTrail 不支持的服务，这种小型攻击基本上是永恒的。同样的攻击可能适用于任何新发布的并且未被记录的服务。

即使这么少的信息对攻击者也有帮助，因为他们可以使用其他未记录的攻击向量，例如跨账户 IAM 用户/角色枚举，来收集更多信息（[`rhinosecuritylabs.com/aws/aws-iam-user-enumeration/`](https://rhinosecuritylabs.com/aws/aws-iam-user-enumeration/)）。

# 通过跨账户方法绕过日志记录

正如我们刚才指出的，可以在 AWS 账户中枚举用户和角色，而无需目标账户中的任何权限或日志。我们需要的一切就是我们自己的 AWS 账户和我们目标的 AWS 账户 ID。

# 枚举用户

就像我们之前在 IAM 章节中介绍的那样，IAM 角色有一个信任策略文档，指定了哪些 IAM 资源/账户可以从中请求临时凭证。在幕后，所有 IAM 资源都是唯一创建的，IAM 角色信任策略也认可这一点。这样做的原因是，如果您指定用户`Mike`可以假定某个角色，然后删除`Mike`；理论上，攻击者可以创建另一个名为`Mike`的 IAM 用户并假定该角色。实际上，情况并非如此，因为在幕后，角色信任策略引用的是唯一用户 ID，而不仅仅是用户名。

由于在幕后将用户 ARN 转换为唯一用户 ID，IAM 不会允许您设置允许访问不存在用户的信任策略。此外，角色可以被假定为跨账户，因此可以在信任策略中指定其他账户 ID。

鉴于这两个事实，如果作为攻击者，我们拥有另一个账户的账户 ID，我们基本上可以暴力破解其账户中存在哪些用户。这个过程已经在一个名为`iam__enum_users`的 Pacu 模块中自动化。使用 Pacu 打开并配置后，我们可以运行以下命令来枚举具有 ID`000000000000`的账户中的 IAM 用户：

```
run iam__enum_users --account-id 000000000000 --role-name TestRole 
```

`TestRole`是在我的账户中创建的 IAM 角色。Pacu 使用该角色来更新信任策略文档以进行枚举，因此很重要的是使用您自己的 AWS 访问密钥运行此模块，并提供具有更新访问权限的角色名称。

运行该模块时，您自己的 AWS CloudTrail 日志将被`iam:UpdateAssumeRolePolicy`日志淹没，但目标账户将看不到任何东西，从而允许您悄悄地收集有关目标环境的信息。

使用自定义单词列表，我们能够从 ID 为`000000000000`的目标账户中枚举出两个用户`Alexa`和`Test`（这只是一个演示，对您没有用，因为`000000000000`不是真实的 AWS 账户）。Pacu 模块的输出看起来像这样：

```
Pacu (Demo:imported-default) > run iam__enum_users --account-id 000000000000 --role-name TestRole
  Running module iam__enum_users...
[iam__enum_users] Warning: This script does not check if the keys you supplied have the correct permissions. Make sure they are allowed to use iam:UpdateAssumeRolePolicy on the role that you pass into --role-name!

[iam__enum_users] Targeting account ID: 000000000000

[iam__enum_users] Starting user enumeration...

[iam__enum_users]   Found user: arn:aws:iam::000000000000:user/Alexa
[iam__enum_users]   Found user: arn:aws:iam::000000000000:user/Test

[iam__enum_users] Found 2 user(s):

[iam__enum_users]     arn:aws:iam::000000000000:user/Alexa
[iam__enum_users]     arn:aws:iam::000000000000:user/Test

[iam__enum_users] iam__enum_users completed.

[iam__enum_users] MODULE SUMMARY:

  2 user(s) found after 7 guess(es).
```

输出显示，从我们修改后的单词列表中的七次猜测中找到了两个有效用户。在撰写本文时，Pacu 使用的默认单词列表有 1,136 个名称。

# 枚举角色

以前可以使用类似的攻击来枚举另一个 AWS 账户中存在的角色，如果只需要 AWS 账户 ID，那么我们基本上可以暴力破解所有存在的角色。由于 Rhino Security Labs 发布后，AWS 已经修改了 STS `AssumeRole` API 调用从 API 返回的错误消息，这意味着不再可能使用这种方法确定角色是否存在。`iam__enum_assume_role` Pacu 模块旨在利用此功能，但由于此更改，它不再起作用。

另一方面，发现了一种新方法，允许您跨账户基础上枚举角色。这种方法与用于枚举跨账户用户的方法相同。最初，这种方法的工作方式与现在不同，但必须进行了一些 API 更改，现在使得这种枚举成为可能。编写了一个新的 Pacu 模块来滥用这种攻击向量，它被命名为`iam__enum_roles`。它的工作方式与`iam__enum_users`模块完全相同，因此可以使用基本相同的命令运行：

```
 run iam__enum_roles --account-id 000000000000 --role-name TestRole 
```

该模块将枚举目标帐户中存在的角色，然后尝试假定这些角色以检索临时凭证，如果其策略配置错误并允许您访问。该模块的一部分如下：

```
Pacu (Spencer:imported-default) > run iam__enum_roles --account-id 000000000000 --role-name TestRole 
  Running module iam__enum_roles... 
[iam__enum_roles] Warning: This script does not check if the keys you supplied have the correct permissions. Make sure they 
are allowed to use iam:UpdateAssumeRolePolicy on the role that you pass into --role-name and are allowed to use sts:AssumeRole to try and assume any enumerated roles! 

[iam__enum_roles] Targeting account ID: 000000000000 

[iam__enum_roles] Starting role enumeration... 

[iam__enum_roles]   Found role: arn:aws:iam::000000000000:role/service-role/AmazonAppStreamServiceAccess 
[iam__enum_roles]   Found role: arn:aws:iam::000000000000:role/CodeDeploy 
[iam__enum_roles]   Found role: arn:aws:iam::000000000000:role/SSM 

[iam__enum_roles] Found 3 role(s): 

[iam__enum_roles]     arn:aws:iam::000000000000:role/service-role/AmazonAppStreamServiceAccess 
[iam__enum_roles]     arn:aws:iam::000000000000:role/CodeDeploy 
[iam__enum_roles]     arn:aws:iam::000000000000:role/SSM 

[iam__enum_roles] Checking to see if any of these roles can be assumed for temporary credentials... 

[iam__enum_roles]   Role can be assumed, but hit max session time limit, reverting to minimum of 1 hour... 

[iam__enum_roles]   Successfully assumed role for 1 hour: arn:aws:iam::000000000000:role/CodeDeploy 

[iam__enum_roles] { 
  "Credentials": { 
    "AccessKeyId": "ASIATR17AL2P90OB3U6Z", 
    "SecretAccessKey": "nIll8wr/T60pbbeIY/hkqRQlC9njUzv3RKO3qznT", 
    "SessionToken": "FQoGAR<snip>iC/aET", 
    "Expiration": "2019-01-16 20:32:08+00:00" 
  }, 
  "AssumedRoleUser": { 
    "AssumedRoleId": "AROAJ9266LEYEV7DH1LLK:qw9YWcRjmAiunsp3KhHM", 
    "Arn": "arn:aws:sts::000000000000:assumed-role/CodeDeploy/qw9YWcRjmAiunsp3KhHM" 
  } 
} 
[iam__enum_roles] iam__enum_roles completed. 

[iam__enum_roles] MODULE SUMMARY: 

  3 role(s) found after 8 guess(es). 
  1 out of 3 enumerated role(s) successfully assumed. 
```

前面的例子显示了找到了一些角色，并且其中一个角色配置错误，允许我们请求其凭证。在撰写本文时，Pacu 使用了 1,136 个名称的默认单词列表。

用户和角色枚举基本上是永恒的，例如冗长的 AWS CLI 错误消息，因为它是在利用预期的功能，而不是 API 中的任何错误。

# 破坏跟踪

有许多方法可以破坏 CloudTrail 跟踪的记录，以尝试在我们的攻击中保持低调，但它们都很可能触发警报，从而暴露我们的活动给关注的人。然而，了解这些方法仍然很重要，因为我们攻击的每个帐户可能甚至没有最基本的监控功能（如 GuardDuty），因此在这种情况下禁用任何 CloudTrail 记录是有意义的。然而，这个问题有部分解决方案；这些解决方案及其局限性将在本节末讨论。

# 关闭记录

破坏 CloudTrail 记录的一种简单方法是简单地关闭任何活动的跟踪。有一个专门用于此目的的 API，即`StopLogging` API。从 AWS CLI，我们可以使用以下命令关闭我们帐户中名为`test`的跟踪的记录：

```
aws cloudtrail stop-logging --name test 
```

此命令必须从创建目标跟踪的区域运行，否则将返回`InvalidHomeRegionException`错误。

这个任务也可以通过`detection__detection` Pacu 模块完成。该 Pacu 命令看起来可能是这样的：

```
 run detection__disruption --trails test@us-east-1 
```

然后会提示您选择四个不同的选项：禁用、删除、最小化或跳过。要停止跟踪的记录，我们将选择禁用（dis）。然后 Pacu 将禁用目标跟踪的记录。

GuardDuty 的更多信息可以在下一章中找到。

无论哪种情况，如果 GuardDuty 正在运行，它将触发一个`Stealth:IAMUser/CloudTrailLoggingDisabled`警报（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2)），表明已禁用了一个跟踪。这将暴露我们对环境的未经授权访问，并且如果有人在意的话，可能会关闭我们的攻击。

# 删除跟踪/S3 存储桶

另一组避免`StopLogging` API 的选项是要么完全删除 CloudTrail 跟踪，要么删除它发送日志的 S3 存储桶。我们可以使用以下命令从 AWS CLI 中删除名为`test`的跟踪：

```
aws cloudtrail delete-trail --name test 
```

这也可以通过 Pacu 完成，通过运行我们之前用于禁用跟踪的相同命令，但选择删除（del）选项：

```
run detection__disruption --trails test@us-east-1 
```

一旦提示要对跟踪执行什么操作，我们将选择`del`，这将随后完全删除 CloudTrail，意味着记录已停止。

我们还可以删除某个跟踪正在将其日志发送到的 S3 存储桶，这将阻止活动跟踪记录任何内容。这可以完全避免 CloudTrail API（如果您知道要删除的存储桶），但仍然非常嘈杂，因为它会使跟踪处于错误状态。如果我们还不知道，我们可以使用 AWS CLI 识别跟踪正在发送日志的存储桶的名称，使用以下命令：

```
aws cloudtrail describe-trails 
```

然后我们将查看我们要定位的跟踪的`S3BucketName`键的值，我们将假设是`cloudtrail_bucket`。然后我们可以使用以下 AWS CLI 命令删除该 S3 存储桶：

```
aws s3api delete-bucket --bucket cloudtrail_bucket
```

现在，CloudTrail 将继续尝试将日志传送到该存储桶，但会失败，这意味着在删除存储桶的期间将不会写入任何日志。如果您已经知道正在被定位的存储桶，您将永远不需要运行任何 CloudTrail API 调用；只需要运行 S3 的`DeleteBucket`调用。目前没有 Pacu 模块可用于执行此任务（获取由跟踪定位的存储桶，然后删除它）。之后，您甚至可以继续在您自己的攻击者账户中创建该存储桶，并提供正确的跨账户写入权限；然后您将获得所有 CloudTrail 日志，而您的目标账户将无法访问它们。

与禁用跟踪、删除跟踪或其目标存储桶类似，在启用 GuardDuty 的情况下，将触发`Stealth:IAMUser/CloudTrailLoggingDisabled`警报（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2)），表明已删除跟踪或其存储桶。同样，这将暴露我们对环境的未经授权访问，并且如果有人在意的话，很可能会关闭我们的攻击。

# 最小化跟踪

在目标账户中避免禁用或删除的另一种选择是修改跟踪以最小化其记录的内容。例如，假设有一个名为`test`的跟踪，它为每个区域记录日志；它记录全局服务事件，启用日志文件验证，启用日志文件加密，并记录对账户中每个 S3 存储桶和 Lambda 函数的访问。

为了避免禁用或删除此跟踪，我们可以使用`UpdateTrail` API 来删除其设置的所有功能。我们可以运行以下 AWS CLI 命令来禁用全局服务事件，将其从全局跟踪更改为单区域跟踪，禁用日志文件加密和禁用日志文件验证：

```
aws cloudtrail update-trail --name test --no-include-global-service-events --no-is-multi-region-trail --no-enable-log-file-validation --kms-key-id "" 
```

通过将 KMS 密钥 ID 设置为空值，从那时起所有日志都将是未加密的。您还可以选择修改哪些设置，例如，如果您想要使用非全局 API 定位`us-west-2`区域，并且该跟踪是在`us-east-1`中创建的全局跟踪。在这种情况下，您只需要包括`--no-is-multi-region-trail`标志，并确保您保持在`us-west-2`中。如果跟踪正在向 SNS 主题发送通知，您还可以通过将主题设置为空字符串来禁用它。与跟踪相关的 CloudWatch 日志也是如此。

与禁用/删除跟踪类似，`detection__disruption` Pacu 模块将为您自动化此过程。我们可以运行相同的命令：

```
run detection__disruption --trails test@us-east-1 
```

然后在提示时，我们选择最小化（`m`）选项，这将删除任何关联的 SNS 主题，禁用全局服务事件，将其从全局跟踪更改为单区域跟踪，禁用日志文件验证，删除与 CloudWatch 日志组和相关角色的任何关联，并删除日志文件加密。

与禁用/删除跟踪类似，在启用了 GuardDuty 的情况下，这些修改类型有可能触发`Stealth:IAMUser/CloudTrailLoggingDisabled`（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2)）和/或`Stealth:IAMUser/LoggingConfigurationModified`（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth3`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth3)）警报，这可能最终导致我们在环境中被发现。在撰写本文时，我们从未看到 GuardDuty 对 CloudTrail 的此类攻击触发，尽管两种发现类型的描述似乎表明它们应该被触发，但目前尚不清楚是否一定会被检测到。

要修改追踪器的 S3 数据和 Lambda 调用事件设置，我们需要使用`PutEventSelectors` API 而不是`UpdateTrail`。我们可以修改事件选择器以删除任何数据事件（S3/Lambda）的选择器，因此这些事件将不再被追踪器记录。我们还可以修改`ReadWriteType`，指定追踪器是否应记录读取事件、写入事件或两者。修改为仅记录读取事件将很简单，这样我们恶意的写入事件就不会被记录。我们可以使用以下 AWS CLI 命令删除所有数据事件记录，仅记录读取事件：

```
aws cloudtrail put-event-selectors --trail-name Test --event-selectors file://event_selectors.json
```

在`event_selectors.json`中，我们将有以下内容：

```
[
    {
        "ReadWriteType": "ReadOnly",
        "IncludeManagementEvents": true,
        "DataResources": []
    }
]
```

这个 JSON 文档告诉 CloudTrail 只记录读取事件，并不记录任何数据事件（S3/Lambda）。一旦应用到追踪器上，它将记录缺少大部分故事的信息，使我们攻击者能够通过日志分析。

# 中断问题（以及一些部分解决方案）

对 CloudTrail 的这些攻击的主要问题在于 GuardDuty 旨在检测它们，但存在一些潜在的绕过方法，使我们能够在不被发现的情况下进行更改。

第一个最简单的绕过方法是检测您已经妥协的用户的常规活动是什么。GuardDuty 使用机器学习（更多内容请参阅第十六章，*GuardDuty*）来检测这些攻击是否异常，因此，如果您妥协了一个有着禁用/删除/修改 CloudTrail 追踪器历史记录的历史的用户，那么您可能也可以做同样的事情，而不被 GuardDuty 检测为异常。

另一个部分解决方案是在日志传送到其 S3 存储桶后修改日志。如果目标正确地在其追踪器上使用了日志文件验证设置，将能够检测到这一点，但如果没有，那么很容易进入日志传送的 S3 存储桶，然后修改日志以删除我们攻击者活动的任何痕迹。有多种方法可以用来防御这种攻击，但在您进行渗透测试时可能会在某个环境中实现。

需要记住的一件事是，在 S3 存储桶中删除/修改日志并不意味着 CloudTrail 事件历史记录中的日志也被删除/修改，因为这些日志将在那里不可变地保存 90 天。由于其速度和限制，CloudTrail 事件历史记录可能难以处理，因此在最坏的情况下（即防御者几乎立即调查您的活动），您仍然可以争取一些时间，以便他们能够适当地检查您的活动。

# 总结

在本章中，我们介绍了设置符合最佳实践的 CloudTrail 事件，以及如何审计目标环境的最佳实践。CloudTrail 并不是一个完美的服务，我们通过使用它不支持的服务来演示，可以在一个账户中执行侦察而不生成任何日志。因此，有必要跟踪 CloudTrail 中不支持的服务，以便在目标环境中利用它们，而不会在日志中显示。跨账户枚举方法还允许我们在不生成日志的情况下发现有关目标账户的信息，这意味着我们可以了解谁在使用环境，以及环境中使用了什么，而不需要使用被破坏的密钥进行 API 调用。我们还展示了如何使用 Pacu 自动化一些对 CloudTrail 的攻击，以及 GuardDuty 如何介入尝试检测这些行为。

在下一章中，我们将更深入地讨论 GuardDuty，重点关注它检测和标记的内容，以及我们如何绕过本章讨论的内容。这些绕过和对 GuardDuty 使用的检测方法的理解将使我们能够以强大的力量攻击环境，同时保持隐秘。
