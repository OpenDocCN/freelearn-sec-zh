# 第四章：内存寻址模式

到目前为止，我们已经对汇编编程的某些基本方面有所了解。我们已经覆盖了英特尔架构的基础，设置了您选择的开发环境，并且了解了 **指令集架构**（**ISA**）。

我们知道可以对不同类型的数据执行哪些操作，但只要不知道如何获取和存储数据，这些操作几乎没有任何价值。当然，我们熟悉 `mov` 指令，但如果不知道如何在内存中寻址数据，这条指令就毫无用处。

幸运的是，英特尔为我们提供了一种非常灵活的内存寻址机制。在本章中，我们将介绍以下几种内存寻址模式：

+   顺序寻址

+   直接寻址

    +   通过立即数地址

    +   通过存储在寄存器中的地址

+   间接寻址

    +   通过一个由立即数指向的地址

    +   通过一个由寄存器指向的地址

+   基础相对寻址

    +   基础 + 索引

    +   基础 + 索引 * 比例

+   基于 IP/RIP 的寻址

+   远指针

上述分类与英特尔如何分类寻址模式无关，因为我们并不关注指令内的地址编码。我们关注的是如何寻址内存，并能恰当地使用它们。值得一提的是，前面的列表代表了数据和代码的寻址模式。此外，本章将使用 64 位示例，以便能够涵盖这里列出的所有模式。

# 寻址代码

当我们说“寻址代码”时，我们指的是 CPU 解析下一条待执行指令的地址的方式，这取决于代码本身的逻辑，它告诉处理器是否应该顺序执行指令，或者跳转到其他位置。

# 顺序寻址

代码的默认寻址模式是 **顺序寻址**，当 **指令指针**（**IP**，32 位系统为 IP，64 位为 RIP）寄存器包含当前执行的指令后面的指令地址时。我们不需要做任何事情来将处理器设置为此模式。指令指针会由 CPU 自动设置为下一条指令的地址。

例如，在执行下面代码的第一条指令时，IP 已经设置为下一条指令的地址，标记为 `next_instruction`。由于第一条指令是 `call`，我们知道它会将返回地址压入堆栈——在这个特定情况下，返回地址也是 `next_instruction` 的地址——第二条指令（`pop` 指令）从堆栈中取回返回地址的值：

```
       call next_instruction 
    next_instruction:
       pop rax
       *; the rest of the code*
```

前面的例子（或其变种）经常出现在不同的打包器和保护器的代码中，也被 shellcode 编写者作为创建位置无关代码的一种手段，在这种代码中，过程和变量的地址可以通过将它们的偏移量从`next_instruction`加到`next_instruction`的地址来计算。

# 直接寻址

*直接寻址*一词意味着指令中直接包含的地址作为操作数。一个例子可能是 *远程调用/jmp*。大多数 Windows 可执行文件被加载在地址 0x00400000，并且第一个部分（默认为代码部分）被加载在地址`0x00401000`。为了举个例子，假设我们有一个可执行文件，我们确定它被加载在上述地址，其代码部分位于基地址（即我们的可执行文件加载的地址）偏移量 0x1000 处，并且在第一部分的开头有某种特殊代码。假设它是一个错误处理程序，用于以正确的方式终止程序执行。在这种情况下，我们可以使用远程调用或远程跳转将执行流引导到该代码：

```
*; The following call would be encoded as (address is underlined):*
*; 0xff 0x1d 0x00 0x10 0x40 0x00*
call far [0x00401000] 

*; or as*
*; 0xff 0x2d 0x00 0x10 0x40 0x00*
jmp far [0x00401000]
```

然而，更常见的例子是寄存器调用，其中目标地址存储在寄存器中：

```
lea rax, [my_proc]
call rax
```

在前面的代码中，我们将 RAX 寄存器加载了我们要调用的`my_proc`过程的地址，然后第二行是实际的调用。这样的模式，例如，编译器在将`switch`语句翻译为汇编时会使用，当特定情况下对应的代码地址要么从跳转表中加载，要么使用某个硬编码的基地址（它也可能在执行时被重新定位）和从跳转表中获取的偏移量来计算。

# 间接寻址

“间接寻址”一词相当直观。正如该模式的名称所示，地址在某个地方，但并不直接使用。相反，它是通过指针引用的，指针可以是寄存器或某个基地址（立即地址）。例如，以下代码会调用同一个过程两次。在第一次调用中，地址是通过存储在`rax`寄存器中的指针获取的，而在第二次调用中，我们使用一个存储我们要调用的过程地址的变量：

```
*; This goes into code section*
 push my_proc
 lea    rax, [rsp]
 call   qword [rax]
 add  rsp, 8
 call  qword [my_proc_address]
 *;*
 *;*
 my_proc:
     ret

 *; This goes into data section*
 my_proc_address dq my_proc
```

正如我们所看到的，在这两种情况下，`call`指令的操作数是指向内存中存储`my_proc`过程地址的位置的指针。这个寻址模式可以用来增强代码片段执行流的混淆。

# 基于 RIP 的寻址

IP 或 RIP（取决于我们是在 32 位还是 64 位平台上）表示相对于指令指针寄存器的寻址。

这个寻址模式的最佳示例是`call`和`jmp`指令。例如，考虑以下代码：

```
call my_proc
 *; or*
 jmp some_label
```

这不会包含 `my_proc` 或 `some_label` 的地址。相反，`call` 指令将以一种方式编码，使得它的参数是从下一条指令到 `my_proc` 的偏移量。如我们所知，指令指针寄存器在处理器执行当前指令时包含下一条指令的地址；因此，我们可以肯定地说，目标地址是相对于指令指针的值计算的（32 位平台为 IP，64 位平台为 RIP）。

相同的规则适用于前面示例中的 `jmp` 指令——目标地址是相对于当前指令指针的值计算的，指令指针包含着下一条指令的地址。

# 数据寻址

数据寻址模式与代码寻址相同，唯一的例外是 32 位系统上的基于 IP 的寻址。

# 顺序寻址

是的，这并不是一个打字错误，当涉及到数据寻址时也存在顺序寻址，尽管它确实需要一些特定的设置。

请记住 RSI/RDI 配对（或者 32 位系统的 ESI/EDI），我们在第一章的 *Intel 架构* 和第三章的 *Intel 指令集架构（ISA）* 中都有提到。这个配对是顺序数据寻址的一个很好的例子，其中源地址和/或目标地址在每次使用这些寄存器（其中一个或两个）的指令执行后自动递增或递减（取决于方向标志的值）。

以下示例通过将文本字符串从数据段的位置复制到栈上分配的缓冲区来说明这种模式：

```
 *; This portion goes into the code section.*
 *; Assuming the RBP register contains the stack frame address*
 *; and the size of the frame is 0x50 bytes.*
 lea rdi, [rbp – 0x50]
 lea rsi, [my_string]
 mov ecx, my_string_len
 rep movsb

 *; And this portion goes into the data section*
 my_string db ‘Just some string’,0
 my_string_len = $ - my_string
```

如我们所见，RDI 寄存器被加载为栈帧中的最低地址，RSI 寄存器被加载为字符串的地址，RCX 寄存器被加载为字符串的长度，包括终止零。之后，每次执行 `rep movsb` 行时，RSI 和 RDI 会顺序递增（递增的大小取决于我们记得的 `movs*` 变体——对于 `movsb` 为 1，`movsw` 为 2，`movsd` 为 4，`movsq` 在 64 位平台上为 8）。

# 直接寻址

就像在代码寻址的情况下，这种模式意味着源操作数或目标操作数（取决于指令和意图）的地址被明确指定。然而，与代码寻址不同，我们能够指定地址本身，除非先将其加载到寄存器中。考虑将变量的值加载到寄存器中或从寄存器存储到内存中的示例：

```
 mov al, [name_of_variable]
 *; or*
 mov [name_of_another_variable], eax
```

在这两种情况下，`name_of_variable` 和 `name_of_another_variable` 都被汇编器转换为这些变量的地址。当然，我们也可以使用寄存器来实现此目的。以下示例演示了一个 `if…else` 语句：

```
*; This goes into code section.*
    xor  rax, rax
    *; inc rax                     ; Increment RAX in order to call the second procedure*
    lea  rbx, [indices]
    add  rax, rbx
    lea  rbx, [my_proc_address]
    add  bl, [rax]
    mov rbx, [rbx]
    call qword rbx
    *; The rest of the code*

   align 8
 my_proc0:
    push rbp
    mov  rbp, rsp
    xor  eax, eax
    mov  rsp, rbp
    pop  rbp
    ret

   align 8
 my_proc1:
    push rbp
    mov  rbp, rsp
    xor  eax, eax
    inc  eax
    mov  rsp, rbp
    pop  rbp
    ret       

 *; And the following goes into data section*
 indices              db 0, 8
    align 8
    my_proc_address      dq my_proc0, my_proc1
```

代码的第一行将 `rax` 寄存器设置为零，当第二行被注释掉时，这会导致代码调用 `my_proc0`。另一方面，如果我们取消注释 `inc rax` 指令，则会调用 `my_proc1`。

# 比例、索引、基址和位移

这是一种非常灵活的寻址模式，因为它允许我们以类似于在数组中寻址数据的方式来寻址内存，这是我们都熟悉的。尽管这种寻址模式通常被称为比例/索引/基址（省略了位移部分），但我们并不强制同时使用所有元素，我们将进一步看到，比例/索引/基址/位移方案常常简化为基址、基址 + 索引或位移 + 索引。后两者可能带或不带比例。但首先，让我们看看谁是谁，哪个部分代表什么：

+   **位移**：从技术上讲，这是相对于某个段基址的整数偏移（默认是 DS）。

+   **基址**：这是一个寄存器，包含相对于位移的数据偏移，或者如果没有指定位移，则包含数据起始地址（实际上，当我们未指定位移时，汇编器会自动加上一个零位移）。

+   **索引**：这是一个寄存器，包含相对于基址 + 位移的数据偏移。这类似于索引或数组成员。

+   **规模**：CPU 并没有数据类型的概念；它只理解大小。因此，如果我们操作的值大于 1 字节，我们必须适当地调整索引值的比例。对于字节、字、双字和四字，比例分别为 1、2、4 或 8。显然，没有必要明确指定比例为 1，因为如果未指定比例，它是默认值。

可以通过在地址前加上段前缀显式指定另一个段（例如，`cs:` 用于 CS，`es:` 用于 ES，等等）。

为了计算最终地址，处理器会取段的基址（默认是 DS），加上位移，再加上基址，最后通过加上索引乘以比例来完成计算：

*段基址 + 位移 + 基址 + 索引 * 比例*

理论上，这一切看起来既简单又清晰，那么我们继续向实践推进，这也更好，且容易得多。如果我们再看一遍直接寻址的示例代码，我们可能会看到其中有几行完全多余的代码。以下是我们要处理的第一行：

```
mov rbx, [rbx]
```

尽管它提供了一个很好的基于寄存器的直接寻址示例，但它可以安全地省略，接下来的指令（`call`）应更改为（记得间接调用吗？）：

```
call qword [rbx]
```

然而，即使这一行也可以像大多数调用代码一样省略。仔细观察问题，我们看到有一个过程指针数组（实际上是一个包含两个元素的数组）。从高级语言的角度来看，以下代码的目的是：

```
int my_proc0()
 {
    return 0;
 }

 int my_proc1()
 {
    return 1;
 }

 int call_func(int selector)
 {
    int (*funcs[])(void) = {my_proc0, my_proc1};
    return funcs[selector]();
 }
```

英特尔架构为基址 + 索引的数组式数据/代码寻址提供了类似的接口，但它引入了方程中的另一个成员——倍增。由于汇编器，尤其是处理器并不关心我们操作的数据类型，我们必须自己帮助它们。

虽然基址部分（无论是标签还是存放地址的寄存器）由处理器视为内存中的地址，索引只是需要加到基址上的字节数，但在这种特定情况下，我们当然可以自己对索引进行缩放，因为算法相当简单。我们只有两个选择器的可能值（在前面的汇编代码中是 `rax` 寄存器），即 `0` 和 `1`，因此我们可以例如将 `rbx` 寄存器加载为 `my_proc_address` 的地址：

```
lea rbx, [my_proc_address]
```

然后，我们将 `rax` 寄存器向左移三次（这样做相当于乘以 8，因为我们在 64 位架构上，地址是 8 字节长的，否则我们会指向 `my_proc0` 地址的第二个字节），并将结果加到 `rbx` 寄存器中。这对单次迭代来说可以，但对于频繁执行的代码来说并不太方便。即使我们使用一个额外的寄存器来存储 `rbx` 和 `rax` 的和——如果我们需要那个寄存器做其他事情怎么办？

这时，倍增部分就发挥作用了。将汇编示例中的调用代码重写，将得到以下结果：

```
xor rax, rax
 *; inc rax                 ; increment RAX to call the second procedure*
 lea rbx, [my_proc_address]
 call qword [rbx + rax * 8]

 *; or even a more convenient one*

 xor rax, rax
 *; inc rax*
 call qword[my_proc_address + rax * 8]
```

当然，基址/索引/倍增模式可以用于寻址任何类型的数组，不一定是函数指针数组。

# RIP 寻址

基于 RIP（在 64 位平台上的指令指针寄存器）寻址数据是在 64 位架构中引入的，它能够生成更加紧凑的代码。这种寻址模式与基址/索引/倍增模式的思想相同，只不过这时指令指针作为基址使用。

例如，如果我们想将某个寄存器加载为一个变量的地址，我们可以在汇编中写下以下代码：

```
lea rbx, [my_variable]
```

汇编器会自动进行所有的调整，最终指令的编码结果将与以下内容等效：

```
lea rbx, [rip + (my_variable – next_instruction)]
```

将 `rbx` 寄存器加载为 `rip` 寄存器的值（即下一个指令的地址）加上一个变量相对于下一个指令地址的字节偏移量。

# 远指针

可以相对安全地说，远指针已经属于过去的历史了，尤其是在应用开发层面；然而，如果在这里不提及它们也是不对的，毕竟我们仍然能用它做一些有用的事情。简单来说，远指针结合了段选择器和段内偏移量。远指针起源于 16 位操作模式时代，经历了 32 位保护模式，最终进入了长模式，尽管它们几乎不再相关，尤其是在长模式下，所有内存都被视为一个平坦的数组，我们几乎不可能再使用它们。

用于将远指针加载到段寄存器的指令（一些已过时）：常用寄存器对如下：

+   **LDS**：这将远指针的选择子部分加载到 DS 寄存器。

+   **LSS**：这将远指针的选择子部分加载到 SS 寄存器。

+   **LES**：这将远指针的选择子部分加载到 ES 寄存器。

+   **LFS**：这将远指针的选择子部分加载到 FS 寄存器。

+   **LGS**：这将远指针的选择子部分加载到 GS 寄存器。

然而，让我们看看如何利用它们。为了简化起见，我们将考虑一个短小的 32 位 Windows 示例，在该示例中我们获取**进程环境块**（**PEB**）的地址：

```
*; This goes into the code section*
mov   word [far_ptr + 4], fs   *; Store FS selector to the selector part of the far_ptr*
lgs   edx, [far_ptr]           *; Load the pointer*
mov   eax, [gs:edx]            *; Load EAX with the address of the TIB*
mov   eax, [eax + 0x30]        *; Load EAX with the address of the PEB*

*; This goes into the data section*
far_ptr   dp 0                 *; Six bytes far pointer:*
 *;     four bytes offset*
 *;     two bytes segment selector*
```

正如你所看到的，这段代码在这个例子中是相当冗余的，因为我们已经将正确的选择子加载到了 FS 寄存器中，但它仍然展示了机制。在现实世界中，没有人会采取这种方式来获取 PEB 的地址；相反，应该会执行以下指令：

```
mov   eax, [fs:0x30]
```

这将会把`eax`寄存器加载为 PEB 的地址，因为`fs:0x00000000`已经是指向 TIB 的远指针。

LDS 和 LES 指令（分别用于 DS 和 ES 寄存器）已过时。

# 总结

本章我们简要介绍了现代 Intel CPU 的寻址模式。有些资源定义了更多的寻址模式，但让我重申，作为奥卡姆剃刀的忠实拥护者，我认为没有理由在没有必要的情况下增加不必要的东西，因为大多数额外的模式只是对上面已解释的模式的变种。

到目前为止，我们已经看到了如何对代码和数据进行寻址，这基本上就是汇编语言编程的精髓。正如你在阅读本书并亲自尝试代码时会看到的，编写汇编程序的至少 90%是编写如何移动数据，数据来自哪里，去往哪里（剩下的 10%是实际对数据的操作）。

通过这一点，我们已经准备好深入探讨汇编编程，并尝试真正编写可运行的程序，而不仅仅是在模板中输入几行代码并在调试器中观察寄存器的变化。

本书的下一部分，*实用汇编*部分，将以一章介绍并行数据处理开始。接着，你将学习宏的基础，并了解数据结构操作机制，我们还将看到我们的汇编代码如何与周围的操作系统交互，这非常重要。
