# 十五、解码 HTTP

在某种程度上，我们大多数人都访问过网页来下载信息。但是当检索一个网页的时候会涉及到什么呢？在这一章中，我们将仔细研究一下**超文本传输协议** ( **HTTP** )。我们将从概述开始，回顾我们在请求内容时可以获得的一些对象和元素。然后我们将比较可用的 HTTP 版本，1.0、1.1 和 2.0，以及使用的方法，比如`GET`、`POST`和`HEAD`。HTTP 有三个版本，每个版本都有一个默认的建立和维护连接的方法。为了让您理解不同方法的机制，我们将比较非持久连接和持久连接之间的差异。

HTTP 是一种无状态协议。您将了解 HTTP 如何通过跟踪每个事务的细节来使用 cookies 维护状态。为了帮助您对 web 连接进行故障诊断，我们将回顾在事务期间发生了什么，并检查请求和响应消息的一般格式。我们将剖析客户机和服务器的 HTTP 头和字段。然后，我们将通过一个 HTTP 流对此进行总结，然后在检查事务 时分解每个元素。

本章将通过涵盖以下主题来解决所有这些问题:

*   描述 HTTP
*   跟踪连接
*   比较请求和响应消息
*   跟随 HTTP 流

# 描述 HTTP

HTTP 是一个应用层协议，负责在客户端浏览器和 web 服务器之间交换数据。HTTP 允许我们收集、分发、协作和传播广泛的数据。虽然是一个无状态协议，但 HTTP 有几个请求方法、错误代码和头，允许我们从许多不同类型的应用访问资源。

注意

HTTP 用于通过网络传输数据。另外两个传输数据的协议包括**文件传输协议** ( **FTP** )和**简单邮件传输协议** ( **SMTP** )。所有的都是提供有效的数据交换方式的关键。

在这一节中，我们将从概述网页的定义开始，并描述 HTTP 在从网站检索对象中的功能。我们将比较客户机和服务器的角色，概述目前使用的版本，然后总结不同类型的 HTTP 方法。

让我们从回顾网页的元素开始。

## 剖析网页

使用一个浏览器，比如 Firefox 或者 Chrome，客户通过点击一个超链接来请求一个页面。该链接将客户端定向到一个网站，该网站是一组链接的网页，服务器将所请求的数据发送给客户端。

我们点击的第一页被称为*索引*或*默认*，这是我们大多数人在搜索内容时的起点。一旦进入网站，每个页面都包含对象，如**超文本标记语言** ( **HTML** )文件、**联合图像专家组** ( **JPEG** )图像、文本、应用和/或 JavaScript。大多数网站都有许多链接页面，这些页面超链接到网站内的其他内容，以及各种可以提取的信息和对象。

在较高层次上，HTTP 将检索包含元素的网页，如下图所示:

![Figure 15.1 – A standard web page
](img/B18389_15_001.jpg)

图 15.1-标准网页

在下载任何对象之前，客户端必须首先访问网页。接下来，让我们回顾一下从网站请求数据时资源是如何定位的。

### 寻找目标

当一个客户端请求一个网页时，用户将点击一个链接，使用一个**统一资源标识符** ( **URI** )请求一个对象，该标识符用于在互联网上标识一个对象(或资源)。一个 URI 的两个*子集*是一个**统一资源定位符** ( **URL** )和一个统一资源名称 ( **URN** )。

在某些情况下，客户端会向服务器请求特定的页面。例如，如果请求 https://www.nist.gov/blogs/cybersecurity-insights,，URL 将以下列方式分解:

*   **主机名**:主机的名为`www.nist.gov`。
*   **路径**:具体资源的路径为`/blogs/cybersecurity-insights`。

一旦请求到达目标，下一步就是使用标准或加密连接与服务器交互。

### 建立联系

当客户端发起与 web 服务器的连接时，它们将根据连接类型使用或者**传输控制协议** ( **TCP** )端口`80`或者端口`443`，如下所述:

*   TCP 端口`80`用于标准的未加密连接。
*   TCP port `443` is used for a secure, encrypted connection.

    注意

    在某些情况下，可以使用备用端口(如`http-alt 8080`或`http-alt 8008`)访问服务器。

如今，使用安全连接很常见，因为大多数网站都使用加密来保护数据交易。当访问一个安全网站时，URL 将使用 **HTTP Secure** ( **HTTPS** )前言进行识别。HTTPS 使用**传输层安全性** ( **TLS** )来保护客户端和服务器之间的所有事务。即使有人能够获得数据流，如果没有适当的密钥来解密数据，他们也不能读取内容。

一旦定位到目标，客户端将向服务器发出请求。每一方在 web 事务中都有一个特定的角色，这将在下面讨论。

### 比较客户端和服务器角色

HTTP 是一种客户端-服务器模型，客户端向服务器发出请求，服务器响应客户端，如下图所示:

![Figure 15.2 – HTTP request and response
](img/B18389_15_002.jpg)

图 15.2–HTTP 请求和响应

一个**客户端**是一个主机，它使用浏览器启动每个会话，与服务器接口并检索对象。

**服务器**是一台永远在线的主机，具有固定**互联网协议** ( **IP** )地址，使用专用的网络服务器软件。虽然有几种 web 服务器应用，但下面列出了前三种:

*   Apache 是当今最流行的开源 web 服务器应用之一。Apache 有一个完整的模块库，支持一组丰富的特性，甚至可以支持最大的站点。
*   nginx(或引擎 X)是第二大流行的开源 web 服务器应用，健壮、可伸缩且易于配置。
*   **Cloudflare** 是一个流行的选项，用于托管网站并帮助防止恶意攻击，如**分布式拒绝服务** ( **DDoS** )攻击。

每当请求一个网页时，版本将是 HTTP 版本 1.0、1.1 或 2.0，如下所述。

## 了解 HTTP 版本

HTTP 目前有三个版本在使用。每个都有一个相关的**意见征询** ( **RFC** )，如下所示:

*   在 *RFC 1945* 中概述的 HTTP 1.0 ，写于 1996 年。这是最初的版本，是在我们刚刚开始看到互联网可能带来的好处时由开发的。这个精简版提供了有限的功能，只有 16 个响应代码，并且没有一个安全的方法来验证用户与网站的交互。
*   在 *RFC 2068* 中概述的 HTTP 1.1 写于 1996 年，在 1.0 版本之后不久。这个版本有许多改进，包括身份验证、改进的性能、重用会话的能力、扩展的状态代码以及细粒度的错误报告。
*   **HTTP 2.0** ，在 *RFC 7540* 中概述，写于 2015 年，由谷歌开发的实验性协议 d 演变而来，称为 **SPeeDY** ( **SPDY** )。v2 通过压缩 HTTP 报头来减少开销，多路传输请求和响应，并主动将内容推送到客户端，从而减少延迟并提高效率。

三个版本都在使用中；然而，你很可能会看到今天的大多数网络流量的 1.1 和 2.0 版本，因为这些版本提供了改进的性能。

在进行分析时，您会看到在 HTTP 头中列出了一个方法，该方法将指示所请求的操作类型。

## 识别 HTTP 方法

HTTP 主要用于获取对象，并使用各种方法与 web 服务器交互以交换信息。下表描述了一些最常用的方法:

![Table 15.1 – Common HTTP methods
](img/B18389_Table_15.1.jpg)

表 15.1–常见的 HTTP 方法

虽然有几种 HTTP 请求方法，但最常用的两种是`GET`和`POST`。

在下一节中，我们将比较连接方法，并介绍如何使用 cookies 来跟踪事务。

# 保持对连接的跟踪

HTTP 的每一个版本都在传输和处理数据的方法上有所发展，使用了一些技术，比如使用具有流水线目标的持久连接来优化连接。此外，因为 HTTP 是一种无状态协议，所以 cookies 用于维护有关连接的客户端信息，例如购物车元素和客户端访问过的页面。

在这一部分，我们将比较建立和维护连接的不同方法，以及如何使用 cookies 来保存状态信息。让我们从比较连接类型开始。

## 评估连接类型

当 HTTP 版本被开发出来时，它只有最少的功能，并且使用非持久连接。随着 1.1 版的推出，增加了一些增强功能。其中一项改进是通过使用持久连接保持数据移动的能力。

让我们从理解非持久连接的机制开始。

### 使用非持久连接

非持久连接是从网页中获取内容的原始方式之一。该方法以下列方式工作:

1.  客户端从 web 服务器请求内容。
2.  服务器将内容返回给客户端。
3.  连接已关闭。

如果客户机想要从 web 服务器获得更多的内容，必须建立一个新的连接，导致每个请求和响应都有一次往返。可以想象，所有的往返和连接都会增加延迟。

非持久连接有两种方法，如下所述:

*   非并行(或串行)连接一次使用一个连接。
*   并行连接使用多个并发连接。

如果可能，使用并行连接，因为这将提高获取对象的整体效率。

使用 HTTP 版时，默认情况下使用非持久连接。HTTP 版本 1.1 通过提供持久连接改进了连接方法，如下所述。

### 提供持久的连接

为了优化连接，HTTP 版引入了使用持久连接来保持会话活动，直到检索到所有对象。这种类型的连接也称为 HTTP 保持活动，因为它避免了每次发出请求时都必须重新建立新的连接。

注意

尽管在 1.1 版中保持活动的想法是正式的，但 1.0 版采用了一种非正式的方法来保持会话活动。这就是为什么您可能会在事务期间看到使用 keep-alive 的 HTTP 1.0 流量。

使用时，HTTP 头可以设置超时，并定义客户端可以发出的最大请求数。

保持活动数据包在客户端和服务器之间发送，以保持会话活动，并验证两端是否仍在响应。保活数据包没有任何数据；它设置了确认 ( **确认**)标志，并且序列号被设置为比*当前序列号*少 1。

HTTP 版改进了这一选项，允许多个并发事务合并到一个连接中。

HTTP 1.1 将持久连接作为默认模式。接下来，让我们看看持久连接如何受益于一个叫做流水线的概念。

#### 流水线数据传输

为了优化使用持久连接的数据传输，HTTP 可以使用管道技术，它保持与服务器的连接，直到获得所有对象。管道提高了数据事务的效率，因为客户端可以立即继续请求对象，而无需等待服务器发送之前的请求。

服务器不是在请求-响应事务后关闭每个连接，而是保持连接打开并等待进一步的请求。使用管道的持久连接是 HTTP 1.1 中的默认连接方法。就建立连接而言，这种类型的连接需要更多的开销。此外，由于服务器正在等待多个请求，它可能会在短时间内处于空闲状态。但是，这种类型的连接是首选，因为它提高了从 web 服务器获取对象时的整体效率。

因为 HTTP 是一种无状态协议，所以 cookies 用于跟踪每个事务的细节。

## 用 cookies 维护状态

当使用 HTTP 时，服务器和客户机本身都不维护关于事务状态的信息。为了克服这个问题，HTTP 使用了 cookie 的概念。

cookie 是服务器创建的字符串，可以放在用户的系统上，然后由用户的浏览器管理，与服务器交互。一旦用户接受了 cookie，cookie 中包含的信息就可以用于以下原因:

*   **认证**:在用户提供登录信息后，该数据可以作为**单点登录** ( **SSO** )的形式与网站进行交互。
*   个性化用户体验(UX):cookie 可以收集购物模式的数据。这个将通过保留以前访问过的对象并定期向客户端呈现信息来改善购物体验。

要进一步了解在 HTTP 对话中使用的 cookie，请访问[HTTP://tcpreplay . app neta . com/wiki/captures . html # big flows-pcap](http://tcpreplay.appneta.com/wiki/captures.html#bigflows-pcap)。一旦到了那里，下载`bigFlows.pcap`以便你可以跟随。

转到**帧 912** ，然后展开 HTTP 头。在那里，您将看到 cookie 和 cookie 对，如下面的屏幕截图所示:

![Figure 15.3 – Viewing cookies in an HTTP header
](img/B18389_15_003.jpg)

图 15.3–查看 HTTP 报头中的 cookies

在大多数情况下，cookies 被设计成有帮助的；但是，它们可能会带来隐私风险，因为它们可以收集营销统计数据和个人信息。这就是为什么在大多数情况下，用户能够*选择*不允许 cookies 出现在他们的系统上。

在某些情况下，会将 cookie 发送到服务器进行维护和检索，以供客户端将来访问。然而，如果一个 cookie 没有被发送到服务器，它就被认为是非持久的，并且会发生以下情况之一:

*   cookie 将过期。
*   当用户关闭浏览器时，cookie 将被删除。
*   用户将移除(或删除)cookie。

在 HTTP 事务中，客户端和服务器之间有一系列的请求和响应。在下一节中，我们将研究请求和响应消息的一般格式。

# 比较请求和响应消息

当与网页交互时，客户端会向服务器请求对象。在大多数情况下，标准事务包括来自客户端的请求和来自服务器的响应。因为客户端和服务器都传递不同的消息，所以消息头略有不同。在这一部分中，我们将从较高的层次上了解客户机和服务器的 HTTP 头和字段。

让我们从检查 HTTP 请求的元素开始。

## 查看 HTTP 请求

当查看客户端请求时，您很可能会看到一个请求行，后跟标题行，如下图所示:

![Figure 15.4 – HTTP request format
](img/B18389_15_004.jpg)

图 15.4–HTTP 请求格式

每个请求消息都将指示方法(如`GET`或`POST`)和 URL，以及附加参数。以下情况也很常见:

*   `\r`符号，用于表示回车
*   `\n`符号，用于表示换行符

标题中的两个符号都提供了格式指南，表示该特定行内容的结尾。要查看示例，返回`bigFlows.pcap`并选择**帧 183** 。然后，展开 HTTP 标头，如下所示:

![Figure 15.5 – HTTP GET request
](img/B18389_15_005.jpg)

图 15.5–HTTP GET 请求

HTTP 请求用于检索对象。大多数 web 服务器提供丰富的交互式内容。因此，标头必须指示客户端可以支持的内容类型。在一个 HTTP 请求中，您将会看到一个对多用途互联网邮件扩展 T2 标题的引用。接下来我们来探讨一下。

### 查看 MIME 标题

MIME 被设计成以各种格式呈现数据，包括文本、图像、音频、应用和视频。最初开发 MIME 头是为了支持电子邮件，后来成为 HTTP 发展的一部分。

当服务器接收到 HTTP 请求时，**请求行**将列出客户机想要的内容，以及浏览器支持的 HTTP 版本。之后，MIME 头包含与客户端可以支持的内容类型相关的字段。这里显示了一个示例:

![Figure 15.6 – HTTP request with a MIME header
](img/B18389_15_006.jpg)

图 15.6–带有 MIME 头的 HTTP 请求

MIME 头包含浏览器版本等值，以及客户端将接受的字符编码和对象。

一旦服务器收到请求，它将向客户端发送响应。报头格式与 HTTP 请求非常相似；但是，这包含特定于服务器响应的详细信息。

## 回应客户

来自服务器的 HTTP 响应以状态行开始，表示版本、状态代码和原因。在状态行之后，结构类似于 HTTP 请求，因为我们发现标题行，如下图所示:

![Figure 15.7 – HTTP response format
](img/B18389_15_007.jpg)

图 15.7–HTTP 响应格式

在状态代码和标题行之后，您将看到消息体，它可以包含客户请求的项目，以及交易的细节。

HTTP 响应的主要元素之一是消息的状态。HTTP 通过使用特定的代码来指示状态，如下所述。

### 了解状态代码

状态码显示在 web 服务器对客户端响应消息的第一行。状态代码按类别分组，如下所示:

*   **1xx 信息**:提供关于交易的一般注释，例如请求已经收到和/或流程正在进行
*   **2xx 成功**:表示服务器能够肯定地接收和处理请求
*   **3xx 重定向**:表示客户端必须被重定向到另一个资源才能完成请求
*   **4xx 客户端错误**:表示请求包含无效语法或由于某种原因无法满足
*   **5xx 服务器错误**:当服务器一方无法完成动作或请求时，出现

虽然有许多状态代码可用，但一些最常见的代码包括:

*   **200 OK** :这是最常见的状态码，代表服务器能够成功返回请求的对象。
*   **301 永久移动**:这个表示请求的对象在 URL 上不再可用，已经永久移动到新的位置。
*   **400 错误请求**:这个状态意味着 HTTP 客户端请求无效，无法被服务器处理。
*   **404 未找到**:如果在服务器上未找到请求的对象，则返回此状态。

在状态行之后，您将看到 MIME 头中与响应相关的各种元素，如下所述。

### 描述 MIME 标头

每当你从一个网页中检索数据时，你的浏览器会正确地格式化请求。反过来，服务器将响应请求并传送数据。然后，浏览器会将结果呈现给客户端。

当服务器向客户端返回对象时，MIME 头中有各种元素，如下所示:

![Figure 15.8 – MIME fields in an HTTP response
](img/B18389_15_008.jpg)

图 15.8–HTTP 响应中的 MIME 字段

字段值定义了诸如内容类型、来源和长度等细节。

在下一节中，让我们探索从发出请求到显示对象再到关闭连接的过程。

# 跟随 HTTP 流

为了更好地理解请求和接收网页时会发生什么，我们将通过一个 HTTP 流来逐步完成这个过程。在检查 HTTP 事务时，我们将进一步分解每个元素。

注意

请记住，每个 HTTP 会话都是不同的。这个示例将提供一个示例，说明在查看 HTTP 对话时您会看到什么。在真正的分析练习中，您很可能需要研究一些不同字段值的含义。

对于这个例子，我们将使用`HTTP.pcap`，因为它是一个完整的对话。要获取副本，请前往 https://www.cloudshark.org/captures/0012f52602a3 的[，然后下载文件并在 Wireshark 中打开。打开后，展开 TCP 标题下的**帧 1** ，您将看到以下内容:](https://www.cloudshark.org/captures/0012f52602a3)

```
[Conversation completeness: Complete, WITH_DATA (31)]
```

这是一个只有 40 个数据包的小捕获，因此不难看到完整对话的所有元素。但是，查看主机之间活动的一种方法是运行流程图。要查看整个对话，进入**统计**菜单选项，然后选择**流程图**。Wireshark 将运行该图，如下面的屏幕截图所示:

![Figure 15.9 – Viewing the HTTP flow
](img/B18389_15_009.jpg)

图 15.9–查看 HTTP 流

一旦进入**流量图**设置，您可以选择**限制以显示过滤器**，如图表左侧所示。但是，因为这个捕获只包含一个对话，所以这是不必要的。

查看流程图后，退出窗口，以便我们可以专注于捕获。要查看客户端和服务器之间的对话，将光标放在**帧 4** 上，单击右键，选择**跟随** | **TCP 流**，如以下截图所示:

![Figure 15.10 – Following the TCP stream
](img/B18389_15_010.jpg)

图 15.10–跟随 TCP 流

选中后，Wireshark 将出现一个窗口，显示以下对话:

![Figure 15.11 – Viewing Follow TCP Stream
](img/B18389_15_011.jpg)

图 15.11–查看跟随 TCP 流

在窗口中，您将看到以下内容:

*   客户端请求在窗口的上方，如图*所示，图 15.11* 使用红色字体
*   服务器响应，从窗口中间开始，如图*图 15.11* 所示，使用蓝色字体

现在我们已经看到了整个对话，让我们来看一下整个过程。第一步是客户端使用三次握手与服务器建立联系。

## 开始对话

在交换任何数据之前，该过程从三方握手开始，我们在`HTTP.pcap`的**帧 1** 、**帧 2** 和**帧 3** 中可以看到，如下图所示:

![Figure 15.12 – Viewing a three-way handshake
](img/B18389_15_012.jpg)

图 15.12–查看三次握手

三次握手是客户端(`192.168.1.140`)和服务器(`174-143.213.184`)之间的**同步** ( **SYN** )和 ACK 数据包的交换，在这里有更详细的描述:

*   客户端通过向服务器发送一个 SYN 数据包来开始这个过程。
*   服务器通过向客户端发送 SYN-ACK 来响应。
*   客户端通过向服务器发送 ACK 进行响应。

没有数据交换，因为握手只是建立连接。建立之后，下一步是客户端向服务器发出请求。

## 请求数据

**第 4 帧**开始了对话，客户端向服务器请求图像。HTTP 头如下面的截图所示:

![Figure 15.13 – Client-side HTTP request
](img/B18389_15_013.jpg)

图 15.13–客户端 HTTP 请求

当检查客户机请求时，我们看到 HTTP 头中有几个值。第一行是从服务器请求数据的`GET`方法。以下是该请求的参数:

*   `Request Method` : `GET`，客户端用来从服务器获取信息。
*   `Request URI`:客户端正在使用`img/layout/logo.png`路径请求`logo.png`图像。
*   `Request Version`:客户端正在使用`HTTP/1.0`。

按照`GET`方法，您将看到这些值:

*   `User-Agent`:列出的用户代理是`Wget/1.12: (linux-gnu)`，是一个简单的非交互浏览器，用于使用 HTTP、FTP 等方法获取文件。
*   `Accept`:列出`*/*`，这是一个通配符值，表示客户端将接受任何 MIME 类型的对象。
*   `Host`:请求的主机是`packetlife.net`。
*   `Connection` : `Keep-Alive`列为连接方式，告知服务器继续发送数据，无需打开新的连接请求。

在字段值之后，我们可以看到 Wireshark 生成的三个详细信息，如下所述:

*   `[Full request URI: http://packetlife.nimg/layout/logo.png]`:这是一个超链接，指向所请求对象的确切位置。
*   `[HTTP request 1/1]`:这表示该请求是一(1)个 HTTP 请求中的第一个。
*   `[Response in frame: 36]`:这是一个超链接，指向包含 HTTP 响应的框架。

在客户机请求被发送到服务器之后，数据被发送到客户机。从**第 5 帧**到**第 35 帧**，您将看到一系列来自客户端和服务器的 ACK 数据包，它们确认数据正在被传输和接收。

一旦完成，服务器将响应客户端，并指示所有数据都已发送。

## 回应客户

在**帧 36** 中，我们看到服务器返回了一个`Status Code: 200 OK`响应，意味着数据已经被成功传送。

与请求数据包不同，我们看到 HTTP 响应中包含更多信息，如下面的屏幕截图所示:

![Figure 15.14 – Server-side HTTP response
](img/B18389_15_014.jpg)

图 15.14–服务器端 HTTP 响应

当检查服务器响应时，我们看到 HTTP 头中有几个值。数据传输的第一行是 Wireshark 生成的值，表示响应的状态，如下所示:

[专家信息(聊天/序列):HTTP/1.1 200 OK\r\n]

该行定义`HTTP/1.1 200 (PNG)`属于**专家信息**控制台中的`Chat`严重性。要查看这个，选择 Wireshark 界面左下角的青色`Expert Info`图标。打开后，展开第二个`Chat`条目，将显示以下信息:

![Figure 15.15 – Viewing Expert Information entries
](img/B18389_15_015.jpg)

图 15.15–查看专家信息条目

在 Wireshark 生成的值之后，您将看到以下内容:

*   `Response Version`:该值表示服务器使用的是 HTTP 版本 1.1。
*   `Status Code`:在这种情况下，数据传输成功，所以服务器返回一个`Status Code 200`响应。
*   `[Status Code Description: OK]`:这一行是 Wireshark 生成的值，表示响应没有问题。
*   `Response Phrase`:该字段值为`OK`，表示数据传输成功。

在交易的详细信息之后，您将看到以下值:

*   `Server`:该字段将网络服务器列为`nginx/0.8.53`。nginx 是一种流行的开源 web 服务器，是 Apache 的替代产品。
*   `Date`:该字段标记对象被访问的日期和时间，并用于监控用于缓存计算的资源的年龄。**第 35 帧**将`Tue, 01 Mar 2011 20:45:16 GMT`列为日期。
*   `Content-Type`:这个字段提供了一个关于什么类型的对象被返回给客户端的参考。**第 35 帧**将`Content-Type`列为`image/png`，是**便携图形格式** ( **PNG** )格式的图像。
*   `Content-Length`:该字段列出了图像的长度，为`21684`字节。在字段值下面，您将看到 Wireshark 生成的一个`[Content length: 21684]`值。这个值将与 HTTP 头底部的`Portable Network Graphics`头匹配。如果将光标放在标题上，您将看到状态栏中反映的值，如下面的屏幕截图所示:

![Figure 15.16 – Content length of the image
](img/B18389_15_016.jpg)

图 15.16–图像的内容长度

*   `Last-Modified`:该字段值将指示页面上次修改的时间，列为`Fri, 21 Jan 2011 03:41:14 GMT`。
*   `Connection`:该值被列为`keep-alive`(或持久)连接。
*   `Keep-Alive`:这个字段值列出了`timeout=20`，它是一个由服务器设置的值(以秒为单位),表示在关闭连接之前保持对话的时间。

在网络上，缓存的概念很重要，因为在大多数情况下，发出请求的主机希望收到尽可能最新的副本。缓存值用于标识页面的年龄。

### 控制缓存

网络上的大多数对象通常都有超时值。接下来的几个值提供了一种监控页面年龄的方法。条目包括以下内容:

*   `Expires`:该值指定对象何时到期。在**第 35 帧**中，到期日期列为`Wed, 29 Feb 2012 20:45:16 GMT`。
*   `Cache-Control`: This value is listed as `max-age=31536000`.

    注意

    在很少变化的资产上，习惯上把`Cache-Control`值设为`max-age=31536000`，代表 1 年的秒数。

*   `Cache-Control`:该字段值被列为`public`，这意味着这些值可以存储在共享缓存中。其他值可以包括`private`或`no-cache`。
*   `Vary`:该字段表示缓存服务器支持的内容类型。在这种情况下，值为`Accept-Encoding`。如果该指示器不存在，则格式可能存储不正确，并且当客户端检索页面时，它可能会以不可读的格式呈现页面。
*   `Accept-Ranges`:该字段值指示当响应客户端的数据请求时，服务器将使用哪个*单元*。字段值列为`bytes`，很常见。

在 HTTP 字段值的末尾，我们看到了`Portable Graphics Format`头，这表明该对象是一个 PNG 文件。接下来，我们来考察一下图像。

### 导出对象

如果捕获中有未加密的对象，您可以在 Wireshark 中导出它们。要查看`HTTP.pcap`文件中的内容，进入**文件**菜单选项，然后选择**导出对象** | **HTTP…** ，将会出现以下窗口:

![Figure 15.17 – Viewing Export HTTP object list
](img/B18389_15_017.jpg)

图 15.17–查看导出 HTTP 对象列表

如果您想让查看内容，点击图像并选择**保存**，这将弹出一个对话框，让您选择保存文件的位置。保存后，您可以打开图像，如下所示:

![Figure 15.18 – The extracted image
](img/B18389_15_018.jpg)

图 15.18–提取的图像

一旦数据传输完毕，客户端不再请求对象，下一步就是结束对话。

## 结束对话

在交易的结束时，客户端和服务器交换一系列**的完成** ( **FIN** )和 ACK 包，如下图所示:

![Figure 15.19 – Exchange of FIN-ACK packets
](img/B18389_15_019.jpg)

图 15.19–FIN-ACK 数据包的交换

虽然这是一个简单的数据事务示例，但它提供了一种理解客户机与 web 服务器交互的机制的可靠方法。

# 总结

HTTP 是一个丰富的协议，在一个事务中，数据将跨越几个网络，同时会遇到不同的客户端和服务器。因此，存在大量的规则和变量。在这次讨论中，我们主要关注客户机和服务器之间的 HTTP 请求-响应会话的关键元素。

我们首先逐步介绍了网页的关键元素，以及检索数据和对象时客户端和服务器的角色。我们回顾了不同的 HTTP 版本，并简要介绍了可用的 HTTP 方法。然后，我们继续学习不同类型的连接，以及 cookies 如何帮助维护事务期间的状态。最后，我们用一个完整 HTTP 对话的简单示例进行了总结。

在下一章中，我们将回顾**地址解析协议** ( **ARP** )，并从概述这一基本协议的作用和目的开始。为了让您了解 ARP 是如何工作的，我们将介绍一个 ARP 事务，并仔细看看报头和字段值。我们将看到无偿 ARP 的重要性，并简要提及您可能会遇到的一些其他类型的 ARP 流量。最后，我们将了解 ARP 攻击以及如何识别和防御这些类型的威胁。

# 问题

现在，是时候检查你的知识了。选择以下问题的最佳答案，然后检查您的答案，这些答案可在*评估*附录中找到:

1.  两个主要的 HTTP 请求方法是`GET`和 _____。
    1.  `PUT`
    2.  `DELETE`
    3.  `POST`
    4.  `STATE`
2.  _____ 是当今最流行的开源 web 服务器应用之一，因为它拥有完整的模块库，甚至可以支持最大的网站。
    1.  云耀斑
    2.  Microsoft **IIS**
    3.  升速
    4.  街头流氓
3.  HTTP 版本 _____ 通过压缩报头来减少开销，多路传输请求和响应，并主动将内容推送到客户端，从而减少延迟并提高效率。
    1.  One
    2.  One point one
    3.  One point two
    4.  Two
4.  从 web 服务器传输数据时，持久连接会保持会话活动，直到检索到所有对象。这种类型的连接也称为 HTTP _____。
    1.  耀斑状态
    2.  并联接法
    3.  保持活力
    4.  Cookie 状态
5.  在 HTTP 头中，您可以看到在`Cache-Control`字段中列出的值`3600`。这意味着内容可以在缓存中保存 _____。
    1.  1 天
    2.  1 小时
    3.  1 年
    4.  1 个月
6.  _____ 最初是为支持电子邮件而开发的，旨在以各种格式呈现数据，包括文本、图像、音频、应用和视频。
    1.  升速
    2.  哑剧
    3.  饼干艺术
    4.  nginx
7.  网络上的大多数对象通常都有超时值。_____ 值提供了一种监控页面年龄的方法。
    1.  隐藏物
    2.  哑剧
    3.  饼干
    4.  状态

# 延伸阅读

请参考以下链接了解更多信息:

*   访问[https://www.w3schools.com/tags/ref_httpmethods.asp](https://www.w3schools.com/tags/ref_httpmethods.asp)了解更多关于 HTTP 请求方法的信息。
*   通过访问[https://nginx.org/en/](https://nginx.org/en/)了解更多 nginx。
*   很少更改的对象的缓存控制将默认为 1 年。请访问[https://Ashton . codes/set-cache-control-max-age-1-year/](https://ashton.codes/set-cache-control-max-age-1-year/)了解为什么这是默认设置。
*   要了解当今最流行的网络服务器软件，请访问[https://digitalintheround . com/what-is-the-most-popular-we B- server/](https://digitalintheround.com/what-is-the-most-popular-web-server/)。
*   通过访问[https://datatracker.ietf.org/doc/html/rfc7231#section-4.2](https://datatracker.ietf.org/doc/html/rfc7231#section-4.2)了解从服务器请求数据的安全方法。
*   有关 HTTP 方法的详细列表，请访问[https://www.tutorialspoint.com/http/http_methods.htm](https://www.tutorialspoint.com/http/http_methods.htm)。
*   请访问[https://www . iana . org/assignments/http-status-codes/HTTP-status-codes . XHTML](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)查看 HTTP 响应代码的完整列表。
*   请访问[https://SVN . Apache . org/repos/ASF/traffic server/site/branches/2.0 . x/docs/SDK/HTTP headers . html](https://svn.apache.org/repos/asf/trafficserver/site/branches/2.0.x/docs/sdk/HTTPHeaders.html)了解关于 HTTP 头的讨论。
*   请访问[https://developer . Mozilla . org/en-US/docs/Web/HTTP/Headers/Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)了解有关缓存控制的更多信息。